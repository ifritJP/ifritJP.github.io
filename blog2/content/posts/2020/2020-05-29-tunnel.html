<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-06-12 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tunnel/Reverse Tunnel over websocket を作った</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="ifritJP" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:1f739d935676111cfff4b4693e3816e664797050&dn=gpl-3.0.txt GPL-v3-or-Later
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.cacheClassElem = elem.className;
         elem.cacheClassTarget = target.className;
         target.className = "code-highlighted";
         elem.className   = "code-highlighted";
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(elem.cacheClassElem)
         elem.className = elem.cacheClassElem;
       if(elem.cacheClassTarget)
         target.className = elem.cacheClassTarget;
     }
    /*]]>*///-->
// @license-end
</script>
</head>
<body>
<div id="content">
<h1 class="title">Tunnel/Reverse Tunnel over websocket を作った</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orga9718ae">1. 「Tunnel/Reverse Tunnel over websocket」 とは</a></li>
<li><a href="#orgc24d14e">2. VPN (Virtual Private Network)</a></li>
<li><a href="#org1716b86">3. 開発した背景</a></li>
<li><a href="#org737f75a">4. ネットワーク環境</a></li>
<li><a href="#org1f2fe05">5. 使用方法</a>
<ul>
<li><a href="#org8c46251">5.1. 注意事項</a></li>
<li><a href="#orgb5029f1">5.2. ビルド</a></li>
<li><a href="#org59d40a2">5.3. tunnel コマンド</a>
<ul>
<li><a href="#orgb333532">5.3.1. オプション一覧</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgd532ca8">6. 開発に関して</a>
<ul>
<li><a href="#org43c60db">6.1. スレッド</a>
<ul>
<li><a href="#org44d16b1">6.1.1. tunnel 内に複数の TCP セッションを通す場合</a></li>
</ul>
</li>
<li><a href="#orgd2132e7">6.2. Tunnel の再接続</a>
<ul>
<li><a href="#orge43a62a">6.2.1. フロー制御</a></li>
<li><a href="#org29dede0">6.2.2. リングバッファ</a></li>
<li><a href="#orgb30ac29">6.2.3. 送信パケットの結合</a></li>
</ul>
</li>
<li><a href="#org6c140e8">6.3. protocol</a>
<ul>
<li><a href="#org2a507bb">6.3.1. AuthCallenge</a></li>
<li><a href="#org6c794a6">6.3.2. AuthResponse</a></li>
<li><a href="#orga52a110">6.3.3. AuthResult ( server -&gt; client )</a></li>
</ul>
</li>
<li><a href="#org5840775">6.4. 開発言語</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
とある理由から 「Tunnel/Reverse Tunnel over websocket」 が必要になったので作ってみた。
</p>

<p>
「Tunnel/Reverse Tunnel over websocket」 が何かというと、
「websocket を tunnel にして別の TCP 通信を通すもの」だ。
</p>

<div id="outline-container-orga9718ae" class="outline-2">
<h2 id="orga9718ae"><span class="section-number-2">1</span> 「Tunnel/Reverse Tunnel over websocket」 とは</h2>
<div class="outline-text-2" id="text-1">
<p>
「Tunnel/Reverse Tunnel over websocket」を少し具体的にいうと、
次のような構成で通信を可能にするモノだ。
</p>


<div class="figure">
<p><object type="image/svg+xml" data="../tunnel.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
上の図は network_1, network_2, network_A, network_B の
4 つのネットワークを表わしている。
</p>

<p>
このネットワーク間でポートが制限されていると、
tcp_client_A は tcp_server_B と直接通信が出来ない。
</p>


<p>
開放されているポートで接続し、そのセッション上に仮想的な Tunnel を構築する。
そして、その Tunnel 内にポートの制限を受けない通信を実現する。
</p>


<p>
左は Tunnel の構成例である。
ポート制限されている network_1, network_2 を、
tunnel server / tunnel client で接続して tunnel を構成し、
その tunnel を使って tcp client A と tcp server B を接続する。
</p>

<p>
右は Reverse Tunnel の構成例である。
ポート制限されている network_A, network_B を、
tunnel server / tunnel client で接続して tunnel を構成し、
その tunnel を使って tcp client D と tcp server C を接続する。
</p>

<p>
Tunnel と Revers Tunnel の違いは、
tcp client/server の位置関係である。
</p>

<p>
具体的には、
Tunnel server と同じネットワークに tcp server が属する構成が Tunnel で、
逆に Tunnel server と同じネットワークに tcp client が属する構成が Reverse Tunnel である。
</p>

<p>
そして、 Tunnel server と client 間の通信経路として、
websocket を利用して tunnel を構築するのが
「Tunnel/Reverse Tunnel over websocket」である。
</p>
</div>
</div>


<div id="outline-container-orgc24d14e" class="outline-2">
<h2 id="orgc24d14e"><span class="section-number-2">2</span> VPN (Virtual Private Network)</h2>
<div class="outline-text-2" id="text-2">
<p>
このような制限されたネットワーク間で通信路を構築する方法として、
WireGuard や OpenVPN などの低レイヤー VPN がある。
</p>

<p>
低レイヤー VPN は、その名の通り仮想的なネットワークを低レイヤーで構築する。
これによって、通常のネットワークと同様に扱えて利便性が高いが、
通常のネットワークと同様であるが故、逆にリスクになる可能性がある。
</p>

<p>
今回は VPN ではなく、Tunnel を実現するのが目的である。
</p>

<p>
なお、ここでは「レイヤー 2 あるいは 3 を仮想化する技術」を VPN とし、
「ネットワーク間で TCP セッションを転送する技術」を Tunnel とする。
</p>
</div>
</div>

<div id="outline-container-org1716b86" class="outline-2">
<h2 id="org1716b86"><span class="section-number-2">3</span> 開発した背景</h2>
<div class="outline-text-2" id="text-3">
<p>
制限されたネットワーク間での通信を確立できないかどうか、
当初はフリーのツールを探していて幾つか tunnel ソフトを試してみたが、
tunnel が接続できなかったり、接続できてもすぐに切れてしまったりで
イマイチ希望したものとは違った。
</p>

<p>
特に自分の環境は (A)/(B) 間のネットワーク環境が悪く、
tunnel を確立しても、ある程度経過すると切断されてしまう問題があったため、
再接続して tcp セッションを継続できる機能は必須だ。
</p>

<p>
tunnel が切断されても tunnel を再接続することで、
tunnel 内の tcp 通信を継続させることは論理的に可能だ。
しかし、検討していた幾つかのフリーのツールでは、
tunnel が切断されると tunnel を再接続しても tcp 通信が継続できなかった。
そもそも tunnel を接続すること自体、
成功したり失敗したりしているような状況だった。
</p>

<p>
そこで、今回はフリーのツールを検討することは諦め、
自分の勉強も兼てスクラッチで開発することにした。
</p>

<p>
ただし、ネットワーク間を接続することが目的であれば、
WireGuard や OpenVPN を使うことが多くの場合ベストだろう。
</p>
</div>
</div>

<div id="outline-container-org737f75a" class="outline-2">
<h2 id="org737f75a"><span class="section-number-2">4</span> ネットワーク環境</h2>
<div class="outline-text-2" id="text-4">
<p>
今回開発した Tunnel ツールを使って、
自分のネットワーク環境の Tunnel 間通信強制切断状況を確認したところ、
次のようになった。
</p>

<dl class="org-dl">
<dt>(a)</dt><dd>接続は最大でも 15 分程度で切断される</dd>
<dt>(b)</dt><dd>昼間は 30 秒程度で切断される</dd>
<dt>(c)</dt><dd>接続の 7 割強は 1 分以内で切断される</dd>
</dl>

<p>
(a) について、
どうやら自分の環境では http 通信は 15 分程度でセッションが強制切断されるらしい。
</p>

<p>
(b), (c) について、
無通信が続くと 30 〜 60 秒程度で強制切断されるようなので、
無通信を回避するために 20 秒毎にトンネル間でダミーの通信を行なうよう対応した。
</p>

<p>
ただ、これでも通信負荷が高くなると数分で切断されることがある。
</p>
</div>
</div>

<div id="outline-container-org1f2fe05" class="outline-2">
<h2 id="org1f2fe05"><span class="section-number-2">5</span> 使用方法</h2>
<div class="outline-text-2" id="text-5">
<p>
このツールは Go で開発しているため、
事前に Go(1.14.2) の環境を構築してあることが前提である。
</p>
</div>

<div id="outline-container-org8c46251" class="outline-3">
<h3 id="org8c46251"><span class="section-number-3">5.1</span> 注意事項</h3>
<div class="outline-text-3" id="text-5-1">
<p>
tunnel 間の通信がインターネットを経由する場合、セキュリティには十分注意すること。
</p>

<ul class="org-ul">
<li>tunnel client/server 間通信の暗号化や、client 認証を実装しているが、
tunnel 内の TCP セッションは raw な tcp 接続をせずに、 ssh などで接続すること。</li>
<li>tunnel server は常駐させず、必要な時にだけ起動するように運用すること。</li>
<li>pass , encPass オプションを必ず指定し、適切な期間で変更すること。</li>
<li>ip オプションを指定し、接続可能な client を制限すること。</li>
</ul>
</div>
</div>

<div id="outline-container-orgb5029f1" class="outline-3">
<h3 id="orgb5029f1"><span class="section-number-3">5.2</span> ビルド</h3>
<div class="outline-text-3" id="text-5-2">
<p>
次のコマンドを実行することで、
tunnel ディレクトリ内に tunnel コマンドがカレントディレクトリに生成される。
</p>

<div class="org-src-container">
<pre class="src src-sh">$ git clone --depth 1 https://github.com/ifritJP/tunnel.git
$ cd tunnel
$ make
</pre>
</div>
</div>
</div>

<div id="outline-container-org59d40a2" class="outline-3">
<h3 id="org59d40a2"><span class="section-number-3">5.3</span> tunnel コマンド</h3>
<div class="outline-text-3" id="text-5-3">
<p>
tunnel コマンドは tunnel server と、 tunnel client の両方の役割を持ち、
オプションで切り替える。
</p>

<ul class="org-ul">
<li>server</li>
</ul>

<p>
server のコマンド例を示す。
</p>

<pre class="example">
$ tunnel -mode r-wsserver -server :6666 -port :8001 -remote localhost:22 -pass XXXXXXX -encPass YYYYYYYY
</pre>


<p>
これは次のサーバの実行を指定している。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">option</th>
<th scope="col" class="org-left">意味</th>
<th scope="col" class="org-left">サンプルの意味</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">-mode</td>
<td class="org-left">client/server の種類</td>
<td class="org-left">reverse websocket server</td>
</tr>

<tr>
<td class="org-left">-server</td>
<td class="org-left">tunnel サーバの情報</td>
<td class="org-left">ポート 6666 を使用して websocket server を建てる</td>
</tr>

<tr>
<td class="org-left">-port</td>
<td class="org-left">tunnel で接続する際のポート番号</td>
<td class="org-left">ポート 8001 を使用</td>
</tr>

<tr>
<td class="org-left">-remote</td>
<td class="org-left">tunnel で繋げる接続先</td>
<td class="org-left">localhost の 22 ポートに接続</td>
</tr>

<tr>
<td class="org-left">-pass</td>
<td class="org-left">client の認証用パスワード</td>
<td class="org-left">XXXXXXX</td>
</tr>

<tr>
<td class="org-left">-encPass</td>
<td class="org-left">client/server 間の通信路の暗号パスワード</td>
<td class="org-left">YYYYYYYY</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>client</li>
</ul>

<p>
client のコマンド例を示す
</p>

<pre class="example">
$ tunnel -mode r-wsclient -proxy http://user:pass@proxy.hoge.com:8080/ -server hoge.hoge.com:80 -pass XXXXXXX -encPass YYYYYYYY
</pre>


<p>
これは次のクライアントの実行を指定している。
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">option</th>
<th scope="col" class="org-left">意味</th>
<th scope="col" class="org-left">サンプルの意味</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">-mode</td>
<td class="org-left">client/server の種類</td>
<td class="org-left">reverse websocket client</td>
</tr>

<tr>
<td class="org-left">-proxy</td>
<td class="org-left">proxy サーバの情報</td>
<td class="org-left"><a href="http://proxy.hoge.com::8080/">http://proxy.hoge.com::8080/</a> に user, pass で接続</td>
</tr>

<tr>
<td class="org-left">-server</td>
<td class="org-left">tunnel サーバの情報</td>
<td class="org-left">hoge.hoge.com の 80 に接続する</td>
</tr>

<tr>
<td class="org-left">-pass</td>
<td class="org-left">client の認証用パスワード</td>
<td class="org-left">XXXXXXX</td>
</tr>

<tr>
<td class="org-left">-encPass</td>
<td class="org-left">client/server 間の通信路の暗号パスワード</td>
<td class="org-left">YYYYYYYY</td>
</tr>
</tbody>
</table>

<ul class="org-ul">
<li>tunnel への接続</li>
</ul>

<p>
上記のサンプルは localhost の 22 番ポートに接続するための reverse tunnel を構築している。
つまり、このサーバ側の 8001 ポートに繋げると、 client 側の ssh に接続されることになる。
</p>

<p>
よって、サーバ側で次のコマンドを実行することで、クライアントの ssh に接続できる。
</p>

<pre class="example">
$ ssh -p 8001 localhost
</pre>
</div>

<div id="outline-container-orgb333532" class="outline-4">
<h4 id="orgb333532"><span class="section-number-4">5.3.1</span> オプション一覧</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
tunnel コマンドで使用可能なオプションについて説明する
</p>
</div>

<ol class="org-ol">
<li><a id="org519448a"></a>基本<br />
<div class="outline-text-5" id="text-5-3-1-1">
<ul class="org-ul">
<li>-mode string
<ul class="org-ul">
<li>次のいずれかを指定する</li>
<li>サーバ
<ul class="org-ul">
<li>wsserver</li>
<li>r-wsserver</li>
<li>server</li>
<li>r-server</li>
</ul></li>
<li>クライアント
<ul class="org-ul">
<li>wsclient</li>
<li>r-wsclient</li>
<li>client</li>
<li>r-client</li>
</ul></li>
<li>"r-" が付くものは、 reverse tunnel である。</li>
<li>ws が付くものは、 over websocket である。</li>
<li>ws が付かないものは、 tcp で直接接続する。
<ul class="org-ul">
<li>tcp による接続は、実験的なサポートである。</li>
<li>tcp で接続できる環境なら、 このツールを使わずに ssh した方が良いだろう。</li>
</ul></li>
<li>"r-", "ws" は client/server で一致している必要がある。</li>
</ul></li>
<li>-server string
<ul class="org-ul">
<li>server を示す。</li>
<li>サーバ側で指定する場合は、開放するポートを指定する。 (:1234 or localhost:1234)
<ul class="org-ul">
<li>この port に接続可能なネットワークを制限する場合は、
そのネットワークを指定する。
例えば localhost に制限する場合は <code>localhost:1234</code> として指定する。</li>
</ul></li>
<li>クライアント側で指定する場合は、ホスト名を含めて指定する (hoge.com:1234)</li>
</ul></li>
<li>-port string
<ul class="org-ul">
<li>構築した tunnel に接続するためのポート (:1234 or localhost:1234)</li>
<li>reverse tunnel の場合は、 server 側で指定する。tunnel の場合は client 側で指定する。</li>
<li>この port に接続可能なネットワークを制限する場合は、
そのネットワークを指定する。
例えば localhost に制限する場合は <code>localhost:1234</code> として指定する。</li>
</ul></li>
</ul>


<ul class="org-ul">
<li>-proxy string
<ul class="org-ul">
<li>websocket server に接続するための proxy</li>
<li>proxy 不要なら省略する。</li>
<li>認証が必要な proxy の場合、 <a href="http://user:pass@proxy.hoge.com:port/">http://user:pass@proxy.hoge.com:port/</a> の形式で指定する。</li>
<li>現状は HTTP proxy のみ対応している。</li>
<li>client 側で指定する</li>
</ul></li>
<li>-remote string
<ul class="org-ul">
<li>tunnel で接続するリモートホスト  (hoge.com:1234)
<ul class="org-ul">
<li>最初に説明した (B) あるいは (C) のホスト</li>
</ul></li>
<li>localhost 等を指定した場合、 reverse とそうでないかによって意味が異なる。
<ul class="org-ul">
<li>例えば reverse tunnel の場合はクライアント自信が接続先になり、
通常の tunnel の場合はサーバ自信が接続先になる。</li>
</ul></li>
<li>reverse tunnel の場合は、 server 側で指定する。tunnel の場合は client 側で指定する。</li>
</ul></li>
<li>-UA string
<ul class="org-ul">
<li>Proxy に接続する際の User Agent を指定する</li>
<li>websocket の client で有効</li>
</ul></li>
</ul>
</div>
</li>

<li><a id="orgccb6fcd"></a>セキュリティ関連<br />
<div class="outline-text-5" id="text-5-3-1-2">
<ul class="org-ul">
<li>-pass string
<ul class="org-ul">
<li>client 認証で使用する。</li>
<li>client/server で共通のものを指定する必要がある。</li>
<li>client 認証は challenge/respose で行なう。</li>
</ul></li>
<li>-encPass string
<ul class="org-ul">
<li>client/server 間通信の暗号パスワード。</li>
<li>client/server で共通のものを指定する必要がある。</li>
</ul></li>
<li>-encCount int
<ul class="org-ul">
<li>client/server 間の暗号処理回数を指定する。
<ul class="org-ul">
<li>-1 : infinity</li>
<li>0 : plain, no encrypt.</li>
<li>N : packet count (default 1000)</li>
</ul></li>
<li>このツールは tunnel client/server 間の通信を暗号化するが、tunnel 内を通すのが ssh などの場合、
二度の暗号化が走ることになり、tunnel client/server 間の暗号は無駄になる。
そこで、tunnel client/server 間の暗号化回数を指定することで、暗号化にかかる負荷軽減を可能にする。</li>
<li>回数は tunnel の通信パケット単位</li>
<li>暗号アルゴリズムは AES256 CFB を使用している。</li>
</ul></li>
<li>-ip string
<ul class="org-ul">
<li>server に接続可能な client の、 IP アドレスパターンを正規表現で指定する。</li>
<li>このオプションを省略した場合、 client の IP を限定しない。</li>
</ul></li>
</ul>
</div>
</li>
</ol>
</div>
</div>
</div>

<div id="outline-container-orgd532ca8" class="outline-2">
<h2 id="orgd532ca8"><span class="section-number-2">6</span> 開発に関して</h2>
<div class="outline-text-2" id="text-6">
<p>
これ以降の章では、この Tunnel ツール開発に関する技術的な内容について記載する。
</p>
</div>

<div id="outline-container-org43c60db" class="outline-3">
<h3 id="org43c60db"><span class="section-number-3">6.1</span> スレッド</h3>
<div class="outline-text-3" id="text-6-1">
<p>
この Tunnel ツールは、1 つの TCP セッションにつき 5 つのスレッドを持つ。
</p>

<ul class="org-ul">
<li>tunnel session 制御</li>
<li>WriteQeue → tunnel のパケット送信制御 (packetWriter)</li>
<li>tunnel → ReadQueue のパケット受信制御 (packetReader)</li>
<li>ReadQueue → host のパケット転送制御 (tunnel2Stream)</li>
<li>WriteQeue → tunnel のパケット転送制御 (stream2Tunnel)</li>
<li>無通信が一定時間続かないようにするダミーパケット送信制御 (keepalive)</li>
</ul>

<p>
スレッド多す過ぎという気もするが、
メニーコア時代な現代であれば、
少ないスレッドで複雑なコードを書くよりも、
処理毎にスレッドを分けた方がメンテナンス性も性能も良いんじゃないだろうか？
</p>


<p>
下図は、各スレッドの役割を図示している。
</p>


<div class="figure">
<p><object type="image/svg+xml" data="tunnel_thread.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="../tunnel_thread.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<ul class="org-ul">
<li>packetReader は tunnel からデータを読み取り ReadQueue に送る</li>
<li>tunnel2Stream が ReadQueue からデータを読み取り host に送る</li>
<li>stream2Tunnel が host からデータを読み取り WriteQueue に送る</li>
<li>packetWriter は WriteQueue からデータを読み取り tunnel に送る</li>
<li>keepalive が WriteQueue にダミーデータを送る</li>
</ul>
</div>


<div id="outline-container-org44d16b1" class="outline-4">
<h4 id="org44d16b1"><span class="section-number-4">6.1.1</span> tunnel 内に複数の TCP セッションを通す場合</h4>
<div class="outline-text-4" id="text-6-1-1">
<p>
tunnel には複数の TCP セッションを通すことができる。    
次の要素は、tunnel 内の TCP セッション毎に増える。
</p>

<ul class="org-ul">
<li>tunnel2Stream</li>
<li>stream2Tunnel</li>
<li>ReadQueue</li>
</ul>

<p>
これらをまとめて CITI (connection in tunnel information ) とすると、
2 つの TCP セッションを通す場合は次のような構成になる。
</p>


<div class="figure">
<p><object type="image/svg+xml" data="tunnel_thread_multi.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="../tunnel_thread_multi.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>
</div>



<div id="outline-container-orgd2132e7" class="outline-3">
<h3 id="orgd2132e7"><span class="section-number-3">6.2</span> Tunnel の再接続</h3>
<div class="outline-text-3" id="text-6-2">
<p>
tunnel が切断されても、
tunnel を再接続すれば tunnel 内に流れる tcp セッションは継続通信可能である。
</p>

<p>
<i>ただし、tcp 通信のタイムアウト以内に再接続できることが条件である。</i>
</p>

<p>
tunnel を再接続すれば tcp セッションは継続通信可能だ。
しかし、そう単純にはいかないケースがある。
それは『送信したつもりになっているパケットが、相手に届いていないことがある』からだ。
この場合、相手に届いていないパケットを送信しなおす必要がある。
</p>

<p>
「tcp は udp と違って再送制御などを行なって信頼性を確保しているんじゃないのか？」
と思う人もいるだろう。私も最初はそう思っていた。
しかし、実際はそうではない。
なぜなら、再送制御などはあくまでも TCP セッションが続いている場合に行なわれることで、
TCP セッションが切断された場合は再送制御なども当然破棄される。
</p>

<p>
つまり、強制的にセッションが切断された場合は、
送ったつもりのデータが相手に届いていないことが普通にありえる。
</p>

<p>
このような「送ったつもりが相手に届いていないデータ」がある場合、
TCP セッションを継続させるにはそのデータを再送してやる必要がある。
この再送処理は、 packetWriter スレッドが実行する。
</p>
</div>

<div id="outline-container-orge43a62a" class="outline-4">
<h4 id="orge43a62a"><span class="section-number-4">6.2.1</span> フロー制御</h4>
<div class="outline-text-4" id="text-6-2-1">
<p>
前述の通り、再接続後は送信側と受信側とでデータの不整合を確認し、
受信されていないデータの再送信が必要になる。
</p>

<p>
これを実現するには、送信済みデータを保持しておく必要がある。
しかし、全ての送信済みのデータを保持しておく訳にもいかないので、
保持可能なパケット数を決めておく。
そして保持可能なパケット数と相手が受信していないパケット数のバランスが
崩れないようにフロー制御を行なう。
</p>

<p>
もっとも単純なのは、送信するたびに相手の受信を持ってから次の送信を行なうことだが、
これだと通信効率が悪すぎる。
そこで、保持可能なパケット数の半分づつ確認を行なっている。
</p>


<div class="figure">
<p><object type="image/svg+xml" data="../tunnel-flow.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<ul class="org-ul">
<li>stream2Tunnel は、パケットを queue に書き込む前に送信済みパケット数を確認する。
<ul class="org-ul">
<li>保持可能なパケット数の半分であれば、 sync を待つ</li>
</ul></li>
<li>tunnel2Stream は、受信したパケット数をカウントし、
保持可能なパケット数の半分であれば sync を queue に入れる</li>
</ul>
</div>
</div>

<div id="outline-container-org29dede0" class="outline-4">
<h4 id="org29dede0"><span class="section-number-4">6.2.2</span> リングバッファ</h4>
<div class="outline-text-4" id="text-6-2-2">
<p>
前述の通り再送信のデータ保持のためにフロー制御を行なっている。
このデータ保持用のバッファは、
保持可能なパケット数分のバッファを通信開始時に用意しておき、
それをリングバッファにして使い回している。
</p>


<div class="figure">
<p><object type="image/svg+xml" data="tunnel_ring.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>


<div class="figure">
<p><object type="image/svg+xml" data="../tunnel_ring.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>
</div>
</div>


<div id="outline-container-orgb30ac29" class="outline-4">
<h4 id="orgb30ac29"><span class="section-number-4">6.2.3</span> 送信パケットの結合</h4>
<div class="outline-text-4" id="text-6-2-3">
<p>
tunnel は 2 つの Host の間のパケットを中継する。
一つのパケットは、MTU サイズに近いほど効率よく送信することができる。
</p>

<p>
そこで、細かいパケットを 1 つのパケットに結合して送信する処理を行なう。
</p>

<p>
次の図で示す通り tunnel に送信するパケットは stream2Tunnel から WriteQueue に入れられる。
そして packetWriter でパケットを取り出して tunnel に送信する。
</p>


<div class="figure">
<p><object type="image/svg+xml" data="../tunnel_thread.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
この packetWriter でパケットを取り出す時に、
WriteQueue に複数のパケットが入っている場合、
そのパケットを結合して送信する。
</p>

<p>
パケットを結合するために、積極的にパケットが溜るのを待つことはない。
これによって、通信のリアルタイム性が損なわれることはない。
</p>
</div>
</div>
</div>


<div id="outline-container-org6c140e8" class="outline-3">
<h3 id="org6c140e8"><span class="section-number-3">6.3</span> protocol</h3>
<div class="outline-text-3" id="text-6-3">
<p>
ここでは tunnel client/server 間で通信を開始する時の protocol について説明する。
</p>

<p>
protocol は 3 つの情報をやり取りする。
</p>


<div class="figure">
<p><object type="image/svg+xml" data="../tunnel-auth.svg" class="org-svg">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<p>
この protocol の後は、-port オプションで指定されたポートをリスニングし、
アクセス毎に TCP 接続セッションを開始する。
</p>
</div>

<div id="outline-container-org2a507bb" class="outline-4">
<h4 id="org2a507bb"><span class="section-number-4">6.3.1</span> AuthCallenge</h4>
<div class="outline-text-4" id="text-6-3-1">
<p>
AuthCallenge は、次の情報を client に通知する。
</p>

<ul class="org-ul">
<li>Challenge/Response 認証の Challenge 情報</li>
<li>バージョン</li>
<li>サーバの動作モード</li>
</ul>

<p>
client は、この情報から Challenge/Response の Response 情報を生成する。
</p>
</div>
</div>

<div id="outline-container-org6c794a6" class="outline-4">
<h4 id="org6c794a6"><span class="section-number-4">6.3.2</span> AuthResponse</h4>
<div class="outline-text-4" id="text-6-3-2">
<p>
AuthResponse は、次の情報を server に通知する。
</p>

<ul class="org-ul">
<li>Challenge/Response 認証の Response 情報</li>
<li>セッションID
<ul class="org-ul">
<li>新規接続か、切断時の再接続かを示す。</li>
<li>新規の場合 0。再接続の場合、再接続先を示すセッションID。</li>
</ul></li>
<li>client 側パケットの WriteNo/ReadNo
<ul class="org-ul">
<li>再接続する時、再送信が必要かどうかを確認するためのパケット情報</li>
</ul></li>
<li>制御コード
<ul class="org-ul">
<li>特殊な処理を行なう場合に指定する。</li>
<li>例えば tunnel 間のラウンドトリップタイムを計測するモードを指定できる。</li>
</ul></li>
</ul>

<p>
server は、この情報から client 認証を行なう。
</p>
</div>
</div>

<div id="outline-container-orga52a110" class="outline-4">
<h4 id="orga52a110"><span class="section-number-4">6.3.3</span> AuthResult ( server -&gt; client )</h4>
<div class="outline-text-4" id="text-6-3-3">
<p>
AuthResult は、次の情報を client に通知する。
</p>

<ul class="org-ul">
<li>認証結果</li>
<li>セッションID
<ul class="org-ul">
<li>どのセッション ID を使用して通信を行なうかを示す。</li>
</ul></li>
<li>Server 側パケットの WriteNo/ReadNo</li>
</ul>

<p>
以上で、 tunnel の client/server 間の接続が確立する。
</p>
</div>
</div>
</div>

<div id="outline-container-org5840775" class="outline-3">
<h3 id="org5840775"><span class="section-number-3">6.4</span> 開発言語</h3>
<div class="outline-text-3" id="text-6-4">
<p>
この Tunnel ツールの開発には、次の技術が不可欠である。
</p>

<ul class="org-ul">
<li>TCP</li>
<li>Proxy Client</li>
<li>HTTP Client/Server</li>
<li>WebSocket Client/Server</li>
</ul>

<p>
これら技術との相性の良さという意味では、
node.js が一番始めに候補に上りそうな気がする。
しかし、今は Go の勉強中ということもあり Go で開発を行なった。
</p>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2020-05-29</p>
<p class="author">Author: ifritJP</p>
<p class="date">Created: 2020-06-12</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>