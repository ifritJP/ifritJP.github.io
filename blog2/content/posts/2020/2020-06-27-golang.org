#+TITLE: Go 言語 (golang) について思ったこと
#+DATE: 2020-06-27
# -*- coding:utf-8 -*-
#+LAYOUT: post
#+TAGS: LuneScript
#+AUTHOR: ifritJP
#+OPTIONS: ^:{}
#+STARTUP: nofold

Go の勉強を兼て「[[http://192.168.0.130:1313/posts/2020/2020-06-04-go-proxy/][これ]]」を Go で作っていたんだが、その時感じた Go の特徴をまとめておく。


Go は気軽に書けるのに、非常に高い実行パフォーマンスを出せる使い勝手の良い言語だと思う。

また、パッケージマネージャを言語自身に内蔵しているため、
拡張パッケージが揃っていて、今後さらにパッケージが充実して使える言語になるだろう。

こんな様なことは、もう誰もが書いていることだと思うので、
以降では、もう少し違った角度で Go について考えたことをまとめておく。

* Go はエンジニアを信用している言語

*「エンジニアを信用している」* とはどういう事かというと、
Go を使うエンジニアはつまらない間違いをしない高レベルな技術を持っていることを
前提にしている、ということだ。

この根拠は、Go の次の言語仕様から来ている。

- nil 安全がない
- 構造体のコンストラクタがない
- アクセス制限が公開と package 内限定しかない
- Generics がない
- 基本的に mutable
- shadowing 可能
- 排他制御が古典的

静的型付け言語は、安全方向に仕様を振っていて、
出来ることを制限する手段を提供していることが多い(例えばアクセス制限や Generics 等)。
一方 Go では、そのような制限する手段を提供していない部分が多い。

では何故、Go は言語仕様による制限をしないのか？
それは、 Go の設計者が、そんな機能に頼らなくても安全に開発を進められる、
という思いがあったからだろう。

一方近年話題になっている Rust では、
Go とは逆にエンジニアを信用していない言語で、
エンジニアはヒューマンエラーを起すことを前提にしている。
そして、ヒューマンエラーが起きたときは、コンパイラレベルで検知して
エラーするようにしている。ただ、これを実現するために多くのメタ情報を
コード上に宣言する必要がある。

これは言語仕様の決め方の方向性が違うだけで、
どちらが正解で、どちらが間違っているというものではない。

プロジェクトで採用する言語を決定する際に、
どのような言語がそのプロジェクトにマッチするのかを判断することが重要だ。
