<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>hoge blog</title>
    <link>https://ifritjp.github.io/blog2/public/</link>
    <description>Recent content on hoge blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sun, 24 Mar 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://ifritjp.github.io/blog2/public/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Android 版 Firefox のアプリ切り替え時の処理</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2024/2024-03-24-android-firefox-active/</link>
      <pubDate>Sun, 24 Mar 2024 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2024/2024-03-24-android-firefox-active/</guid>
      <description>Android 版 Firefox は、 バックグラウンドに切り替えると android の省電力機能によって、 Web ページの状態が保持されず、 アプリをフォアクラウンドに切り替えた際に Web ページがリロードされることがあります。 静的な Web ページであれば、リロードするだけで画面を再構成されます。 セッション管理が必要な Web ページであれば、 Cookie を利用してセッションを復元できます。 Web Extension の場合、通常の Web ページとは異なる制御が必要になります。 省電力機能によって Web Extension のペー</description>
    </item>
    
    <item>
      <title>Firefox の File System API (オリジンプライベートファイルシステム)</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2024/2024-03-13-firefox-file-system-api/</link>
      <pubDate>Wed, 13 Mar 2024 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2024/2024-03-13-firefox-file-system-api/</guid>
      <description>ブラウザ上で動作するウェブアプリ内のデータは、 基本的に RAM 上で管理されるだけで不揮発には保持されない。 不揮発にデータを保持するには、次の 3 つの方法がある。 Cookie データの本体をサーバ側で記録しておき、 サーバ側で管理しているデータへのアクセスキーをブラウザ側で不揮発に管理する方法。 Web Storage API Key-value 方式の簡易的な DB で、 比較的に小さいサイズのデータをブラウザ側で不揮発に管理する方法。 File System API ブラウザ側のファイルシステムを</description>
    </item>
    
    <item>
      <title>ブラウザ(Firefox)の拡張機能で「出来ること」と「出来ないこと」</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2024/2024-01-14-firefox-extension-permission/</link>
      <pubDate>Sun, 14 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2024/2024-01-14-firefox-extension-permission/</guid>
      <description>ブラウザ(Firefox)の拡張機能は、 通常の Web のクライアントサイドプログラム(JavaScript + wasm) では出来ないことが 実現可能になっている。 例えば、拡張機能は表示中の全てのタブ内の情報にアクセスできる。 とはいえ、何でも出来てしまうと、それはそれでセキュリティ上問題になる。 そのため、セキュリティ問題となるようなことはそもそも実現できない。 例えば、ブラウザを実行している環境内のネットワークへの TCP,UDP で</description>
    </item>
    
    <item>
      <title>Firefox の拡張機能で additional review が必要な manifest.json の項目</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2024/2024-01-07-firefox-extension-review/</link>
      <pubDate>Sun, 07 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2024/2024-01-07-firefox-extension-review/</guid>
      <description>Firefox の拡張機能をインストール可能な状態にするには署名が必要で、 この署名には addons.mozilla.org のレビューが必要になる。 レビューとはいえ基本的には機械的に処理され、 署名処理自体は数分程度で終了する。 しかし中には例外があり、機械的なレビューではなく、 追加レビュー(additional review)が必要なケースが存在する。 では、どんなときに additional review が必要になるか？ それは、 manifest.json の項目に依存するらしい。 manifest.json の項目だけでなく、 JS コード</description>
    </item>
    
    <item>
      <title>Android 版 Firefox で動かす拡張機能を Wireless debug する</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2024/2024-01-06-wireless-debug-firefox-on-android/</link>
      <pubDate>Sat, 06 Jan 2024 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2024/2024-01-06-wireless-debug-firefox-on-android/</guid>
      <description>昨年終盤から Firefox の拡張機能開発に手を出し始めた。 折角作った拡張機能なので PC 版だけでなく、 android 版 Firefox でも動かそうと思い Android 版 Firefox でのデバッグ方法を調べたので、 備忘録として載せておく。 なお、基本は次の公式ドキュメント通りだが、 躓いたところもあるので改めてここに設定手順を残す。 &amp;lt;https://firefox-source-docs.mozilla.org/devtools-user/about_colon_debugging/index.html#connecting-to-android-over-wi-fi&amp;gt; Wireless debug Android 版 Firefox の拡張機能のデバッグを行なうには、 Android 版 Firefox とそれをデバッグする PC 版 Firefox を接続する必要がある。 そしてその接続方法には、次の 2 つある。</description>
    </item>
    
    <item>
      <title>YouTube2ppt (YouTube 動画から powerpoint のスライドを生成) ブラウザ拡張機能</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2023/2023-12-10-youtube2ppt/</link>
      <pubDate>Sun, 10 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2023/2023-12-10-youtube2ppt/</guid>
      <description>最近 ML(Machine Learning)を勉強しています。 その勉強でよく参考にするのが、 YouTube の解説動画です。 解説動画をパワポにまとめる この解説動画は、スライドを再生しながら内容を解説する動画になっています。 動画での解説は文字よりも情報が頭に入ってくる、というメリットはありますが、 動画を後で見返すのは時間がかかるし、 どの再生時間だったかを探すのも面倒です。 そのため、自分の理解を深めるため &amp;amp; 後で見返したときに確認したい</description>
    </item>
    
    <item>
      <title>rye と jupyter notebook</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2023/2023-12-03-rye-notebook/</link>
      <pubDate>Sun, 03 Dec 2023 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2023/2023-12-03-rye-notebook/</guid>
      <description>前回は、ML 勉強環境を構築するための rye セットアップ方法についてでした。 今回は、 rye で jupyter notebook をセットアップするところです。 rye をセットアップしておけば、あとは普通にコマンドを叩くだけで、 特に躓くところはないです。 jupyter notebook セットアップ 以下を実行します。 # project 作成 $ rye init ntbk # ここで指定する project 名は、 pypi でインストールするパッケージ名と被らないようにする $ cd ntbk # project 設定 $ rye pin 3.10 $ rye add notebook $ rye sync 上記コメントに書いていますが、 rye の</description>
    </item>
    
    <item>
      <title>rye と ML(Machine Learning)</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2023/2023-11-10-rye-ai/</link>
      <pubDate>Fri, 10 Nov 2023 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2023/2023-11-10-rye-ai/</guid>
      <description>ML (Machine Learning) の開発環境で利用する Python の仮想環境管理に rye を使ってみようと思ってかなり悪戦苦闘した記録。 重い腰を上げてようやく ML 系の学習を初めようと、 学習用の開発環境を準備しました。 そして、せっかくだから Python の仮想環境管理に比較的評判の良い rye を使ってみたのが全ての始まりでした。 実は rye は Python のバージョンに依存する Python で ML を使うとなると、 現在は多くの場合 Python のバージョンは 3.10 までの対応になります。 一方で、 Python の最新は 3.12 です。</description>
    </item>
    
    <item>
      <title>LuneScript セルフホストビルド時の go スレッド状態</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2023/2023-11-03-lunescript-selfhost-thread/</link>
      <pubDate>Tue, 31 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2023/2023-11-03-lunescript-selfhost-thread/</guid>
      <description>LuneScript セルフホストビルド時の go スレッドの状態について調べてみました。 グラフの説明 次の図は、 go ランタイムのトレース機能(GODEBUG=schedtrace=5)を使って取得した go のスレッドスケジューリング情報と、 セルフホストビルドのモジュールの Meta 情報解析進捗状態を示したグラフです。 それぞれの値は次の通りです。 ready meta セルフホストビルドにおける Meta 情報解析が終了したモジュール数 threads go のスレッド数 active threads go のスレッド</description>
    </item>
    
    <item>
      <title>LuneScript のソースコード規模とビルド時間の推移</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2023/2023-10-29-lunescript-performance-history/</link>
      <pubDate>Sun, 29 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2023/2023-10-29-lunescript-performance-history/</guid>
      <description>LuneScript のソースコード規模まとめをやったのが、3年前の 2020/10/1。 ../../2020/2020-10-01-lunescript-codesize/ 3年経ったのでそろそろ振り返りをやっても良い頃だろう、ということで、 今回はソースコード規模とついでにビルド時間の推移についてのネタ。 ソースコード規模とビルド時間の推移 以下は、 2020/11/8 から現在までのソースコード規模とビルド時間の推移を示す図である。 このグラフは、以下の 4 つの値の推移を表わしている。 セルフホストビルドの実時間 .lns から .lua, .go への</description>
    </item>
    
    <item>
      <title>PC9801-OS/V という PC9801 シリーズ向けの OS</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2023/2023-10-23-pc9801-os-v/</link>
      <pubDate>Mon, 23 Oct 2023 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2023/2023-10-23-pc9801-os-v/</guid>
      <description>そろそろ Windows12 が出ると噂されている。 自分の PC 環境は win10 が現役で、 win11 を入れる前にもう win12 なのかと、 なんとも微妙な気持ちがある。 Windows が普及し始めた時代 ところで、今はデスクトップ PC 向け OS といえば、ほぼ windows 一択の状況である。 もちろん、 Mac 派や Linux 派の方がいるのは分っているが、 一旦ここではそれらを取り上げない。 そんな windows がここまで勢力を強めたのは、 自分が知る限り win95 あるいは win98 辺りだ。 そして、今思うと不思議なことだが、何故か PC の</description>
    </item>
    
    <item>
      <title>お金にまつわる話し</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2023/2023-09-30-security/</link>
      <pubDate>Sat, 30 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2023/2023-09-30-security/</guid>
      <description>今回のネタは、これまでとちょっと違った毛色のネタである。 ネタの背景 日本人あるあるだと思うが、 これまでほとんど 「お金を運用する」 ということを やってこなかった。 何となく「運用ってのは金持ちのすること」みたいな感覚があったし、 はっきり言って 「お金のリテラシー」 が低かった。 なお、「ほとんど」と付けている通り、全く経験がない訳ではない。 実は 10 数年前にデビューしていたりする。 ただ、そのデビューしたタイミングが</description>
    </item>
    
    <item>
      <title>Microsoft アカウントの生年月日設定</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2023/2023-09-02-microsoft_account_birthday/</link>
      <pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2023/2023-09-02-microsoft_account_birthday/</guid>
      <description>久々にプライベートのアカウントで teams にアクセスしようとしたら、 未成年だから使えない、というような内容が表示された。 「どういうことっちゃ？」と思い、 ブラウザでログインしてアカウント設定を見てみると、 生年月日が 2016 年になっていた。なお誕生日は本来の日付だった。 2016 年というと、たぶん win7 から win10 へのアップグレードをしたタイミングだと思われる。 そして、そのアップグレードをするタイミングで windows のライセンスを登録するため</description>
    </item>
    
    <item>
      <title>Windows のマイクの音が小さい(というか無音)</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2023/2023-09-02-mic_volume/</link>
      <pubDate>Sat, 02 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2023/2023-09-02-mic_volume/</guid>
      <description>普段ウェブ会議には使わない作業用 PC でウェブ会議をしようと思い、 会議の少し前に外付けのマイクとカメラのセットアップを開始。 しかし、カメラは設定できたものの、マイクは音が録れない状況に。 そんな訳で、今回はマイクの音が小さい(というか無音)の場合の 対処方法について。 結論 先に結論を書くと、以下の手順で問題解決できた。 「スタートメニュー」 → 「設定」→ 「プライバシー」→ 「マイク」 「アプリがマイクにアクセスでき</description>
    </item>
    
    <item>
      <title>久々のネタ更新(さらに久々の lctags 更新)</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2023/2023-07-23-lctags-update/</link>
      <pubDate>Sun, 23 Jul 2023 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2023/2023-07-23-lctags-update/</guid>
      <description>github に上げている個人的なツールの中で、 スターの付いている数少ないプロジェクトの1つである lctags。 これを久し振りに更新した。 更新内容は以下の通り。 docker による環境構築対応 C++ の auto 型推論対応 libclang15 対応 暫くノーメンテだった lctags を、このタイミングで更新したのは、 イマドキの C++ に使うには色々と不備があった為。 仕事で新しいプロジェクトに入り、そこで C++ をメインで利用していたので、 ソースを読む補助ツールとして lctags を導入しよう</description>
    </item>
    
    <item>
      <title>monaco editor に自作言語拡張(インデント、補完、syntax エラー)を登録する</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2023/2023-04-23-monago/</link>
      <pubDate>Sun, 23 Apr 2023 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2023/2023-04-23-monago/</guid>
      <description>次の URL で提供している LuneScript playground 環境のエディタを、 シンプルな textarea からモダンな monaco editor に変更しました。 &amp;lt;https://ifritjp.github.io/LuneScript-webFront/lnsc_web_frontend/for_wasm/&amp;gt; 今回のネタは、monaco editor に独自言語の次の機能を追加する方法についてです。 インデント調整 コード補完 syntax エラー表示 monaco editor monaco editor は、 vscode のエディタ・コアです。 &amp;lt;https://microsoft.github.io/monaco-editor/&amp;gt; web 上で動作する高機能エディタには、 monaco editor とは別に Ace もありますが、 今回は monaco editor の方を採用しました。 その理由は、 近い将来的に vscode 用の LuneScript extension を作成するときに、 monaco editor を知っていた方</description>
    </item>
    
    <item>
      <title>LuneScript のセルフホストビルド時間と GOMAXPROCS</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2023/2023-03-19-gomaxprocs/</link>
      <pubDate>Sun, 19 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2023/2023-03-19-gomaxprocs/</guid>
      <description>LuneScript のセルフホストビルド時間が1秒を切れない問題。 GOMAXPROCS を設定すれば、もしかしたら簡単に短縮できるのではないか？ と思って GOMAXPROCS を 1 〜 11 まで変えてみた。 その結果が次の図。 この図を見ると、GOMAXPROCS を上げるごとに、僅かにビルド時間(real time)が下っている。 一方で、 real time の下げ幅よりも、 並列処理の合計時間(user time)の上げ幅の方が大きくなってしまっている。 今は 6 コアの Ryzen 3600 使っていて、 次の候</description>
    </item>
    
    <item>
      <title>LuneScript のコレクション側を Go の generics を利用するように変更</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2023/2023-02-27-go-generics3/</link>
      <pubDate>Mon, 27 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2023/2023-02-27-go-generics3/</guid>
      <description>&amp;lt;../../2023/2023-02-11-go-generics2/&amp;gt; 前回の記事で書いた通り、 go の generics のパフォーマンスが向上したため、 LuneScript の v1.6.0 で go の generics を利用するように対応しました。 なお、現状は collection 型の対応に限定しています。 LuneScript で、新しくクラスで定義した generics は、従来通りの対応です。 詳しくは以下を参照。 &amp;lt;https://ifritjp.github.io/documents/lunescript/generics-go/&amp;gt; なお、この対応前と対応後では、 LuneScript のパフォーマンスはほとんど誤差レベルの差しかありませんでした。。。 なので、現状は積極的に使っていくモノではないです。 まぁ、でも今回の対応で既存バ</description>
    </item>
    
    <item>
      <title>Golang の generics パフォーマンスがもの凄く改善されていた</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2023/2023-02-11-go-generics2/</link>
      <pubDate>Sat, 11 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2023/2023-02-11-go-generics2/</guid>
      <description>以前 Golang 1.19.2 の generics のパフォーマンスを計測したところ、 generics を使ったケースと、自前で any からキャストするケースを比較すると、 なぜか自前で any からキャストする方が速くなるという謎の現象が発生していました。 前回の結果はここ。 ../../2022/2022-10-15-go-generics/ go のバージョンが 1.20 に上ったので、 再度同じテストをして確認してみます。 確認方法 テストするコードは前回と全く同じものを使います。 このコードを go の 1.19.2 と 1.20 でビルドし、実行結果を比較します。 実行結果 実行結</description>
    </item>
    
    <item>
      <title>LuneScript のタプルの go 実装</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2023/2023-01-29-tuple-implementation/</link>
      <pubDate>Sun, 29 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2023/2023-01-29-tuple-implementation/</guid>
      <description>LuneScript の v1.5.3 からタプルを対応している。 このタプルの go 実装についてパフォーマンスを調べた内容を載せておく。 LuneScript のタプルの go 変換初期実装 ここでは、LuneScript のタプルを go に変換した際に、 どのような実装になっているかを説明する。 LuneScript で次のようなタプル (int と str のペア) を定義した場合、 (int,str) go では次の型として扱う。 []any つまり、タプルの各要素の型情報は一旦 any に丸め、 タプルから値を取得する際に型変換を行なう。 例えば次の LuneScript</description>
    </item>
    
    <item>
      <title>Raspberry pi に接続していた USB HDD が調子悪いので色々と対応してみた(未解決)</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2023/2023-01-09-raspi-strange-hdd/</link>
      <pubDate>Mon, 09 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2023/2023-01-09-raspi-strange-hdd/</guid>
      <description>Raspberry pi でサーバ運用を始めて約 2 年。 どうにも最近 Raspberry pi に接続している USB HDD の調子がイマイチだったので、 その対応を行なった。 ただし、未解決。。。 ここでは、その対応の記録を残す。 症状と作業内容 不調の症状は以下。 「HDD のファイルを Read すると、不定期に iowait が増大し、最悪数秒程度止まる。」 ちなみに usb hdd は、 バスパワーではなく AC アダプタ付きの USB HDDケースを使ったもの。 なので「電流が足らない」ということではないはず。 念の</description>
    </item>
    
    <item>
      <title>actix-web (Rust の web フレームワーク)</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2023/2023-01-06-actix-web/</link>
      <pubDate>Fri, 06 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2023/2023-01-06-actix-web/</guid>
      <description>Web サーバを作成するにあたり actix-web を使ってみたので、 初心者の目線から見た感想など。 actix-web 世の中には言語ごとに様々な web フレームワークがありますが、 actix-web は Rust の web フレームワークです。 なんで actix-web を選んだのかと言えば、「Rust を使いたかった」から。 Rust は数年前に話題になったときに、どんなもんなんだろう？と、 チュートリアルと簡単なツールを作っただけで、それ以降触っていなかったので、 そろそろちゃんと触っておこう、と思ったのが</description>
    </item>
    
    <item>
      <title>Golang の WASM (JavaScript の非同期処理 async との連携)</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2022/2022-12-18-go-wasm-async/</link>
      <pubDate>Sun, 18 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2022/2022-12-18-go-wasm-async/</guid>
      <description>go の wasm と、JavaScript の非同期処理との連携についてです。 基本的な go の wasm と JavaScript 間のインタフェースについては、 以前のネタを確認してください。 ../2022-09-19-go-wasm go の wasm の非同期処理 複数の goroutine を利用したプログラムを wasm に変換すると、 GOMAXPROCS=1 を指定した時と同じ動作になります。 つまり、複数の goroutine を起動させても、 複数の goroutine が同時に動作することはなく、 ある瞬間にアクティブになる goroutine は 1 つだけということです。 これは前回のネタでも書いたことです</description>
    </item>
    
    <item>
      <title>FDM 3D プリンタのスライス設定と STL エラー対策</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2022/2022-12-04-3d-printer-slice/</link>
      <pubDate>Sun, 04 Dec 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2022/2022-12-04-3d-printer-slice/</guid>
      <description>今回も引き続き 3D プリンタ系の話です。 3D プリントの出来 3D プリントの出来は次の要素で決まります。 3D プリンタの性能 フィラメントの性能 スライサーの性能、パラメータ どんなに良い 3D プリンタやフィラメントを使っても、 スライサーの性能が悪い、 スライサーのパラメータの設定が正しくない場合、 意図したプリントは出来ません。 Ultimaker cura 3D プリンタでオブジェクトをプリントするには、 3D オブジェクトを積層データ形式に変換する必要があり</description>
    </item>
    
    <item>
      <title>100 均で作る超お手軽・安価な 3D プリンタ用フィラメント除湿・送出・保管ボックス</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2022/2022-11-27-3d-printer-filament-box/</link>
      <pubDate>Sun, 27 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2022/2022-11-27-3d-printer-filament-box/</guid>
      <description>今回は珍しくソフト系のネタではなく、3D プリンタ系の話です。 FDM 式は面倒が少ない 3D プリンタを購入するにあたり、事前に色々と調べた結果、 光造形式ではなく FDM 式にしました。 FDM 式を選んだ主な理由は 「面倒が少ない」 です。 光造形式の洗浄・二次硬化はどうしても面倒に感じました。 またそれ以外にも光造形式の以下の点が気になり、FDM 式を選択しています。 レジンの匂い 多くのレジンが無駄になってエコ(economy,eco</description>
    </item>
    
    <item>
      <title>Golang の Heap メモリ制限</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2022/2022-10-27-go-limit-heap/</link>
      <pubDate>Thu, 27 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2022/2022-10-27-go-limit-heap/</guid>
      <description>go は GC で heap メモリを管理している。 Java の場合、最大 heap サイズを指定し、 そのサイズを越えた場合は OutOfMemoryError になる。 最大 heap サイズが指定されていない場合はデフォルトのサイズが利用される。 なお、Java でメモリフルが発生する際は、 最大 heap サイズがデフォルト設定のまま、というケースが多い。 まぁ、ここでは Java の話は置いておいて、 go での heap 制御ってどうなの？と、いうのが今回の話。 GOGC と GOMEMLIMIT go の heap メモリ制御は、 java のような予め決められた heap</description>
    </item>
    
    <item>
      <title>Golang の generics パフォーマンス</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2022/2022-10-15-go-generics/</link>
      <pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2022/2022-10-15-go-generics/</guid>
      <description>LuneScript は、 Golang (1.16 以降)へのトランスコンパイルを対応しています。 また、LuneScript は Generics に対応しています。 一方で、 Golang は version 1.18 から Generics に対応しています。 つまり、 LuneScript は Golang が Generics 対応する前から Generics を利用できていました。 では、 Generics を利用していた LuneScript のコードを どうやって Generics 対応前の Golang にトランスコンパイルしていたかというと、 Generics の型パラメータの値を interface{} に変換して処理を行なっていました。 Java でいうところの autoboxing のようなことを変換時にやって</description>
    </item>
    
    <item>
      <title>Golang の WASM (Golang から JavaScript の呼び出し, JavaScript から Golang の呼び出し)</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2022/2022-09-19-go-wasm/</link>
      <pubDate>Mon, 19 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2022/2022-09-19-go-wasm/</guid>
      <description>LuneScript Web Frontは今迄 fengari を利用していましたが、 golang の wasm で動かせるようにサポートしました。 その際に golang の wasm の利用方法について調べたことをまとめておきます。 golang の wasm 基本的なことは以下の公式ドキュメントをみてください。 &amp;lt;https://github.com/golang/go/wiki/WebAssembly&amp;gt; 最低限のステップをまとめると、以下の手順になります。 以下の環境変数を指定して WASM 化したいプロジェクトをビルドします。 これで main.wasm に WASM 化したコードが出力されます。 $ GOOS=js GOARCH=wasm go build -o main.wasm 以下の wasm_exec.js をコピーします。 $</description>
    </item>
    
    <item>
      <title>LuneScript の工数( SLOC )</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2022/2022-08-04-sloc/</link>
      <pubDate>Thu, 04 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2022/2022-08-04-sloc/</guid>
      <description>&amp;lt;http://localhost:1313/posts/2020/2020-08-01-lunescript-man-hour/&amp;gt; 以前 LuneScript の工数を考えたが、今回は別の面から工数を考えてみる。 ソフトウェア開発分析データ集2020 &amp;lt;https://www.ipa.go.jp/ikc/reports/20200930.html&amp;gt; 上記のリンク先の資料「ソフトウェア開発分析データ集2020」の p.84 に、 新規開発の SLOC 生産性の表「A1-2-1 SLOC 規模別 SLOC 生産性(新規開発)」がある。 この表には、コード規模毎に最小、最大、平均の SLOC 生産性が載っている。 このデータから LuneScript の工数を計算する。 LuneScript の工数 LuneScript の現在の規模はコメント含んで約 56 Kline。 SLOC は本</description>
    </item>
    
    <item>
      <title>WebSocket client と TCP client の中継ツールを作った</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2022/2022-06-01-wstcplink/</link>
      <pubDate>Wed, 01 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2022/2022-06-01-wstcplink/</guid>
      <description>wstcplink を作った。 &amp;lt;https://github.com/ifritJP/wstcplink&amp;gt; これが何かというと、 WebSocket client と TCP client の中継ツールだ。 次のような感じ。 ⇔⇔⇔⇔⇔⇔⇔⇔ Webブラウザ → このツール ← tcp クライアント ⇔⇔⇔⇔⇔⇔⇔⇔ Web アプリケーションとの双方向通信 Web アプリケーションで双方向通信するには、 web socket を使うのが標準だと思う。 (web socket にも課題はあるが、その辺りはここでは触れない。) で、その場合 web socket に対応したサーバが必要になる。 一方で、web socket に対応するのが困難な環境もある。 イマ</description>
    </item>
    
    <item>
      <title>Raspberry pi イメージのバックアップ</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2022/2022-04-30-raspi-backup/</link>
      <pubDate>Sat, 30 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2022/2022-04-30-raspi-backup/</guid>
      <description>家で運用している Raspberry pi サーバイメージのバックアップを shrink するのに どうするのが良いのか調べていたら、 https://github.com/Drewsif/PiShrink を使えばいいだけだということが分かった。 事前に raspi の sdcard イメージファイルを作って、 それを以下のように実行すれば ok. $ sudo pishrink.sh sdcard.img これを実行すると、次が行なわれる。 指定のイメージファイル内の /etc/rc.local が /etc/rc.local.bak にバックアップされる 指定のイメージファイル内の /etc/rc.local に、以下を実行するスクリプトが作成される。 shrink させたファイルシステムを expand する</description>
    </item>
    
    <item>
      <title>M5stack(ESP32) で Bluetooth(btstack) の機能を利用する際の注意点</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2022/2022-02-23-m5stack-btstack/</link>
      <pubDate>Wed, 23 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2022/2022-02-23-m5stack-btstack/</guid>
      <description>M5stack の公式 Web サイトを見ると、 M5stack の開発環境は以下のものが挙げられています。 &amp;lt;https://docs.m5stack.com/en/platform&amp;gt; UIFlow Arduino Camera Series Micropython .NET nanoFramework これらは、ソフトウェアを簡単に開発することにフォーカスされていて、 Bluetooth を制御する API の充実度は低いようです。 上記の開発環境で提供されていない Bluetooth の機能を利用するには、 ESP32 の official SDK の esp-idf か、 汎用的な Bluetooth Library の btstack を使う必要があります。 M5stack で Bluetooth の機能を利用するアプリを開発する場合、 その機能がどの開発環境で提供されているかを調査し、 その中</description>
    </item>
    
    <item>
      <title>OS に依存しない Bluetooth キーボードのキー入れ替え (M5stack版)</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2022/2022-02-22-bt-keyboard-remapper/</link>
      <pubDate>Tue, 22 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2022/2022-02-22-bt-keyboard-remapper/</guid>
      <description>前回 Raspberry pi zero w 版の keyboard remapper に引き続き、 M5stack 版の keyboard remapper を作成しました。 M5stack は、 Raspberry pi zero w と比べて以下の長所があります。 モデルによっては小型軽量 基板が剥き出しになっていない 今は Raspberry pi より入手性が良い 消費電力が 1/5 以下 本体に汎用的に使えるボタンが付いている モデルによっては、本体にディスプレイが付いている 一方で、以下の短所があります。 ROM/RAM が圧倒的に少ない 独自 OS で、開発環境が限定的 情報が少ない 環境構築に時間がかかる 動作確認には</description>
    </item>
    
    <item>
      <title>HID Keyboard の Key スキャンコード</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2022/2022-01-16-keyboard-key-scan-code/</link>
      <pubDate>Sun, 16 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2022/2022-01-16-keyboard-key-scan-code/</guid>
      <description>普段、何気に使っている keyboard。 このキーボードがどのように動いているか。 そして、カスタマイズするにはどうすれば良いかを簡単に説明していく。 キーボードと OS の役割り USB で定義される HID keyboard の各キーには、 スキャンコードという値を割り振られています。 keyboard は、キーが押下された時にこのスキャンコードを PC に通知します。 そして、PC はそのスキャンコードを受け、どのキーが押下されたかを検出します。 ところで、キーボー</description>
    </item>
    
    <item>
      <title>Hardware Keyboard Remapper(OS に依存しないキーボードのキー入れ替え)を作った</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2022/2022-01-10-hw-keyboard-remapper/</link>
      <pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2022/2022-01-10-hw-keyboard-remapper/</guid>
      <description>皆さんはキーボードのキーを入れ替えてますか？ キー入れ替えのメジャーな用途は、 Ctrl キーと Cap Lock キーの入れ替えでしょう。 そのような人は、 「OS のキー入れ替え設定」するのが新しい PC セットアップ時の手順の一つに なっている人も少なくないでしょう。 しかし、「OS のキー入れ替え設定」が常に出来るとは限りません。 例えば、共有 PC を使うケースや、 そもそも OS がキー入れ替えをサポートしていないケースなど。 そのような時に使うこ</description>
    </item>
    
    <item>
      <title>液晶ディスプレイメーカーのドット抜け保証</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2021/2021-12-05-display-dots/</link>
      <pubDate>Sun, 05 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2021/2021-12-05-display-dots/</guid>
      <description>4K ディスプレイが欲しくなったので調べものをしている。 液晶ディスプレイを選ぶ際、用途によってさまざまな観点でチェックするだろう。 しかし、誰もが気になるのは 「ドット抜け」 だろう。 そんな訳で、各メーカー毎のドット抜け保証についてまとめてみた。 ドット抜け保証まとめ 国内で購入可能なメジャーメーカーの保証状況を以下に示す。 順位 メーカー 保証内容 リンク 1? EIZO 1点もない (例外あり) リンク 2? ACER 中央に集中して3点以内、又</description>
    </item>
    
    <item>
      <title>LuneScript がエラーハンドリングと大域脱出をサポートできていない理由</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2021/2021-11-14-lunescript-error-handling/</link>
      <pubDate>Sun, 14 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2021/2021-11-14-lunescript-error-handling/</guid>
      <description>数ヶ月間 LuneScript から離れていますが、生存アピールのためにちょっと触れておきます 今日現在、 LuneScript は言語機能としてエラーハンドリングと大域脱出をサポートしていません。 現在でも、module 機能を利用して 裏技的にエラーハンドリングと大域脱出を使うことは出来なくもないです。 しかし、それはあくまでも裏技で正式機能ではありません。 「何故サポートしていないか？」というと、 エラーハンドリングと大域脱出のベストプラクティスが</description>
    </item>
    
    <item>
      <title>WSL2 共存による VirtualBox/VMWare の性能低下と、性能重視時の排他設定方法</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2021/2021-11-08-wsl2-virtualbox/</link>
      <pubDate>Mon, 08 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2021/2021-11-08-wsl2-virtualbox/</guid>
      <description>VirtualBox/VMWare と WSL2 は共存可能です。 しかし、共存させると VirtualBox/VMWare 上の GuestOS にオーバーヘッドがかかります。 今回はオーバーヘッドの概要と、共存と排他の設定切り替え方法のネタです。 VirtualBox と WSL2 共存のオーバーヘッド 以下に VirtualBox と WSL2 の実行時の階層図を示します。 この図は、次の 4 つの状態を表わしています。 (A) 従来の Windows で VirtualBox を動かす状態 (B) Windows で WSL2 を動かす状態 (C) Windows で WSL2 と VirtualBox を動かす状態(異常時) (D) Windows で WSL2 と VirtualBox を動かす状態(正常時) (A) は、 WSL サポート前の Windows で VirtualBox を</description>
    </item>
    
    <item>
      <title>MS Teams client の作り方</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2021/2021-08-30-teams-client/</link>
      <pubDate>Mon, 30 Aug 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2021/2021-08-30-teams-client/</guid>
      <description>自作ツールで、MS Teams に対して投稿を read/write する方法について書きます。 Teams の管理者権限の許可が必須 「 Teams の管理者権限の許可が必須 」です。 大事なことなので始めに書きます。 自作ツールで、MS Teams に任意に投稿を read/write するには、 「 Teams の管理者権限の許可が必須 」です。 たとえ自分自身のアカウントを使って投稿したくても、 自作ツールから行なうには管理者権限の許可が必須 なんです。 MS Graph API へのアクセス MS Graph API は、以下のサイトにリファレンスが</description>
    </item>
    
    <item>
      <title>asciidoc の pdf 化</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2021/2021-07-26-asciidoc-2-pdf/</link>
      <pubDate>Mon, 26 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2021/2021-07-26-asciidoc-2-pdf/</guid>
      <description>asciidoctor-pdf を利用すると asciidoc を pdf 化できます。 ここでは、 asciidoctor-pdf のセットアップと pdf 化時のレイアウト変更方法について説明します。 asciidoctor-pdf のセットアップ asciidoctor-pdf が既にインストールされている場合、 日本語フォントのインストール時に conflict することがあるので、 ここでは docker を利用します。 docker を使わなくても、ローカル環境に ruby をインストールし、 Dockerfile の RUN と同等の手順を実行してもインストールできます。 asciidoctor-pdf が conflict した場合は、 asciidoctor-pdf をアンインストールしてから asciidoctor-pdf をインストー</description>
    </item>
    
    <item>
      <title>org-mode ドキュメントの翻訳ツールの使い方</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2021/2021-07-25-org-traslation-intro/</link>
      <pubDate>Mon, 19 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2021/2021-07-25-org-traslation-intro/</guid>
      <description>先日の記事に書いた org-mode ドキュメントの翻訳ツールを作成したので、 今回はそのツールの使用方法を書きます。 セットアップ golang がインストールされている環境で、以下を実行してください。 go install -tags gopherlua github.com/ifritJP/trans-orgmode@latest GCP の設定 GCP アカウントを既に持っていることを前提に説明します。 アカウントが無い場合は、作成してください。 プロジェクトの作成 以下の手順に従って作業します。 &amp;lt;https://cloud.google.com/translate/docs/setup?hl=ja#project&amp;gt; これにより、以下を行ないます。 プロジェクトを作成 API の有効化 サービスアカ</description>
    </item>
    
    <item>
      <title>org-mode ドキュメントの翻訳ツール検討</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2021/2021-07-19-org-traslation/</link>
      <pubDate>Mon, 19 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2021/2021-07-19-org-traslation/</guid>
      <description>私は org-mode を使って LuneScript のリファレンスを作成しています。 日本語のリファレンスを書くのも大変ですが、 それを英訳しようとすると気が遠くなります。 そこで機械翻訳を使う予定ですが、 .org ファイルをそのまま機械翻訳で処理すると、 コードブロックや org-mode の区切り記号まで変換され、 意図した結果を得られません。 そこで今回は、org-mode の機械翻訳をスムーズに行なえるツールを検討します。 構成 今回検討する org-mode 翻訳ツールは、以下の構成</description>
    </item>
    
    <item>
      <title>LuneScript のトランスコンパイル高速化 (スタック割り当て)</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2021/2021-07-02-lunescript-value-assigned-stack/</link>
      <pubDate>Fri, 02 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2021/2021-07-02-lunescript-value-assigned-stack/</guid>
      <description>今回の記事は、 先日検討した LuneScript のクラスのオブジェクトを スタックに割り当てて高速化できるかどうか？の検討結果です。 結果 今回の検討結果は以下の通りです。 「スタック割り当て自体は有効ですが、 スタック割り当てから escape されないように設計しないと効果を得られません。」 なんだか当たり前な検討結果ですが、そうなんだから仕方がない。 では、なぜそのような結果になったかを説明していきます。 検討内容 LuneScript でオブジェクトをスタック</description>
    </item>
    
    <item>
      <title>LuneScript のトランスコンパイル高速化 (トランスコンパイル時間を 2273 パーセント改善)</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2021/2021-06-28-lunescript-build-time-2000/</link>
      <pubDate>Mon, 28 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2021/2021-06-28-lunescript-build-time-2000/</guid>
      <description>先月から続いて、LuneScript のトランスコンパイル高速化作業をしています。 セルフホストのトランスコンパイル時間 今回の時間短縮は以下の通りです。 lua VM 版 go ビルド版 lua/go 改善前 5/6 (6e5661a9) 25.69 sec 5.84 sec 440% 改善後 5/25 (364095ef) 17.42 sec 2.22 sec 785% 改善後2 6/7(52df422b) 17.57 sec 1.82 sec 965% 改善後3 6/29(8898c475) 18.07 sec 1.13 sec 1599% 改善率(改善前/改善後3) 142% 517% この表は、セルフホスティングしているソースのトランスコンパイル時間の計測結果を 示しています。 lua VM で動作させた lnsc と、go でビル</description>
    </item>
    
    <item>
      <title>LuneScript のセルフホストのマルチスレッド化 (トランスコンパイル時間を 1412 パーセント改善)</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2021/2021-06-04-lunescript-selfhost-para/</link>
      <pubDate>Fri, 04 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2021/2021-06-04-lunescript-selfhost-para/</guid>
      <description>LuneScript の高速化のため、マルチスレッド化を行ないました。 今回は、LuneScript のどこをマルチスレッド化したのか、 マルチスレッド化で何故高速化できるのかを説明します。 ビルド時間 今回の時間短縮は以下の通りです。 lua VM 版 go ビルド版 lua/go 改善前 5/6 (6e5661a9) 25.69 sec 5.84 sec 440% 改善後 5/25 (364095ef) 17.42 sec 2.22 sec 785% 改善後2 6/7(52df422b) 17.57 sec 1.82 sec 965% 改善率(改善前/改善後2) 146% 329% この表は、セルフホスティングしているソースのトランスコンパイル時間の計測結果を 示してい</description>
    </item>
    
    <item>
      <title>LuneScript のこれからの予定</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2021/2021-05-26-lunescript-plan/</link>
      <pubDate>Wed, 26 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2021/2021-05-26-lunescript-plan/</guid>
      <description>今月上旬に TypeScriptToLua の存在を知ったことで、 「Lua のトランスコンパイラ」という LuneScript の主な 存在意義 がほとんど消えてしまいました。 それによって LuneScript 開発に対するモチベーションが一気に下りましたが、 よくよく考えてみれば、今迄も自分以外の誰かが使っていた訳でもないし、 独自言語開発は元々自分がやりたかったこと でもあるので、 TypeScriptToLua があろうとなかろうと 今迄と然程違いはないんじゃないか、 という結論になりました。 そんな訳で、Lune</description>
    </item>
    
    <item>
      <title>LuneScript のトランスコンパイル時間を 1157 パーセント改善した件</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2021/2021-05-25-lunescript-improved-build-time/</link>
      <pubDate>Tue, 25 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2021/2021-05-25-lunescript-improved-build-time/</guid>
      <description>前回から引き続き LuneScript のトランスコンパイル時間短縮を行なっています。 今回の時間短縮は以下の通りです。 lua go lua/go 改善前(6e5661a9) 25.69 sec 5.84 sec 440% 改善後(364095ef) 17.42 sec 2.22 sec 785% 改善率(改善前/改善後) 147% 263% この表は、セルフホスティングしているソースのトランスコンパイル時間の計測結果を 示しています。 lua VM で動作させた lnsc と、go でビルドした lnsc で計測しています。 改善前の 6e5661a9 は、5/6 のバージョンです。 改善後の 364095ef</description>
    </item>
    
    <item>
      <title>LuneScript のスレッドにおける mutable 制御</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2021/2021-05-16-lunescript-thread-mutable-control/</link>
      <pubDate>Sun, 16 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2021/2021-05-16-lunescript-thread-mutable-control/</guid>
      <description>LuneScript は golang へのトランスコンパイルをサポートしている。 golang 対応の付加機能として、LuneScript には限定的な非同期処理を提供している。 今回は、この「限定」を緩和する方法を検討する。 非同期処理を「限定」する理由 非同期処理を限定する主な理由は、非同期処理を安全に実行するためだ。 では、非同期処理のなにが危険なのかといえば、データアクセスの競合だ。 Rust では、データアクセスの競合が発生しないように、 言語の syntax で論理</description>
    </item>
    
    <item>
      <title>Go の関数パフォーマンス</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2021/2021-05-15-go-func-performance/</link>
      <pubDate>Sat, 15 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2021/2021-05-15-go-func-performance/</guid>
      <description>LuneScript は golang へのトランスコンパイルをサポートしている。 golang 対応の付加機能として、LuneScript には限定的なスレッド機能を提供している。 「限定的」の大きな理由の一つとして、 golang 向け LuneScript ランタイムのマルチスレッド対応問題がある。 golang 向け LuneScript ランタイム golang 向け LuneScript ランタイムは、幾つか機能を持っている。 その機能の中には、次のものを含む。 and or 演算子の処理を実現するためのスタック。 lua ランタイム制御。 LuneScript は元々 Lua 向けのトランス</description>
    </item>
    
    <item>
      <title>Language Server Protocol (LSP) メモ</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2021/2021-05-04-lsp/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2021/2021-05-04-lsp/</guid>
      <description>Language Server Protocol (LSP) の調査メモ。 後でまとめる予定だが、まずは調べた情報を列挙していく。 LSP とは LSP は、プログラミング開発する上で役立つ様々なサポート機能を定義するプロトコル。 従来は、エディタの開発者や、エディタの拡張機能開発者が プログラミング言語毎に様々なサポート機能の開発を行なっていた。 これにより、同じプログラミング言語でも、エディタごとに異る実装が必要で、 あるエディタでは使える機能が、別のエディタでは使えない</description>
    </item>
    
    <item>
      <title>LuneScript の import と meta</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2021/2021-05-04-lunescript-meta/</link>
      <pubDate>Tue, 04 May 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2021/2021-05-04-lunescript-meta/</guid>
      <description>LuneScript は、モジュールを利用する際に import 命令を使用する。 この import 命令は、次の処理を行う。 指定のモジュールの .lns ファイルを解析し、何を定義しているかを調べる shebang などで起動した場合は、指定のモジュールをロードする 今回は、前者の話をする。 meta 情報 モジュールがどんなクラスや関数や変数を定義しているのかを示す情報を、 LuneScript では meta 情報と呼ぶ。 この meta 情報は、 そのモジュール内で pub (あるいは pro) 宣言されている情報からなる。 これには次の情</description>
    </item>
    
    <item>
      <title>Rapberry pi 4 で構築する NAS (USB HDD UASP) の性能</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2021/2021-04-03-raspi-usb-hdd/</link>
      <pubDate>Sat, 03 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2021/2021-04-03-raspi-usb-hdd/</guid>
      <description>Rapberry pi 4 で簡易的な NAS を構築している。 メイン PC の OS が Windows なので、 NAS で使っている HDD を Windows PC と直接接続してアクセスすることを考えて、 NTFS フォーマットの USB HDD を raspi にマウントしていた。 しかし、これだとパフォーマンスが全く出ない(ntfs-3g が重すぎる)。 次回の windows 10 アップデートで、 WSL2 の機能をつかった ext4 マウントがサポートさるようなので、 USB HDD のファイルシステムを NTFS から ext4 に変更することにした。 これによって、NTFS の時は smb</description>
    </item>
    
    <item>
      <title>go1.16 の embed によるファイル埋め込み</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2021/2021-02-28-go-embed/</link>
      <pubDate>Sun, 28 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2021/2021-02-28-go-embed/</guid>
      <description>go1.16 から embed が利用可能になりました。 &amp;lt;https://golang.org/pkg/embed/&amp;gt; embed によって、 プログラムにバイナリデータを埋め込む処理が簡単に行なえるようになります。 LuneScript のコンパイラは、 go でビルドした際に Lua 環境がなくても動作するように、 Lua 用のセルフホストコードをコンパイラ内部に埋め込み、 実行時に埋め込んであるセルフホストコードをロードしています。 以前は、 Lua 用のセルフホストコードを []byte として定義するコードを生成するスクリプトを 自前で実行して、それをビ</description>
    </item>
    
    <item>
      <title>raspberry pi の sdcard 書き換え回数寿命を考える</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2021/2021-02-17-rasp-sdcard/</link>
      <pubDate>Wed, 17 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2021/2021-02-17-rasp-sdcard/</guid>
      <description>raspberry pi でローカルサーバを立ち上げているが、 この sdcard 寿命が気になったので調べてみた。 sdcard はでなく、 hdd や ssd で運用する方法もあるが、 sdcard で運用できる方がランニングコストが良いので、できれば sdcard で運用したい。 sdcard の寿命の見積り iostat -h で sdcard への書き込み量を調べると、 1日約 1GB の書き込み がある。 この書き込みが sdcard の 何ブロックを書き換えているのか不明 なので、 とりあえず 10 倍の 10GB 相当 のブロックを書き換えたとする。 次に sdcard が SLC か MLC か TLC かだ</description>
    </item>
    
    <item>
      <title>highlight.js で独自言語の色付けを追加</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2021/2021-02-01-hilightjs/</link>
      <pubDate>Mon, 01 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2021/2021-02-01-hilightjs/</guid>
      <description>LuneScript の解説サイトは、 hugo を使用して構築している。 その解説サイトに掲載しているソースコードは、 hugo によって解析されて、色付けに必要な &amp;lt;span class=&amp;#34;&amp;#34;&amp;gt; が付加され、 css で色付けを行なっている。 なお、 ソースコードの解析自体は hugo というよりも、 hugo が chroma の API を呼び出して利用している。 しかし LuneScript は超マイナー言語なので、 chroma の対応言語には当然 LuneScript が入っていない。 これだと LuneScript のサンプルコードのハイライトが付かないため、コードを読み難い。 そこで、L</description>
    </item>
    
    <item>
      <title>WSL2 と cygwin xorg を使って GUI 表示するまでのハマりどころ</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2020/2020-12-09-wsl2-xwin/</link>
      <pubDate>Wed, 09 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2020/2020-12-09-wsl2-xwin/</guid>
      <description>WSL2 と virtual BOX が共存できるようになったらしいので、 家の環境に WSL2 を入れてみました。 セットアップ自体は上手くいきましたが、 結果として virtual BOX のパフォーマンス(DISK IO？)は 1,2 割程度落ちたようです。 WSL2 のパフォーマンスが WSL2 無効時の virtual BOX と同等程度なので、 virtual BOX から WSL2 に完全移行できるなら問題ないと思いますが、 WSL2 に完全移行できず、かつ、1,2 割程度のパフォーマンスダウンが許容出来ない場合は、 従来通り WSL2 無効で運用すること</description>
    </item>
    
    <item>
      <title>github actions でビルドしたモジュールを google drive にアップロード</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2020/2020-12-05-lns-release/</link>
      <pubDate>Sat, 05 Dec 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2020/2020-12-05-lns-release/</guid>
      <description>LuneScript の CI 環境として github actions を使用している。 この CI のテスト時にビルドした go 版 LuneScript のシングルバイナリを、 google drive にアップロードして公開するように対応した。 &amp;lt;https://drive.google.com/drive/folders/1S5NgeM6qIOIUC0rkBHqnWZcuhmsTqB2w&amp;gt; 今回は、この手順について説明する。 公開方法 基本的には次の手順に従えば出来るが、 Google の UI の一部が変っているので、そこを主に補足していく。 &amp;lt;https://qiita.com/satackey/items/56729c8551aabb2ae7cc&amp;gt; skicka google drive へのアップロードは skicka を利用する。 skicka は OSS だ。 この skicka を利用するためには、 OAuth2 認証 ClientID と Client Secret が必要になる。 OAuth2 認証は、ウェブサービス</description>
    </item>
    
    <item>
      <title>go の自作モジュールを github で公開して import するまで</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2020/2020-11-28-golang-module/</link>
      <pubDate>Sat, 28 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2020/2020-11-28-golang-module/</guid>
      <description>LuneScript 向けの別ツールを作ろうと思い、 LuneScript の go 向けランタイムを単独モジュールとして分割して管理すべく 奮闘した際の備忘録。 go のモジュール go は、 github に公開されているモジュールを取得して使用できる。 では、自作モジュールを github に公開して使用するにはどうすれば良いか？ ここでは、その方法について順を追って説明する。 go のモジュール管理のおさらい go にはモジュール管理機能が内包されており、 基本的には次の手順でコマンドを実行する</description>
    </item>
    
    <item>
      <title>LuneScript のトランスコンパイル時間を 478 パーセント改善した件</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2020/2020-11-08-lunescript-speed-up-batch/</link>
      <pubDate>Sun, 08 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2020/2020-11-08-lunescript-speed-up-batch/</guid>
      <description>前回から引き続き LuneScript のトランスコンパイル時間短縮を行なっています。 今回の時間短縮は以下の通りです。 改善前(lua) 改善後(go) 参考 (lua batch) 参考 (luajit) 20.65 sec 4.32 sec 21.90 sec 21.56 sec この表の通り、 (/ 20.65 4.32) 4.780092592592592 ≒ 478% 改善しています。 以降では、今回の LuneScript 性能向上の実現方法について説明します。 一括処理 従来は、複数ある .lns ファイルを一つずつ処理するために、 LuneScript をファイル数分実行していました。 今回は、複数ある .lns ファイル全てを 一回の LuneScript の起動で処理</description>
    </item>
    
    <item>
      <title>LuneScript のトランスコンパイル時間を 425 パーセント改善した件</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2020/2020-11-01-lunescript-speed-up/</link>
      <pubDate>Sun, 01 Nov 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2020/2020-11-01-lunescript-speed-up/</guid>
      <description>LuneScript は Lua 向けのトランスコンパイラで、 LuneScript 自体も Lua 上で動作しています。 また、LuneScript は LuneScript 自体の処理を、 LuneScript で開発する所謂セルフホスティングを採用しています。 そのセルフホスティングしているコード規模は、右肩上がりで増大しています。 上記グラフは少し以前のもので、現在は 50Kline を突破しています。 コード規模が増えて一番気になるのは、やはりコンパイル時間です。 特に LuneScript は Lua で動作するため、 一般的なネイティブのコン</description>
    </item>
    
    <item>
      <title>LuneScript のコード規模の推移を調べた</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2020/2020-10-01-lunescript-codesize/</link>
      <pubDate>Thu, 01 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2020/2020-10-01-lunescript-codesize/</guid>
      <description>これまでの LuneScript のコード規模の推移を調べてみた。 これは単純に LuneScript をセルフホストしている .lns ファイルの行数をトータルした結果。 よって、コメントや空行等も入っている。 2020年前半はさぼってたけど、それ以外はコンスタントに成長している感じ。 参考までに、このグラフを作った gnuplot スクリプト。 1列目に YYYY-MM-DD の日付データ、2列目に行数データの dump.csv からデータをロードして、 codesize.svg を出力する。 file=&amp;#39;dump&amp;#39; se g se xdata time se timefmt &amp;#34;%Y-%m-%d&amp;#34; se datafile separator &amp;#34;,&amp;#34; se format x &amp;#34;%Y/%m&amp;#34; se title &amp;#39;Code Size of</description>
    </item>
    
    <item>
      <title>emacs yasnippet の snippet を対応させるモード名に / 等のファイル名に使用できない文字がある場合</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2020/2020-08-19-emacs-yasnippet/</link>
      <pubDate>Wed, 19 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2020/2020-08-19-emacs-yasnippet/</guid>
      <description>emacs で snippet を管理するパッケージに yasnippet がある。 yasnippet はメジャーモード毎に snippet を登録しておき、 編集中のメジャーモードに合せて snippet を呼び出すことができる。 yasnippet に snippet を登録するには、 変数 yas-snippet-dirs で指定しているディレクトリ内に メジャーモード名のディレクトリを作成し、 そのメジャーモード名のディレクトリ内に snippet 情報を記述したファイルを置く。 これにより、 yasnippet のロード時、あるいは M-x yas-reload-all 実行時に、 snippet が yasnippet に登録される。 ここで問題がある。 説明した通り</description>
    </item>
    
    <item>
      <title>LuneScript の開発工数</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2020/2020-08-01-lunescript-man-hour/</link>
      <pubDate>Sat, 01 Aug 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2020/2020-08-01-lunescript-man-hour/</guid>
      <description>LuneScript の開発を続けて約 2 年経過。 2年間ずっと開発し続けているわけではないけど、 かなりの時間を LuneScript の開発にあてている。 そんな訳で、今回は LuneScript の開発工数を概算してみる。 もちろん、作業時間の記録なんて面倒なことはしていないので、 あくまで概算である。 開発作業 LuneScript に限ったことではないが、 github で個人開発する際は、 だいたい次のように開発を進めている。 作業項目(TODOリスト)を doc/todo.org にリストアップする TODOリストを順次潰して</description>
    </item>
    
    <item>
      <title>Google Cloud Functions の deploy で &#39;missing dot in first path element; Error ID: 3182a79f&#39; エラー</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2020/2020-07-18-gcp-function-deploy/</link>
      <pubDate>Sat, 18 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2020/2020-07-18-gcp-function-deploy/</guid>
      <description>GCP から「Go 1.11 は使えなくなるから Go 1.13 にして」という通知があったので、 忘れないうちに Go 1.13 にして deploy をしたら、次のエラーが出た。 ERROR: (gcloud.functions.deploy) OperationError: code=13, message=Build failed: go mod: -require=xxxxxx/hoge/foo@v0.0.0: invalid path: malformed module path &amp;#34;xxxxxx/hoge/foo&amp;#34;: missing dot in first path element; Error ID: 3182a79f どうやら、モジュールの先頭ディレクトリは FQDN の形式しないと NG になったようだ。 いままでは . を含まない適当な名前にしてたんだが、 「xxxxxx/hoge/foo の xxxxxx に . が含まれてない == FQDN ではない」、 ということで NG っぽい。 xxxxxx を github pages の自分の</description>
    </item>
    
    <item>
      <title>LuneScript の Google 検索ワード</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2020/2020-07-15-lunescript-search/</link>
      <pubDate>Wed, 15 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2020/2020-07-15-lunescript-search/</guid>
      <description>先日、 Google 翻訳で lunescript が固有名詞として認識された可能性について ネタにしたが、 どうやら本当に lunescript が固有名詞として認識されたのではないかと思われる。 というのも、 google の検索バーに lunesc まで入力すると、 上のように lunescript が候補に挙げられる。 google の単語として登録されたからといって、 LuneScript の認知度が上った訳でもないが、何となく嬉しい。 なお、 lunescript を検索した際の関連ワードは次の通り。 ちゃんと lua を認識している。 念のため、次の状態で確認している</description>
    </item>
    
    <item>
      <title>デュアルブートの ubuntu を upgrade したら windows の BitLocker が PIN の認証失敗するようになった</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2020/2020-07-10-bitlocker/</link>
      <pubDate>Fri, 10 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2020/2020-07-10-bitlocker/</guid>
      <description>イマドキは少数派だと思うが、 PC に ubuntu と windows のデュアルブートを設定している。 さらに面倒なことに、 windows は BitLocker で暗号化 &amp;amp; PIN 認証を設定している。 そして、この状態で ubuntu を apt upgrade したら、 何故か windows ブート時の BitLocker の PIN 認証が失敗するようになった。 PIN を間違えているはずはないのだが、何度やっても PIN 認証が通らない。 しかたがないので、 BitLocker の回復キーを入力したところ問題なく起動した。 そういえば ubuntu の apt upgrade 実行時、grub の更新が掛った。 その際、</description>
    </item>
    
    <item>
      <title>Go 言語 (golang) について思ったこと</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2020/2020-06-27-golang/</link>
      <pubDate>Sat, 27 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2020/2020-06-27-golang/</guid>
      <description>Go の勉強を兼て「これ」を Go で作っていたんだが、その時感じた Go の特徴をまとめておく。 Go は気軽に書けるのに、非常に高い実行パフォーマンスを出せる使い勝手の良い言語だと思う。 また、パッケージマネージャを言語自身に内蔵しているため、 拡張パッケージが揃っていて、今後さらにパッケージが充実して使える言語になるだろう。 こんな様なことは、もう誰もが書いていることだと思うので、 以降では、もう少し違った角度で Go につい</description>
    </item>
    
    <item>
      <title>LuneScript の Google 翻訳</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2020/2020-06-26-lunescript-trans/</link>
      <pubDate>Fri, 26 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2020/2020-06-26-lunescript-trans/</guid>
      <description>以前 lunescript の紹介記事を書いている時に、 lunescript の日本語訳がふと気になったんで調べていたんだが、 その時の Google 翻訳の結果が衝撃的だった。 &amp;lt;https://ifritjp.github.io/documents/lunescript/tutorial1/#headline-3&amp;gt; で、久し振りに Google 翻訳で lunescript を翻訳してみた。 その結果は次の通り。 めでたく lunescript の日本語訳が lunescript になった。 これは、 LuneScript が Google に固有名詞として認識されたということだろうか？ それとも、該当する単語が登録されていないから、 とりあえずそのまま表示しているだけなんだろうか？</description>
    </item>
    
    <item>
      <title>dot のレイアウト指定</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2020/2020-06-09-graph/</link>
      <pubDate>Tue, 09 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2020/2020-06-09-graph/</guid>
      <description>tunnel ツールのネタを書いた時、 dot を使ってグラフを作った。 dot は手軽にグラフを書ける便利なツールだが、 レイアウト制御に難があると思う。 グラフ作成ツールの利点と欠点 dot などのグラフ作成ツールの利点には次が挙げられる。 ノードのリンクを指定するだけで、後はツールが良い感じにグラフを自動で作成してくれる。 パワポ等でグラフを作成するのと比べると、これは大きな利点だ。 そして多くの場合、ツールが作成するグラフは、それなり</description>
    </item>
    
    <item>
      <title>go の proxy server (github.com/elazarl/goproxy) の使い方</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2020/2020-06-04-go-proxy/</link>
      <pubDate>Thu, 04 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2020/2020-06-04-go-proxy/</guid>
      <description>go で proxy server を建てるには、 github.com/elazarl/goproxy を使うと簡単に実現できる。 https://github.com/elazarl/goproxy github の readme を見れば、簡単な使い方が載っているので特に問題はないだろう。 ただ、一点だけハマったポイントがあるので書いておく。 proxy 環境下で goproxy を使う場合の注意点 package main import ( &amp;#34;github.com/elazarl/goproxy&amp;#34; &amp;#34;log&amp;#34; &amp;#34;net/http&amp;#34; ) func main() { proxy := goproxy.NewProxyHttpServer() proxy.Verbose = true log.Fatal(http.ListenAndServe(&amp;#34;:8080&amp;#34;, proxy)) } github の readme にサンプルとして上記コードが載っている。 基本的にこれで問題ないのだが、 proxy 環境下で動かす場合には注意が必要だ。 多くの場合、 proxy 環境下では環境変数に次のような設</description>
    </item>
    
    <item>
      <title>Tunnel/Reverse Tunnel over websocket を作った</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2020/2020-05-29-tunnel/</link>
      <pubDate>Fri, 29 May 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2020/2020-05-29-tunnel/</guid>
      <description>とある理由から 「Tunnel/Reverse Tunnel over websocket」 が必要になったので作ってみた。 「Tunnel/Reverse Tunnel over websocket」 が何かというと、 「websocket を tunnel にして別の TCP 通信を通すもの」だ。 「Tunnel/Reverse Tunnel over websocket」 とは 「Tunnel/Reverse Tunnel over websocket」を少し具体的にいうと、 次のような構成で通信を可能にするモノだ。 frame</description>
    </item>
    
    <item>
      <title>Hugo を org-mode で使う時の注意点</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2020/2020-03-29-hugo-org/</link>
      <pubDate>Sun, 29 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2020/2020-03-29-hugo-org/</guid>
      <description>技術情報を GitHub Pages で公開するにあたって、 Hugo を使うことにした。 Hugo は Markdown で静的サイトを構築するツールだが、org-mode にも対応している。 「対応」といっても、当然完全なものではない。 今回 Hugo を org-mode で使ってハマった点を紹介する。 *「TITLE は文書の先頭に書く」 hugo で使用する .org のファイルは、先頭に TITLE を書かなければならない。 .org に記載されている #+TITLE 自体は認識しているようなのだが、 それが先頭に無い限りその記事のタイトルと</description>
    </item>
    
    <item>
      <title>raspberry pi の USB MASS STORAGE 自動マウントを無効化する</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2020/2020-02-21-raspberrypi-mount/</link>
      <pubDate>Fri, 21 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2020/2020-02-21-raspberrypi-mount/</guid>
      <description>raspberry pi に SSD を接続して簡易 NAS にしている。 この簡易 NAS では、 SSD を取り外ししやすいように autofs によるマウントを設定した。 しかし、SSD を接続すると PCManFM の自動マウントが動いて autofs が正常にマウントできない現象が発生した。 そこで PCManFM の自動マウントを無効化した。 PCManFM の自動マウントを無効化 ~/.config/pcmanfm/LXDE-pi/pcmanfm.conf の以下の設定を変更する。 mount_on_startup=0 mount_removable=0 これで、PCManFM の自動マウントを無効化できる。</description>
    </item>
    
    <item>
      <title>emacs lisp の quote</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2020/2020-02-18-emacs-quoted-list/</link>
      <pubDate>Tue, 18 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2020/2020-02-18-emacs-quoted-list/</guid>
      <description>emacs lisp の quote でハマったのでネタに書いておく。 (defvar hoge-val nil) (defun hoge-init () (setq hoge-val &amp;#39;(:val nil)) ) (defun hoge-set () (plist-put hoge-val :val &amp;#34;1&amp;#34;)) 上記のように変数 hoge-val に対して plist-put で処理する関数を定義して、 次のようにコールすると。 (let (val1 val2 val3) (hoge-init) (setq val1 (plist-get hoge-val :val)) (hoge-set) (setq val2 (plist-get hoge-val :val)) (hoge-init) (setq val3 (plist-get hoge-val :val)) (message (format &amp;#34;%s %s %s&amp;#34; val1 val2 val3))) 最後の (message (format &amp;#34;%s %s %s&amp;#34; val1 val2 val3)) で &amp;#34;nil 1 1&amp;#34; が出力される。 てっきり、 &amp;#34;nil 1 nil&amp;#34; が出力されるものだと思っていた。 なぜなら、val3 をセットする直前に hoge-init を実行しており、 この hoge-init は hoge-val を &amp;#39;(:val nil) で初期化する関数なので、</description>
    </item>
    
    <item>
      <title>org-mode 9.3.5 で babel(dot/plantuml) が動かなかった</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2020/2020-02-13-emacs-org-9.3.5/</link>
      <pubDate>Thu, 13 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2020/2020-02-13-emacs-org-9.3.5/</guid>
      <description>emacs の org-mode では、 .org ファイル内に C や python 等ソースコードを書いて、 export 時にそのソースコードを色付けした状態で載せることができる。 この機能を babel と言う。 babel では、ソースコードの色付けだけでなく、 dot や plantuml 等のグラフ生成言語を利用することで、 .org ファイル内に書いたグラフ生成言語からグラフを生成して、 所定位置にグラフを挿入することもできる。 今回、 org-mode 9.3.5 の babel を使って dot の画像を出力しようとしたところ、 エラーしたので原因を追ってみた</description>
    </item>
    
    <item>
      <title>emacs 用 reviewboard モードの宣伝</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2020/2020-02-03-emacs-reviewboard/</link>
      <pubDate>Mon, 03 Feb 2020 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2020/2020-02-03-emacs-reviewboard/</guid>
      <description>この記事は、emacs 用 reviewboard モードの宣伝である。 &amp;lt;https://github.com/ifritJP/emacs-reviewboard-front&amp;gt; reviewboard は、ソースコードレビューを Web 上で行ない記録するためのツール。 今は github の Pull-Request に代表されるように Web 上のソースレビューが普及しているが、 reviewboard の初版が 2007 年であることを考えると、 当時は先進的なツールだったと思う。 そんな reviewboard を emacs で操作するモードを今になって作ったので、 どれ程の人が使うかは不明だが、折角なので宣伝しておく。 機能 このモードでは、次の機能を提供する。 修正ファ</description>
    </item>
    
    <item>
      <title>C 言語のラッパー関数オーバーヘッド</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2019/2019-10-15-wrapper-overhead/</link>
      <pubDate>Tue, 15 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2019/2019-10-15-wrapper-overhead/</guid>
      <description>プログラムを組む際、ラッパー関数を作ることは良くある。 このラッパー関数のオーバーヘッドが気になったので簡単に調べてみた。 計測用サンプルは次の通り。 #include&amp;lt;stdio.h&amp;gt; typedef void (func_t)( int val1, int val2 ); void func( int val1, int val2 ) { printf( &amp;#34;%d %d&amp;#34;, val1, val2 ); } void wrapper0( int val1, int val2 ) { func( val1, val2 ); } void wrapper1( func_t * pFunc, int val1, int val2 ) { pFunc( val1, val2 ); } void wrapper2( int val1, int val2, func_t * pFunc ) { pFunc( val1, val2 ); } main() { wrapper0( 0, 1 ); wrapper1( func, 0, 1 ); wrapper2( 0, 1, func ); } 関数 func() をコールする 3 種類のラッパー関数 wrapper0, wrapper1, wrapper2 を用意した。 それぞれのラッパー関数は次</description>
    </item>
    
    <item>
      <title>C 言語の可変長引数 (va_list) 処理のオーバーヘッド</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2019/2019-08-06-va-performance/</link>
      <pubDate>Tue, 06 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2019/2019-08-06-va-performance/</guid>
      <description>以前 C 言語の関数ポインタによる関数コールのオーバーヘッドがどの程度なのか調べたが、 今回は可変長引数(va_list)処理のオーバーヘッドについて調べてみた。 結果 初めに結果から書くと、 可変長引数(va_list)処理のオーバーヘッドは、めちゃめちゃ掛る。 また、引数の数に応じて時間が増加する。 所感 今回の実験によって、 va_list 処理には当初の想定を遥かに越えたオーバーヘッドが かかることが分った。 個人的には、コン</description>
    </item>
    
    <item>
      <title>如何なる開発手法、プログラム言語を用いても、日本の全てのソフトウェアプロジェクトは必ず技術的負債になる</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2019/2019-08-02-engineering/</link>
      <pubDate>Fri, 02 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2019/2019-08-02-engineering/</guid>
      <description>「日本の全てのソフトウェアプロジェクトは必ず技術的負債になる」というタイトルですが、 次の条件を満す場合に限ります。 「プロジェクトに関わるソフトウェアエンジニアの大半が技術に無関心」 動機 このネタは、次の記事を読んで個人的に思うことがあったのをきっかけに 書いています。 オブジェクト指向プログラミング – 1兆ドル規模の大失敗 &amp;lt;https://okuranagaimo.blogspot.com/2019/07/1.html&amp;gt; 大企業の技術系インターンシップに参加した &amp;lt;https://blog.browniealice.net/post/internship2019winter/&amp;gt; ソフト開発で世界と闘った及川卓也氏が見た</description>
    </item>
    
    <item>
      <title>emacs26.2 で矢印(→)等の一部のフォントが半角表示されるようになった</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2019/2019-07-19-font/</link>
      <pubDate>Fri, 19 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2019/2019-07-19-font/</guid>
      <description>emacs のバージョンを 26.2 に変えたことで、 色々と細かいところの使い勝手が変っている。 その中で、 → 等の一部のフォントが半角表示されるようになったのが 微妙にストレスだったのでちょっと追ってみた。 原因 原因、と言うよりは起因と言った方が良いかもしれないが、 → 等の一部のフォントが半角表示されるようになったのは、 フォントに &amp;#34;DejaVu Sans Mono&amp;#34; を使用していることに起因していた。 これを &amp;#34;Bitstream Vera Sans Mono&amp;#34; に変更することで、現象が治った。 全く同じ環</description>
    </item>
    
    <item>
      <title>stream は rewind/seek できる？</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2019/2019-07-10-stream/</link>
      <pubDate>Wed, 10 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2019/2019-07-10-stream/</guid>
      <description>これは seekable な stream と none_seekable な stream の使い分けに関する記事です。 使い分けが十分出来ている人は読まなくても大丈夫です。 皆さんは bitstream という単語をご存知でしょうか？ AV (Audio&amp;amp;Visual) が好きな人や、 それらの業界に関係のある人ならそこそこ聞く単語だと思いますが、 一般的にはあまり馴染の無い単語でしょうか。 馴染の無い人の為に身近な HDD レコーダを例に挙げて説明すると、 HDD レコーダはデジタル放送の電波に乗っているデータをそのまま記録していますが、 この</description>
    </item>
    
    <item>
      <title>python のクラスを JSON 化</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2019/2019-07-04-python-json/</link>
      <pubDate>Thu, 04 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2019/2019-07-04-python-json/</guid>
      <description>コレ を作るにあたって、データの serialize/deserialize の方法を調べた結果、 marshmallow_dataclass に落ち着きました。 いくつか調べた中で、パッと見、直感的に出来そうだった、というだけの理由ですが。。 実際、面倒な処理はほとんど無く、 serialize/deserialize が可能になりました。 使い型 marshmallow_dataclass は、 クラスを宣言する際に @dataclass デコレータを付けて宣言し、 メンバの型を宣言するのが基本です。 こんな感じ。 @dataclass class LogItem: # ゲームタイトル title:str # 日付 date:int # テキスト text:str # テキスト長 len:int メンバの宣言が python っぽくないと思</description>
    </item>
    
    <item>
      <title>ゲームのメッセージ欄に表示されたメッセージの読み上げシステム</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2019/2019-06-28-text-to-speech/</link>
      <pubDate>Fri, 28 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2019/2019-06-28-text-to-speech/</guid>
      <description>4 月頃から、英語のレベルを上げるため参考書を買って勉強をしている。 その参考書を使った最低限の基礎英語の復習は終ったので、次のステップに進むことにした。 基礎が終った後の学習方法には何が良いのか色々と調べてみたが、 色々な意見があるが最終的には「持続できるものが良い」というのが結論のようだ。 まぁ、「持続すること」が英語学習で最も難しいことは、 私自身が何度も挫折した経験があるので認識している。 そもそも、先</description>
    </item>
    
    <item>
      <title>Raspberry pi zero w で Bluetooth 色々(ファイル転送:obex、 IP over BT:PAN )</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2019/2019-06-15-rasp0w/</link>
      <pubDate>Sat, 15 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2019/2019-06-15-rasp0w/</guid>
      <description>だいぶ前に買って放置していた Raspberry pi zero w をセットアップしました。 Raspberry pi zero w と言えば「小型軽量」が売りなんで、 今回はポータブルな IOT デバイスとして使う事を目的として、 Bluetooth の機能(ファイル転送、 IP over Bluetooth) のセットアップをしました。 イマドキ Bluetooth なんて、 最新のイメージでセットアップすればすぐに使えるだろうと思って余裕でした。 しかし、実際には目的の機能が動作するまでに、かなりの時間が掛ってしまいました。 少なくとも、パッケー</description>
    </item>
    
    <item>
      <title>VMWare ディスクイメージが圧縮されないときの対応方法</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2019/2019-05-20-vmware/</link>
      <pubDate>Mon, 20 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2019/2019-05-20-vmware/</guid>
      <description>VMWare のディスクイメージのサイズは、Gest OS 上のディスクサイズと異なる。 基本的には、Gest OS 上で実際に使用されているサイズに圧縮された形でホスト OS 上に保持される。 しかし、 Gest OS 上でファイル作成、削除を繰り返していると、 Gest OS 上での使用サイズよりも、 ホスト OS 上でのディスクイメージサイズがかなり大きくなっていることがある。 このような状態になった時に、ホスト OS 上のディスクイメージサイズを、 Gest OS 上での使用サイ</description>
    </item>
    
    <item>
      <title>関数ポインタのオーバーヘッド</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2019/2019-05-19-func-pointer/</link>
      <pubDate>Sun, 19 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2019/2019-05-19-func-pointer/</guid>
      <description>現在 LuneScript の C 言語へのトランスコンパイル処理を対応中だが、 トランスコンパイルする際に関数ポインタによる関数コールのオーバーヘッドが どの程度なのか気になったので調べてみた。 結果 初めに結果から書くと、 関数ポインタによる関数コールのオーバーヘッドは、 通常の関数コールに比べて約 1.267 倍となることが判った。 この数値は、あくまで今回の実験結果であって、 関数ポインタかどうかの違いだけはなく、他の要因も入ってしまっている</description>
    </item>
    
    <item>
      <title>emacs 更新に伴なう gdb の設定</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2019/2019-05-13-emacs26-gdb/</link>
      <pubDate>Mon, 13 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2019/2019-05-13-emacs26-gdb/</guid>
      <description>とある事情で使い続けていた emacs23.4 (2012/1) を、 先日 emacs26.2 (2019/4) にアップデートした。 このとき gdb 周りの設定を変更する必要があったので、備忘録としてまとめておく。 2019-06-12: my-gud-stop, my-gud-mode-func を追加 2019-08-26: dedicate の抑制追加 なお、M-x gud-gdb で起動すれば従来形式のインタフェースが利用できるが、 ブレークポイントが表示されない等の不具合があるので M-x gdb を利用する。 それにしても、新しい M-x gdb のインタフェースは emacs っぽくないと思うんだけど、 オレがおっさんだからそう思うんだろう</description>
    </item>
    
    <item>
      <title>『エンジニア就職志望者が情報工学科に行くのは間違い』は間違い</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2019/2019-04-18-engineer/</link>
      <pubDate>Thu, 18 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2019/2019-04-18-engineer/</guid>
      <description>たまたま見つけたブログの記事で気になったものがあったので、 自分の意見を書いておきます。 気になったブログの記事 「エンジニア就職志望者が情報工学科に行くのは間違いです！学べることが違います！」 &amp;lt;https://www.torikun.com/entry/engineer-jouhoukougaku&amp;gt; この記事を要約すると、 大学の情報工学科のプログラミング単位取得だけでは 学習時間が足りないのでプログラミングスキルを上げるのは難しい。 スキルを上げるにはプログラミングスクールがオススメ というモノです。 まぁ確かに、</description>
    </item>
    
    <item>
      <title>Android で emacs/org-mode/qiita 投稿</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2019/2019-03-23-termux-org/</link>
      <pubDate>Sat, 23 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2019/2019-03-23-termux-org/</guid>
      <description>外出先の暇な時間を有効利用するため、ドキュメント書きをしたくなることがあります。 そして私は emacs ユーザ。 emacs ユーザが書きモノをするといえば、 emacs/org-mode です。 ここでは、 Android で emacs/org-mode を使って qiita に投稿するまでの環境作りを紹介します。 ノート PC を持っている人は、普通にノート PC を持っていけば良いと思います。 用意するもの タブレット Bluetooth キーボード タブレット用スタンド 環境構築 Android アプリ まずは Android に次のアプリを入れます。 termux ハードウェアキーボー</description>
    </item>
    
    <item>
      <title>この度 Lua 神を拝命しました</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2019/2019-03-16-lua/</link>
      <pubDate>Sat, 16 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2019/2019-03-16-lua/</guid>
      <description>forkwell の github 分析結果が面白かったので貼っておく。</description>
    </item>
    
    <item>
      <title>Outlook で送信された日本語メールを Mew で受信すると文字化けする問題の対応</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2019/2019-02-07-outlook/</link>
      <pubDate>Thu, 07 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2019/2019-02-07-outlook/</guid>
      <description>Outlook は当初から評判が良くないため個人的には使用していません。 もうず〜〜〜〜〜と、 PC のメール環境は Mew を使用しています。 しかし、自分のメール送信・受信環境は好きなものを選べますが、 相手のメール送信・受信環境は選べません。 そしてつい先日も、 Outlook から送信されたメールで文字化けメールを受信しました。 どうして化けたのか気になったので、調べてみました。 メールの MIME に示されているコードは &amp;#34;gb2312&amp;#34; となっている 同じメールを Outlook で受</description>
    </item>
    
    <item>
      <title>電ファミニコゲーマー</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2019/2019-02-03-interview/</link>
      <pubDate>Sun, 03 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2019/2019-02-03-interview/</guid>
      <description>ここ十年ほどまともにゲームしてないけど、 ネット検索しているときになんとなく気になった記事を読んでみたら、 ものスゴく面白かった。 古めの記事だけど、載っけておく。 格ゲー“暗黒の10年”は、『鉄拳』を世界一売れる格闘ゲームへと鍛え上げた──世界市場に活路を拓いた戦略を訊く【バンダイナムコ原田勝弘インタビュー／西田宗千佳連載】 http://news.denfaminicogamer.jp/interview/180428 「久夛良木が面白かったからやってただけ」 プレイステーションの立役者に訊くその誕</description>
    </item>
    
    <item>
      <title>デフォルト引数の問題の対応</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2019/2019-01-27-default-arg/</link>
      <pubDate>Sun, 27 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2019/2019-01-27-default-arg/</guid>
      <description>先日のデフォルト引数の指定し忘れ問題の対応を行なった。 詳しくは、次の記事を参照。 &amp;lt;https://qiita.com/dwarfJP/items/922c523d27a6d77fff6d&amp;gt;</description>
    </item>
    
    <item>
      <title>デフォルト引数の問題</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2019/2019-01-23-default-arg/</link>
      <pubDate>Wed, 23 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2019/2019-01-23-default-arg/</guid>
      <description>関数をコールする際、引数を省略してコールできる機能をもつ言語が多く存在する。 ここでは、その機能を「デフォルト引数」と呼ぶ。 デフォルト引数の例として、Lua のサンプルを次に示す。 local function func( x, y ) print( x, y ) end func( &amp;#34;abc&amp;#34; ) // abc nil Lua では関数コール時に省略された引数は、 nil として処理される。 上記の func( &amp;#34;abc&amp;#34; ) は、引数 x, y のうち y が省略され、 実行すると abc nil が表示される。 デフォルト引数は、引数が多い関数を呼び出す際に有効な機能であ</description>
    </item>
    
    <item>
      <title>org-mode で blog</title>
      <link>https://ifritjp.github.io/blog2/public/posts/2019/2019-01-17-setup-jekyll/</link>
      <pubDate>Thu, 17 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/blog2/public/posts/2019/2019-01-17-setup-jekyll/</guid>
      <description>blog を始めるにあたって、 emacs から出来るだけ簡単に記事を更新できる環境にするために、 次の URL の情報をもとにいくつか調査。 &amp;lt;https://orgmode.org/worg/org-blog-wiki.html&amp;gt; とりあえず org-mode + jekyll で構築してみた。 以下は、org-mode + jekyll で環境構築から記事を投稿するまでの流れをまとめたメモ。 使用するソフト ruby gem bundler jekyll jekyll-org jekyll は、 markdown でサイトを構築可能なツール。 markdown は書き慣れていないので org-mode で記事を書けるように jekyll plugin の jekyll-org を使用する。 setup install ruby install ruby-dev install gem $ gem install bundler jekyll jekyll-org jekyll setup blog のプロジェクト</description>
    </item>
    
  </channel>
</rss>
