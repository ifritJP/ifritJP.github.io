# -*- coding:utf-8 -*-
#+LAYOUT: post
#+TITLE: stream は rewind/seek できる？
#+TAGS: english
#+AUTHOR: ifritJP
#+OPTIONS: ^:{}
#+STARTUP: nofold

皆さんは bitstream という単語をご存知でしょうか？

AV (Audio&Visual) が好きな人や、
それらの業界に関係のある人ならそこそこ聞く単語だと思いますが、
一般的にはあまり馴染の無い単語でしょうか。

馴染の無い人の為に身近な HDD レコーダを具体例に挙げて説明すると、
HDD レコーダはデジタル放送の電波に乗っているデータをそのまま記録していますが、
このデータが bitstream です。
HDD レコーダは、デジタル放送の bitstream を HDD に記録し、
記録した bitstream を再生する装置と言えます。
もちろん、実際にはそんな単純ではないですが、概ね間違ったことは言ってません。

* stream

プログラムでデータを扱う時、stream という概念を使って制御します。

| 言語  | stream (入力) |
|-------+---------------|
| Java  | InputStream   |
| Swift | InputStream   |
| Go    | io.Reader     |

上記は言語毎の入力系 stream の例です。

ちなみに入力系の stream とは何かというと、
流れてくるデータを読み出してそれを処理するためのものです。

例えば、先ほどの HDD レコーダの例で説明すると、

- デジタル放送の電波に乗っている bitstream を読み取る部分
- HDD に記録されている bitstream を読み込む部分

が入力系の stream です。

また、上記言語の stream には共通することがあります。

それは、データの流れが一方通行で遡ることが出来ない、ということです。

プログラム的に言うと、上記の stream は seek や rewind をサポートしていません。

これを、先ほどの HDD レコーダの例で説明すると、
「過去に放送された番組の録画はできない」ということです。

24 時間全ての番組を常に録画し続けて、
「1週間前に放送された任意の番組を再生する」機能を持つ HDD レコーダはありますが、
それはあくまで録画してあるものを再生しているのであって、
過去に放送された番組を録画することは出来ません。
もしそれが出来るなら、
本当の意味でのタイムマシーンを作ることが出来ることと同義になります。

なお、「過去に放送された番組の録画はできない」ですが、
「録画した番組」の逆再生などは出来ます。

先ほど説明した通り、次のどちらもの入力 stream です。

- デジタル放送の電波に乗っている bitstream を読み取る部分
  - 過去に放送された番組の録画はできない
- HDD に記録されている bitstream を読み込む部分
  - 録画した番組は逆再生など出来る

これはつまり、 stream には次の 2 つのタイプが存在することを意味します。

- 流れが一方通行で遡ることが出来ない stream
- 流れを遡ることが出来る stream

これ以降、上記をそれぞれ none_seekable と seekable とします。

* none_seekable と seekable の使い分け

上記の通り、stream には次の 2 つのタイプが存在します。

では、実際のプログラムでは stream はどう使い分けるべきか？ と考えた場合、
seekable である必要がない場合は極力 none_seekable を使うべきです。

なぜならば、
seekable は none_seekable を包括する概念であり、
seekable な stream は none_seekable として使用することが出来ますが、
none_seekable な stream を seekable として使用することが出来ないからです。

次に、疑似言語を使って説明します。

#+BEGIN_SRC txt
fn funcA( data: seekable ) {
  sub( data );
}
fn funcB( data: none_seekable ) {
  sub( data );
}
#+END_SRC

上記は、 seekable な引数を持つ関数 funcA と、
none_seekable な引数を持つ関数 funcB を定義する疑似言語です。
また sub() は、 none_seekable な引数を持つ関数です。

ここで、この関数 funcA は seekable な stream でしか使用できないのに対し、
この関数 funcB は seekable, none_seekable どちらでも使用できることになり、
funcB は funcA よりも汎用性が高いと言えます。

関数の汎用性が高いことが良いプログラムである、とは一概には言えませんが、
ミドルウェアなどのライブラリでは、汎用性が高い方が良いとされます。

つまり、 stream を入力に持つ関数の処理においては、
seek や rewind の使用は極力避け、
none_seekable の strem で処理可能にすべきである、と言えます。

ただし、 seek や rewind を使用しないと目標のパフォーマンスが出ないとか、
必要なワークメモリが規定を越えてしまう、等の問題がある場合は、
無理に none_seekable で処理する必要はありません。

とはいえ、あくまでも原則は、
seekable ではなく none_seekable で処理できるかどうかを検討するべきです。

* データフォーマット

stream を処理する際に、
それを none_seekable として扱うには、
stream に流れるデータのフォーマットが none_seekable として
扱い易い構造になっている必要があります。

データフォーマットが none_seekable として扱い難い構造の場合、
上記のように「目標のパフォーマンスが出ない」、「必要なワークメモリが規定を越えてしまう」
という問題が発生してしまいます。

データフォーマットを定義する時は、
必ず none_seekable で処理することを考えて定義しましょう。

なお、 stream で処理することが多い画像や音声などのデータフォーマットは、
基本的には none_seekable で処理できるように定義されています。

もしもそうでなければ、放送でデジタルデータを扱うことは出来ません。

* まとめ

stream を扱う際は、次を注意する必要があります。
  
- 極力 none_seekable で扱う
- データフォーマットを決める時点で、 none_seekable で扱えることを考慮する
  
* 最後に

なんでこんなことを書いたかというと、
最近とある画像デーコードのライブラリを扱うことがあったんですが、
そのライブラリの入力が seekable であることを前提としていてムカついた、
という経験をしたためです。

データ streaming 処理を行なう場合の基本的な考え方なので、
必ずこれらを考慮に入れて設計するようにお願いします。

以上。
