#+LAYOUT: post
#+TITLE: LuneScript から C 言語への変換
#+TAGS: LuneScript


LuneScript の開発当初から、C 言語への変換を目的の一つとしていた。

当初は Rust 形式のライフタイム制御方式によるメモリ管理を予定していたが、
現在は次の理由から GC による動的制御を採用している。

- ライフタイム制御式は制御が複雑であり、対応工数がかなり掛ると予想
- Lua への変換にはライフタイム制御は無関係
- 動くものを早い段階で作りたい

今からライフタイム制御方式に切り替えることも一つの手段だが、
C 言語への変換制御の実現性の目処を早い段階で立てたいのもあるので、
現状の GC による動的制御のまま、C 言語への変換制御の検討を行なう。

また、LuneScript での TODO は残っているが、
それらを対応しなくてもプログラム言語として完成度はかなり高くなっているので、
一旦 C 言語への変換制御の対応優先度を上げて検討する。

* 構成

C 言語へ変換後のソースは、 Lua のライブラリをリンクする構成とする。

これは、 LuneScript のマクロや meta 情報などが Lua VM 上で動作することを
前提に開発しているため、その制御をそのまま C 言語変換後も利用したいため。

また、Lua の標準ライブラリを利用しているソースを C 言語に変換した際に、
C 言語で Lua の標準ライブラリ相当のものをスクラッチするよりも、
Lua ライブラリを利用した方が工数を削減できるため。

この辺りは、C 言語へ変換後ソースの実行パフォーマンスの問題や、
対応工数に余裕があれば、Lua ライブラリなしで実行可能な構成を検討する。

* 値

- int, real, str は、C 言語の int, double, char にマッピングする。
  - ただし、 int は long long などにカスタマイズできるようにする。
- それ以外の型は全値を格納可能な union 系の型 STEM で扱う。
- Map や List 等の collection の要素は STEM で扱う。
  - こうしないと List<int> → List<stem> への変換が困難になるため。
- LuneScript では、クラスのインスタンスを stem に変換した後、
  Map<str,stem> のように扱えるが、これはサポートしない。
  そもそもこのような使い方は、 LuneScript でも未定義な動きである。
- STEM 型のデータは動的に alloc し、参照カウント式の GC で管理する。
- 初期段階では List や Map 等のオブジェクトは C++ の STL を利用し、
  C から使用可能なようにラッピングする。

** 参照カウンタ

- 参照カウンタのインクリメントタイミング
  - 変数代入時
  - 関数の先頭で、引数の参照カウンタをインクリメントする。
    - 関数呼び出し側ではインクリメントしない。
- 参照カウンタのデクリメントタイミング  
  - ブロック終了時

*** ブロック開始、終了処理

error() 関数等で大域ジャンプすると、
参照カウンタのデクリメントが通常の方法で対応出来ない。

そこで、ブロック階層毎にインクリメント対象の stem 値を保持し、
大域ジャンプ時にその情報を利用して参照カウンタをデクリメントする。

大域ジャンプに対応するため、次を処理する

- ブロック開始時
  - そのブロック内で宣言している STEM 型変数を保持可能な領域を確保する
    - 前述のインクリメントタイミングで、確保した領域にその変数をセットする
  - 関数開始時は、引数も同様に処理する。
- ブロック終了時
  - 確保した領域に保持されている変数情報をデクリメントする
