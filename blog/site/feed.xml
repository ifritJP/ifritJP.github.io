<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://ifritjp.github.io/blog/site/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ifritjp.github.io/blog/site/" rel="alternate" type="text/html" /><updated>2019-05-20T19:56:13+09:00</updated><id>https://ifritjp.github.io/blog/site/feed.xml</id><title type="html">hoge blog</title><subtitle>Qiita に投稿する程でないネタを上げるネタサイト。 ポエムや、メモ、自分用の備忘録、Web から集めただけの情報などなど。</subtitle><entry><title type="html">VMWare ディスクイメージが圧縮されないときの対応方法</title><link href="https://ifritjp.github.io/blog/site/2019/05/20/vmware.html" rel="alternate" type="text/html" title="VMWare ディスクイメージが圧縮されないときの対応方法" /><published>2019-05-20T00:00:00+09:00</published><updated>2019-05-20T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/05/20/vmware</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/05/20/vmware.html">&lt;p&gt;VMWare のディスクイメージのサイズは、Gest OS 上のディスクサイズと異なる。&lt;/p&gt;
&lt;p&gt;基本的には、Gest OS 上で実際に使用されているサイズに圧縮された形でホスト OS 上に保持される。&lt;/p&gt;
&lt;p&gt;しかし、 Gest OS 上でファイル作成、削除を繰り返していると、
  Gest OS 上での使用サイズよりも、
  ホスト OS 上でのディスクイメージサイズがかなり大きくなっていることがある。&lt;/p&gt;
&lt;p&gt;このような状態になった時に、ホスト OS 上のディスクイメージサイズを、
  Gest OS 上での使用サイズ程度に削減するツール(vmware-toolbox-cmd)が
  vmware から提供されている。&lt;/p&gt;
&lt;p&gt;通常は、この vmware-toolbox-cmd を使うことで圧縮されるはずなのだが、
  自分の環境では全くサイズが変わらなかった。&lt;/p&gt;
&lt;p&gt;いくつか試した結果、削減出来た方法をメモしておく。&lt;/p&gt;
&lt;h1&gt;Gest OS 上でのディスクのクローン&lt;/h1&gt;
&lt;p&gt;今回実施した方法は Gest OS 上でのディスクのクローンを作成することだ。&lt;/p&gt;
&lt;p&gt;ある意味分かりきった方法かもしれない。&lt;/p&gt;
&lt;p&gt;ただ、クローン作成の方法はファイル単位のコピーではなく、
  &lt;b&gt;dd コマンドによるクローン作成&lt;/b&gt; で上手くいった、
  ということは意外と言えるんじゃないだろうか？&lt;/p&gt;
&lt;p&gt;ファイル単位のコピーだと、コピーにかなり時間がかかると思うが、
  dd コマンドで済んだので、10 GB 近いコピーも比較的短時間でコピーが出来た。&lt;/p&gt;
&lt;p&gt;dd コマンドは、特に何か特別なオプションを付けて実行したのではなく、
  普通に実行しただけだ。&lt;/p&gt;
&lt;p&gt;念の為、作業手順をまとめておく。&lt;/p&gt;
&lt;h2&gt;作業手順&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;クローン先の空のディスクイメージを作成する&lt;/li&gt;
  &lt;li&gt;ディスクイメージを VMWare に登録する&lt;/li&gt;
  &lt;li&gt;Gest OS を起動する&lt;/li&gt;
  &lt;li&gt;vmware-toolbox-cmd を使って圧縮&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;example&quot;&gt;
vmware-toolbox-cmd disk shrinkonly
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;Gest OS 上での圧縮対象ディスクと、クローン先のデバイス名をメモる&lt;/li&gt;
  &lt;li&gt;dd コマンドでクローン作成&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;example&quot;&gt;
dd if=/dev/圧縮対象 of=/dev/クローン先 bs=1M
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;ここで指定するドライブは、パーティションではなくドライブ全体を指定すること。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
  &lt;li&gt;Gest OS を shutdown
    &lt;ul&gt;
      &lt;li&gt;ここでクローン先のディスクイメージを見て、
        Gest OS 上の使用量とほぼ同じサイズに削減されていることを確認する。
        もしも削減されていない場合、これ以降の作業には意味はない。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;圧縮対象ディスクイメージを VMWare から除外し、
    代わりにクローンしたイメージを登録する。
    &lt;ul&gt;
      &lt;li&gt;この時クローンイメージを割り付けるハードウェアの ID などが、
        元の圧縮対象ディスクイメージと同じになるように登録する。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Gest OS を起動する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上の手順により、サイズが圧縮されたクローンのイメージで運用できる。&lt;/p&gt;</content><author><name>ifritJP</name></author><category term="LuneScript" /></entry><entry><title type="html">関数ポインタのオーバーヘッド</title><link href="https://ifritjp.github.io/blog/site/2019/05/19/func-pointer.html" rel="alternate" type="text/html" title="関数ポインタのオーバーヘッド" /><published>2019-05-19T00:00:00+09:00</published><updated>2019-05-19T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/05/19/func-pointer</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/05/19/func-pointer.html">&lt;p&gt;現在 LuneScript の C 言語へのトランスコンパイル処理を対応中だが、
  トランスコンパイルする際に関数ポインタによる関数コールのオーバーヘッドが
  どの程度なのか気になったので調べてみた。&lt;/p&gt;
&lt;h1&gt;結果&lt;/h1&gt;
&lt;p&gt;初めに結果から書くと、&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
関数ポインタによる関数コールのオーバーヘッドは、
通常の関数コールに比べて約 1.267 倍となることが判った。
&lt;/pre&gt;
&lt;p&gt;この数値は、あくまで今回の実験結果であって、
  関数ポインタかどうかの違いだけはなく、他の要因も入ってしまっている。
  また、実行環境によっても差は出てくるだろう。&lt;/p&gt;
&lt;p&gt;しかし、それでも目安程度にはなるだろう。&lt;/p&gt;
&lt;h1&gt;所感&lt;/h1&gt;
&lt;p&gt;論理的に考えて、関数ポインタの関数コールが通常の関数コールに比べて
  遅くなることは理解していたが、これまで調べたことはなかった。
  それが、今回の実験で明かになった。&lt;/p&gt;
&lt;p&gt;個人的にはもっと差が出るかと思ったが、案外少ない結果になった。
  これは、実験用コードが小さ過ぎて全てキャッシュに乗ってしまっているのが一番の要因だとは思う。
  とはいえ、明らかなオーバーヘッドがあることには違いない。&lt;/p&gt;
&lt;p&gt;プログラミングをしていれば感じていることだと思うが、
  プログラムは関数コールの塊だ。&lt;/p&gt;
&lt;p&gt;つまり、関数コールのオーバーヘッドは、
  そのままプログラム全体の性能低下に直結する。&lt;/p&gt;
&lt;p&gt;「関数ポインタ」というと、あまり使わっていないイメージを持つ人も多いかもしれないが、
  オブジェクト指向の「ポリモーフィズム」あるいは「多態性」というと、
  良く使っているイメージがあるのではないだろうか？&lt;/p&gt;
&lt;p&gt;関数ポインタなど動的に動作が変わる処理は、
  目的の制御を実現する上で非常に重要だが、
  コードの把握が難しくなったり、オーバーヘッドによる性能低下を引き起こす可能性がある。&lt;/p&gt;
&lt;p&gt;関数ポインタと通常の関数は、その特性にあわせてどちらを使用するかの検討が必要だ。&lt;/p&gt;
&lt;p&gt;今回の実験結果をうけて、それがより明らかになったと思う。&lt;/p&gt;
&lt;h1&gt;実験詳細&lt;/h1&gt;
&lt;p&gt;ここでは、今回の実験方法について説明する。&lt;/p&gt;
&lt;h2&gt;コード&lt;/h2&gt;
&lt;p&gt;実験用に次の C 言語コードを作成した。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;c&quot;&gt;
void sub( void ) {
}
void func_direct( func_t * pFunc ) {
    sub();
}
void func_indirect( func_t * pFunc ) {
    pFunc();
}
&lt;/pre&gt;
&lt;p&gt;func_direct() は sub() 関数を直接コールする関数で、
  func_indirect() は sub() 関数を関数ポインタでコールする関数だ。&lt;/p&gt;
&lt;p&gt;この両者の関数を実行したときの実行時間を比較している。&lt;/p&gt;
&lt;p&gt;ちなみにコードの全体は次の通りである。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;c&quot;&gt;
#include &amp;lt;sys/time.h&amp;gt;
#include &amp;lt;time.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

typedef void (func_t)( void );

double getTime( void ) {
    struct timeval tm;
    gettimeofday( &amp;amp;tm, NULL );
    return tm.tv_sec + tm.tv_usec / 1000000.0;
}
void sub( void ) {
}
void func_direct( func_t * pFunc ) {
    sub();
}
void func_indirect( func_t * pFunc ) {
    pFunc();
}
void func_none( func_t * pFunc ) {
}
int main( int argc, const char * argv[] ) {
    long long loop;
    const char * pMode;

    double prev = getTime();
    switch ( argc ) {
    case 1:
        pMode = &amp;quot;indirect&amp;quot;;
        for ( loop = 0; loop &amp;lt; 1000 * 1000 * 1000 * 2; loop++ ) {
            func_indirect( sub );
        }
        break;
    case 2:
        pMode = &amp;quot;direct&amp;quot;;
        for ( loop = 0; loop &amp;lt; 1000 * 1000 * 1000 * 2; loop++ ) {
            func_direct( sub );
        }
        break;
    case 3:
        pMode = &amp;quot;none&amp;quot;;
        for ( loop = 0; loop &amp;lt; 1000 * 1000 * 1000 * 2; loop++ ) {
            func_none( sub );
        }
        break;
    }
    printf( &amp;quot;%s: time = %g\n&amp;quot;, pMode, getTime() - prev );
    return 0;
}
&lt;/pre&gt;
&lt;p&gt;このプログラムは、コマンドラインの引数によって
  func_direct(), func_indirect(), func_none()  のいずれかを
  所定の回数分実行し、実行時間を表示する。&lt;/p&gt;
&lt;p&gt;ちなみに func_none() は、関数ポインタと通常の関数コールの差を出す際に、
  できるだけ他の要因を除外するために作成した関数だ。&lt;/p&gt;
&lt;h2&gt;計測結果&lt;/h2&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
indirect: time = 11.4617
indirect: time = 11.2905
indirect: time = 11.2595
indirect: time = 11.3391
indirect: time = 11.3123
direct: time = 10.5253
direct: time = 10.5927
direct: time = 10.5389
direct: time = 10.6043
direct: time = 10.5259
none: time = 7.64467
none: time = 7.60627
none: time = 7.75474
none: time = 7.60123
none: time = 7.63887
&lt;/pre&gt;
&lt;p&gt;これは、コマンドライン引数を変えて上記のプログラムをそれぞれ 5 回ずつ実行した結果だ。&lt;/p&gt;
&lt;p&gt;それぞれを平均すると次のようになる。&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;時間(秒)&lt;/th&gt;&lt;th&gt;関数コールの時間(秒)&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;関数ポインタ&lt;/td&gt;&lt;td&gt;11.333&lt;/td&gt;&lt;td&gt;3.683&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;通常関数コール&lt;/td&gt;&lt;td&gt;10.557&lt;/td&gt;&lt;td&gt;2.908&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;関数コールなし&lt;/td&gt;&lt;td&gt;7.649&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;上記の「関数コールの時間」は、計測した時間から「関数コールなし」の時間を引いたものだ。&lt;/p&gt;
&lt;p&gt;つまり、 for 分の制御などの関数ポインタのオーバーヘッドとは直接関係ない処理の時間を引いている。&lt;/p&gt;
&lt;p&gt;この結果をもとに、次の計算をすると&lt;/p&gt;
&lt;p&gt;(/ 3.683 2.908) 1.266506189821183&lt;/p&gt;
&lt;p&gt;関数ポインタによる関数コールのオーバーヘッドは、
  通常の関数コールに比べて &lt;b&gt;約 1.267 倍&lt;/b&gt; となる。&lt;/p&gt;
&lt;p&gt;以上&lt;/p&gt;</content><author><name>ifritJP</name></author><category term="LuneScript" /></entry><entry><title type="html">emacs 更新に伴なう gdb の設定</title><link href="https://ifritjp.github.io/blog/site/2019/05/13/emacs26.html" rel="alternate" type="text/html" title="emacs 更新に伴なう gdb の設定" /><published>2019-05-13T00:00:00+09:00</published><updated>2019-05-13T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/05/13/emacs26</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/05/13/emacs26.html">&lt;p&gt;とある事情で使い続けていた emacs23.4 (2012/1) を、
  先日 emacs26.2 (2019/4) にアップデートした。&lt;/p&gt;
&lt;p&gt;このとき gdb 周りの設定を変更する必要があったので、備忘録としてまとめておく。&lt;/p&gt;
&lt;h1&gt;emacs の gdb 設定&lt;/h1&gt;
&lt;pre class=&quot;src&quot; lang=&quot;el&quot;&gt;
;; gud-overlay-arrow-position が nil だとエラーするので。。
(setq gud-tooltip-display
      &amp;#39;((and gud-overlay-arrow-position
	     (eq (tooltip-event-buffer gud-tooltip-event)
		 (marker-buffer gud-overlay-arrow-position)))))

;; gdb バッファの C-c C-c で、プログラムを停止させる。
(setq gdb-gud-control-all-threads nil)

;; input/output バッファが勝手に表示されるのはウザいので、抑制
(setq gdb-display-io-nopopup t)
&lt;/pre&gt;
&lt;p&gt;以降で、上記の設定について説明する。&lt;/p&gt;
&lt;h2&gt;gud-tooltip-display&lt;/h2&gt;
&lt;p&gt;1 つ目は、単純に gud.el の不具合のような気がするが、
  tooltip を表示する処理を修正している。&lt;/p&gt;
&lt;p&gt;gud-tooltip-display は、 gud で tooltip を表示する処理のようだが、
  この処理で &lt;code&gt;(make-buffer gud-overlay-arrow-position)&lt;/code&gt; を実行している。&lt;/p&gt;
&lt;p&gt;この処理は、 gud-overlay-arrow-position が nil の時にも実行されるケースがあるようで、
  その時にエラーにならないように and を追加している。&lt;/p&gt;
&lt;h2&gt;gdb-gud-control-all-threads&lt;/h2&gt;
&lt;p&gt;gdb-gud-control-all-threads は、
  gud の制御を全スレッドに対して反映させるかどうかのフラグで、
  emacs 23 ではデフォルト nil だった。&lt;/p&gt;
&lt;p&gt;新しい gdb では、 gdb-gud-control-all-threads がデフォルト t になっている。&lt;/p&gt;
&lt;p&gt;gdb-gud-control-all-threads が t だと、
  どうにもこうにも意図したデバッグ制御にならなかったので nil とした。&lt;/p&gt;
&lt;p&gt;なお、 C-c C-c でデバッグ対象プログラムを停止できるが、正常に動作しない場合がある。&lt;/p&gt;
&lt;p&gt;その場合 M-x gud-stop-subjob してから C-c C-c すると、停止する。&lt;/p&gt;
&lt;h2&gt;gdb-display-io-nopopup&lt;/h2&gt;
&lt;p&gt;emacs23.4 の gdb は、
  デバッグ対象プログラムの stdin/out と gdb の制御コマンドを、
  一つのバッファで管理していた。&lt;/p&gt;
&lt;p&gt;しかし、 新しい gdb は stdin/out と、gdb の制御コマンドを別々のバッファで管理している。&lt;/p&gt;
&lt;p&gt;gdb-display-io-nopopup は、
  stdin/out に変化があった際のポップアップ制御を抑制するかどうかのフラグ。&lt;/p&gt;
&lt;p&gt;デフォルトだと t だが、
  これだとソース編集中やステップ実行中に、
  stdin/out のバッファが突然表示されてウザいので nil とした。&lt;/p&gt;
&lt;p&gt;なお、gdb-display-io-nopopup を t とすると、
  M-x gdb 実行時にも stdin/out のバッファが表示されないため、
  stdin/out にアクセスする場合は 自分で C-x b 等で切り替える必要がある。&lt;/p&gt;
&lt;p&gt;ちなみに stdin/out バッファの名前は &lt;code&gt;*input/output of ...*&lt;/code&gt; 。
  ここで &amp;#8230; には、デバッグ対象のファイル名が入る。&lt;/p&gt;
&lt;p&gt;以上。&lt;/p&gt;</content><author><name></name></author><category term="LuneScript" /></entry><entry><title type="html">『エンジニア就職志望者が情報工学科に行くのは間違い』は間違い</title><link href="https://ifritjp.github.io/blog/site/2019/04/18/engineer.html" rel="alternate" type="text/html" title="『エンジニア就職志望者が情報工学科に行くのは間違い』は間違い" /><published>2019-04-18T00:00:00+09:00</published><updated>2019-04-18T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/04/18/engineer</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/04/18/engineer.html">&lt;p&gt;たまたま見つけたブログの記事で気になったものがあったので、
  自分の意見を書いておきます。&lt;/p&gt;
&lt;h1&gt;気になったブログの記事&lt;/h1&gt;
&lt;p&gt;「エンジニア就職志望者が情報工学科に行くのは間違いです！学べることが違います！」&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.torikun.com/entry/engineer-jouhoukougaku&quot;&gt;https://www.torikun.com/entry/engineer-jouhoukougaku&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;この記事を要約すると、&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;大学の情報工学科のプログラミング単位取得だけでは
    学習時間が足りないのでプログラミングスキルを上げるのは難しい。&lt;/li&gt;
  &lt;li&gt;スキルを上げるにはプログラミングスクールがオススメ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;というモノです。&lt;/p&gt;
&lt;p&gt;まぁ確かに、
  大学の講義・実習だけで十分なプログラミングスキルを身に付けるのは不可能であるのは事実です。&lt;/p&gt;
&lt;p&gt;とはいえ、『エンジニア就職志望者が情報工学科に行くのは間違い』というのは、
  流石に異論があります。&lt;/p&gt;
&lt;p&gt;ブログの著者と自分とで異なる意見になる理由を考えると、&lt;/p&gt;
&lt;p&gt;&lt;b&gt;【「エンジニア」という言葉の定義が違う】&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;から、だと思います。&lt;/p&gt;
&lt;h1&gt;「エンジニア」とは&lt;/h1&gt;
&lt;p&gt;上記の記事では、エンジニアには次の能力が必要だとしています。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;プログラミングスキル&lt;/li&gt;
  &lt;li&gt;コミュニケーション能力&lt;/li&gt;
  &lt;li&gt;マネジメント能力&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらは確かに重要です。&lt;/p&gt;
&lt;p&gt;というか、「コミュニケーション能力」や「マネジメント能力」は、
  エンジニアでなくても社会で働くには必要な能力です。&lt;/p&gt;
&lt;p&gt;つまりこの著者は、&lt;/p&gt;
&lt;p&gt;&lt;b&gt;【「エンジニア」に特化して必要な能力は「プログラミングスキル」だけ】&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;と主張しているように読めます。&lt;/p&gt;
&lt;p&gt;これは、私の考えと完全に異なります。&lt;/p&gt;
&lt;p&gt;まず、私が考える「エンジニア」像を説明します。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;エンジニアとは、曖昧なゴールイメージを技術によってスマートな形で実現できる能力を持つ人。&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;例えば「家を建てる」というゴールイメージがあるとします。&lt;/p&gt;
&lt;p&gt;家を建てることは情報系の「エンジニア」の仕事ではないと思いますが、
  あくまで例として考えてください。&lt;/p&gt;
&lt;p&gt;この場合、次のような様々なことを決定し、設計書を作成して建築する必要があります。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;建てる場所&lt;/li&gt;
  &lt;li&gt;予算&lt;/li&gt;
  &lt;li&gt;広さ&lt;/li&gt;
  &lt;li&gt;デザイン&lt;/li&gt;
  &lt;li&gt;機能性&lt;/li&gt;
  &lt;li&gt;耐久性&lt;/li&gt;
  &lt;li&gt;拡張性&lt;/li&gt;
  &lt;li&gt;メンテナンス性&lt;/li&gt;
  &lt;li&gt;建材&lt;/li&gt;
  &lt;li&gt;日程&lt;/li&gt;
  &lt;li&gt;etc&amp;#8230;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このように、
  曖昧なゴールイメージを実現するために具体的な作業項目に分解し、
  分解された作業の課題を洗い出し、
  課題を解決し、
  イメージを具現化する技術を持つのが、私が考える「エンジニア」です。&lt;/p&gt;
&lt;p&gt;もちろん、現実には一人のエンジニアが全てを担当できる訳ではありません。&lt;/p&gt;
&lt;p&gt;しかし、ブログの著者のような「エンジニア ＝ プログラミングスキルのある人 」では、
  絶対にありません。&lt;/p&gt;
&lt;p&gt;またブログの記事には、次の記載があります。&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
例えば、大学２年生の時にはフーリエ変換という数学の公式を習います。
この技術はパソコンの仕組みを突き詰めて行くと重要になってくる有名な数式です。
微分とか積分とかいろいろ難しい公式を覚えて問題を解いていきます。
エンジニアの方ならおわかりかと思いますが、
エンジニアとして仕事をする上でこのフーリエ変換を使う人はぜんぜんいません。
&lt;/pre&gt;
&lt;p&gt;確かに全てのエンジニアが微分・積分を必要とする訳ではないです。
  しかし、技術の背景を知っているエンジニアと、
  プログラミングしか出来ないプログラマーでは、担当できる範囲が全く違ってきます。&lt;/p&gt;
&lt;p&gt;たとえばディープラーニングなどの技術は、
  プログラミングしか出来ないプログラマーでは &lt;b&gt;絶対&lt;/b&gt; に作り出すことは出来ません。
  様々な知識を持つエンジニアが集結してこそ可能なものです。&lt;/p&gt;
&lt;p&gt;もちろん大学の講義レベルの知識だけで、すぐに何かが実現出来るということはありません。
  しかし、大学の講義はさまざまな技術の基礎そのものであり、
  その基礎を身に付けているかどうかで、その後の応用が出来るかどうかの違いに繋がってきます。&lt;/p&gt;
&lt;p&gt;特に基礎部分は、体系的に学んだ方がより深い理解につながります。
  そして大学の情報工学部の単位は、体系的に学ぶことが出来る構成になっています。&lt;/p&gt;
&lt;p&gt;つまり大学の情報工学部は、『「エンジニア」になるためのもっとも早道である』と言えます。&lt;/p&gt;
&lt;h1&gt;認識が異なる理由&lt;/h1&gt;
&lt;p&gt;では、ブログの著者は何故「エンジニア ＝ プログラミングスキルのある人」という
  認識なのでしょうか？&lt;/p&gt;
&lt;p&gt;あくまで私の想像ですが、これは日本のソフトウェア開発業界の特色によるものだと思います。&lt;/p&gt;
&lt;p&gt;その特色とは、いわゆる「ゼネコン方式」です。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;大手が仕様を決め、実装を外部にアウトソーシングする。&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;ブログ著者にとって「エンジニア」とはアウトソーシング先であり、
  「エンジニアは安い金額で実装さえ出来れば良い」という思考なのではないでしょうか？&lt;/p&gt;
&lt;p&gt;日本には、このような思考が蔓延しているため、
  エンジニアの待遇は良くならないし、
  技術レベルも世界から離される一方なのではないでしょうか？&lt;/p&gt;
&lt;p&gt;なお、ブログ著者のプロフィールを見ると、 IBM Tokyo Lab に務めているとあります。
  いわゆる大手であるのは間違いないでしょう。&lt;/p&gt;
&lt;h1&gt;エンジニア就職志望者はどうあるべきか&lt;/h1&gt;
&lt;p&gt;私の考えは、「エンジニア就職志望者は様々な技術を学ぶべき」です。&lt;/p&gt;
&lt;p&gt;「他人が作った仕様を元に、プログラムだけ組んでいれば幸せ」という人は、
  ブログ著者が主張するようにプログラミングスクールなりに行けば良いと思います。&lt;/p&gt;
&lt;p&gt;ただ、日本のゼネコン方式ソフトウェア開発を請け負う、
  いわゆる SIer の給与は発注元の企業よりもかなり低いのが一般的です。
  それこそ IBM の半分かそれ以下ではないでしょうか？
  そのことは認識しておく必要があります。&lt;/p&gt;
&lt;p&gt;なお、エンジニア志望者が行くべきなのは、情報工学科でなくても良いと思います。&lt;/p&gt;
&lt;p&gt;というのも、私の「エンジニア」の定義は広いので、
  情報工学科では収まりきらないためです。
  何を極めたいかによって、何を学ぶべきかは変ってくるでしょう。&lt;/p&gt;
&lt;p&gt;一つだけ必須技術を上げるならば、それは &lt;b&gt;「英語」&lt;/b&gt; です。&lt;/p&gt;
&lt;p&gt;今後の「エンジニア」業界で、
  日本が世界をリードすることは極一部を除いて無いでしょう。&lt;/p&gt;
&lt;p&gt;つまり、新しい技術は海外から導入することになります。
  その時、その技術の解説は英語であるのが一般的です。&lt;/p&gt;
&lt;p&gt;英語が出来れば、いち早く技術の導入が可能になります。&lt;/p&gt;
&lt;p&gt;まぁ、これは今に始まったことではなく、
  それこそコンピュータサイエンスという言葉が一般化したころから英語が標準でした。&lt;/p&gt;
&lt;p&gt;ただ平成の時代は、&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;今よりは技術の進歩が激しくなく、日本語の翻訳を待っていてもまだどうにかなっていた&lt;/li&gt;
  &lt;li&gt;国内で働いているだけなら、外国人を相手にする機会がほとんどなかった&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;などの理由から「英語は出来た方が良い」というレベルでした。&lt;/p&gt;
&lt;p&gt;しかし現在は、&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;技術の進歩が激しく、日本語の翻訳を待っていたら周回遅れどころか浦島太郎になる&lt;/li&gt;
  &lt;li&gt;ある程度新しい技術を取り入れる場合、国内の日本人だけで開発するのが難しくなった&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;などで、まともな「エンジニア」として働くには、英語はなくてはならない状況です。&lt;/p&gt;
&lt;p&gt;もしもあなたがエンジニアを志す学生で、英語を苦手としているのならば、
  留年してでも英語は習得しておくべきです。&lt;/p&gt;
&lt;p&gt;世界と戦う意思のあるまともな日本の企業でエンジニアとして働くのであれば、
  入社資格として英語のレベルを問われるでしょう。&lt;/p&gt;
&lt;p&gt;逆に英語のレベルを不問とするような会社は、
  世界と戦うことを諦めているか、
  あなたを安く使える労働力と捉えているかのどちらかの可能性が高いです。&lt;/p&gt;
&lt;p&gt;また、英語がまともに出来れば外資系や海外で働くことも選択肢になります。&lt;/p&gt;
&lt;p&gt;英語習得のために大学を 1 年留年したとしても、
  その後のエンジニア人生を考えれば充分おつりがくるでしょう。&lt;/p&gt;
&lt;p&gt;英語が出来ない私だからこそ、
  英語が出来ない現状がどれほどマズいことかを、
  この歳になって身をもって感じています。&lt;/p&gt;
&lt;p&gt;私はこれまで何度も英語の学習に挑戦と挫折を繰り返してきましたが、
  今の状況なって本当にマズいことを実感し、
  ラストチャンスとして人生で何度目かのトライをしています。&lt;/p&gt;
&lt;p&gt;皆さんは、私のような思いをしないで済むように、英語だけは身につけてください。&lt;/p&gt;
&lt;p&gt;もしかしたら、英語よりも中国語の方が良いかもしれませんが、
  それはまだ何ともいえない状況です。&lt;/p&gt;</content><author><name></name></author><category term="LuneScript" /></entry><entry><title type="html">Android で emacs/org-mode/qiita 投稿</title><link href="https://ifritjp.github.io/blog/site/2019/03/23/termux-org.html" rel="alternate" type="text/html" title="Android で emacs/org-mode/qiita 投稿" /><published>2019-03-23T00:00:00+09:00</published><updated>2019-03-23T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/03/23/termux-org</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/03/23/termux-org.html">&lt;p&gt;外出先の暇な時間を有効利用するため、ドキュメント書きをしたくなることがあります。&lt;/p&gt;
&lt;p&gt;そして私は emacs ユーザ。&lt;/p&gt;
&lt;p&gt;emacs ユーザが書きモノをするといえば、 emacs/org-mode です。&lt;/p&gt;
&lt;p&gt;ここでは、 Android で emacs/org-mode を使って qiita に投稿するまでの環境作りを紹介します。&lt;/p&gt;
&lt;p&gt;ノート PC を持っている人は、普通にノート PC を持っていけば良いと思います。&lt;/p&gt;
&lt;h1&gt;用意するもの&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;タブレット&lt;/li&gt;
  &lt;li&gt;Bluetooth キーボード&lt;/li&gt;
  &lt;li&gt;タブレット用スタンド&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;環境構築&lt;/h1&gt;
&lt;h2&gt;Android アプリ&lt;/h2&gt;
&lt;p&gt;まずは Android に次のアプリを入れます。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;termux&lt;/li&gt;
  &lt;li&gt;ハードウェアキーボード配列変更アプリ (英語 or 日本語)&lt;/li&gt;
  &lt;li&gt;Hacker&amp;#8217;s Keyboard&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;全て Root なしに Google Play で入れられます。&lt;/p&gt;
&lt;p&gt;配列変更アプリは US 配列と JIS 配列でアプリが分かれているので、
  好きな方を入れてください。
  入れた後に、 Android の設定でハードウェアキーレイアウトを
  「Ctrl、Caps 交換」に切り替えます。
  なお、 Caps/Ctrl の入れ替えが不要な場合は、配列変更アプリを入れなくて良いです。&lt;/p&gt;
&lt;p&gt;Hacker&amp;#8217;s Keyboard は必須ではないですが、
  他の IME では、ハードウェアキーボードと想定外の干渉をすることがあります。&lt;/p&gt;
&lt;h2&gt;termux 設定&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;ピンチイン、アウトでフォントサイズを変更&lt;/li&gt;
  &lt;li&gt;次のパッケージを termux にインストール
    &lt;ul&gt;
      &lt;li&gt;emacs&lt;/li&gt;
      &lt;li&gt;curl&lt;/li&gt;
      &lt;li&gt;git&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;emacs 設定&lt;/h2&gt;
&lt;h3&gt;~/.emacs/init.el 設定&lt;/h3&gt;
&lt;p&gt;次の内容の ~/.emacs/init.el を作成&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;lisp&quot;&gt;
(package-initialize)

(add-to-list &amp;#39;package-archives &amp;#39;(&amp;quot;melpa&amp;quot; . &amp;quot;https://melpa.org/packages/&amp;quot;))
&lt;/pre&gt;
&lt;h3&gt;パッケージインストール&lt;/h3&gt;
&lt;p&gt;M-x package-list-packages で、次のパッケージを emacs にインストール&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ox-qm&lt;/li&gt;
  &lt;li&gt;ddskk&lt;/li&gt;
  &lt;li&gt;helm&lt;/li&gt;
  &lt;li&gt;session&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;helm/session は必須じゃないけど、入れておいて損はない。&lt;/p&gt;
&lt;h3&gt;org-qiita.el インストール&lt;/h3&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ git clone https://github.com/ifritJP/org-qiita-el
&lt;/pre&gt;
&lt;p&gt;設定等の話は次を参考に。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://qiita.com/dwarfJP/items/594a8d4b0ac6d248d1e4&quot;&gt;https://qiita.com/dwarfJP/items/594a8d4b0ac6d248d1e4&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;パッケージ設定&lt;/h4&gt;
&lt;pre class=&quot;src&quot; lang=&quot;lisp&quot;&gt;
(show-paren-mode)

(add-to-list &amp;#39;load-path (expand-file-name &amp;quot;~/work/org-qiita-el&amp;quot;))
(require &amp;#39;ox-qmd)
(require &amp;#39;org-qiita)
(setq org-qiita-token &amp;quot;XXXXXXXXXXXXXXXXXXXXXXXXX&amp;quot;)  &amp;lt;---- qiita のトークン (org-qiita.el の説明参考)
(setq org-qiita-export-kill-close t)


(setq my-key-map (make-keymap))
(define-key global-map (kbd &amp;quot;C-z&amp;quot;) my-key-map)
(define-key my-key-map (kbd &amp;quot;SPC&amp;quot;) &amp;#39;set-mark-command)
(define-key my-key-map (kbd &amp;quot;i&amp;quot;) &amp;#39;helm-imenu)

(define-key global-map (kbd &amp;quot;C-x b&amp;quot;) &amp;#39;helm-mini)

(require &amp;#39;helm)
(require &amp;#39;session)
(require &amp;#39;recentf)
&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;Android は Ctrl-SPC が、「キーボードレイアウト切替」になっています。&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;このため、 Ctrl-SPC がシステムに奪われて set-mark-command が動作しません。&lt;/p&gt;
&lt;p&gt;暫定対応として、 C-z SPC に set-mark-command を割り当てました。
  使い勝手はイマイチですが、意識してやればなんとか使えるレベルです。&lt;/p&gt;
&lt;h1&gt;最後に&lt;/h1&gt;
&lt;p&gt;簡単なドキュメント書きなら、これで十分です。&lt;/p&gt;
&lt;p&gt;ノート PC と比べても、遜色ないレベルです。&lt;/p&gt;
&lt;p&gt;とはいえ欠点もあります。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;タブレットでの Web 検索がやり難い
    &lt;ul&gt;
      &lt;li&gt;タブレットは org-mode 専用で、検索は別途スマホでやる方が良いと思います。&lt;/li&gt;
      &lt;li&gt;ただ、検索結果をコピペするような場合は、タブレットでやった方が良いです。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;C-SPC が使えない。
    &lt;ul&gt;
      &lt;li&gt;これは android の制約で、しかたがない？&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;次回は、外出先でのソフト開発に耐えられる環境について書きたいと思います。&lt;/p&gt;</content><author><name>ifritJP</name></author><category term="emacs org qiita" /></entry><entry><title type="html">この度 Lua 神を拝命しました</title><link href="https://ifritjp.github.io/blog/site/2019/03/16/lua.html" rel="alternate" type="text/html" title="この度 Lua 神を拝命しました" /><published>2019-03-16T00:00:00+09:00</published><updated>2019-03-16T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/03/16/lua</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/03/16/lua.html">&lt;p&gt;forkwell の github 分析結果が面白かったので貼っておく。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;forkwell.png&quot; alt=&quot;forkwell.png&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="mew outlook" /></entry><entry><title type="html">Outlook で送信された日本語メールを Mew で受信すると文字化けする問題の対応</title><link href="https://ifritjp.github.io/blog/site/2019/02/07/outlook.html" rel="alternate" type="text/html" title="Outlook で送信された日本語メールを Mew で受信すると文字化けする問題の対応" /><published>2019-02-07T00:00:00+09:00</published><updated>2019-02-07T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/02/07/outlook</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/02/07/outlook.html">&lt;p&gt;Outlook は当初から評判が良くないため個人的には使用していません。
  もうず〜〜〜〜〜と、 PC のメール環境は Mew を使用しています。&lt;/p&gt;
&lt;p&gt;しかし、自分のメール送信・受信環境は好きなものを選べますが、
  相手のメール送信・受信環境は選べません。&lt;/p&gt;
&lt;p&gt;そしてつい先日も、 Outlook から送信されたメールで文字化けメールを受信しました。&lt;/p&gt;
&lt;p&gt;どうして化けたのか気になったので、調べてみました。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;メールの MIME に示されているコードは &amp;#8221;&lt;b&gt;gb2312&lt;/b&gt;&amp;#8221; となっている&lt;/li&gt;
  &lt;li&gt;同じメールを Outlook で受信している人に聞いてみると、文字化けしていないと言う&lt;/li&gt;
  &lt;li&gt;emacs のコード変換で化けたのか？と思い、
    メールを保存してブラウザの表示言語を簡体字中国語設定で表示してみると文字化けしなかった。
    &lt;ul&gt;
      &lt;li&gt;この時のブラウザのテキストエンコーディングを見てみると &amp;#8221;&lt;b&gt;GBK&lt;/b&gt;&amp;#8221; だった&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;emacs で利用可能な文字コードを見てみると &amp;#8221;&lt;b&gt;gb2312&lt;/b&gt;&amp;#8221; と &amp;#8221;&lt;b&gt;GBK&lt;/b&gt;&amp;#8221; は別ものとして存在している。&lt;/li&gt;
  &lt;li&gt;試しに文字化けしたメールを、 emacs の &amp;#8221;&lt;b&gt;GBK&lt;/b&gt;&amp;#8221; を指定して開くと文字化けしなかった&lt;/li&gt;
  &lt;li&gt;Wikipedia を見ると &amp;#8221;&lt;b&gt;GBK&lt;/b&gt;&amp;#8221; は &amp;#8221;&lt;b&gt;gb2312&lt;/b&gt;&amp;#8221; を拡張したものということが分った
    &lt;ul&gt;
      &lt;li&gt;また、 Microsoft が GBK を Windows コードページ 936 として定義した、との記載がある。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MS も Outlook で送信すると文字コード判定が間違えることを認識している
    &lt;ul&gt;
      &lt;li&gt;次の URL に記載されている「方法3」が、まさにそれの対処方法&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://support.microsoft.com/ja-jp/help/881816&quot;&gt;https://support.microsoft.com/ja-jp/help/881816&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上のことから、次の事が考えられます。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Outlook で所定の文字を含むメールを送信する際、
    Outlook の自動文字コード判定によって WCP936 として認識される。&lt;/li&gt;
  &lt;li&gt;WCP936 は本来 GBK であるが、メールの MIME には charset=&amp;#8221;gb2312&amp;#8221; として宣言される&lt;/li&gt;
  &lt;li&gt;メールを受信した Mew は、 MIME の情報を見て gb2312 として処理するが、
    実際のメールは gb2312 ではなく GBK でエンコーディングされているため、文字化けする。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Mew での対応&lt;/h1&gt;
&lt;p&gt;Outlook のダメさ加減を嘆いてもしようがないので、
  ここでは Mew で受信した時に化けずに表示できる対応をします。&lt;/p&gt;
&lt;p&gt;対応コードは以下です。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;el&quot;&gt;
(defun my-mew-change-gb2312-for-outlook ()
  &amp;quot;outlook 対応。 Outlook の gb2312 は gbk になっている。。。&amp;quot;
  (setq mew-cs-database-for-decoding
	(mapcar (lambda (X)
		  (if (equal (car X) &amp;quot;gb2312&amp;quot;)
		      (list (car X) &amp;#39;gbk)
		    X))
		mew-cs-database-for-decoding)))

(eval-after-load &amp;quot;mew&amp;quot;
  &amp;#39;(my-mew-change-gb2312-for-outlook))
&lt;/pre&gt;
&lt;p&gt;以下で上記処理の説明をします。&lt;/p&gt;
&lt;p&gt;Mew は MIME の charset と、
  emacs の coding-system の紐付けを &lt;b&gt;mew-cs-database-for-decoding&lt;/b&gt; で管理しています。&lt;/p&gt;
&lt;p&gt;こんな感じ。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
(defvar mew-cs-database-for-decoding
  `((&amp;quot;us-ascii&amp;quot;          nil)
    (&amp;quot;iso-8859-1&amp;quot;        iso-8859-1)
    (&amp;quot;iso-8859-2&amp;quot;        iso-8859-2)
    (&amp;quot;iso-8859-3&amp;quot;        iso-8859-3)
    (&amp;quot;iso-8859-4&amp;quot;        iso-8859-4)
    (&amp;quot;iso-8859-5&amp;quot;        iso-8859-5)
    (&amp;quot;iso-8859-6&amp;quot;        iso-8859-6)
    (&amp;quot;iso-8859-7&amp;quot;        iso-8859-7)
    (&amp;quot;iso-8859-8&amp;quot;        iso-8859-8)
    (&amp;quot;iso-8859-8-i&amp;quot;      iso-8859-8) ;; temporary solution
    (&amp;quot;iso-8859-9&amp;quot;        iso-8859-9)
    (&amp;quot;iso-8859-15&amp;quot;       iso-8859-15)
    (&amp;quot;iso-2022-cn&amp;quot;       iso-2022-cn)
    (&amp;quot;iso-2022-cn-ext&amp;quot;   iso-2022-cn-ext)
    (&amp;quot;gbk&amp;quot;               gbk)
    (&amp;quot;gb2312&amp;quot;            cn-gb-2312) ;; should be before cn-gb
    (&amp;quot;cn-gb&amp;quot;             cn-gb-2312)
&lt;/pre&gt;
&lt;p&gt;この設定では、 MIME の gb2312 を cn-gb-2312 に紐付けしているので、
  gb2312 を gbk の紐付けに変更しているのが先ほどのコードとなります。&lt;/p&gt;
&lt;p&gt;中国語圏とメールのやり取りしたときに何か問題がおこるかもですが、
  自分にはそんな予定はないのでとりあえずこれで十分かな、と。&lt;/p&gt;</content><author><name></name></author><category term="mew outlook" /></entry><entry><title type="html">電ファミニコゲーマー</title><link href="https://ifritjp.github.io/blog/site/2019/02/03/interview.html" rel="alternate" type="text/html" title="電ファミニコゲーマー" /><published>2019-02-03T00:00:00+09:00</published><updated>2019-02-03T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/02/03/interview</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/02/03/interview.html">&lt;p&gt;ここ十年ほどまともにゲームしてないけど、
  ネット検索しているときになんとなく気になった記事を読んでみたら、
  ものスゴく面白かった。&lt;/p&gt;
&lt;p&gt;古めの記事だけど、載っけておく。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;格ゲー“暗黒の10年”は、『鉄拳』を世界一売れる格闘ゲームへと鍛え上げた──世界市場に活路を拓いた戦略を訊く【バンダイナムコ原田勝弘インタビュー／西田宗千佳連載】&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://news.denfaminicogamer.jp/interview/180428&quot;&gt;http://news.denfaminicogamer.jp/interview/180428&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;「久夛良木が面白かったからやってただけ」 プレイステーションの立役者に訊くその誕生秘話【丸山茂雄×川上量生】&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://news.denfaminicogamer.jp/interview/ps_history&quot;&gt;http://news.denfaminicogamer.jp/interview/ps_history&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="言語処理系" /></entry><entry><title type="html">デフォルト引数の問題の対応</title><link href="https://ifritjp.github.io/blog/site/2019/01/27/default-arg.html" rel="alternate" type="text/html" title="デフォルト引数の問題の対応" /><published>2019-01-27T00:00:00+09:00</published><updated>2019-01-27T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/01/27/default-arg</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/01/27/default-arg.html">&lt;p&gt;先日のデフォルト引数の指定し忘れ問題の対応を行なった。&lt;/p&gt;
&lt;p&gt;詳しくは、次の記事を参照。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://qiita.com/dwarfJP/items/922c523d27a6d77fff6d&quot;&gt;https://qiita.com/dwarfJP/items/922c523d27a6d77fff6d&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="言語処理系" /></entry><entry><title type="html">デフォルト引数の問題</title><link href="https://ifritjp.github.io/blog/site/2019/01/23/default-arg.html" rel="alternate" type="text/html" title="デフォルト引数の問題" /><published>2019-01-23T00:00:00+09:00</published><updated>2019-01-23T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/01/23/default-arg</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/01/23/default-arg.html">&lt;p&gt;関数をコールする際、引数を省略してコールできる機能をもつ言語が多く存在する。&lt;/p&gt;
&lt;p&gt;ここでは、その機能を「デフォルト引数」と呼ぶ。&lt;/p&gt;
&lt;p&gt;デフォルト引数の例として、Lua のサンプルを次に示す。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;lua&quot;&gt;
local function func( x, y )
  print( x, y )
end
func( &amp;quot;abc&amp;quot; ) // abc nil
&lt;/pre&gt;
&lt;p&gt;Lua では関数コール時に省略された引数は、 nil として処理される。
  上記の &lt;code&gt;func( &amp;quot;abc&amp;quot; )&lt;/code&gt; は、引数 x, y のうち y が省略され、
  実行すると abc nil が表示される。&lt;/p&gt;
&lt;p&gt;デフォルト引数は、引数が多い関数を呼び出す際に有効な機能である。
  特に Lua は、引数の違いによって実行する関数を切り替える関数オーバーロードがないため、
  デフォルト引数は良く使われる機能の一つである。&lt;/p&gt;
&lt;p&gt;しかし、デフォルト引数は便利である一方、不具合を発生させるリスクにもなる。&lt;/p&gt;
&lt;p&gt;そのリスクとは、意図してデフォルト引数を使用しているのか、
  それとも、本来指定すべき引数を指定し忘れているのか、を判断出来ないということである。
  タイプミス等で関数に渡す引数を間違えることが良くある。
  それを判断できないというのはリスクが高い。&lt;/p&gt;
&lt;p&gt;Lua の トランスコンパイラである LuneScript でも、同じ問題を抱えている。&lt;/p&gt;
&lt;p&gt;次は LuneScript のデフォルト引数のサンプルである。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;lua&quot;&gt;
fn func( val: int! ): int {
   when! val {
      return val + 1;
   }
   return 0;
}
print( func( 1 ) );   // 2
print( func( nil ) ); // 0
print( func() );      // 0
&lt;/pre&gt;
&lt;p&gt;このサンプルは、デフォルト引数を持つ func() の関数呼び出しを 3 パターン行なっている。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;func( 1 )&lt;/li&gt;
  &lt;li&gt;func( nil )&lt;/li&gt;
  &lt;li&gt;func()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LuneScript は Lua と同じで、引数が省略されると nil が指定される。
  よって、 &lt;code&gt;func( nil )&lt;/code&gt; と &lt;code&gt;func()&lt;/code&gt; は同義である。
  しかし、 &lt;code&gt;func()&lt;/code&gt; が引数の指定忘れではないと、誰が保証できるだろうか？&lt;/p&gt;
&lt;p&gt;また、 LuneScript では nilable は必ず省略可能なデフォルト引数になってしまう。&lt;/p&gt;
&lt;p&gt;デフォルト引数をサポートする多くの言語では、
  デフォルト引数はデフォルト値を定義する必要がある。
  一方 LuneScript では、nilable は必ずデフォルト引数になってしまう。&lt;/p&gt;
&lt;p&gt;「nil の時でも省略せずに明示すべき」としたくても、
  現在の言語仕様ではそれが出来ない。&lt;/p&gt;
&lt;p&gt;この辺りを解決する方法を検討している。&lt;/p&gt;
&lt;p&gt;ただこれを解決するには、現状の言語仕様との互換を持たせるのは難しいかもしれない。&lt;/p&gt;</content><author><name></name></author><category term="言語処理系" /></entry></feed>