<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://ifritjp.github.io/blog/site/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ifritjp.github.io/blog/site/" rel="alternate" type="text/html" /><updated>2019-02-07T20:20:21+09:00</updated><id>https://ifritjp.github.io/blog/site/feed.xml</id><title type="html">hoge blog</title><subtitle>Qiita に投稿する程でないネタを上げるネタサイト。 ポエムや、メモ、自分用の備忘録、Web から集めただけの情報などなど。</subtitle><entry><title type="html">Outlook で送信した日本語メールを Mew で受信すると文字化けする問題の対応</title><link href="https://ifritjp.github.io/blog/site/2019/02/07/outlook.html" rel="alternate" type="text/html" title="Outlook で送信した日本語メールを Mew で受信すると文字化けする問題の対応" /><published>2019-02-07T00:00:00+09:00</published><updated>2019-02-07T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/02/07/outlook</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/02/07/outlook.html">&lt;p&gt;Outlook は当初から年代から評判が良くないため個人的には使用していません。
  もうず〜〜〜〜〜と、 PC のメール環境は Mew を使用しています。&lt;/p&gt;
&lt;p&gt;しかし、自分のメール送信・受信環境は好きなものを選べますが、
  相手のメール送信・受信環境は選べません。&lt;/p&gt;
&lt;p&gt;そしてつい先日も、 Outlook から送信されたメールで文字化けメールを受信しました。&lt;/p&gt;
&lt;p&gt;そのメールは Outlook から送信されたものです。&lt;/p&gt;
&lt;p&gt;どうして化けたのか調べてみました。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;メール内に示されているコードは &amp;#8221;&lt;b&gt;bg2312&lt;/b&gt;&amp;#8221; となっている&lt;/li&gt;
  &lt;li&gt;そのメールを Outlook で受信している人に聞いてみると、文字化けはないと言う&lt;/li&gt;
  &lt;li&gt;emacs のコード変換に化けたのか？とメールを保存してブラウザで表示すると、
    簡体字中国語設定だと文字化けせずに表示された。
    &lt;ul&gt;
      &lt;li&gt;この時のブラウザのテキストエンコーディングを見てみると &amp;#8221;&lt;b&gt;GBK&lt;/b&gt;&amp;#8221; だった&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;emacs で利用可能な文字コードを見てみると &amp;#8221;&lt;b&gt;bg2312&lt;/b&gt;&amp;#8221; と &amp;#8221;&lt;b&gt;GBK&lt;/b&gt;&amp;#8221; は別ものとして存在している。&lt;/li&gt;
  &lt;li&gt;試しに文字化けしたメールを emacs の &amp;#8221;&lt;b&gt;GBK&lt;/b&gt;&amp;#8221; を適応して開くと文字化けしなかった&lt;/li&gt;
  &lt;li&gt;Wikipedia を見ると &amp;#8221;&lt;b&gt;GBK&lt;/b&gt;&amp;#8221; は &amp;#8221;&lt;b&gt;bg2312&lt;/b&gt;&amp;#8221; を拡張したものということが分った
    &lt;ul&gt;
      &lt;li&gt;また、 GBK の説明には Microsoft が GBK を Windows コードページ 936 として定義したとの記載がある。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MS も Outlook で送信すると文字コード判定が間違えることを認識している
    &lt;ul&gt;
      &lt;li&gt;次の URL に記載されている「方法3」が、まさにそれの対処方法&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://support.microsoft.com/ja-jp/help/881816&quot;&gt;https://support.microsoft.com/ja-jp/help/881816&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上のことから、次の事が考えられます。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Outlook で所定の文字を含むメールを送信する際、
    Outlook の自動文字コード判定によって WCP936 として認識される。&lt;/li&gt;
  &lt;li&gt;WCP936 は本来 GBK であるが、メールの MIME には charset=&amp;#8221;gb2312&amp;#8221; として宣言される&lt;/li&gt;
  &lt;li&gt;メールを受信した Mew は、 MIME の情報を見て gb2312 として処理するが、
    実際のメールは gb2312 ではなく GBK でエンコーディングされているため、文字化けする。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Mew での対応&lt;/h1&gt;
&lt;p&gt;Outlook のダメさ加減を嘆いてもしようがないので、
  ここでは Mew で受信した時に化けずに表示できる対応をします。&lt;/p&gt;
&lt;p&gt;対応コードは以下です。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;el&quot;&gt;
(defun my-mew-change-bg2312-for-outlook ()
  &amp;quot;outlook 対応。 Outlook の bg2312 は gbk になっている。。。&amp;quot;
  (setq mew-cs-database-for-decoding
	(mapcar (lambda (X)
		  (if (equal (car X) &amp;quot;gb2312&amp;quot;)
		      (list (car X) &amp;#39;gbk)
		    X))
		mew-cs-database-for-decoding)))

(eval-after-load &amp;quot;mew&amp;quot;
  &amp;#39;(my-mew-change-bg2312-for-outlook))
&lt;/pre&gt;
&lt;p&gt;上記の説明をすると、次を対応しています。&lt;/p&gt;
&lt;p&gt;Mew は MIME の charset と、
  emacs の coding-system の紐付けを &lt;b&gt;mew-cs-database-for-decoding&lt;/b&gt; で管理しています。&lt;/p&gt;
&lt;p&gt;こんな感じ。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
(defvar mew-cs-database-for-decoding
  `((&amp;quot;us-ascii&amp;quot;          nil)
    (&amp;quot;iso-8859-1&amp;quot;        iso-8859-1)
    (&amp;quot;iso-8859-2&amp;quot;        iso-8859-2)
    (&amp;quot;iso-8859-3&amp;quot;        iso-8859-3)
    (&amp;quot;iso-8859-4&amp;quot;        iso-8859-4)
    (&amp;quot;iso-8859-5&amp;quot;        iso-8859-5)
    (&amp;quot;iso-8859-6&amp;quot;        iso-8859-6)
    (&amp;quot;iso-8859-7&amp;quot;        iso-8859-7)
    (&amp;quot;iso-8859-8&amp;quot;        iso-8859-8)
    (&amp;quot;iso-8859-8-i&amp;quot;      iso-8859-8) ;; temporary solution
    (&amp;quot;iso-8859-9&amp;quot;        iso-8859-9)
    (&amp;quot;iso-8859-15&amp;quot;       iso-8859-15)
    (&amp;quot;iso-2022-cn&amp;quot;       iso-2022-cn)
    (&amp;quot;iso-2022-cn-ext&amp;quot;   iso-2022-cn-ext)
    (&amp;quot;gbk&amp;quot;               gbk)
    (&amp;quot;gb2312&amp;quot;            cn-gb-2312) ;; should be before cn-gb
    (&amp;quot;cn-gb&amp;quot;             cn-gb-2312)
&lt;/pre&gt;
&lt;p&gt;この設定では、 MIME の gb2312 を cn-gb-2312 に紐付けしているので、
  gb2312 を gbk に紐付けしなおしているのが先ほどのコードとなります。&lt;/p&gt;
&lt;p&gt;中国語圏とメールをやり取りしたときに何か問題がおこるかもですが、
  自分にはそんな予定はないのでとりあえずこれで十分かな、と。&lt;/p&gt;</content><author><name></name></author><category term="mew outlook" /></entry><entry><title type="html">電ファミニコゲーマー</title><link href="https://ifritjp.github.io/blog/site/2019/02/03/interview.html" rel="alternate" type="text/html" title="電ファミニコゲーマー" /><published>2019-02-03T00:00:00+09:00</published><updated>2019-02-03T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/02/03/interview</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/02/03/interview.html">&lt;p&gt;ここ十年ほどまともにゲームしてないけど、
  ネット検索しているときになんとなく気になった記事を読んでみたら、
  ものスゴく面白かった。&lt;/p&gt;
&lt;p&gt;古めの記事だけど、載っけておく。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;格ゲー“暗黒の10年”は、『鉄拳』を世界一売れる格闘ゲームへと鍛え上げた──世界市場に活路を拓いた戦略を訊く【バンダイナムコ原田勝弘インタビュー／西田宗千佳連載】&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://news.denfaminicogamer.jp/interview/180428&quot;&gt;http://news.denfaminicogamer.jp/interview/180428&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;「久夛良木が面白かったからやってただけ」 プレイステーションの立役者に訊くその誕生秘話【丸山茂雄×川上量生】&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://news.denfaminicogamer.jp/interview/ps_history&quot;&gt;http://news.denfaminicogamer.jp/interview/ps_history&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="言語処理系" /></entry><entry><title type="html">デフォルト引数の問題の対応</title><link href="https://ifritjp.github.io/blog/site/2019/01/27/default-arg.html" rel="alternate" type="text/html" title="デフォルト引数の問題の対応" /><published>2019-01-27T00:00:00+09:00</published><updated>2019-01-27T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/01/27/default-arg</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/01/27/default-arg.html">&lt;p&gt;先日のデフォルト引数の指定し忘れ問題の対応を行なった。&lt;/p&gt;
&lt;p&gt;詳しくは、次の記事を参照。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://qiita.com/dwarfJP/items/922c523d27a6d77fff6d&quot;&gt;https://qiita.com/dwarfJP/items/922c523d27a6d77fff6d&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="言語処理系" /></entry><entry><title type="html">デフォルト引数の問題</title><link href="https://ifritjp.github.io/blog/site/2019/01/23/default-arg.html" rel="alternate" type="text/html" title="デフォルト引数の問題" /><published>2019-01-23T00:00:00+09:00</published><updated>2019-01-23T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/01/23/default-arg</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/01/23/default-arg.html">&lt;p&gt;関数をコールする際、引数を省略してコールできる機能をもつ言語が多く存在する。&lt;/p&gt;
&lt;p&gt;ここでは、その機能を「デフォルト引数」と呼ぶ。&lt;/p&gt;
&lt;p&gt;デフォルト引数の例として、Lua のサンプルを次に示す。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;lua&quot;&gt;
local function func( x, y )
  print( x, y )
end
func( &amp;quot;abc&amp;quot; ) // abc nil
&lt;/pre&gt;
&lt;p&gt;Lua では関数コール時に省略された引数は、 nil として処理される。
  上記の &lt;code&gt;func( &amp;quot;abc&amp;quot; )&lt;/code&gt; は、引数 x, y のうち y が省略され、
  実行すると abc nil が表示される。&lt;/p&gt;
&lt;p&gt;デフォルト引数は、引数が多い関数を呼び出す際に有効な機能である。
  特に Lua は、引数の違いによって実行する関数を切り替える関数オーバーロードがないため、
  デフォルト引数は良く使われる機能の一つである。&lt;/p&gt;
&lt;p&gt;しかし、デフォルト引数は便利である一方、不具合を発生させるリスクにもなる。&lt;/p&gt;
&lt;p&gt;そのリスクとは、意図してデフォルト引数を使用しているのか、
  それとも、本来指定すべき引数を指定し忘れているのか、を判断出来ないということである。
  タイプミス等で関数に渡す引数を間違えることが良くある。
  それを判断できないというのはリスクが高い。&lt;/p&gt;
&lt;p&gt;Lua の トランスコンパイラである LuneScript でも、同じ問題を抱えている。&lt;/p&gt;
&lt;p&gt;次は LuneScript のデフォルト引数のサンプルである。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;lua&quot;&gt;
fn func( val: int! ): int {
   when! val {
      return val + 1;
   }
   return 0;
}
print( func( 1 ) );   // 2
print( func( nil ) ); // 0
print( func() );      // 0
&lt;/pre&gt;
&lt;p&gt;このサンプルは、デフォルト引数を持つ func() の関数呼び出しを 3 パターン行なっている。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;func( 1 )&lt;/li&gt;
  &lt;li&gt;func( nil )&lt;/li&gt;
  &lt;li&gt;func()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LuneScript は Lua と同じで、引数が省略されると nil が指定される。
  よって、 &lt;code&gt;func( nil )&lt;/code&gt; と &lt;code&gt;func()&lt;/code&gt; は同義である。
  しかし、 &lt;code&gt;func()&lt;/code&gt; が引数の指定忘れではないと、誰が保証できるだろうか？&lt;/p&gt;
&lt;p&gt;また、 LuneScript では nilable は必ず省略可能なデフォルト引数になってしまう。&lt;/p&gt;
&lt;p&gt;デフォルト引数をサポートする多くの言語では、
  デフォルト引数はデフォルト値を定義する必要がある。
  一方 LuneScript では、nilable は必ずデフォルト引数になってしまう。&lt;/p&gt;
&lt;p&gt;「nil の時でも省略せずに明示すべき」としたくても、
  現在の言語仕様ではそれが出来ない。&lt;/p&gt;
&lt;p&gt;この辺りを解決する方法を検討している。&lt;/p&gt;
&lt;p&gt;ただこれを解決するには、現状の言語仕様との互換を持たせるのは難しいかもしれない。&lt;/p&gt;</content><author><name></name></author><category term="言語処理系" /></entry><entry><title type="html">org-mode で blog</title><link href="https://ifritjp.github.io/blog/site/2019/01/17/setup-jekyll.html" rel="alternate" type="text/html" title="org-mode で blog" /><published>2019-01-17T00:00:00+09:00</published><updated>2019-01-17T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/01/17/setup-jekyll</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/01/17/setup-jekyll.html">&lt;p&gt;blog を始めるにあたって、
  emacs から出来るだけ簡単に記事を更新できる環境にするために、
  次の URL の情報をもとにいくつか調査。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://orgmode.org/worg/org-blog-wiki.html&quot;&gt;https://orgmode.org/worg/org-blog-wiki.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;とりあえず org-mode + jekyll で構築してみた。&lt;/p&gt;
&lt;p&gt;以下は、org-mode + jekyll で環境構築から記事を投稿するまでの流れをまとめたメモ。&lt;/p&gt;
&lt;h1&gt;使用するソフト&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;ruby&lt;/li&gt;
  &lt;li&gt;gem
    &lt;ul&gt;
      &lt;li&gt;bundler&lt;/li&gt;
      &lt;li&gt;jekyll&lt;/li&gt;
      &lt;li&gt;jekyll-org&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;jekyll は、 markdown でサイトを構築可能なツール。
  markdown は書き慣れていないので org-mode で記事を書けるように
  jekyll plugin の jekyll-org を使用する。&lt;/p&gt;
&lt;h2&gt;setup&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;install ruby&lt;/li&gt;
  &lt;li&gt;install ruby-dev&lt;/li&gt;
  &lt;li&gt;install gem&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ gem install bundler jekyll jekyll-org
&lt;/pre&gt;
&lt;h3&gt;jekyll setup&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;blog のプロジェクトディレクトリ作成&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ cd blog_top
$ jekyll new blog
&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;初回は、ここで必要な gem がインストールされる。&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;blog ディレクトリが生成され、blog ディレクトリ以下に幾つかのファイルが作成される。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;_config.yml を編集
    &lt;ul&gt;
      &lt;li&gt;次の項目を編集
        &lt;ul&gt;
          &lt;li&gt;title:&lt;/li&gt;
          &lt;li&gt;email:&lt;/li&gt;
          &lt;li&gt;description:&lt;/li&gt;
          &lt;li&gt;twitter_username:&lt;/li&gt;
          &lt;li&gt;github_username:&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;plugins の項目に jekyll-org を追加&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;src&quot; lang=&quot;yml&quot;&gt;
plugins:
  - jekyll-org
&lt;/pre&gt;
&lt;h3&gt;jekyll-org の設定&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/eggcaker/jekyll-org&quot;&gt;https://github.com/eggcaker/jekyll-org&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gemfile に次を追加&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
# jekyll-org
gem &amp;#39;jekyll-org&amp;#39;, &amp;#39;&amp;gt;= 1.0.2&amp;#39;
&lt;/pre&gt;
&lt;p&gt;Gemfile 編集後、次のコマンドを実行&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ bundle install
&lt;/pre&gt;
&lt;h3&gt;github pages 用の設定&lt;/h3&gt;
&lt;p&gt;github pages の /blog に jekyll のディレクトリを作成した場合の設定&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;_config.yml を編集
    &lt;ul&gt;
      &lt;li&gt;次の項目を設定
        &lt;ul&gt;
          &lt;li&gt;baseurl: &amp;#8220;/blog/site&amp;#8221;&lt;/li&gt;
          &lt;li&gt;url: &amp;#8220;https://XXXXXXXX.github.io&amp;#8221;&lt;/li&gt;
          &lt;li&gt;destination: site&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;jekyll の変換後の html は _site 以下に出力されるが、
  github pages は _site 以下にはアクセスできないようなので、
  &lt;code&gt;destination: site&lt;/code&gt; で出力先を site に変更する。&lt;/p&gt;
&lt;h1&gt;記事作成&lt;/h1&gt;
&lt;p&gt;_posts/ 以下に、次の名前のファイルを作成する&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
YYYY-MM-DD-title.org
&lt;/pre&gt;
&lt;p&gt;例えば 2019-01-01-hoge.org とする。&lt;/p&gt;
&lt;p&gt;title は、記事のタイトルで無くてもよい。
  title は、 記事の URL に使用される。&lt;/p&gt;
&lt;p&gt;_posts/ の下にサブディレクトリを掘って、その中にファイルを作成しても良い。&lt;/p&gt;
&lt;h2&gt;記事のフォーマット&lt;/h2&gt;
&lt;p&gt;次のメタ情報を入れれば、後は普通の org-mode 通りに記載可能。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;org&quot;&gt;
#+LAYOUT: post
#+TITLE: org-mode で blog
#+TAGS: org-mode jekyll
&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;+TAGS&lt;/b&gt; はオプション。&lt;/p&gt;
&lt;h3&gt;ワンポイントネタ&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;URL を書くだけだとリンクにならない。
    &lt;ul&gt;
      &lt;li&gt;リンクにする場合は URL を &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; で囲む。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;変換&lt;/h1&gt;
&lt;p&gt;書いた記事は jekyll を使って html に変換する。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ cd blog
$ jekyll b
&lt;/pre&gt;
&lt;h1&gt;確認&lt;/h1&gt;
&lt;p&gt;jekyll は httpd サーバ機能を持つ。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ cd blog
$ jekyll s
&lt;/pre&gt;
&lt;p&gt;この状態でブラウザで http://localhost:4000 にアクセスすれば、
  変換後の内容を確認できる。&lt;/p&gt;
&lt;p&gt;なお、記事を修正すれば動的に変換されるので、
  記事を修正後にブラウザをリロードすれば、修正後の内容を確認できる。&lt;/p&gt;
&lt;p&gt;httpd サーバを終了する場合は、 Ctrl-C。&lt;/p&gt;
&lt;h2&gt;ネットワークアクセス&lt;/h2&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ jekyll s 
&lt;/pre&gt;
&lt;p&gt;このコマンドで起動した httpd サーバは、 localhost でしかアクセスできない。&lt;/p&gt;
&lt;p&gt;つまり PC 外部からアクセス出来ない。&lt;/p&gt;
&lt;p&gt;セキュリティという意味では安全であるが、不便だったりする。&lt;/p&gt;
&lt;p&gt;PC 外部からアクセスしたい場合は、次のコマンドで httpd サーバを起動する。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ jekyll s --host 0.0.0.0
&lt;/pre&gt;</content><author><name></name></author><category term="org-mode jekyll" /></entry></feed>