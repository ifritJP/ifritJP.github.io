<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://ifritjp.github.io/blog/site/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ifritjp.github.io/blog/site/" rel="alternate" type="text/html" /><updated>2020-02-19T06:25:04+09:00</updated><id>https://ifritjp.github.io/blog/site/feed.xml</id><title type="html">hoge blog</title><subtitle>Qiita に投稿する程でないネタを上げるネタサイト。 ポエムや、メモ、自分用の備忘録、Web から集めただけの情報などなど。</subtitle><entry><title type="html">emacs lisp の quote</title><link href="https://ifritjp.github.io/blog/site/2020/02/18/emacs-quoted-list.html" rel="alternate" type="text/html" title="emacs lisp の quote" /><published>2020-02-18T00:00:00+09:00</published><updated>2020-02-18T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2020/02/18/emacs-quoted-list</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2020/02/18/emacs-quoted-list.html">&lt;p&gt;emacs lisp の quote でハマったのでネタに書いておく。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;lisp&quot;&gt;
(defvar hoge-val nil)
(defun hoge-init ()
  (setq hoge-val &amp;#39;(:val nil))
  )
(defun hoge-set ()
  (plist-put hoge-val :val &amp;quot;1&amp;quot;))
&lt;/pre&gt;
&lt;p&gt;上記のように変数 hoge-val に対して plist-put で処理する関数を定義して、
  次のようにコールすると。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;lisp&quot;&gt;
(let (val1 val2 val3)
   (hoge-init)
   (setq val1 (plist-get hoge-val :val))
   (hoge-set)
   (setq val2 (plist-get hoge-val :val))
   (hoge-init)
   (setq val3 (plist-get hoge-val :val))
   (message (format &amp;quot;%s %s %s&amp;quot; val1 val2 val3)))
&lt;/pre&gt;
&lt;p&gt;最後の (message (format &amp;#8220;%s %s %s&amp;#8221; val1 val2 val3)) で &amp;#8220;nil 1 1&amp;#8221; が出力される。&lt;/p&gt;
&lt;p&gt;てっきり、 &amp;#8220;nil 1 nil&amp;#8221; が出力されるものだと思っていた。
  なぜなら、val3 をセットする直前に hoge-init を実行しており、
  この hoge-init は hoge-val を &amp;#8216;(:val nil) で初期化する関数なので、
  (plist-get hoge-val :val) は nil を返すと考えたからだ。&lt;/p&gt;
&lt;p&gt;しかし実際には、最後の (plist-get hoge-val :val) は &amp;#8220;1&amp;#8221; になる。&lt;/p&gt;
&lt;p&gt;なぜこのような結果になるかと言うと、
  &amp;#8216;() は定数として扱い、
  関数 hoge-init を実行する際には新しくリストを生成せず、
  defun を評価した時の値そのものが使い続けられる。&lt;/p&gt;
&lt;p&gt;そして (plist-put) でリストの中身を操作した場合、その定数自体が書き変わり、
  hoge-init 関数は変数に書き変わった定数を代入しているため初期化できない。&lt;/p&gt;
&lt;p&gt;一方で、 hoge-init の処理に list 関数を使うと、&amp;#8221;nil 1 nil&amp;#8221; となる。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;lisp&quot;&gt;
(defun hoge-init ()
  (setq hoge-val (list :val nil))
  )
&lt;/pre&gt;
&lt;p&gt;(list) は評価されるたび新規にリストを生成しているため、変数を初期化出来る。&lt;/p&gt;
&lt;p&gt;よく考えてみると納得できるけど、
  実際の動きと見た目のギャップにどうにもこうにも意味不明だった。&lt;/p&gt;
&lt;p&gt;これまで一度も意識せずにきたのが不思議なくらい、かなり基本的な内容だと思う。&lt;/p&gt;
&lt;p&gt;quote した値の変更は、要注意ってことで。&lt;/p&gt;</content><author><name>ifritJP</name></author><category term="emacs org-mode" /></entry><entry><title type="html">org-mode 9.3.5 で babel(dot/plantuml) が動かなかった</title><link href="https://ifritjp.github.io/blog/site/2020/02/13/emacs-org-9.3.5.html" rel="alternate" type="text/html" title="org-mode 9.3.5 で babel(dot/plantuml) が動かなかった" /><published>2020-02-13T00:00:00+09:00</published><updated>2020-02-13T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2020/02/13/emacs-org-9.3.5</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2020/02/13/emacs-org-9.3.5.html">&lt;p&gt;emacs の org-mode では、
  .org ファイル内に C や python 等ソースコードを書いて、
  export 時にそのソースコードを色付けした状態で載せることができる。&lt;/p&gt;
&lt;p&gt;この機能を babel と言う。&lt;/p&gt;
&lt;p&gt;babel では、ソースコードの色付けだけでなく、
  dot や plantuml 等のグラフ生成言語を利用することで、
  .org ファイル内に書いたグラフ生成言語からグラフを生成して、
  所定位置にグラフを挿入することもできる。&lt;/p&gt;
&lt;p&gt;今回、 org-mode 9.3.5 の babel を使って dot の画像を出力しようとしたところ、
  エラーしたので原因を追ってみた。&lt;/p&gt;
&lt;h1&gt;エラー箇所&lt;/h1&gt;
&lt;p&gt;エラーは次の関数で発生していた。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;lisp&quot;&gt;
(defun org-babel-chomp (string &amp;amp;optional regexp)
  &amp;quot;Strip a trailing space or carriage return from STRING.
The default regexp used is \&amp;quot;[ \\f\\t\\n\\r\\v]\&amp;quot; but another one
can be specified as the REGEXP argument.&amp;quot;
  (let ((regexp (or regexp &amp;quot;[ \f\t\n\r\v]&amp;quot;)))
    (while (and (&amp;gt; (length string) 0)
                (string-match regexp (substring string -1)))
      (setq string (substring string 0 -1)))
    string))
&lt;/pre&gt;
&lt;p&gt;エラーの内容は次のものだった。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
Debugger entered--Lisp error: (wrong-type-argument stringp nil)
  string-match(nil &amp;quot;c&amp;quot;)
  (and (&amp;gt; (length string) 0) (string-match regexp (substring string -1)))
  (while (and (&amp;gt; (length string) 0) (string-match regexp (substring string -1))) (setq string (substring string 0 -1)))
  (let ((regexp (or regexp &amp;quot;[ \f\011\n\015\013]&amp;quot;))) (while (and (&amp;gt; (length string) 0) (string-match regexp (substring string -1))) (setq string (substring string 0 -1))) string)
&lt;/pre&gt;
&lt;p&gt;このエラーは、
  上記の org-babel-chomp 関数の regexp 引数が nil だった場合に発生する。&lt;/p&gt;
&lt;h1&gt;エラーの修正&lt;/h1&gt;
&lt;p&gt;このエラーに対し、
  次のように let で宣言する変数を別名(regexp-work)で定義することで回避した。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;lisp&quot;&gt;
(defun org-babel-chomp (string &amp;amp;optional regexp)
  &amp;quot;Strip a trailing space or carriage return from STRING.
The default regexp used is \&amp;quot;[ \\f\\t\\n\\r\\v]\&amp;quot; but another one
can be specified as the REGEXP argument.&amp;quot;
  (let ((regexp-work (or regexp &amp;quot;[ \f\t\n\r\v]&amp;quot;)))
    (while (and (&amp;gt; (length string) 0)
                (string-match regexp-work (substring string -1)))
      (setq string (substring string 0 -1)))
    string))
&lt;/pre&gt;
&lt;h1&gt;エラーの原因&lt;/h1&gt;
&lt;p&gt;エラーの原因を確認するため、
  エラーを再現する処理を抜き出して書き換えると次になる。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;lisp&quot;&gt;
;;; -*- lexical-binding: t; -*-
(defun hoge (regexp)
  (let ((regexp (or regexp &amp;quot;a&amp;quot;)))
    (string-match regexp &amp;quot;b&amp;quot;)))
&lt;/pre&gt;
&lt;p&gt;上記の hoge 関数の引数 regexp に nil をセットしてコールすると同じエラーになる。
  なお、この現象は lexical-binding を有効にしている時だけ発生する。&lt;/p&gt;
&lt;p&gt;上記関数の処理を説明すると次のようになる。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;let で新しく変数 regexp を宣言する
    &lt;ul&gt;
      &lt;li&gt;このとき、引数 regexp が nil 以外なら、引数 regexp の値を変数 regexp にセットする&lt;/li&gt;
      &lt;li&gt;引数 regexp が nil なら、 &amp;#8220;a&amp;#8221; を変数 regexp にセットする。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;つまり、let で宣言している変数 regexp には必ず nil 以外がセットされるはずである。&lt;/p&gt;
&lt;p&gt;しかし、実際には string-match に渡される regexp には nil がセットされている。&lt;/p&gt;
&lt;p&gt;何故このような結果になるか原因を想像すると、&lt;/p&gt;
&lt;p&gt;「string-match でアクセスするシンボル regexp は、
  let で宣言している regexp ではなく、関数の引数 regexp が参照されるため」&lt;/p&gt;
&lt;p&gt;と考えるのが妥当だろう。&lt;/p&gt;
&lt;p&gt;string-match は let のスコープなので、
  普通に考えれば string-match の regexp は let で宣言している変数 regexp であるはず。
  しかし、実際には何故か関数の引数 regexp になっている。&lt;/p&gt;
&lt;p&gt;これが emacs lisp の仕様なのか、はたまた仕様外の動作なのかは良く分からない。&lt;/p&gt;
&lt;p&gt;ちなみに、これが発生している環境は emacs 26.2 だが、
  他の環境で発生するかどうかは確認していない。&lt;/p&gt;
&lt;p&gt;org-mode の履歴を追ってみたが、
  この関数の処理は lexical-binding を使うようになる前から変っていないので、
  lexical-binding にした事による影響だろう。&lt;/p&gt;
&lt;p&gt;以上。&lt;/p&gt;</content><author><name>ifritJP</name></author><category term="emacs org-mode" /></entry><entry><title type="html">emacs 用 reviewboard モードの宣伝</title><link href="https://ifritjp.github.io/blog/site/2020/02/03/emacs-reviewboard.html" rel="alternate" type="text/html" title="emacs 用 reviewboard モードの宣伝" /><published>2020-02-03T00:00:00+09:00</published><updated>2020-02-03T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2020/02/03/emacs-reviewboard</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2020/02/03/emacs-reviewboard.html">&lt;p&gt;この記事は、emacs 用 reviewboard モードの宣伝である。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ifritJP/emacs-reviewboard-front&quot;&gt;https://github.com/ifritJP/emacs-reviewboard-front&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;reviewboard は、ソースコードレビューを Web 上で行ない記録するためのツール。&lt;/p&gt;
&lt;p&gt;今は github の Pull-Request に代表されるように
  Web 上のソースレビューが普及しているが、
  reviewboard の初版が 2007 年であることを考えると、
  当時は先進的なツールだったと思う。&lt;/p&gt;
&lt;p&gt;そんな reviewboard を emacs で操作するモードを今になって作ったので、
  どれ程の人が使うかは不明だが、折角なので宣伝しておく。&lt;/p&gt;
&lt;h1&gt;機能&lt;/h1&gt;
&lt;p&gt;このモードでは、次の機能を提供する。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;修正ファイル一覧から必要なファイルを選択して review request (以降 rrq と記す)を登録
    &lt;ul&gt;
      &lt;li&gt;rrq の summary/description/testing_done を編集&lt;/li&gt;
      &lt;li&gt;修正ファイルの追加、削除可能&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;レビューを受けて更新したファイル郡を、一発でアップロード&lt;/li&gt;
  &lt;li&gt;レビューコメントのリプライ登録&lt;/li&gt;
  &lt;li&gt;rrq の publish/close/discard&lt;/li&gt;
  &lt;li&gt;rrq に登録したファイルをコミット&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;設定&lt;/h2&gt;
&lt;h3&gt;環境&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;curl, rbt, svn を事前にインストールしておく
    &lt;ul&gt;
      &lt;li&gt;rbt は、 diff の登録に利用する。&lt;/li&gt;
      &lt;li&gt;curl は、 reviewboard の WebAPI へのアクセスに利用する。&lt;/li&gt;
      &lt;li&gt;環境によっては、 proxy 等の環境変数設定が必要な場合がある。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;上記 github から emacs-reviewboard-front を取得し適当な場所に展開する&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;emacs-lisp&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;emacs-reviewboard-front のパスに load-path に追加する。&lt;/li&gt;
  &lt;li&gt;次の設定を行なう。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;src&quot; lang=&quot;el&quot;&gt;
(require &amp;#39;rbfront-mode)
(setq rb/front-rb-api-token &amp;quot;TOKEN&amp;quot;)
(setq rb/front-rb-url &amp;quot;http://reviewboard.host/path&amp;quot;)
(setq rb/front-rbt &amp;quot;rbt&amp;quot;)
(setq rb/front-proxy &amp;quot;http://proxy.host:8080/&amp;quot;)
(setq rb/front-rb-repository &amp;quot;RESPOSITORY_NAME&amp;quot;)
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;rb/front-rb-api-token は、
    reviewboard のアカウント管理ページで生成した API Tokens を指定する。&lt;/li&gt;
  &lt;li&gt;rb/front-rb-url は、
    reviewboard のサーバの URL を指定する。&lt;/li&gt;
  &lt;li&gt;rb/front-proxy は、
    reviewboard のサーバにアクセスする際に使用する proxy を指定する。&lt;/li&gt;
  &lt;li&gt;front-rb-repository は、
    reviewboard に diff を登録する際の repository 名を指定する。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;新規登録&lt;/h2&gt;
&lt;p&gt;emacs-reviewboard-front では、現状 svnp.el を使用することを前提としている。&lt;/p&gt;
&lt;p&gt;ここでは、svnp.el の細かい使用方法については説明しない。
  rrq の新規登録に必要な最低限の操作について説明する。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;M-x svn-status で修正ファイル一覧を表示し、
    commit する要領でファイルを選択する。&lt;/li&gt;
  &lt;li&gt;j キー押下で、rrq 編集バッファが表示される。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;編集バッファ&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/blog/site/assets/rb-new.png&quot; alt=&quot;/blog/site/assets/rb-new.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;title と description、 test を編集する。&lt;/li&gt;
  &lt;li&gt;編集後、 C-c C-c 押下により submit 処理で reviewboard に登録する。
    &lt;ul&gt;
      &lt;li&gt;新規登録の場合、 mini-buffer で reviewer を選択する。
        &lt;ul&gt;
          &lt;li&gt;この mini-buffer では TAB キーによる補完が可能。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;修正ファイルの追加・削除&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;rrq に登録する修正ファイルを追加したい場合、 C-c C-a を押下する。
    &lt;ul&gt;
      &lt;li&gt;mini-buffer で、ファイルが存在するディレクトリを指定し、
        その後表示されるファイル一覧から上記のようにファイルを選択する。&lt;/li&gt;
      &lt;li&gt;選択後、 j キー押下で、ファイルが追加される。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;rrq に登録する修正ファイルを除外する場合、
    除外するファイルにカーソルを移動して C-c C-SPC を押下する。
    &lt;ul&gt;
      &lt;li&gt;除外を reviewboard に反映するには、 C-c C-u を押下する。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;review コメント&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;review コメントの表示はサーバアクセスが多くなるため、
    デフォルトでは非表示にしている。&lt;/li&gt;
  &lt;li&gt;表示する場合、 C-c C-d する。&lt;/li&gt;
  &lt;li&gt;デフォルトで表示にする場合、 rb/front-display-comment-p に nil 以外を設定する。&lt;/li&gt;
  &lt;li&gt;review コメントに対するリプライを登録する場合、
    コメントにカーソルを合わせて C-c C-r。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;submit モード&lt;/h3&gt;
&lt;p&gt;submit 時の動作を、次のどちらかに変更できる。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;submit と同時に publish する&lt;/li&gt;
  &lt;li&gt;submit だけする&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C-c C-t でモードを切り替える。&lt;/p&gt;
&lt;p&gt;デフォルトは publish する。&lt;/p&gt;
&lt;p&gt;デフォルトを submit だけに切り替える場合、
  rb/front-submit-and-publish-p に nil を設定する。&lt;/p&gt;
&lt;h2&gt;rrq リスト表示&lt;/h2&gt;
&lt;p&gt;M-x rb/front-list で、
  自分が登録した rrq 一覧を表示する。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/site/assets/rb-list.png&quot; alt=&quot;/blog/site/assets/rb-list.png&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;リスト操作&lt;/h3&gt;
&lt;dl&gt;
  &lt;dt&gt;(g)&lt;/dt&gt;&lt;dd&gt;リストを更新する&lt;/dd&gt;
  &lt;dt&gt;(RET)&lt;/dt&gt;&lt;dd&gt;カーソル位置の rrq を編集する&lt;/dd&gt;
  &lt;dt&gt;(u)&lt;/dt&gt;&lt;dd&gt;カーソル位置の rrq の diff を、再アップロードする&lt;/dd&gt;
  &lt;dt&gt;(p)&lt;/dt&gt;&lt;dd&gt;カーソル位置の rrq を publish する。&lt;/dd&gt;
  &lt;dt&gt;(c)&lt;/dt&gt;&lt;dd&gt;カーソル位置の rrq を close する。&lt;/dd&gt;
  &lt;dt&gt;(d)&lt;/dt&gt;&lt;dd&gt;カーソル位置の rrq を discard する。&lt;/dd&gt;
  &lt;dt&gt;(C)&lt;/dt&gt;&lt;dd&gt;カーソル位置の rrq に登録したファイルを commit する。&lt;/dd&gt;
&lt;/dl&gt;
&lt;h3&gt;diff の再アップロード&lt;/h3&gt;
&lt;p&gt;再アップロードを行なうため、ローカルの work ディレクトリを指定する必要がある。
  work ディレクトリの指定は mini-buffer で行なう。&lt;/p&gt;
&lt;h2&gt;注意&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;rrq 編集バッファで C-c C-c を実行すると、
    バッファ内容がサーバに登録され、即時 publish する。&lt;/li&gt;
  &lt;li&gt;rrq 編集バッファの C-c C-a による修正ファイル追加は、
    新規 rrq の場合を除き即時 publish する。
    新規 rrq の場合、submit 時に rrq 情報と一緒に更新ファイル情報が登録される。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>ifritJP</name></author><category term="emacs reviewboard" /></entry><entry><title type="html">C 言語のラッパー関数オーバーヘッド</title><link href="https://ifritjp.github.io/blog/site/2019/10/15/wrapper-overhead.html" rel="alternate" type="text/html" title="C 言語のラッパー関数オーバーヘッド" /><published>2019-10-15T00:00:00+09:00</published><updated>2019-10-15T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/10/15/wrapper-overhead</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/10/15/wrapper-overhead.html">&lt;p&gt;プログラムを組む際、ラッパー関数を作ることは良くある。&lt;/p&gt;
&lt;p&gt;このラッパー関数のオーバーヘッドが気になったので簡単に調べてみた。&lt;/p&gt;
&lt;p&gt;計測用サンプルは次の通り。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;c&quot;&gt;
#include&amp;lt;stdio.h&amp;gt;
typedef void (func_t)( int val1, int val2 );
void func( int val1, int val2 )
{
    printf( &amp;quot;%d %d&amp;quot;, val1, val2 );
}
void wrapper0( int val1, int val2 )
{
    func( val1, val2 );
}
void wrapper1( func_t * pFunc, int val1, int val2 )
{
    pFunc( val1, val2 );
}
void wrapper2( int val1, int val2, func_t * pFunc )
{
    pFunc( val1, val2 );
}
main() {
    wrapper0( 0, 1 );
    wrapper1( func, 0, 1 );
    wrapper2( 0, 1, func );
}
&lt;/pre&gt;
&lt;p&gt;関数 func() をコールする 3 種類のラッパー関数 wrapper0, wrapper1, wrapper2 を用意した。&lt;/p&gt;
&lt;p&gt;それぞれのラッパー関数は次の形になっている。&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;ラッパー&lt;/th&gt;&lt;th&gt;引数&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;wrapper0&lt;/td&gt;&lt;td&gt;呼び出し先と同じ引数&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;wrapper1&lt;/td&gt;&lt;td&gt;ラッパー独自引数の後に呼び出し先と同じ引数&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;wrapper2&lt;/td&gt;&lt;td&gt;呼び出し先と同じ引数の後にラッパー独自引数&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;これを gcc の x64 で -O の最適化した結果が次になる。
  (func の処理は省略)&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;asm&quot;&gt;
0000000000000021 &amp;lt;wrapper0&amp;gt;:
  21:	48 83 ec 08          	sub    $0x8,%rsp
  25:	e8 00 00 00 00       	callq  2a &amp;lt;wrapper0+0x9&amp;gt;
  2a:	48 83 c4 08          	add    $0x8,%rsp
  2e:	c3                   	retq   

000000000000002f &amp;lt;wrapper1&amp;gt;:
  2f:	48 83 ec 08          	sub    $0x8,%rsp
  33:	48 89 f8             	mov    %rdi,%rax
  36:	89 f7                	mov    %esi,%edi
  38:	89 d6                	mov    %edx,%esi
  3a:	ff d0                	callq  *%rax
  3c:	48 83 c4 08          	add    $0x8,%rsp
  40:	c3                   	retq   

0000000000000041 &amp;lt;wrapper2&amp;gt;:
  41:	48 83 ec 08          	sub    $0x8,%rsp
  45:	ff d2                	callq  *%rdx
  47:	48 83 c4 08          	add    $0x8,%rsp
  4b:	c3                   	retq   

000000000000004c &amp;lt;main&amp;gt;:
  4c:	48 83 ec 08          	sub    $0x8,%rsp
  50:	be 01 00 00 00       	mov    $0x1,%esi
  55:	bf 00 00 00 00       	mov    $0x0,%edi
  5a:	e8 00 00 00 00       	callq  5f &amp;lt;main+0x13&amp;gt;
  5f:	ba 01 00 00 00       	mov    $0x1,%edx
  64:	be 00 00 00 00       	mov    $0x0,%esi
  69:	bf 00 00 00 00       	mov    $0x0,%edi
  6e:	e8 00 00 00 00       	callq  73 &amp;lt;main+0x27&amp;gt;
  73:	ba 00 00 00 00       	mov    $0x0,%edx
  78:	be 01 00 00 00       	mov    $0x1,%esi
  7d:	bf 00 00 00 00       	mov    $0x0,%edi
  82:	e8 00 00 00 00       	callq  87 &amp;lt;main+0x3b&amp;gt;
  87:	b8 00 00 00 00       	mov    $0x0,%eax
  8c:	48 83 c4 08          	add    $0x8,%rsp
  90:	c3                   	retq   
&lt;/pre&gt;
&lt;p&gt;上記通り wrapper0 と wrapper2 は、ほぼ同じコードになっており、
  wrapper1 は引数をずらす処理が余分に入っている。&lt;/p&gt;
&lt;p&gt;想像通りの結果といえば想像通りだが、
  ちゃんと最適化された処理になっている。&lt;/p&gt;
&lt;p&gt;以上のことから言えることは、
  ラッパー関数独自の引数は、先頭ではなく末尾にもっていった方が良いということだ。&lt;/p&gt;
&lt;p&gt;ただし、ここまで最適化が効くケースは、
  ラッパー関数内での目的の関数コールが先頭にある場合に限られるので、
  目的の関数コールを先頭に持ってこれない場合は、気にしないで良いだろう。&lt;/p&gt;
&lt;p&gt;なお、 -O2 で最適化をかけると wrapper1, wrapper2 は次の処理に最適化された。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;asm&quot;&gt;
0000000000000030 &amp;lt;wrapper1&amp;gt;:
  30:	48 89 f8             	mov    %rdi,%rax
  33:	89 f7                	mov    %esi,%edi
  35:	89 d6                	mov    %edx,%esi
  37:	ff e0                	jmpq   *%rax
  39:	0f 1f 80 00 00 00 00 	nopl   0x0(%rax)

0000000000000040 &amp;lt;wrapper2&amp;gt;:
  40:	ff e2                	jmpq   *%rdx
&lt;/pre&gt;
&lt;p&gt;個人的には、こっちの方が納得がいく。&lt;/p&gt;
&lt;p&gt;また、次のようにラッパー関数に static 宣言を付加して、
  外部からコールされないことを明示すると、&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;c&quot;&gt;
#include&amp;lt;stdio.h&amp;gt;
typedef void (func_t)( int val1, int val2 );
void func( int val1, int val2 )
{
    printf( &amp;quot;%d %d&amp;quot;, val1, val2 );
}
static void wrapper0( int val1, int val2 )
{
    func( val1, val2 );
}
static void wrapper1( func_t * pFunc, int val1, int val2 )
{
    pFunc( val1, val2 );
}
static void wrapper2( int val1, int val2, func_t * pFunc )
{
    pFunc( val1, val2 );
}
main() {
    wrapper0( 0, 1 );
    wrapper1( func, 0, 1 );
    wrapper2( 0, 1, func );
}
&lt;/pre&gt;
&lt;p&gt;出力結果は次のように、 ラッパーがインライン展開され、
  ラッパーの引数の違いによる差分は無くなった。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;asm&quot;&gt;
0000000000000021 &amp;lt;main&amp;gt;:
  21:	48 83 ec 08          	sub    $0x8,%rsp
  25:	be 01 00 00 00       	mov    $0x1,%esi
  2a:	bf 00 00 00 00       	mov    $0x0,%edi
  2f:	e8 00 00 00 00       	callq  34 &amp;lt;main+0x13&amp;gt;
  34:	be 01 00 00 00       	mov    $0x1,%esi
  39:	bf 00 00 00 00       	mov    $0x0,%edi
  3e:	e8 00 00 00 00       	callq  43 &amp;lt;main+0x22&amp;gt;
  43:	be 01 00 00 00       	mov    $0x1,%esi
  48:	bf 00 00 00 00       	mov    $0x0,%edi
  4d:	e8 00 00 00 00       	callq  52 &amp;lt;main+0x31&amp;gt;
  52:	b8 00 00 00 00       	mov    $0x0,%eax
  57:	48 83 c4 08          	add    $0x8,%rsp
  5b:	c3                   	retq   
&lt;/pre&gt;
&lt;p&gt;基本的に、ソースコードはメンテナンス性や可読性を優先すべきだが、
  ソースコードを自動生成するような場合は、
  このような細かいことも意識しておいた方が良いだろう。&lt;/p&gt;
&lt;p&gt;以上。&lt;/p&gt;</content><author><name>ifritJP</name></author><category term="C" /></entry><entry><title type="html">C 言語の可変長引数 (va_list) 処理のオーバーヘッド</title><link href="https://ifritjp.github.io/blog/site/2019/08/06/va-performance.html" rel="alternate" type="text/html" title="C 言語の可変長引数 (va_list) 処理のオーバーヘッド" /><published>2019-08-06T00:00:00+09:00</published><updated>2019-08-06T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/08/06/va-performance</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/08/06/va-performance.html">&lt;p&gt;以前 C 言語の関数ポインタによる関数コールのオーバーヘッドがどの程度なのか調べたが、
  今回は可変長引数(va_list)処理のオーバーヘッドについて調べてみた。&lt;/p&gt;
&lt;h1&gt;結果&lt;/h1&gt;
&lt;p&gt;初めに結果から書くと、&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
可変長引数(va_list)処理のオーバーヘッドは、めちゃめちゃ掛る。
また、引数の数に応じて時間が増加する。
&lt;/pre&gt;
&lt;h1&gt;所感&lt;/h1&gt;
&lt;p&gt;今回の実験によって、 va_list 処理には当初の想定を遥かに越えたオーバーヘッドが
  かかることが分った。&lt;/p&gt;
&lt;p&gt;個人的には、コンパイラがもっと賢くやってくれているものだと思っていたが、
  実際には全く賢くなかった。&lt;/p&gt;
&lt;p&gt;C 言語で可変長引数を積極的に使用することはあまりないとは思うが、
  可変長引数の使用はオーバーヘッドを十分考慮に入れて慎重に検討するべきだということが判った。&lt;/p&gt;
&lt;p&gt;この可変長引数のオーバーヘッドを調べたのは、
  LuneScript のメソッド呼び出し処理を C 言語にトランスコンパイルした際に
  可変長引数を利用しようと思ったからなのだが、
  この結果から可変長引数は使えないことが分った。&lt;/p&gt;
&lt;p&gt;対応する前に結果が分って良かったが、
  可変長引数が使えなくなったのは当初の目論見が崩れてしまった。&lt;/p&gt;
&lt;h1&gt;実験詳細&lt;/h1&gt;
&lt;p&gt;ここでは、今回の実験方法について説明する。&lt;/p&gt;
&lt;h2&gt;コード&lt;/h2&gt;
&lt;p&gt;実験用に次の C 言語コードを作成した。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;c&quot;&gt;
int func( int val1, int val2 ) {
    return val1 + val2;
}
int sub( int dummy, int val1, int val2 ) {
    return func( val1, val2 );
}


int funcv2( va_list ap ) {
    int val1 = va_arg( ap, int );
    int val2 = va_arg( ap, int );
    return val1 + val2;
}
int subv2( int dummy, ... ) {
    int val;
    va_list ap;
    va_start( ap, dummy );

    val = funcv2( ap );
    
    va_end( ap );
    return val;
}
&lt;/pre&gt;
&lt;p&gt;func, sub は、可変長引数を使用しないパターン。
  funcv2, subv2 は、可変長引数を使用しするパターン。&lt;/p&gt;
&lt;p&gt;ちなみにコードの全体は次の通りである。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;c&quot;&gt;
#include &amp;lt;sys/time.h&amp;gt;
#include &amp;lt;time.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;stdarg.h&amp;gt;

int func( int val1, int val2 ) {
    return val1 + val2;
}

int sub( int dummy, int val1, int val2 ) {
    return func( val1, val2 );
}


int funcv2( va_list ap ) {
    int val1 = va_arg( ap, int );
    int val2 = va_arg( ap, int );
    return val1 + val2;
}

int subv2( int dummy, ... ) {
    int val;
    va_list ap;
    va_start( ap, dummy );

    val = funcv2( ap );
    
    va_end( ap );
    return val;
}

int funcv3( va_list ap ) {
    int val1 = va_arg( ap, int );
    int val2 = va_arg( ap, int );
    int val3 = va_arg( ap, int );
    return val1 + val2 + val3;
}

int subv3( int dummy, ... ) {
    int val;
    va_list ap;
    va_start( ap, dummy );

    val = funcv3( ap );
    
    va_end( ap );
    return val;
}


double getTime( void ) {
    struct timeval tm;
    gettimeofday( &amp;amp;tm, NULL );
    return tm.tv_sec + tm.tv_usec / 1000000.0;
}


main( int argc, const char * argv[] ) {
    long long loop = strtoll( argv[ 1 ], NULL, 10 ) * 1000ll;
    long long count = 0;
    int sum = 0;

    double prev = getTime();
    if ( strcmp( argv[ 2 ], &amp;quot;1&amp;quot; ) == 0 ) {
        for ( count = 0; count &amp;lt; loop; count++ ) {
            sum += sub( 0, 1, 2 );
        }
    }
    else if ( strcmp( argv[ 2 ], &amp;quot;2&amp;quot; ) == 0 ) {
        for ( count = 0; count &amp;lt; loop; count++ ) {
            sum += subv2( 0, 1, 2 );
        }
    }
    else {
        for ( count = 0; count &amp;lt; loop; count++ ) {
            sum += subv3( 0, 1, 2, 3 );
        }
    }
    printf( &amp;quot;%s: %lld time = %g, %d\n&amp;quot;, argv[ 2 ], loop, getTime() - prev, sum );
}

&lt;/pre&gt;
&lt;p&gt;このプログラムは、コマンドラインの引数によって
  sub, subv2, subv3 を指定の回数分実行し、実行時間を表示する。&lt;/p&gt;
&lt;h2&gt;計測結果&lt;/h2&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;時間(秒)&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;固定長引数(sub: 2 引数)&lt;/td&gt;&lt;td&gt;0.62&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;可変長引数(subv2: 2 引数)&lt;/td&gt;&lt;td&gt;11.95&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;可変長引数(subv3: 3 引数)&lt;/td&gt;&lt;td&gt;16.16&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;上記結果を見ると分かる通り、可変長引数は処理時間の桁が違う。&lt;/p&gt;
&lt;p&gt;また、引数の数に応じて時間が増加する。&lt;/p&gt;
&lt;p&gt;以上&lt;/p&gt;</content><author><name>ifritJP</name></author><category term="LuneScript" /></entry><entry><title type="html">如何なる開発手法、プログラム言語を用いても、日本の全てのソフトウェアプロジェクトは必ず技術的負債になる</title><link href="https://ifritjp.github.io/blog/site/2019/08/02/engineering.html" rel="alternate" type="text/html" title="如何なる開発手法、プログラム言語を用いても、日本の全てのソフトウェアプロジェクトは必ず技術的負債になる" /><published>2019-08-02T00:00:00+09:00</published><updated>2019-08-02T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/08/02/engineering</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/08/02/engineering.html">&lt;p&gt;「日本の全てのソフトウェアプロジェクトは必ず技術的負債になる」というタイトルですが、
  次の条件を満す場合に限ります。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;「プロジェクトに関わるソフトウェアエンジニアの大半が技術に無関心」&lt;/b&gt;&lt;/p&gt;
&lt;h1&gt;動機&lt;/h1&gt;
&lt;p&gt;このネタは、次の記事を読んで個人的に思うことがあったのをきっかけに
  書いています。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;オブジェクト指向プログラミング &amp;#8211; 1兆ドル規模の大失敗
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://okuranagaimo.blogspot.com/2019/07/1.html&quot;&gt;https://okuranagaimo.blogspot.com/2019/07/1.html&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;大企業の技術系インターンシップに参加した
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://blog.browniealice.net/post/internship2019winter/&quot;&gt;https://blog.browniealice.net/post/internship2019winter/&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ソフト開発で世界と闘った及川卓也氏が見た、日本の弱点と可能性
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://headlines.yahoo.co.jp/article?a=20190801-00010000-chuokou-bus_all&quot;&gt;https://headlines.yahoo.co.jp/article?a=20190801-00010000-chuokou-bus_all&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上記の記事は各自に読んでもらうとして、
  それぞれの記事の内容をものすごく大雑把にまとめると&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;「OOP はダメだから、関数型プログラミングを使え」&lt;/li&gt;
  &lt;li&gt;「日本を代表する大企業に実情に失望した」&lt;/li&gt;
  &lt;li&gt;「日本の企業はソフトウェア開発を理解していない」&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;になると思います。&lt;/p&gt;
&lt;h1&gt;プログラミング言語は道具にすぎない&lt;/h1&gt;
&lt;p&gt;上記ブログで「OOP はダメだから、関数型プログラミングを使え」と書かれています。
  私は、OOP が万能だなんて思ってませんし、
  上記ブログで指摘されている側面があることも理解しています。&lt;/p&gt;
&lt;p&gt;ですが、オブジェクト指向プログラミングにしろ関数型プログラミングにしろ、
  万能ではないという意味ではどちらも同じです。&lt;/p&gt;
&lt;p&gt;プログラム言語は道具です。
  いかなる道具であっても、
  その道具を安全に運用できるかどうかは、最終的には使う人に依存することになります。&lt;/p&gt;
&lt;p&gt;例えば、古典的なプログラミング言語の代表格に C 言語がありますが、
  ご存知の通り C 言語には GC もないですし、 NULL 安全でもありません。
  そのような高度な「安全」機能を持たない C 言語は、Linux Kernel の開発言語です。
  C 言語によって Linux Kernel を開発しているという事実は、
  高度な「安全」機能が搭載されていないプログラミング言語であっても、
  使用する人次第で大規模プロジェクトでも問題なく運用できるという一つの実証と言えます。&lt;/p&gt;
&lt;p&gt;逆に、C 言語よりも高度な「安全」機能を搭載しているプログラミング言語を使用した
  プロジェクトが技術的負債の塊になり運用困難になった、
  という例はいくらでも身近にあると思います。
  もし身近に無いとしても、ネットで検索すれば多数ヒットします。&lt;/p&gt;
&lt;p&gt;だからと言って、 C 言語の様に使用する人への依存が高過ぎる言語と、
  Rust のように先進的な安全機能搭載言語のどちらを使っても大差はない、
  というつもりはありません。
  私が言いたいのは、「より安全」と言われる技術を使っても、
  それを使用する人への依存性が無くなることはない、ということです。&lt;/p&gt;
&lt;p&gt;自動運転に例えると、
  プログラム言語自体が提供する「安全」は高々レベル 3 のサポートにすぎません。&lt;/p&gt;
&lt;p&gt;レベル 3 の自動運転には、ドライバーの運転技術が必須であるように、
  現存するどのようなプログラム言語であっても、
  ソフトウェアエンジニアの能力が欠かせません。&lt;/p&gt;
&lt;h1&gt;「ソフトウェアエンジニアの大半が技術に無関心」であることの問題&lt;/h1&gt;
&lt;p&gt;なぜ「プロジェクトに関わるソフトウェアエンジニアの大半が技術に無関心」だとダメなのか？&lt;/p&gt;
&lt;p&gt;これは単純に、そのようなプロジェクトではどのように「安全」な環境であっても、
  その「安全」がレベル 5 の自動運転のように「完全」でない限り、
  「不具合をエンジニア自ら作り込んでしまう」からです。&lt;/p&gt;
&lt;p&gt;前述している通り、プログラミング言語はあくまでも道具であって、
  その道具を安全に運用できるかどうかは、最終的には使う人に依存することになります。
  そしてプログラミング言語を使う人はソフトウェアエンジニアであり、
  ソフトウェアエンジニアの能力は、多くの場合、技術への関心度に比例します。&lt;/p&gt;
&lt;p&gt;特に統計を取った訳ではなく、裏付け資料がある訳でもないですが、
  個人的な経験上、技術への関心度が高いソフトウェアエンジニアほど能力が高く、
  技術への関心度が低いソフトウェアエンジニアほど能力が低い傾向にあります。&lt;/p&gt;
&lt;p&gt;つまり、
  「プロジェクトに関わるソフトウェアエンジニアの大半が技術に無関心」であるということは、
  ソフトウェアエンジニアの大半の能力が低いということと、ほぼ同義になります。&lt;/p&gt;
&lt;p&gt;「技術への関心度が低いソフトウェアエンジニアほど能力が低い傾向にある」という持論の
  根拠となるエピソードを一つ挙げておきます。&lt;/p&gt;
&lt;p&gt;あるソフトウェアエンジニアＡがモジュールの設計をしていました。&lt;/p&gt;
&lt;p&gt;そのモジュールは、他モジュールとの依存が高いことが問題になっていたので、
  「DI(Dependency injection)の手法を取り入れたら
  もっとスッキリした設計になる可能性があるので検討してみてはどうですか？」
  と、そのソフトウェアエンジニアＡに話をすると、
  「そういう難しいことは逆に不具合につながるのでやりたくない」と
  言われて一蹴されました。
  DI を検討した結果、従来通りの方法を採用する方が良いという結論になったのであれば
  納得できますが、なんとなく難しそうというイメージだけで拒否していました。
  そして、そのモジュールは依存が高いまま実装されました。&lt;/p&gt;
&lt;p&gt;DI のことを理解していれば、それが難しいと考える人はほとんどいないでしょうし、
  テストがしやすいことから、むしろ不具合も低減できる可能性があり、
  DI を取り入れることで不具合に繋がることを心配する人はいないでしょう。&lt;/p&gt;
&lt;p&gt;このように、技術への関心度が低いと、
  自分が知らない技術を積極的に取り入れるようなことをせず、
  自分が使える技術だけで解決しようとします。
  これによって、よりスマートに実現できる方法が他にあるにもかかわらず、
  潜在的な問題を含む古い方法によってモジュールが作られていき、
  それが積み重なってプロジェクト全体の品質が下っていきます。
  そしてそれは時間が経過するほど、手をつけられない技術的負債になります。&lt;/p&gt;
&lt;p&gt;一言で表現すれば、技術への関心度が低いエンジニアは「技術的負債製造機」です。&lt;/p&gt;
&lt;p&gt;例え TEST FIRST の開発プロセスであっても、それは防げないでしょう。
  ならぜなら、
  テストというのは作成した成果物が仕様通りに出来ていることを確認するものであって、
  仕様そのものに不具合があった場合は、その不具合を検知することは出来ないからです。
  仕様を作るのはソフトウェアエンジニアです。
  能力の低いソフトウェアエンジニアほど、穴の多い仕様を作る傾向にあります。&lt;/p&gt;
&lt;p&gt;能力の低いソフトウェアエンジニアには仕様を作らせず、
  能力の高いソフトウェアエンジニアだけで仕様を作れば良い、という考えもあると思います。&lt;/p&gt;
&lt;p&gt;確かに、能力の高い人の比率が高い場合はそういう運用が可能かもしれません。
  しかし、ここでは大半が能力が低いことを前提にしているので、
  そのような運用は難しいです。&lt;/p&gt;
&lt;p&gt;また、例え仕様に問題がなくても、
  実際にコード化した時に不具合が埋め込まれることは良くあります。
  そして、テストで検出されることもなくリリースされ、市場で時限爆弾のように爆発する、
  お決まりのパターンです。もはや伝統芸能の域です。&lt;/p&gt;
&lt;h1&gt;なぜ日本で問題なのか？&lt;/h1&gt;
&lt;p&gt;ここまでの話を納得していただけたとして、次の疑問が浮ぶかもしれません。&lt;/p&gt;
&lt;p&gt;「プロジェクトに関わるソフトウェアエンジニアの大半が技術に無関心」が
  技術的負債を生み出す原因ならば、日本でなくても同じことが言えるのではないか？&lt;/p&gt;
&lt;p&gt;それは確かにそうです。
  しかし、日本の場合、終身雇用 &amp;amp; 転職しずらい社会環境によって、
  一度雇ったソフトウェアエンジニアが技術に無関心だったとしても、
  そのソフトウェアエンジニアを他の優秀なソフトウェアエンジニアに入れ替える、
  ということが非常に困難なため、このような状況になり易いです。&lt;/p&gt;
&lt;p&gt;さらに、日本ではソフトウェア開発をゼネコン方式で開発するという文化があり、
  一つのプロジェクトを社内の優秀なソフトウェアエンジニアだけで開発する、
  というのは非常に稀なケースであり、
  一部(あるいは全部)のモジュールをアウトソーシングするケースが多くあります。&lt;/p&gt;
&lt;p&gt;これによって、プロジェクトの品質コントロールをより困難にしています。&lt;/p&gt;
&lt;p&gt;また、日本では全ての社員の待遇に差を付けず、
  等しくすることを善しとする文化があるようで、
  ソフトウェアエンジニアの能力に応じた待遇にする、というようなことを滅多にしません。
  一方で、マネジメント能力に関しては、
  能力に応じた待遇にするキャリアパスが古くから存在するため、
  自分ではコードを一切書かないで一日中パワーポイントやエクセルの資料をせっせと作成している
  ソフトウェアエンジニア(？)が多く存在します。
  そして、マネジメント能力以外のソフトウェアエンジニアの能力が評価対象ではないため、
  自然と「プロジェクトに関わるソフトウェアエンジニアの大半が技術に無関心」と
  いう状況になる傾向にあります。
  いわゆる Japanese Traditional Big Company では、
  特にこの傾向が顕著なのではないでしょうか？&lt;/p&gt;
&lt;p&gt;最初に紹介したブログの著者が「日本を代表する大企業に実情に失望した」原因は、
  このような背景があるためだと思います。&lt;/p&gt;
&lt;p&gt;また、このような背景を作り出しているのは、
  Yahoo の記事にある「日本の企業はソフトウェア開発を理解していない」ためだと思います。&lt;/p&gt;
&lt;p&gt;以上のように、日本のソフトウェア開発プロジェクトには
  技術的負債を生み出す環境が整っているため、
  いかなる開発手法、プログラム言語を用いても技術的負債化を防ぐことは出来ません。&lt;/p&gt;
&lt;p&gt;それなのに、この状況を改善する為と称して、新しいプロジェクト進捗管理手法を導入する、
  という斜め上な施策が実施されることがあります。&lt;/p&gt;
&lt;p&gt;どういう論理で考えると、「新しいプロジェクト進捗管理手法を導入すること」と、
  「プロジェクトの技術的負債化を防ぐこと」が繋がるのでしょうかね？&lt;/p&gt;
&lt;h1&gt;最後に&lt;/h1&gt;
&lt;p&gt;私は LuneScript という言語を開発しています。
  「プログラム言語は単なる道具でしかない」というのは、
  ある意味自己否定しているようにも思われるかもしれません。&lt;/p&gt;
&lt;p&gt;ですが、プログラム言語自体で提供できる安全機能は
  まだまだ残っていると思っているので、
  ソフトウェアエンジニアの助けになるような安全機能を提供できるように
  今後も開発を続けていきたいと考えています。&lt;/p&gt;
&lt;p&gt;以上。&lt;/p&gt;</content><author><name>ifritJP</name></author><category term="engineering" /></entry><entry><title type="html">emacs26.2 で矢印(→)等の一部のフォントが半角表示されるようになった</title><link href="https://ifritjp.github.io/blog/site/2019/07/19/font.html" rel="alternate" type="text/html" title="emacs26.2 で矢印(→)等の一部のフォントが半角表示されるようになった" /><published>2019-07-19T00:00:00+09:00</published><updated>2019-07-19T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/07/19/font</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/07/19/font.html">&lt;p&gt;emacs のバージョンを 26.2 に変えたことで、
  色々と細かいところの使い勝手が変っている。&lt;/p&gt;
&lt;p&gt;その中で、 &lt;code&gt;→&lt;/code&gt; 等の一部のフォントが半角表示されるようになったのが
  微妙にストレスだったのでちょっと追ってみた。&lt;/p&gt;
&lt;h1&gt;原因&lt;/h1&gt;
&lt;p&gt;原因、と言うよりは起因と言った方が良いかもしれないが、
  &lt;code&gt;→&lt;/code&gt; 等の一部のフォントが半角表示されるようになったのは、
  フォントに &amp;#8220;DejaVu Sans Mono&amp;#8221; を使用していることに起因していた。&lt;/p&gt;
&lt;p&gt;これを &amp;#8220;Bitstream Vera Sans Mono&amp;#8221; に変更することで、現象が治った。&lt;/p&gt;
&lt;p&gt;全く同じ環境で、 emacs 26.2 ではなく、以前使用していたバージョンの emacs だと
  現象は発生しなかった。&lt;/p&gt;
&lt;p&gt;emacs の処理が変ったことが原因であるのはほぼ間違い無いが、
  emacs の何がどう変ってこの現象が発生し、
  どう設定(使用するフォントを変える以外で)すれば、
  現象を修正できたのかは残念ながら分からないまま。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;と、思ったが、次のブログに答えがあった。&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://misohena.jp/blog/2017-09-26-symbol-font-settings-for-emacs25.html&quot;&gt;http://misohena.jp/blog/2017-09-26-symbol-font-settings-for-emacs25.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;詳しくは、上記ブログを確認してもらうとして、
  要点だけ説明すると use-default-font-for-symbols に nil 以外が設定されていると、
  シンボル等の文字のフォントが default フォントを使用するようになるらしい。
  このデフォルト値が t であるため、矢印等の一部のフォントが半角になっていた。&lt;/p&gt;
&lt;p&gt;ということで、
  以下を設定してやれば、使用するフォントを変えなくても全角で表示されるようになる。&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
(setq use-default-font-for-symbols nil)
&lt;/pre&gt;
&lt;p&gt;じゃぁ、どうして &amp;#8220;Bitstream Vera Sans Mono&amp;#8221; に変えると
  全角で表示されたのか？が気になったんで調べてみたが、
  どうやら &amp;#8220;Bitstream Vera Sans Mono&amp;#8221; には矢印などのフォントが
  含まれていなことが原因のようだ。&lt;/p&gt;
&lt;p&gt;fontforge でフォントの中身を見ると、
  &amp;#8220;Bitstream Vera Sans Mono&amp;#8221; には矢印のフォントがなく、
  &amp;#8220;DejaVu Sans Mono&amp;#8221; には矢印のフォントがあることが判った。&lt;/p&gt;
&lt;p&gt;つまり、&amp;#8221;DejaVu Sans Mono&amp;#8221; には矢印のフォントがあるので、それが表示され、
  &amp;#8220;Bitstream Vera Sans Mono&amp;#8221; には矢印のフォントがないので、
  別で設定していた全角のフォントが表示された、ということだろう。&lt;/p&gt;
&lt;p&gt;あぁ、これでストレスが一つ減った。&lt;/p&gt;</content><author><name>ifritJP</name></author><category term="font emacs" /></entry><entry><title type="html">stream は rewind/seek できる？</title><link href="https://ifritjp.github.io/blog/site/2019/07/10/stream.html" rel="alternate" type="text/html" title="stream は rewind/seek できる？" /><published>2019-07-10T00:00:00+09:00</published><updated>2019-07-10T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/07/10/stream</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/07/10/stream.html">&lt;p&gt;&lt;b&gt;これは seekable な stream と none_seekable な stream の使い分けに関する記事です。&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;使い分けが十分出来ている人は読まなくても大丈夫です。&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;皆さんは bitstream という単語をご存知でしょうか？&lt;/p&gt;
&lt;p&gt;AV (Audio&amp;amp;Visual) が好きな人や、
  それらの業界に関係のある人ならそこそこ聞く単語だと思いますが、
  一般的にはあまり馴染の無い単語でしょうか。&lt;/p&gt;
&lt;p&gt;馴染の無い人の為に身近な HDD レコーダを例に挙げて説明すると、
  HDD レコーダはデジタル放送の電波に乗っているデータをそのまま記録していますが、
  このデータが bitstream です。
  HDD レコーダは、デジタル放送の bitstream を HDD に記録し、
  記録した bitstream を再生する装置と言えます。
  もちろん、実際にはそんな単純ではないですが、概ね間違ったことは言ってません。&lt;/p&gt;
&lt;h1&gt;stream&lt;/h1&gt;
&lt;p&gt;プログラムでデータを扱う時、stream という概念を使って制御します。&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;言語&lt;/th&gt;&lt;th&gt;stream (入力)&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Java&lt;/td&gt;&lt;td&gt;InputStream&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Swift&lt;/td&gt;&lt;td&gt;InputStream&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Go&lt;/td&gt;&lt;td&gt;io.Reader&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;上記は言語毎の入力系 stream の例です。&lt;/p&gt;
&lt;p&gt;ちなみに入力系の stream とは何かというと、
  流れてくるデータを読み出すためのものです。&lt;/p&gt;
&lt;p&gt;例えば、先ほどの HDD レコーダの例で説明すると、&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;デジタル放送の電波に乗っている bitstream を読み取る部分&lt;/li&gt;
  &lt;li&gt;HDD に記録されている bitstream を読み込む部分&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;が入力系の stream です。&lt;/p&gt;
&lt;p&gt;また、上記言語の stream (InputStream,io.Reader)には共通することがあります。&lt;/p&gt;
&lt;p&gt;それは、データの流れが一方通行で遡ることが出来ない、ということです。&lt;/p&gt;
&lt;p&gt;プログラム的に言うと、上記の stream は seek や rewind をサポートしていません。&lt;/p&gt;
&lt;p&gt;これを、先ほどの HDD レコーダの例で説明すると、
  「過去に放送された番組の録画はできない」ということです。&lt;/p&gt;
&lt;p&gt;24 時間全ての番組を常に録画し続けて、
  「1週間前に放送された任意の番組を再生する」機能を持つ HDD レコーダはありますが、
  それはあくまで録画してあるものを再生しているのであって、
  過去に放送された番組を録画することは出来ません。
  もしそれが出来るなら、
  本当の意味でのタイムマシーンを作ることが出来ることと同義になります。&lt;/p&gt;
&lt;p&gt;なお、「過去に放送された番組の録画はできない」ですが、
  「録画した番組」の逆再生などは出来ます。&lt;/p&gt;
&lt;p&gt;先ほど説明した通り、次のどちらもの入力 stream です。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;デジタル放送の電波に乗っている bitstream を読み取る部分
    &lt;ul&gt;
      &lt;li&gt;過去に放送された番組の録画はできない&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HDD に記録されている bitstream を読み込む部分
    &lt;ul&gt;
      &lt;li&gt;録画した番組は逆再生など出来る&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これはつまり、 stream には次の 2 つのタイプが存在することを意味します。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;流れが一方通行で遡ることが出来ない stream&lt;/li&gt;
  &lt;li&gt;流れを遡ることが出来る stream&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これ以降、上記をそれぞれ none_seekable と seekable とします。&lt;/p&gt;
&lt;h1&gt;none_seekable と seekable の使い分け&lt;/h1&gt;
&lt;p&gt;上記の通り、stream には none_seekable と seekable の 2 つのタイプが存在します。&lt;/p&gt;
&lt;p&gt;では、実際のプログラムでは stream はどう使い分けるべきか？ と考えた場合、
  seekable である必要がない場合は極力 none_seekable を使うべきです。&lt;/p&gt;
&lt;p&gt;なぜならば、
  seekable は none_seekable を包括する概念であり、
  seekable な stream は none_seekable として使用することが出来ますが、
  none_seekable な stream は seekable として使用することが出来ないからです。&lt;/p&gt;
&lt;p&gt;次に、疑似言語を使って説明します。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
fn funcA( data: seekable ) {
  sub( data );
}
fn funcB( data: none_seekable ) {
  sub( data );
}
&lt;/pre&gt;
&lt;p&gt;上記は、 seekable な引数を持つ関数 funcA と、
  none_seekable な引数を持つ関数 funcB を定義する疑似言語コードです。
  また sub() は、 none_seekable な引数を持つ関数とします。&lt;/p&gt;
&lt;p&gt;ここで、この関数 funcA は seekable な stream でしか使用できないのに対し、
  この関数 funcB は seekable, none_seekable どちらでも使用できることになり、
  funcB は funcA よりも汎用性が高いと言えます。&lt;/p&gt;
&lt;p&gt;関数の汎用性が高いことが良いプログラムである、とは一概には言えませんが、
  ミドルウェアなどのライブラリでは、汎用性が高い方が良いとされます。&lt;/p&gt;
&lt;p&gt;つまり、 stream を入力に持つ関数の処理においては、
  seek や rewind の使用は極力避け、
  none_seekable の stream で処理可能にすべきである、と言えます。&lt;/p&gt;
&lt;p&gt;ただし例外として、 seek や rewind を使用しないと目標のパフォーマンスが出ないとか、
  必要なワークメモリが規定を越えてしまう、等の問題がある場合は、
  無理に none_seekable で処理する必要はありません。&lt;/p&gt;
&lt;p&gt;とはいえ、あくまでも原則は、
  seekable ではなく none_seekable で処理できるかどうかを検討するべきです。&lt;/p&gt;
&lt;p&gt;言語の組込みの型として seekable と none_seekable が分かれていない言語は、
  結構あると思います。&lt;/p&gt;
&lt;p&gt;そのような言語でも、
  seekable と none_seekable の考え方自体は有効なので実践してください。&lt;/p&gt;
&lt;h1&gt;none_seekable で処理することのメリット&lt;/h1&gt;
&lt;p&gt;seekable ではなく none_seekable で処理することのメリットとして、
  Web ブラウザでの処理を例に挙げて説明します。&lt;/p&gt;
&lt;p&gt;もしもブラウザの処理が全て seekable であった場合、
  ブラウジングスピードが遅くなることが予想されます。&lt;/p&gt;
&lt;p&gt;なぜなら、Web ブラウザは、サーバから HTML をダウンロードし、
  HTML 内のリンクを抽出し、そのリンクをさらにダウンロードします。
  そしてリンクが画像の場合、画像をデコードして表示します。&lt;/p&gt;
&lt;p&gt;画像のデコード処理が none_seekable であるならば、
  画像データのダウンロード開始と同時にデコード処理が開始でき、
  画像データのダウンロード終了とほぼ同時にデコード処理を完了できます。&lt;/p&gt;
&lt;p&gt;一方でもしも画像のデコード処理が seekable だった場合、
  画像データをダウンロード終了してからデコード処理を行なわなければならず、
  その分タイムロスになります。
  さらに欠点はタイムロスだけでなく、
  画像データの全てをダウンロードして一旦 RAM やストレージに格納しておく必要があり、
  その分のリソースを消費することになります。&lt;/p&gt;
&lt;p&gt;画像データのサイズなんてイマドキのハードウェアスペックなら無視できる、
  という意見もあるかもしれませんが、例えば 8K の低圧縮画像などは軽く数 10MB を越えます。
  こういった画像のデータを全てダウンロードしてからデコードするなんてしてたら、
  無駄にリソースを消費することが分かると思います。&lt;/p&gt;
&lt;p&gt;また、最近はほとんど使われていませんが、
  progressive JPEG なんて画像フォーマットが使われていた時期がありましたが、
  これは none_seekable で処理して始めて意味のあるものです。&lt;/p&gt;
&lt;p&gt;progressive JPEG を簡単に説明すると、
  画像データの一部をダウンロードするだけで、低解像度の画像をデコードできる技術で、
  ダウンロードが進むごとにデコード結果の解像度が上がるというものです。&lt;/p&gt;
&lt;p&gt;これは、ネットワークの通信速度が低速なころに使用されていた画像フォーマットで、
  いまではほとんど使われなくなったものですが、
  none_seekable で処理しなければ全く意味のないものです。&lt;/p&gt;
&lt;p&gt;他にも none_seekable で処理することのメリットとして、
  動画配信に代表されるストリーミングサービスがあります。&lt;/p&gt;
&lt;p&gt;あれも、 none_seekable が前提にあるからこそ可能なサービスです。&lt;/p&gt;
&lt;p&gt;「ストリーミングサービスが none_seekable だ」と書くと
  「Youtube はシークできるぞ」とかツッコミがあると思うので一応補足しておきます。&lt;/p&gt;
&lt;p&gt;たしかに Youtube などの動画配信サービスはシークできるのが当たり前です。
  しかし、通常再生時は none_seekable で処理していて、
  シークなどの操作が入った時だけ、
  サーバからデータをダウンロードしなおして処理しています。
  つまり、基本は none_seekable です。&lt;/p&gt;
&lt;p&gt;もしも動画データが seekable 前提だった場合、
  動画データを全てダウンロードしてからでないと再生できないか、
  seek 処理が大量に発生してサーバ間の通信負荷が非常に高くなることが予想されます。&lt;/p&gt;
&lt;p&gt;また、seekable(randam access) は none_seekable(sequential) と比べて
  非常にパフォーマンスが悪くなるのが一般的です。&lt;/p&gt;
&lt;p&gt;例えば HDD の randam access は sequential と比べて 2 桁以上のパフォーマンス劣化、
  SSD でも 1 桁以上劣化します。
  RAM であっても、randam access することでキャッシュミスが発生しやすくなり、
  パフォーマンス劣化からは逃れられません。
  現代ではほとんど使われませんが、
  テープデバイスなんて使った日には、どれほどかかるか想像すら出来ません。&lt;/p&gt;
&lt;h1&gt;データフォーマット&lt;/h1&gt;
&lt;p&gt;stream を処理する際に、
  それを none_seekable として扱うには、
  stream に流れるデータのフォーマットが none_seekable として
  扱い易い構造になっている必要があります。&lt;/p&gt;
&lt;p&gt;データフォーマットが none_seekable として扱い難い構造の場合、
  上記のように「目標のパフォーマンスが出ない」、「必要なワークメモリが規定を越えてしまう」
  という問題が発生する可能性があります。&lt;/p&gt;
&lt;p&gt;ある程度の大きさになるデータフォーマットを定義する時は、
  必ず none_seekable で処理することを考えて定義しましょう。&lt;/p&gt;
&lt;p&gt;なお、 stream で処理することが多い画像や音声などのデータフォーマットは、
  基本的には none_seekable で処理できるように定義されています。&lt;/p&gt;
&lt;p&gt;もしもそうでなければ、放送や動画配信でデジタルデータを扱うことは出来ません。&lt;/p&gt;
&lt;p&gt;ちなみに、データの encode と decode の none_seekable での扱い易さは、
  相反することがあります。&lt;/p&gt;
&lt;p&gt;その場合、どちらかを優先するか、折衷案の検討が必要です。
  一つ言えることは、作業バッファを 0 にすることはまず不可能なので、
  どの程度の作業バッファサイズなら妥当かを判断することが重要です。&lt;/p&gt;
&lt;h1&gt;例外&lt;/h1&gt;
&lt;p&gt;none_seekable で処理することで、
  ダウンロードとデコードを同時に処理できるため高速に処理できる、と説明しましたが、
  一部例外があります。&lt;/p&gt;
&lt;p&gt;それは、専用ハードウェアを使用してデコードする場合です。&lt;/p&gt;
&lt;p&gt;HDD レコーダなどの家電製品では、
  動画や音声を処理する専用ハードウェアを搭載しています。
  それら専用ハードウェアは、データを渡すと高速に処理して結果を返してくれますが、
  処理するデータは全て揃えてから渡さなければならない、
  という制約があることがほとんどです。&lt;/p&gt;
&lt;p&gt;その場合は、none_seekable でダウンロードとデコードを同時に処理するよりも、
  専用ハードウェアを使用して処理する方が高速に処理できます。&lt;/p&gt;
&lt;p&gt;ただし、当然専用ハードウェアであるため、処理できるデータは限られていますし、
  そのような専用ハードウェアが利用できる環境は限られています。&lt;/p&gt;
&lt;h1&gt;まとめ&lt;/h1&gt;
&lt;p&gt;stream を扱う際は、次を注意する必要があります。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;極力 none_seekable で扱う&lt;/li&gt;
  &lt;li&gt;データフォーマットを決める時点で、 none_seekable で扱えることを考慮する&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;最後に&lt;/h1&gt;
&lt;p&gt;なんでこんなことを書いたかというと、
  最近とある画像コーデックのライブラリを扱うことがあったんですが、
  そのライブラリへの入力が seekable であることを前提としていてムカついた、
  という経験をしたためです。&lt;/p&gt;
&lt;p&gt;データ streaming 処理を行なう場合の基本的な考えなので、
  必ずこれらを考慮に入れて設計するようにお願いします。&lt;/p&gt;
&lt;p&gt;以上。&lt;/p&gt;</content><author><name>ifritJP</name></author><category term="english" /></entry><entry><title type="html">python のクラスを JSON 化</title><link href="https://ifritjp.github.io/blog/site/2019/07/04/python-json.html" rel="alternate" type="text/html" title="python のクラスを JSON 化" /><published>2019-07-04T00:00:00+09:00</published><updated>2019-07-04T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/07/04/python-json</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/07/04/python-json.html">&lt;p&gt;&lt;a href=&quot;https://github.com/ifritJP/game-message-tts&quot;&gt;コレ&lt;/a&gt; を作るにあたって、データの serialize/deserialize の方法を調べた結果、
  &lt;a href=&quot;https://pypi.org/project/marshmallow-dataclass/&quot;&gt;marshmallow_dataclass&lt;/a&gt; に落ち着きました。&lt;/p&gt;
&lt;p&gt;いくつか調べた中で、パッと見、直感的に出来そうだった、というだけの理由ですが。。&lt;/p&gt;
&lt;p&gt;実際、面倒な処理はほとんど無く、 serialize/deserialize が可能になりました。&lt;/p&gt;
&lt;h1&gt;使い型&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://pypi.org/project/marshmallow-dataclass/&quot;&gt;marshmallow_dataclass&lt;/a&gt; は、
  クラスを宣言する際に &lt;code&gt;@dataclass&lt;/code&gt; デコレータを付けて宣言し、
  メンバの型を宣言するのが基本です。&lt;/p&gt;
&lt;p&gt;こんな感じ。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;py&quot;&gt;
@dataclass
class LogItem:
    # ゲームタイトル
    title:str
    # 日付
    date:int
    # テキスト
    text:str
    # テキスト長
    len:int
&lt;/pre&gt;
&lt;p&gt;メンバの宣言が python っぽくないと思う方もいるかもしれませんが、
  静的型付け言語になれていると、こっちの方が馴染み易い気がします。&lt;/p&gt;
&lt;p&gt;JSON 化する場合は、
  次のようにクラスメソッドに JSON 化するクラスのインスタンスを渡すだけです。&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
item = LogItem( &amp;quot;title&amp;quot;, time.time(), &amp;quot;text&amp;quot;, len( &amp;quot;text&amp;quot; ) )
print( marshmallow_dataclass.class_schema( LogItem )().dumps( item ) )
&lt;/pre&gt;
&lt;p&gt;逆に JSON からクラスインスタンスを生成するには、
  次のようにクラスメソッドに渡すだけです。&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
marshmallow_dataclass.class_schema( LogItem )().loads( text )
&lt;/pre&gt;
&lt;p&gt;とても簡単です。&lt;/p&gt;
&lt;p&gt;ただ、躓いた点があったので、気をつけるべき点として書いておきます。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;python3.7 以降を使用する&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@dataclass&lt;/code&gt; デコレータを付けたクラスに次を宣言してはならない
    &lt;ul&gt;
      &lt;li&gt;コンストラクタ __init__&lt;/li&gt;
      &lt;li&gt;@staticmethod load()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>ifritJP</name></author><category term="python" /></entry><entry><title type="html">ゲームのメッセージ欄に表示されたメッセージの読み上げシステム</title><link href="https://ifritjp.github.io/blog/site/2019/06/28/text-to-speech.html" rel="alternate" type="text/html" title="ゲームのメッセージ欄に表示されたメッセージの読み上げシステム" /><published>2019-06-28T00:00:00+09:00</published><updated>2019-06-28T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/06/28/text-to-speech</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/06/28/text-to-speech.html">&lt;p&gt;4 月頃から、英語のレベルを上げるため参考書を買って勉強をしている。&lt;/p&gt;
&lt;p&gt;その参考書を使った最低限の基礎英語の復習は終ったので、次のステップに進むことにした。&lt;/p&gt;
&lt;p&gt;基礎が終った後の学習方法には何が良いのか色々と調べてみたが、
  色々な意見があるが最終的には「持続できるものが良い」というのが結論のようだ。&lt;/p&gt;
&lt;p&gt;まぁ、「持続すること」が英語学習で最も難しいことは、
  私自身が何度も挫折した経験があるので認識している。&lt;/p&gt;
&lt;p&gt;そもそも、先日まで復習していた参考書もかなり眠い目をこすりながらやっていて、
  このまま参考書を進めていっても、間違いなくまた挫折することは明らかだった。&lt;/p&gt;
&lt;p&gt;じゃぁ、何が一番持続できるか？と考えた時、自分にはゲームが良いだろう。
  という結論になった。&lt;/p&gt;
&lt;h1&gt;海外ゲームによる英語学習&lt;/h1&gt;
&lt;p&gt;ゲームのジャンルは、いわゆるノベルゲームあるいはアドベンチャーゲーム。
  有名どころで STEINS;GATE と言えば通じるだろうか？
  これなら文章量がハンパないので、勉強量という意味では問題ないだろう。
  「ゲームでの英語学習は効率が悪い」という意見があるが、
  「持続すること」が一番重要なので、「効率の悪さ」はこの際無視することにした。&lt;/p&gt;
&lt;p&gt;ともかく今は、英語の文章を英語のまま解釈できるようになるため、
  英語の文章をひたすら入力していくのが最も重要な期間で、
  その期間を挫折せずにやりすごすためにも、「持続すること」が一番重要と考えている。&lt;/p&gt;
&lt;p&gt;「習うより慣れよ」、脊髄反射できるまでの試練だ。&lt;/p&gt;
&lt;p&gt;そもそも、本当に効率の良い英語学習方法が存在するのであれば
  文科省もバカじゃないんだからその方法を採用しているはず。
  そして、その学習方法に本当に効果があれば、
  日本人の大多数が英語が出来ないまま放置されているはずがない。
  しかし、現実問題として私を含め日本人の大多数が英語が出来ないままである。&lt;/p&gt;
&lt;p&gt;つまり「日本国内における英語学習方法の違いによる効率の差」は、
  ほとんど誤差レベルなんだと思う。&lt;/p&gt;
&lt;p&gt;もちろん、「英語しか話せない人の中で生活すること」と、
  「日本国内で独学で英語を学習する」のとでは、英語の習得効率に明らかな違いはあるだろう。
  しかし、「日本国内で独学で英語を学習する方法」は、
  どのような学習方法であっても、どれも大差ないレベルなんだと思う。&lt;/p&gt;
&lt;h2&gt;海外ゲームによる英語学習における問題&lt;/h2&gt;
&lt;p&gt;ということで、先週辺りから海外のゲームをプレイしているんだが、一つ問題がある。&lt;/p&gt;
&lt;p&gt;その問題とは「reading の経験値しか得られない」ということだ。&lt;/p&gt;
&lt;p&gt;日本のゲームの海外移植版をやるのがとっかかり易いと考えてたが、
  そのゲームの TEXT は英語だが音声は日本語のままだった。
  てっきり海外移植版なら音声も英語になっているものだと思っていたが、完全に想定外だった。&lt;/p&gt;
&lt;p&gt;それならば、海外制作のオリジナルゲームなら音声も英語だろう、と思って探したが、
  そもそも海外制作のノベルゲームやアドベンチャーゲームというジャンルはほとんど無かった。
  あっても、音声がないという状況だ。
  もちろん、他のジャンルのゲームなら英語音声のものはある。
  しかしそのようなゲームは、TEXT の量的問題や、
  そもそも英語とか関係なくゲームが進んでいって、
  ほとんど単にゲームをプレイしているだけになってしまう、という問題がある。&lt;/p&gt;
&lt;p&gt;ちなみに、海外ドラマや映画を学習手段として試したことがあるが、
  アレはスピードが速すぎて、
  自分のレベルではとてもではないけどハードルが高過ぎるという結論になっている。&lt;/p&gt;
&lt;p&gt;自分のペースで進められる、というのが、
  ノベルゲームやアドベンチャーゲームの良いところだ。&lt;/p&gt;
&lt;p&gt;もちろん、内容が面白く持続できるということが前提だが。&lt;/p&gt;
&lt;p&gt;なお、今回海外のゲームを探してみて初めて気が付いたことだが、
  海外でアドベンチャーゲームというと、日本のアドベンチャーゲームとは全く違って、
  アクションゲームがアドベンチャーゲームに分類されていた。&lt;/p&gt;
&lt;p&gt;まぁ「adventure」 は「冒険」なんだから、当然といえば当然だろうが。&lt;/p&gt;
&lt;p&gt;だいぶ前置きが長くなったが、
  そんな訳で、多くの時間を費やして「reading の経験値しか得られない」のは勿体無いので、
  「どうにかしてゲームに音声を付けよう」と思い、今回のツール制作に至った。&lt;/p&gt;
&lt;h1&gt;ゲームに音声を付ける手段&lt;/h1&gt;
&lt;p&gt;ここで想定するゲームは、
  メッセージを表示する領域があり、クリックすることでメッセージが更新されて、
  ストーリーが進んでいくものだ。&lt;/p&gt;
&lt;p&gt;このメッセージを取り出し、機械音声でしゃべらせる。&lt;/p&gt;
&lt;p&gt;もう少し技術的にいうと次になる。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;スクリーンショットでゲーム画面をキャプチャ&lt;/li&gt;
  &lt;li&gt;キャプチャしたゲーム画面からメッセージ領域を判定し&lt;/li&gt;
  &lt;li&gt;メッセージ領域内のメッセージ画像を抽出し&lt;/li&gt;
  &lt;li&gt;抽出したメッセージ画像を OCR にかけて TEXT に変換し&lt;/li&gt;
  &lt;li&gt;変換した TEXT を Text To Speech で音声化する&lt;/li&gt;
  &lt;li&gt;上記を GUI でコントロール&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;メッセージ画像の抽出は OpenCV、 OCR は Tesseract OCR、
  Text To Speech は Windows10 標準の SAPI.SpVoice を利用する。&lt;/p&gt;
&lt;p&gt;クラウドサービスの API を使えば、これらを全て行なってくれるものもありそうだが、
  今回は上記の技術を組み合わせで自前で作成する。&lt;/p&gt;
&lt;p&gt;&lt;i&gt;まぁ、自分で作ること自体も面白そうだし。&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;なお、お手軽に作るため、開発言語は Python とする。&lt;/p&gt;
&lt;p&gt;プログラミング言語として、個人的にはあまり Python は好きではないんだけど、
  手軽でさまざまなライブラリが揃っていて情報量も豊富、という意味では、
  今は Python に敵う言語はないんじゃないかと思う。&lt;/p&gt;
&lt;p&gt;なんだかんだ言っても、プログラミング言語はツールにすぎないので、
  目的の物を簡単に作れるのが一番良い。
  特に趣味で作るケースでは。&lt;/p&gt;
&lt;p&gt;業務で使う場合は、
  「チョット待て、他の言語はちゃんと検討したのか？」と言っておく。&lt;/p&gt;
&lt;p&gt;自分で開発している LuneScript も、
  lua VM 上で動作する大規模アプリを開発するには向いているけど、
  使えるライブラリは皆無(Lua 用ライブラリは使えるけど、まともに使うには module 宣言が必要)
  なので、残念ながらこういう用途には向いていない。&lt;/p&gt;
&lt;p&gt;ちなみに、 cygwin 版 python で作業しようと思ったが、
  pip がどうにもこうにも期待通りに動作しなかったので、
  普通の windows 版 python にした。&lt;/p&gt;
&lt;p&gt;以降では、各技術について補足する。&lt;/p&gt;
&lt;h2&gt;スクリーンショット&lt;/h2&gt;
&lt;p&gt;スクリーンショット用に次をインストールする。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ pip install pywin32
$ pip install Pillow
$ pip install pyscreenshot
&lt;/pre&gt;
&lt;p&gt;pywin32 は、 win32gui で特定の Window の領域を取得するために必要。&lt;/p&gt;
&lt;p&gt;具体的には次のような感じ。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;py&quot;&gt;
def getImageOf( window_title ):
    rect = win32gui.GetWindowRect( win32gui.FindWindow(None,  window_title ) )
    return ImageGrab.grab().crop( rect )
&lt;/pre&gt;
&lt;h2&gt;OpenCV&lt;/h2&gt;
&lt;p&gt;次の処理を OpenCV で行なう。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ゲーム画面からメッセージ領域を判定&lt;/li&gt;
  &lt;li&gt;メッセージ領域内のメッセージ画像を抽出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ちなみに OpenCV のインストールは次で出来る。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ pip install opencv-python
&lt;/pre&gt;
&lt;h2&gt;OCR (Tesseract OCR)&lt;/h2&gt;
&lt;p&gt;次の処理を Tesseract OCR で行なう。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;抽出したメッセージ画像を OCR にかけて TEXT に変換&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tesseract OCR は、次の URL からバイナリをダウンロードしてインストールし、&lt;/p&gt;
&lt;p&gt;https://github.com/UB-Mannheim/tesseract/wiki&lt;/p&gt;
&lt;p&gt;さらに python から利用するためのパッケージをインストールする。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ pip3 install pyocr
&lt;/pre&gt;
&lt;h2&gt;Windows10 Text To Speech (SAPI.SpVoice)&lt;/h2&gt;
&lt;p&gt;次の処理を SAPI.SpVoice で行なう。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;変換した TEXT を Text To Speech で音声化する&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mhammond/pywin32/releases&quot;&gt;https://github.com/mhammond/pywin32/releases&lt;/a&gt; から、
  python のバージョンに合う win32com モジュールのインストーラをダウンロードし、
  インストールする。&lt;/p&gt;
&lt;p&gt;SAPI.Speech の制御方法は、次の URL を参考に。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.daniweb.com/programming/software-development/code/217062/text-to-speech-using-com-python&quot;&gt;https://www.daniweb.com/programming/software-development/code/217062/text-to-speech-using-com-python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;この SAPI.SpVoice の音声は、
  一昔前の合成音声に比べればだいぶマシに聞こえるが、やはり違和感を感じる。&lt;/p&gt;
&lt;p&gt;英語が出来ない自分が、英語の音声に違和感の文句を云うのもどうかと思うが、
  やはりイマドキの最新の Text To Speech 技術と比べると、品質が落ちる。&lt;/p&gt;
&lt;p&gt;そこで、Text To Speech の部分はクラウドサービスを使って違和感の緩和を検討する。
  これについては後日取り上げる。&lt;/p&gt;
&lt;h2&gt;GUI&lt;/h2&gt;
&lt;p&gt;GUI は tkinter を利用する。&lt;/p&gt;
&lt;p&gt;用途は次の通り。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ゲームの Window 指定&lt;/li&gt;
  &lt;li&gt;OCR のトリガ&lt;/li&gt;
  &lt;li&gt;OCR 後のメッセージ表示 &amp;amp; 編集&lt;/li&gt;
  &lt;li&gt;音声再生制御 (再生スピード,音量)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;ログ&lt;/h2&gt;
&lt;p&gt;折角なので、学習の履歴を残す。&lt;/p&gt;
&lt;p&gt;履歴は、日付、OCR 結果、全文字数 で、JSON 形式で残す。&lt;/p&gt;
&lt;h2&gt;欠点&lt;/h2&gt;
&lt;p&gt;このシステムの一番の欠点は、読み上げられる音声に全く感情が入らないってことだろう。
  ゲームのト書部分なら無感情でも問題ないが、
  セリフが無感情で読み上げられるのは、いささか味気ない。
  まぁ、そこは割り切るしかないが。
  今は、クリアに音声が聞こえる事の方が重要だろう。
  感情がどうこういうのは、
  実力が付いてから海外ドラマや映画を見るようにすれば良い話だ。&lt;/p&gt;
&lt;h1&gt;最後に&lt;/h1&gt;
&lt;p&gt;専門知識がなくても、フリーの技術を組合せるだけで、
  これだけのものが作れるようになったというのはスゴい時代になったものだ。&lt;/p&gt;
&lt;p&gt;ちなみにソースは &lt;a href=&quot;https://github.com/ifritJP/game-message-tts.git&quot;&gt;https://github.com/ifritJP/game-message-tts.git&lt;/a&gt; にある。
  興味があれば。&lt;/p&gt;</content><author><name>ifritJP</name></author><category term="english" /></entry></feed>