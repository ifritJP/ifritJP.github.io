<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://ifritjp.github.io/blog/site/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ifritjp.github.io/blog/site/" rel="alternate" type="text/html" /><updated>2019-04-18T21:39:07+09:00</updated><id>https://ifritjp.github.io/blog/site/feed.xml</id><title type="html">hoge blog</title><subtitle>Qiita に投稿する程でないネタを上げるネタサイト。 ポエムや、メモ、自分用の備忘録、Web から集めただけの情報などなど。</subtitle><entry><title type="html">『エンジニア就職志望者が情報工学科に行くのは間違い』は間違い</title><link href="https://ifritjp.github.io/blog/site/2019/04/18/engineer.html" rel="alternate" type="text/html" title="『エンジニア就職志望者が情報工学科に行くのは間違い』は間違い" /><published>2019-04-18T00:00:00+09:00</published><updated>2019-04-18T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/04/18/engineer</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/04/18/engineer.html">&lt;p&gt;たまたま見つけたブログの記事で気になったものがあったので、
  自分の意見を書いておきます。&lt;/p&gt;
&lt;h1&gt;気になったブログの記事&lt;/h1&gt;
&lt;p&gt;「エンジニア就職志望者が情報工学科に行くのは間違いです！学べることが違います！」&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.torikun.com/entry/engineer-jouhoukougaku&quot;&gt;https://www.torikun.com/entry/engineer-jouhoukougaku&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;この記事を要約すると、&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;大学の情報工学科のプログラミング単位取得だけでは
    学習時間が足りないのでプログラミングスキルを上げるのは難しい。&lt;/li&gt;
  &lt;li&gt;スキルを上げるにはプログラミングスクールがオススメ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;というモノです。&lt;/p&gt;
&lt;p&gt;まぁ確かに、
  大学の講義・実習だけで十分なプログラミングスキルを身に付けるのは不可能であるのは事実です。&lt;/p&gt;
&lt;p&gt;とはいえ、『エンジニア就職志望者が情報工学科に行くのは間違い』というのは、
  流石に異論があります。&lt;/p&gt;
&lt;p&gt;ブログの著者と自分とで異なる意見になる理由を考えると、&lt;/p&gt;
&lt;p&gt;&lt;b&gt;【「エンジニア」という言葉の定義が違うから】&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;だと思います。&lt;/p&gt;
&lt;h1&gt;「エンジニア」とは&lt;/h1&gt;
&lt;p&gt;上記の記事では、エンジニアには次の能力が必要だとしています。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;プログラミングスキル&lt;/li&gt;
  &lt;li&gt;コミュニケーション能力&lt;/li&gt;
  &lt;li&gt;マネジメント能力&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらは確かに重要です。&lt;/p&gt;
&lt;p&gt;というか、「コミュニケーション能力」や「マネジメント能力」は、
  エンジニアでなくても社会で働くには必要な能力です。&lt;/p&gt;
&lt;p&gt;つまりこの著者は、&lt;/p&gt;
&lt;p&gt;&lt;b&gt;【「エンジニア」に特化して必要な能力は「プログラミングスキル」だけ】&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;と主張しているように読めます。&lt;/p&gt;
&lt;p&gt;これは、私の考えと完全に異なります。&lt;/p&gt;
&lt;p&gt;まず、私が考える「エンジニア」像を説明します。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;エンジニアとは、曖昧なゴールイメージを技術によってスマートな形で実現できる能力を持つ人。&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;具体例を挙げると、例えば「家を建てる」というゴールイメージがあるとします。
  この場合、次のような様々なことを決定し、設計書を作成して建築する必要があります。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;建てる場所&lt;/li&gt;
  &lt;li&gt;予算&lt;/li&gt;
  &lt;li&gt;広さ&lt;/li&gt;
  &lt;li&gt;デザイン&lt;/li&gt;
  &lt;li&gt;機能性&lt;/li&gt;
  &lt;li&gt;耐久性&lt;/li&gt;
  &lt;li&gt;拡張性&lt;/li&gt;
  &lt;li&gt;メンテナンス性&lt;/li&gt;
  &lt;li&gt;建材&lt;/li&gt;
  &lt;li&gt;日程&lt;/li&gt;
  &lt;li&gt;etc&amp;#8230;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このように、
  曖昧なゴールイメージを実現するために具体的な作業項目に分解し、
  分解された作業の課題を洗い出し、
  課題を解決し、
  イメージを具現化する技術を持つのが、私が考える「エンジニア」です。&lt;/p&gt;
&lt;p&gt;もちろん、現実には一人のエンジニアが全てを担当できる訳ではありません。&lt;/p&gt;
&lt;p&gt;しかし、ブログの著者のような「エンジニア ＝ プログラミングスキルのある人 」では、
  絶対にありません。&lt;/p&gt;
&lt;p&gt;またブログの記事では、次の記載があります。&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
例えば、大学２年生の時にはフーリエ変換という数学の公式を習います。
この技術はパソコンの仕組みを突き詰めて行くと重要になってくる有名な数式です。
微分とか積分とかいろいろ難しい公式を覚えて問題を解いていきます。
エンジニアの方ならおわかりかと思いますが、
エンジニアとして仕事をする上でこのフーリエ変換を使う人はぜんぜんいません。
&lt;/pre&gt;
&lt;p&gt;確かに全てのエンジニアが微分・積分を使う訳ではないです。
  しかし、技術の背景を知っているエンジニアと、
  プログラミングしか出来ないプログラマーでは、担当できる範囲が全く違ってきます。&lt;/p&gt;
&lt;p&gt;たとえばディープラーニングなどの技術は、
  プログラミングしか出来ないプログラマーでは &lt;b&gt;絶対&lt;/b&gt; に作り出すことは出来ません。
  様々な知識を持つエンジニアが集結してこそ可能なものです。&lt;/p&gt;
&lt;h1&gt;認識が異なる理由&lt;/h1&gt;
&lt;p&gt;では、ブログの著者は何故「エンジニア ＝ プログラミングスキルのある人」という
  認識なのでしょうか？&lt;/p&gt;
&lt;p&gt;これはあくまで私の想像ですが、日本のソフトウェア開発業界の特色によるものだと思います。&lt;/p&gt;
&lt;p&gt;その特色とは、いわゆる「ゼネコン方式」です。&lt;/p&gt;
&lt;p&gt;大手が仕様を決め、実装を外部にアウトソーシングする。&lt;/p&gt;
&lt;p&gt;ブログ著者にとって「エンジニア」とはアウトソーシング先であり、
  「エンジニアは実装さえ出来れば良い」という思考なのではないでしょうか？&lt;/p&gt;
&lt;p&gt;このような思考があるから、
  日本のエンジニアの待遇は良くならないし、
  技術レベルも世界から離される一方なのではないでしょうか？&lt;/p&gt;
&lt;p&gt;なお、ブログ著者のプロフィールを見ると、 IBM Tokyo Lab に務めているとあります。
  いわゆる大手であるのは間違いないでしょう。&lt;/p&gt;
&lt;h1&gt;エンジニア就職志望者はどうあるべきか&lt;/h1&gt;
&lt;p&gt;私の考えは、「エンジニア就職志望者は様々な技術を学ぶべき」です。&lt;/p&gt;
&lt;p&gt;「他人が作った仕様通りのプログラムを組んでいれば幸せ」という人は、
  ブログ著者が主張するようにプログラミングスクールなりに行けば良いと思います。&lt;/p&gt;
&lt;p&gt;ただ、日本のゼネコン方式ソフトウェア開発を請け負う、
  いわゆる SIer の給与は発注元の企業よりもかなり低いのが一般的です。
  それこそ IBM の半分かそれ以下ではないでしょうか？
  そのことは認識しておく必要があります。&lt;/p&gt;
&lt;p&gt;なお、エンジニア志望者が行くべきなのは、情報工学科でなくても良いと思います。&lt;/p&gt;
&lt;p&gt;というのも、私の「エンジニア」の定義は広いので、
  情報工学科では収まりきらないためです。
  何を極めたいかによって、何を学ぶべきかは変ってくるでしょう。&lt;/p&gt;
&lt;p&gt;一つだけ必須技術を上げるならば、それは &lt;b&gt;「英語」&lt;/b&gt; です。&lt;/p&gt;
&lt;p&gt;今後の「エンジニア」業界で、
  日本が世界をリードすることは極一部を除いて無いでしょう。&lt;/p&gt;
&lt;p&gt;つまり、新しい技術は海外から導入することになります。
  その時、その技術の解説は英語であるのが一般的です。&lt;/p&gt;
&lt;p&gt;英語が出来れば、いち早く技術の導入が可能になります。&lt;/p&gt;
&lt;p&gt;英語が出来ない私が言うのもアレですが、今後の「エンジニア」には英語が必須です。
  今現在でも英語は必要ですが、今後はさらに必要度が上昇します。&lt;/p&gt;
&lt;p&gt;もしかしたら、英語よりも中国語の方が良いかもしれませんが、
  それはまだ何ともいえない状況です。&lt;/p&gt;</content><author><name></name></author><category term="LuneScript" /></entry><entry><title type="html">LuneScript から C 言語への変換</title><link href="https://ifritjp.github.io/blog/site/2019/04/10/convert_c.html" rel="alternate" type="text/html" title="LuneScript から C 言語への変換" /><published>2019-04-10T00:00:00+09:00</published><updated>2019-04-10T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/04/10/convert_c</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/04/10/convert_c.html">&lt;p&gt;LuneScript の開発当初から、C 言語への変換を目的の一つとしていた。&lt;/p&gt;
&lt;p&gt;当初は Rust 形式のライフタイム制御方式によるメモリ管理を予定していたが、
  現在は次の理由から GC による動的制御を採用している。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ライフタイム制御式は制御が複雑であり、対応工数がかなり掛ると予想&lt;/li&gt;
  &lt;li&gt;Lua への変換にはライフタイム制御は無関係&lt;/li&gt;
  &lt;li&gt;動くものを早い段階で作りたい&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;今からライフタイム制御方式に切り替えることも一つの手段だが、
  C 言語への変換制御の実現性の目処を早い段階で立てたいのもあるので、
  現状の GC による動的制御のまま、C 言語への変換制御の検討を行なう。&lt;/p&gt;
&lt;p&gt;また、LuneScript での TODO は残っているが、
  それらを対応しなくてもプログラム言語として完成度はかなり高くなっているので、
  一旦 C 言語への変換制御の対応優先度を上げて検討する。&lt;/p&gt;
&lt;h1&gt;構成&lt;/h1&gt;
&lt;p&gt;C 言語へ変換後のソースは、 Lua のライブラリをリンクする構成とする。&lt;/p&gt;
&lt;p&gt;これは、 LuneScript のマクロや meta 情報などが Lua VM 上で動作することを
  前提に開発しているため、その制御をそのまま C 言語変換後も利用したいため。&lt;/p&gt;
&lt;p&gt;また、Lua の標準ライブラリを利用しているソースを C 言語に変換した際に、
  C 言語で Lua の標準ライブラリ相当のものをスクラッチするよりも、
  Lua ライブラリを利用した方が工数を削減できるため。&lt;/p&gt;
&lt;p&gt;この辺りは、C 言語へ変換後ソースの実行パフォーマンスの問題や、
  対応工数に余裕があれば、Lua ライブラリなしで実行可能な構成を検討する。&lt;/p&gt;
&lt;h1&gt;値&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;int, real, str は、C 言語の int, double, char にマッピングする。
    &lt;ul&gt;
      &lt;li&gt;ただし、 int は long long などにカスタマイズできるようにする。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;それ以外の型は全値を格納可能な union 系の型 STEM で扱う。&lt;/li&gt;
  &lt;li&gt;Map や List 等の collection の要素は STEM で扱う。
    &lt;ul&gt;
      &lt;li&gt;こうしないと List&amp;lt;int&amp;gt; → List&amp;lt;stem&amp;gt; への変換が困難になるため。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;LuneScript では、クラスのインスタンスを stem に変換した後、
    Map&amp;lt;str,stem&amp;gt; のように扱えるが、これはサポートしない。
    そもそもこのような使い方は、 LuneScript でも未定義な動きである。&lt;/li&gt;
  &lt;li&gt;STEM 型のデータは動的に alloc し、参照カウント式の GC で管理する。&lt;/li&gt;
  &lt;li&gt;初期段階では List や Map 等のオブジェクトは C++ の STL を利用し、
    C から使用可能なようにラッピングする。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;参照カウンタ&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;参照カウンタのインクリメントタイミング
    &lt;ul&gt;
      &lt;li&gt;変数代入時&lt;/li&gt;
      &lt;li&gt;関数の先頭で、引数の参照カウンタをインクリメントする。
        &lt;ul&gt;
          &lt;li&gt;関数呼び出し側ではインクリメントしない。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;参照カウンタのデクリメントタイミング
    &lt;ul&gt;
      &lt;li&gt;ブロック終了時&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;ブロック開始、終了処理&lt;/h3&gt;
&lt;p&gt;error() 関数等で大域ジャンプすると、
  参照カウンタのデクリメントが通常の方法で対応出来ない。&lt;/p&gt;
&lt;p&gt;そこで、ブロック階層毎にインクリメント対象の stem 値を保持し、
  大域ジャンプ時にその情報を利用して参照カウンタをデクリメントする。&lt;/p&gt;
&lt;p&gt;大域ジャンプに対応するため、次を処理する&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ブロック開始時
    &lt;ul&gt;
      &lt;li&gt;そのブロック内で宣言している STEM 型変数を保持可能な領域を確保する
        &lt;ul&gt;
          &lt;li&gt;前述のインクリメントタイミングで、確保した領域にその変数をセットする&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;関数開始時は、引数も同様に処理する。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ブロック終了時
    &lt;ul&gt;
      &lt;li&gt;確保した領域に保持されている変数情報をデクリメントする&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="LuneScript" /></entry><entry><title type="html">Android で emacs/org-mode/qiita 投稿</title><link href="https://ifritjp.github.io/blog/site/2019/03/23/termux-org.html" rel="alternate" type="text/html" title="Android で emacs/org-mode/qiita 投稿" /><published>2019-03-23T00:00:00+09:00</published><updated>2019-03-23T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/03/23/termux-org</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/03/23/termux-org.html">&lt;p&gt;外出先の暇な時間を有効利用するため、ドキュメント書きをしたくなることがあります。&lt;/p&gt;
&lt;p&gt;そして私は emacs ユーザ。&lt;/p&gt;
&lt;p&gt;emacs ユーザが書きモノをするといえば、 emacs/org-mode です。&lt;/p&gt;
&lt;p&gt;ここでは、 Android で emacs/org-mode を使って qiita に投稿するまでの環境作りを紹介します。&lt;/p&gt;
&lt;p&gt;ノート PC を持っている人は、普通にノート PC を持っていけば良いと思います。&lt;/p&gt;
&lt;h1&gt;用意するもの&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;タブレット&lt;/li&gt;
  &lt;li&gt;Bluetooth キーボード&lt;/li&gt;
  &lt;li&gt;タブレット用スタンド&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;環境構築&lt;/h1&gt;
&lt;h2&gt;Android アプリ&lt;/h2&gt;
&lt;p&gt;まずは Android に次のアプリを入れます。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;termux&lt;/li&gt;
  &lt;li&gt;ハードウェアキーボード配列変更アプリ (英語 or 日本語)&lt;/li&gt;
  &lt;li&gt;Hacker&amp;#8217;s Keyboard&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;全て Root なしに Google Play で入れられます。&lt;/p&gt;
&lt;p&gt;配列変更アプリは US 配列と JIS 配列でアプリが分かれているので、
  好きな方を入れてください。
  入れた後に、 Android の設定でハードウェアキーレイアウトを
  「Ctrl、Caps 交換」に切り替えます。
  なお、 Caps/Ctrl の入れ替えが不要な場合は、配列変更アプリを入れなくて良いです。&lt;/p&gt;
&lt;p&gt;Hacker&amp;#8217;s Keyboard は必須ではないですが、
  他の IME では、ハードウェアキーボードと想定外の干渉をすることがあります。&lt;/p&gt;
&lt;h2&gt;termux 設定&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;ピンチイン、アウトでフォントサイズを変更&lt;/li&gt;
  &lt;li&gt;次のパッケージを termux にインストール
    &lt;ul&gt;
      &lt;li&gt;emacs&lt;/li&gt;
      &lt;li&gt;curl&lt;/li&gt;
      &lt;li&gt;git&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;emacs 設定&lt;/h2&gt;
&lt;h3&gt;~/.emacs/init.el 設定&lt;/h3&gt;
&lt;p&gt;次の内容の ~/.emacs/init.el を作成&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;lisp&quot;&gt;
(package-initialize)

(add-to-list &amp;#39;package-archives &amp;#39;(&amp;quot;melpa&amp;quot; . &amp;quot;https://melpa.org/packages/&amp;quot;))
&lt;/pre&gt;
&lt;h3&gt;パッケージインストール&lt;/h3&gt;
&lt;p&gt;M-x package-list-packages で、次のパッケージを emacs にインストール&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ox-qm&lt;/li&gt;
  &lt;li&gt;ddskk&lt;/li&gt;
  &lt;li&gt;helm&lt;/li&gt;
  &lt;li&gt;session&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;helm/session は必須じゃないけど、入れておいて損はない。&lt;/p&gt;
&lt;h3&gt;org-qiita.el インストール&lt;/h3&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ git clone https://github.com/ifritJP/org-qiita-el
&lt;/pre&gt;
&lt;p&gt;設定等の話は次を参考に。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://qiita.com/dwarfJP/items/594a8d4b0ac6d248d1e4&quot;&gt;https://qiita.com/dwarfJP/items/594a8d4b0ac6d248d1e4&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;パッケージ設定&lt;/h4&gt;
&lt;pre class=&quot;src&quot; lang=&quot;lisp&quot;&gt;
(show-paren-mode)

(add-to-list &amp;#39;load-path (expand-file-name &amp;quot;~/work/org-qiita-el&amp;quot;))
(require &amp;#39;ox-qmd)
(require &amp;#39;org-qiita)
(setq org-qiita-token &amp;quot;XXXXXXXXXXXXXXXXXXXXXXXXX&amp;quot;)  &amp;lt;---- qiita のトークン (org-qiita.el の説明参考)
(setq org-qiita-export-kill-close t)


(setq my-key-map (make-keymap))
(define-key global-map (kbd &amp;quot;C-z&amp;quot;) my-key-map)
(define-key my-key-map (kbd &amp;quot;SPC&amp;quot;) &amp;#39;set-mark-command)
(define-key my-key-map (kbd &amp;quot;i&amp;quot;) &amp;#39;helm-imenu)

(define-key global-map (kbd &amp;quot;C-x b&amp;quot;) &amp;#39;helm-mini)

(require &amp;#39;helm)
(require &amp;#39;session)
(require &amp;#39;recentf)
&lt;/pre&gt;
&lt;p&gt;&lt;b&gt;Android は Ctrl-SPC が、「キーボードレイアウト切替」になっています。&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;このため、 Ctrl-SPC がシステムに奪われて set-mark-command が動作しません。&lt;/p&gt;
&lt;p&gt;暫定対応として、 C-z SPC に set-mark-command を割り当てました。
  使い勝手はイマイチですが、意識してやればなんとか使えるレベルです。&lt;/p&gt;
&lt;h1&gt;最後に&lt;/h1&gt;
&lt;p&gt;簡単なドキュメント書きなら、これで十分です。&lt;/p&gt;
&lt;p&gt;ノート PC と比べても、遜色ないレベルです。&lt;/p&gt;
&lt;p&gt;とはいえ欠点もあります。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;タブレットでの Web 検索がやり難い
    &lt;ul&gt;
      &lt;li&gt;タブレットは org-mode 専用で、検索は別途スマホでやる方が良いと思います。&lt;/li&gt;
      &lt;li&gt;ただ、検索結果をコピペするような場合は、タブレットでやった方が良いです。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;C-SPC が使えない。
    &lt;ul&gt;
      &lt;li&gt;これは android の制約で、しかたがない？&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;次回は、外出先でのソフト開発に耐えられる環境について書きたいと思います。&lt;/p&gt;</content><author><name>ifritJP</name></author><category term="emacs org qiita" /></entry><entry><title type="html">この度 Lua 神を拝命しました</title><link href="https://ifritjp.github.io/blog/site/2019/03/16/lua.html" rel="alternate" type="text/html" title="この度 Lua 神を拝命しました" /><published>2019-03-16T00:00:00+09:00</published><updated>2019-03-16T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/03/16/lua</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/03/16/lua.html">&lt;p&gt;forkwell の github 分析結果が面白かったので貼っておく。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;forkwell.png&quot; alt=&quot;forkwell.png&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="mew outlook" /></entry><entry><title type="html">ノート PC がなくても外出先で本格開発する環境整備</title><link href="https://ifritjp.github.io/blog/site/2019/02/25/lite-pc.html" rel="alternate" type="text/html" title="ノート PC がなくても外出先で本格開発する環境整備" /><published>2019-02-25T00:00:00+09:00</published><updated>2019-02-25T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/02/25/lite-pc</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/02/25/lite-pc.html">&lt;p&gt;私の PC はデスクトップです。ノート PC は持っていません。&lt;/p&gt;
&lt;p&gt;ノート PC は持ち運びが出来て便利ではありますが、
  デスクトップを設置してある場所は、家の中で最も快適と言っても良い場所なので、
  別の場所で PC を触ろうという気になりません。&lt;/p&gt;
&lt;p&gt;また、だいたいの要件はタブレットで済むので、
  PC でやらないといけないようなものは環境の整ったいつもの場所でやるのがベストです。&lt;/p&gt;
&lt;p&gt;そんな訳で、私は「ノート PC 買わない派」です。&lt;/p&gt;
&lt;p&gt;とはいえ、外出先でも開発環境が欲しい時も極まれにあります。&lt;/p&gt;
&lt;p&gt;メモを取る程度であればタブレットでも十分ですが、
  まともな開発にはとても耐えられません。&lt;/p&gt;
&lt;p&gt;最近は termux で、それなりのことが出来るようになっていますが、それでも「それなり」です。&lt;/p&gt;
&lt;p&gt;termux では出来ないことの方が圧倒的に多いです。&lt;/p&gt;
&lt;p&gt;そこで、今回はノート PC がなくてもまともな開発環境を整える方法について紹介します。&lt;/p&gt;
&lt;p&gt;まぁ、ネタばれすると「Raspberrypi を使う」というだけの話なんですが。。。&lt;/p&gt;
&lt;h1&gt;構成&lt;/h1&gt;
&lt;p&gt;必要なものは以下です。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Raspberrypi&lt;/li&gt;
  &lt;li&gt;キーボード&lt;/li&gt;
  &lt;li&gt;タブレット&lt;/li&gt;
  &lt;li&gt;タブレット用スタンド&lt;/li&gt;
  &lt;li&gt;スマホ&lt;/li&gt;
  &lt;li&gt;モバイルバッテリー&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;普段持ち歩くもの以外に少し荷物は増えますが、
  増える重量は一般的なノート PC と同じか少ない程度です。&lt;/p&gt;
&lt;p&gt;Raspberrypi の 1台 や 2 台、誰でも持っているでしょう(違う？).
  無くても 6000 円程度で買えます。&lt;/p&gt;
&lt;p&gt;それぞれの役割は、次の通りです。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Raspberrypi
    &lt;ul&gt;
      &lt;li&gt;今回のメイン頭脳&lt;/li&gt;
      &lt;li&gt;開発環境はここで動かす&lt;/li&gt;
      &lt;li&gt;Raspberry pi 3 か Raspberry pi zero W がオススメだが、
        Raspberry pi zero はパワー不足なので Raspberry pi 3 が無難&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;キーボード
    &lt;ul&gt;
      &lt;li&gt;タブレットではなく Raspberrypi と接続します&lt;/li&gt;
      &lt;li&gt;いつもの使い易いキーボードか、持ち運びしやすいもの&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;タブレット
    &lt;ul&gt;
      &lt;li&gt;Raspberrypi のディスプレイとして使うので、持ち運び可能な範囲で出来るだけ大きいもの&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;スマホ
    &lt;ul&gt;
      &lt;li&gt;インターネットに繋がる Wifi ルータとして利用&lt;/li&gt;
      &lt;li&gt;タブレットを Wifi ルータとして利用可能な場合や、出先に利用可能な AP があれば不要&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;モバイルバッテリー
    &lt;ul&gt;
      &lt;li&gt;Raspberrypi 駆動用&lt;/li&gt;
      &lt;li&gt;AC 電源が確保できるなら USB 充電機でも可&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ちなみに、モバイルディスプレイを買って、
  それと Raspberrypi をつなげば OK ですが、
  それだと面白くないのとモバイルディスプレイなんて&lt;/p&gt;
&lt;h2&gt;利点と欠点&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;利点
    &lt;ul&gt;
      &lt;li&gt;それぞれのパーツに自分の好きなものを利用できる。
        &lt;ul&gt;
          &lt;li&gt;携帯性をとことん追求したり、できるだけ普段の環境に寄せてみたりできます。&lt;/li&gt;
          &lt;li&gt;個人的にはキーボードを自分の好きなものを利用できるのが大きいです。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;使用する際に、表に出すのはキーボード、タブレット、スタンドだけで良い。
        &lt;ul&gt;
          &lt;li&gt;Raspberrypi などは鞄の中にしまったままで使用可能。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;欠点
    &lt;ul&gt;
      &lt;li&gt;ノート PC のように電源入れれば使える、とはならない。&lt;/li&gt;
      &lt;li&gt;WiFi 接続前提なので、電波状況の非常に悪い場所だと使えない。&lt;/li&gt;
      &lt;li&gt;Raspberrypi に構築できない開発環境では使えない。
        &lt;ul&gt;
          &lt;li&gt;windows 系の方は Raspberrypi の代わりに 超小型 PC を使うとか。。。&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;設定&lt;/h1&gt;
&lt;h2&gt;Raspberrypi&lt;/h2&gt;
&lt;p&gt;Raspberrypi に開発環境を構築します。&lt;/p&gt;
&lt;p&gt;Raspberrypi に構築できない&lt;/p&gt;
&lt;p&gt;自分好みの開発環境(IDE や Editor等)をセットアップしておく。&lt;/p&gt;
&lt;p&gt;Raspberrypi で構築できる&lt;/p&gt;</content><author><name></name></author><category term="mew outlook" /></entry><entry><title type="html">Outlook+Exchange 環境で Mew を使う</title><link href="https://ifritjp.github.io/blog/site/2019/02/08/exchange.html" rel="alternate" type="text/html" title="Outlook+Exchange 環境で Mew を使う" /><published>2019-02-08T00:00:00+09:00</published><updated>2019-02-08T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/02/08/exchange</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/02/08/exchange.html">&lt;p&gt;これは、不運にも会社のメール環境が Outlook+Exchange になってしまった Mew ユーザが、
  Outlook に移行せずに Mew を使い続けられるようにすることを目的とした記事です。&lt;/p&gt;
&lt;p&gt;元ネタは次の記事です。&lt;/p&gt;
&lt;p&gt;http://masaoo.blogspot.com/2015/07/outlook-exchange-mew.html&lt;/p&gt;
&lt;p&gt;ちょっとあっさりし過ぎなので、少し補足します。&lt;/p&gt;
&lt;p&gt;なお、使用する OS は Ubuntu とします。&lt;/p&gt;
&lt;p&gt;Outlook+Exchange なのに Ubuntu とは「コレ如何に」って感じですが、
  単純に個人的な好みの問題です。
  Windows でも可能です。&lt;/p&gt;
&lt;h1&gt;DavMail&lt;/h1&gt;
&lt;p&gt;Exchange サーバと Mew との仲介をやってくれるのが DavMail です。&lt;/p&gt;
&lt;p&gt;Ubuntu 18.04 だと apt で簡単に入ります。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ apt install davmail
&lt;/pre&gt;
&lt;h2&gt;設定&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;davmail を実行します。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ davmail   
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;ウィンドウが開くので、 DavmMail Gateway メニューから Setting を選択します。&lt;/li&gt;
  &lt;li&gt;Main タブの OWA URL に Exchange の OWA URL を設定します。
    &lt;ul&gt;
      &lt;li&gt;Outlook のアカウント情報にある「アカウントの設定」に表示されている URL です。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Main タブの POP port, IMAP port, SMTP port をメモっておきます。&lt;/li&gt;
  &lt;li&gt;davmail をセットアップしている PC 以外から利用する場合は、
    Network タブの Allow Remote Connections をチェックします。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Mew の設定&lt;/h1&gt;
&lt;p&gt;いつも通りの Mew の設定をします。&lt;/p&gt;
&lt;p&gt;注意が必要なのは、次くらいでしょう。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;smtp-user, pop-user に Exchange のアカウントを指定する&lt;/li&gt;
  &lt;li&gt;先ほどメモった port を指定する&lt;/li&gt;
&lt;/ul&gt;</content><author><name></name></author><category term="mew outlook" /></entry><entry><title type="html">Outlook で送信された日本語メールを Mew で受信すると文字化けする問題の対応</title><link href="https://ifritjp.github.io/blog/site/2019/02/07/outlook.html" rel="alternate" type="text/html" title="Outlook で送信された日本語メールを Mew で受信すると文字化けする問題の対応" /><published>2019-02-07T00:00:00+09:00</published><updated>2019-02-07T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/02/07/outlook</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/02/07/outlook.html">&lt;p&gt;Outlook は当初から評判が良くないため個人的には使用していません。
  もうず〜〜〜〜〜と、 PC のメール環境は Mew を使用しています。&lt;/p&gt;
&lt;p&gt;しかし、自分のメール送信・受信環境は好きなものを選べますが、
  相手のメール送信・受信環境は選べません。&lt;/p&gt;
&lt;p&gt;そしてつい先日も、 Outlook から送信されたメールで文字化けメールを受信しました。&lt;/p&gt;
&lt;p&gt;どうして化けたのか気になったので、調べてみました。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;メールの MIME に示されているコードは &amp;#8221;&lt;b&gt;gb2312&lt;/b&gt;&amp;#8221; となっている&lt;/li&gt;
  &lt;li&gt;同じメールを Outlook で受信している人に聞いてみると、文字化けしていないと言う&lt;/li&gt;
  &lt;li&gt;emacs のコード変換で化けたのか？と思い、
    メールを保存してブラウザの表示言語を簡体字中国語設定で表示してみると文字化けしなかった。
    &lt;ul&gt;
      &lt;li&gt;この時のブラウザのテキストエンコーディングを見てみると &amp;#8221;&lt;b&gt;GBK&lt;/b&gt;&amp;#8221; だった&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;emacs で利用可能な文字コードを見てみると &amp;#8221;&lt;b&gt;gb2312&lt;/b&gt;&amp;#8221; と &amp;#8221;&lt;b&gt;GBK&lt;/b&gt;&amp;#8221; は別ものとして存在している。&lt;/li&gt;
  &lt;li&gt;試しに文字化けしたメールを、 emacs の &amp;#8221;&lt;b&gt;GBK&lt;/b&gt;&amp;#8221; を指定して開くと文字化けしなかった&lt;/li&gt;
  &lt;li&gt;Wikipedia を見ると &amp;#8221;&lt;b&gt;GBK&lt;/b&gt;&amp;#8221; は &amp;#8221;&lt;b&gt;gb2312&lt;/b&gt;&amp;#8221; を拡張したものということが分った
    &lt;ul&gt;
      &lt;li&gt;また、 Microsoft が GBK を Windows コードページ 936 として定義した、との記載がある。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;MS も Outlook で送信すると文字コード判定が間違えることを認識している
    &lt;ul&gt;
      &lt;li&gt;次の URL に記載されている「方法3」が、まさにそれの対処方法&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://support.microsoft.com/ja-jp/help/881816&quot;&gt;https://support.microsoft.com/ja-jp/help/881816&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上のことから、次の事が考えられます。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Outlook で所定の文字を含むメールを送信する際、
    Outlook の自動文字コード判定によって WCP936 として認識される。&lt;/li&gt;
  &lt;li&gt;WCP936 は本来 GBK であるが、メールの MIME には charset=&amp;#8221;gb2312&amp;#8221; として宣言される&lt;/li&gt;
  &lt;li&gt;メールを受信した Mew は、 MIME の情報を見て gb2312 として処理するが、
    実際のメールは gb2312 ではなく GBK でエンコーディングされているため、文字化けする。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Mew での対応&lt;/h1&gt;
&lt;p&gt;Outlook のダメさ加減を嘆いてもしようがないので、
  ここでは Mew で受信した時に化けずに表示できる対応をします。&lt;/p&gt;
&lt;p&gt;対応コードは以下です。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;el&quot;&gt;
(defun my-mew-change-gb2312-for-outlook ()
  &amp;quot;outlook 対応。 Outlook の gb2312 は gbk になっている。。。&amp;quot;
  (setq mew-cs-database-for-decoding
	(mapcar (lambda (X)
		  (if (equal (car X) &amp;quot;gb2312&amp;quot;)
		      (list (car X) &amp;#39;gbk)
		    X))
		mew-cs-database-for-decoding)))

(eval-after-load &amp;quot;mew&amp;quot;
  &amp;#39;(my-mew-change-gb2312-for-outlook))
&lt;/pre&gt;
&lt;p&gt;以下で上記処理の説明をします。&lt;/p&gt;
&lt;p&gt;Mew は MIME の charset と、
  emacs の coding-system の紐付けを &lt;b&gt;mew-cs-database-for-decoding&lt;/b&gt; で管理しています。&lt;/p&gt;
&lt;p&gt;こんな感じ。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
(defvar mew-cs-database-for-decoding
  `((&amp;quot;us-ascii&amp;quot;          nil)
    (&amp;quot;iso-8859-1&amp;quot;        iso-8859-1)
    (&amp;quot;iso-8859-2&amp;quot;        iso-8859-2)
    (&amp;quot;iso-8859-3&amp;quot;        iso-8859-3)
    (&amp;quot;iso-8859-4&amp;quot;        iso-8859-4)
    (&amp;quot;iso-8859-5&amp;quot;        iso-8859-5)
    (&amp;quot;iso-8859-6&amp;quot;        iso-8859-6)
    (&amp;quot;iso-8859-7&amp;quot;        iso-8859-7)
    (&amp;quot;iso-8859-8&amp;quot;        iso-8859-8)
    (&amp;quot;iso-8859-8-i&amp;quot;      iso-8859-8) ;; temporary solution
    (&amp;quot;iso-8859-9&amp;quot;        iso-8859-9)
    (&amp;quot;iso-8859-15&amp;quot;       iso-8859-15)
    (&amp;quot;iso-2022-cn&amp;quot;       iso-2022-cn)
    (&amp;quot;iso-2022-cn-ext&amp;quot;   iso-2022-cn-ext)
    (&amp;quot;gbk&amp;quot;               gbk)
    (&amp;quot;gb2312&amp;quot;            cn-gb-2312) ;; should be before cn-gb
    (&amp;quot;cn-gb&amp;quot;             cn-gb-2312)
&lt;/pre&gt;
&lt;p&gt;この設定では、 MIME の gb2312 を cn-gb-2312 に紐付けしているので、
  gb2312 を gbk の紐付けに変更しているのが先ほどのコードとなります。&lt;/p&gt;
&lt;p&gt;中国語圏とメールのやり取りしたときに何か問題がおこるかもですが、
  自分にはそんな予定はないのでとりあえずこれで十分かな、と。&lt;/p&gt;</content><author><name></name></author><category term="mew outlook" /></entry><entry><title type="html">電ファミニコゲーマー</title><link href="https://ifritjp.github.io/blog/site/2019/02/03/interview.html" rel="alternate" type="text/html" title="電ファミニコゲーマー" /><published>2019-02-03T00:00:00+09:00</published><updated>2019-02-03T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/02/03/interview</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/02/03/interview.html">&lt;p&gt;ここ十年ほどまともにゲームしてないけど、
  ネット検索しているときになんとなく気になった記事を読んでみたら、
  ものスゴく面白かった。&lt;/p&gt;
&lt;p&gt;古めの記事だけど、載っけておく。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;格ゲー“暗黒の10年”は、『鉄拳』を世界一売れる格闘ゲームへと鍛え上げた──世界市場に活路を拓いた戦略を訊く【バンダイナムコ原田勝弘インタビュー／西田宗千佳連載】&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://news.denfaminicogamer.jp/interview/180428&quot;&gt;http://news.denfaminicogamer.jp/interview/180428&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;「久夛良木が面白かったからやってただけ」 プレイステーションの立役者に訊くその誕生秘話【丸山茂雄×川上量生】&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;http://news.denfaminicogamer.jp/interview/ps_history&quot;&gt;http://news.denfaminicogamer.jp/interview/ps_history&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="言語処理系" /></entry><entry><title type="html">デフォルト引数の問題の対応</title><link href="https://ifritjp.github.io/blog/site/2019/01/27/default-arg.html" rel="alternate" type="text/html" title="デフォルト引数の問題の対応" /><published>2019-01-27T00:00:00+09:00</published><updated>2019-01-27T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/01/27/default-arg</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/01/27/default-arg.html">&lt;p&gt;先日のデフォルト引数の指定し忘れ問題の対応を行なった。&lt;/p&gt;
&lt;p&gt;詳しくは、次の記事を参照。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://qiita.com/dwarfJP/items/922c523d27a6d77fff6d&quot;&gt;https://qiita.com/dwarfJP/items/922c523d27a6d77fff6d&lt;/a&gt;&lt;/p&gt;</content><author><name></name></author><category term="言語処理系" /></entry><entry><title type="html">デフォルト引数の問題</title><link href="https://ifritjp.github.io/blog/site/2019/01/23/default-arg.html" rel="alternate" type="text/html" title="デフォルト引数の問題" /><published>2019-01-23T00:00:00+09:00</published><updated>2019-01-23T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/01/23/default-arg</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/01/23/default-arg.html">&lt;p&gt;関数をコールする際、引数を省略してコールできる機能をもつ言語が多く存在する。&lt;/p&gt;
&lt;p&gt;ここでは、その機能を「デフォルト引数」と呼ぶ。&lt;/p&gt;
&lt;p&gt;デフォルト引数の例として、Lua のサンプルを次に示す。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;lua&quot;&gt;
local function func( x, y )
  print( x, y )
end
func( &amp;quot;abc&amp;quot; ) // abc nil
&lt;/pre&gt;
&lt;p&gt;Lua では関数コール時に省略された引数は、 nil として処理される。
  上記の &lt;code&gt;func( &amp;quot;abc&amp;quot; )&lt;/code&gt; は、引数 x, y のうち y が省略され、
  実行すると abc nil が表示される。&lt;/p&gt;
&lt;p&gt;デフォルト引数は、引数が多い関数を呼び出す際に有効な機能である。
  特に Lua は、引数の違いによって実行する関数を切り替える関数オーバーロードがないため、
  デフォルト引数は良く使われる機能の一つである。&lt;/p&gt;
&lt;p&gt;しかし、デフォルト引数は便利である一方、不具合を発生させるリスクにもなる。&lt;/p&gt;
&lt;p&gt;そのリスクとは、意図してデフォルト引数を使用しているのか、
  それとも、本来指定すべき引数を指定し忘れているのか、を判断出来ないということである。
  タイプミス等で関数に渡す引数を間違えることが良くある。
  それを判断できないというのはリスクが高い。&lt;/p&gt;
&lt;p&gt;Lua の トランスコンパイラである LuneScript でも、同じ問題を抱えている。&lt;/p&gt;
&lt;p&gt;次は LuneScript のデフォルト引数のサンプルである。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;lua&quot;&gt;
fn func( val: int! ): int {
   when! val {
      return val + 1;
   }
   return 0;
}
print( func( 1 ) );   // 2
print( func( nil ) ); // 0
print( func() );      // 0
&lt;/pre&gt;
&lt;p&gt;このサンプルは、デフォルト引数を持つ func() の関数呼び出しを 3 パターン行なっている。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;func( 1 )&lt;/li&gt;
  &lt;li&gt;func( nil )&lt;/li&gt;
  &lt;li&gt;func()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;LuneScript は Lua と同じで、引数が省略されると nil が指定される。
  よって、 &lt;code&gt;func( nil )&lt;/code&gt; と &lt;code&gt;func()&lt;/code&gt; は同義である。
  しかし、 &lt;code&gt;func()&lt;/code&gt; が引数の指定忘れではないと、誰が保証できるだろうか？&lt;/p&gt;
&lt;p&gt;また、 LuneScript では nilable は必ず省略可能なデフォルト引数になってしまう。&lt;/p&gt;
&lt;p&gt;デフォルト引数をサポートする多くの言語では、
  デフォルト引数はデフォルト値を定義する必要がある。
  一方 LuneScript では、nilable は必ずデフォルト引数になってしまう。&lt;/p&gt;
&lt;p&gt;「nil の時でも省略せずに明示すべき」としたくても、
  現在の言語仕様ではそれが出来ない。&lt;/p&gt;
&lt;p&gt;この辺りを解決する方法を検討している。&lt;/p&gt;
&lt;p&gt;ただこれを解決するには、現状の言語仕様との互換を持たせるのは難しいかもしれない。&lt;/p&gt;</content><author><name></name></author><category term="言語処理系" /></entry></feed>