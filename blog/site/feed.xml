<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.5">Jekyll</generator><link href="https://ifritjp.github.io/blog/site/feed.xml" rel="self" type="application/atom+xml" /><link href="https://ifritjp.github.io/blog/site/" rel="alternate" type="text/html" /><updated>2019-08-02T19:58:37+09:00</updated><id>https://ifritjp.github.io/blog/site/feed.xml</id><title type="html">hoge blog</title><subtitle>Qiita に投稿する程でないネタを上げるネタサイト。 ポエムや、メモ、自分用の備忘録、Web から集めただけの情報などなど。</subtitle><entry><title type="html">如何なる開発手法、プログラム言語を用いても、日本の全てのソフトウェアプロジェクトは必ず技術的負債になる</title><link href="https://ifritjp.github.io/blog/site/2019/08/02/engineering.html" rel="alternate" type="text/html" title="如何なる開発手法、プログラム言語を用いても、日本の全てのソフトウェアプロジェクトは必ず技術的負債になる" /><published>2019-08-02T00:00:00+09:00</published><updated>2019-08-02T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/08/02/engineering</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/08/02/engineering.html">&lt;p&gt;「日本の全てのソフトウェアプロジェクトは必ず技術的負債になる」というタイトルですが、
  次の条件を満す場合に限ります。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;「プロジェクトに関わるソフトウェアエンジニアの大半が技術に無関心」&lt;/b&gt;&lt;/p&gt;
&lt;h1&gt;動機&lt;/h1&gt;
&lt;p&gt;このネタは、次の記事を読んで個人的に思うことがあったのをきっかけに
  書いています。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;オブジェクト指向プログラミング &amp;#8211; 1兆ドル規模の大失敗
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://okuranagaimo.blogspot.com/2019/07/1.html&quot;&gt;https://okuranagaimo.blogspot.com/2019/07/1.html&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;大企業の技術系インターンシップに参加した
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://blog.browniealice.net/post/internship2019winter/&quot;&gt;https://blog.browniealice.net/post/internship2019winter/&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;ソフト開発で世界と闘った及川卓也氏が見た、日本の弱点と可能性
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://headlines.yahoo.co.jp/article?a=20190801-00010000-chuokou-bus_all&quot;&gt;https://headlines.yahoo.co.jp/article?a=20190801-00010000-chuokou-bus_all&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上記の記事は各自に読んでもらうとして、
  それぞれの記事の内容をものすごく大雑把にまとめると&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;「OOP はダメだから、関数型プログラミングを使え」&lt;/li&gt;
  &lt;li&gt;「日本を代表する大企業に実情に失望した」&lt;/li&gt;
  &lt;li&gt;「日本の企業はソフトウェア開発を理解していない」&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;になると思います。&lt;/p&gt;
&lt;h1&gt;プログラミング言語は道具にすぎない&lt;/h1&gt;
&lt;p&gt;上記ブログで「OOP はダメだから、関数型プログラミングを使え」と書かれています。
  私は、OOP が万能だなんて思ってませんし、
  上記ブログで指摘されている側面があることも理解しています。&lt;/p&gt;
&lt;p&gt;ですが、オブジェクト指向プログラミングにしろ関数型プログラミングにしろ、
  万能ではないという意味ではどちらも同じです。&lt;/p&gt;
&lt;p&gt;プログラム言語は道具です。
  いかなる道具であっても、
  その道具を安全に運用できるかどうかは、最終的には使う人に依存することになります。&lt;/p&gt;
&lt;p&gt;例えば、古典的なプログラミング言語の代表格に C 言語がありますが、
  ご存知の通り C 言語には GC もないですし、 NULL 安全でもありません。
  そのような高度な「安全」機能を持たない C 言語は、Linux Kernel の開発言語です。
  C 言語によって Linux Kernel を開発しているという事実は、
  高度な「安全」機能が搭載されていないプログラミング言語であっても、
  使用する人次第で大規模プロジェクトでも問題なく運用できるという一つの実証と言えます。&lt;/p&gt;
&lt;p&gt;逆に、C 言語よりも高度な「安全」機能を搭載しているプログラミング言語を使用した
  プロジェクトが技術的負債の塊になり運用困難になった、
  という例はいくらでも身近にあると思います。
  もし身近に無いとしても、ネットで検索すれば多数ヒットします。&lt;/p&gt;
&lt;p&gt;だからと言って、 C 言語の様に使用する人への依存が高過ぎる言語と、
  Rust のように先進的な安全機能搭載言語のどちらを使っても大差はない、
  というつもりはありません。
  私が言いたいのは、「より安全」と言われる技術を使っても、
  それを使用する人への依存性が無くなることはない、ということです。&lt;/p&gt;
&lt;p&gt;自動運転に例えると、
  プログラム言語自体が提供する「安全」は高々レベル 3 のサポートにすぎません。&lt;/p&gt;
&lt;p&gt;レベル 3 の自動運転には、ドライバーの運転技術が必須であるように、
  現存するどのようなプログラム言語であっても、
  ソフトウェアエンジニアの能力が欠かせません。&lt;/p&gt;
&lt;h1&gt;「ソフトウェアエンジニアの大半が技術に無関心」であることの問題&lt;/h1&gt;
&lt;p&gt;なぜ「プロジェクトに関わるソフトウェアエンジニアの大半が技術に無関心」だとダメなのか？&lt;/p&gt;
&lt;p&gt;これは単純に、そのようなプロジェクトではどのように「安全」な環境であっても、
  その「安全」がレベル 5 の自動運転のように「完全」でない限り、
  「不具合をエンジニア自ら作り込んでしまう」からです。&lt;/p&gt;
&lt;p&gt;前述している通り、プログラミング言語はあくまでも道具であって、
  その道具を安全に運用できるかどうかは、最終的には使う人に依存することになります。
  そしてプログラミング言語を使う人はソフトウェアエンジニアであり、
  ソフトウェアエンジニアの能力は、多くの場合、技術への関心度に比例します。&lt;/p&gt;
&lt;p&gt;特に統計を取った訳ではなく、裏付け資料がある訳でもないですが、
  個人的な経験上、技術への関心度が高いソフトウェアエンジニアほど能力が高く、
  技術への関心度が低いソフトウェアエンジニアほど能力が低い傾向にあります。&lt;/p&gt;
&lt;p&gt;つまり、
  「プロジェクトに関わるソフトウェアエンジニアの大半が技術に無関心」であるということは、
  ソフトウェアエンジニアの大半の能力が低いということと、ほぼ同義になります。&lt;/p&gt;
&lt;p&gt;「技術への関心度が低いソフトウェアエンジニアほど能力が低い傾向にある」という持論の
  根拠となるエピソードを一つ挙げておきます。&lt;/p&gt;
&lt;p&gt;あるソフトウェアエンジニアＡがモジュールの設計をしていました。&lt;/p&gt;
&lt;p&gt;そのモジュールは、他モジュールとの依存が高いことが問題になっていたので、
  「DI(Dependency injection)の手法を取り入れたら
  もっとスッキリした設計になる可能性があるので検討してみてはどうですか？」
  と、そのソフトウェアエンジニアＡに話をすると、
  「そういう難しいことは逆に不具合につながるのでやりたくない」と
  言われて一蹴されました。
  DI を検討した結果、従来通りの方法を採用する方が良いという結論になったのであれば
  納得できますが、なんとなく難しそうというイメージだけで拒否していました。
  そして、そのモジュールは依存が高いまま実装されました。&lt;/p&gt;
&lt;p&gt;DI のことを理解していれば、それが難しいと考える人はほとんどいないでしょうし、
  テストがしやすいことから、むしろ不具合も低減できる可能性があり、
  DI を取り入れることで不具合に繋がることを心配する人はいないでしょう。&lt;/p&gt;
&lt;p&gt;このように、技術への関心度が低いと、
  自分が知らない技術を積極的に取り入れるようなことをせず、
  自分が使える技術だけで解決しようとします。
  これによって、よりスマートに実現できる方法が他にあるにもかかわらず、
  潜在的な問題を含む古い方法によってモジュールが作られていき、
  それが積み重なってプロジェクト全体の品質が下っていきます。
  そしてそれは時間が経過するほど、手をつけられない技術的負債になります。&lt;/p&gt;
&lt;p&gt;一言で表現すれば、技術への関心度が低いエンジニアは「技術的負債製造機」です。&lt;/p&gt;
&lt;p&gt;例え TEST FIRST の開発プロセスであっても、それは防げないでしょう。
  ならぜなら、
  テストというのは作成した成果物が仕様通りに出来ていることを確認するものであって、
  仕様そのものに不具合があった場合は、その不具合を検知することは出来ないからです。
  仕様を作るのはソフトウェアエンジニアです。
  能力の低いソフトウェアエンジニアほど、穴の多い仕様を作る傾向にあります。&lt;/p&gt;
&lt;p&gt;能力の低いソフトウェアエンジニアには仕様を作らせず、
  能力の高いソフトウェアエンジニアだけで仕様を作れば良い、という考えもあると思います。&lt;/p&gt;
&lt;p&gt;確かに、能力の高い人の比率が高い場合はそういう運用が可能かもしれません。
  しかし、ここでは大半が能力が低いことを前提にしているので、
  そのような運用は難しいです。&lt;/p&gt;
&lt;p&gt;また、例え仕様に問題がなくても、
  実際にコード化した時に不具合が埋め込まれることは良くあります。
  そして、テストで検出されることもなくリリースされ、市場で時限爆弾のように爆発する、
  お決まりのパターンです。もはや伝統芸能の域です。&lt;/p&gt;
&lt;h1&gt;なぜ日本で問題なのか？&lt;/h1&gt;
&lt;p&gt;ここまでの話を納得していただけたとして、次の疑問が浮ぶかもしれません。&lt;/p&gt;
&lt;p&gt;「プロジェクトに関わるソフトウェアエンジニアの大半が技術に無関心」が
  技術的負債を生み出す原因ならば、日本でなくても同じことが言えるのではないか？&lt;/p&gt;
&lt;p&gt;それは確かにそうです。
  しかし、日本の場合、終身雇用 &amp;amp; 転職しずらい社会環境によって、
  一度雇ったソフトウェアエンジニアが技術に無関心だったとしても、
  そのソフトウェアエンジニアを他の優秀なソフトウェアエンジニアに入れ替える、
  ということが非常に困難なため、このような状況になり易いです。&lt;/p&gt;
&lt;p&gt;さらに、日本ではソフトウェア開発をゼネコン方式で開発するという文化があり、
  一つのプロジェクトを社内の優秀なソフトウェアエンジニアだけで開発する、
  というのは非常に稀なケースであり、
  一部(あるいは全部)のモジュールをアウトソーシングするケースが多くあります。&lt;/p&gt;
&lt;p&gt;これによって、プロジェクトの品質コントロールをより困難にしています。&lt;/p&gt;
&lt;p&gt;また、日本では全ての社員の待遇に差を付けず、
  等しくすることを善しとする文化があるようで、
  ソフトウェアエンジニアの能力に応じた待遇にする、というようなことを滅多にしません。
  一方で、マネジメント能力に関しては、
  能力に応じた待遇にするキャリアパスが古くから存在するため、
  自分ではコードを一切書かないで一日中パワーポイントやエクセルの資料をせっせと作成している
  ソフトウェアエンジニア(？)が多く存在します。
  そして、マネジメント能力以外のソフトウェアエンジニアの能力が評価対象ではないため、
  自然と「プロジェクトに関わるソフトウェアエンジニアの大半が技術に無関心」と
  いう状況になる傾向にあります。
  いわゆる Japanese Traditional Big Company では、
  特にこの傾向が顕著なのではないでしょうか？&lt;/p&gt;
&lt;p&gt;最初に紹介したブログの著者が「日本を代表する大企業に実情に失望した」原因は、
  このような背景があるためだと思います。&lt;/p&gt;
&lt;p&gt;また、このような背景を作り出しているのは、
  Yahoo の記事にある「日本の企業はソフトウェア開発を理解していない」ためだと思います。&lt;/p&gt;
&lt;p&gt;以上のように、日本のソフトウェア開発プロジェクトには
  技術的負債を生み出す環境が整っているため、
  いかなる開発手法、プログラム言語を用いても技術的負債化を防ぐことは出来ません。&lt;/p&gt;
&lt;p&gt;それなのに、この状況を改善する為と称して、新しいプロジェクト進捗管理手法を導入する、
  という斜め上な施策が実施されることがあります。&lt;/p&gt;
&lt;p&gt;どういう論理で考えると、「新しいプロジェクト進捗管理手法を導入すること」と、
  「プロジェクトの技術的負債化を防ぐこと」が繋がるのでしょうかね？&lt;/p&gt;
&lt;h1&gt;最後に&lt;/h1&gt;
&lt;p&gt;私は LuneScript という言語を開発しています。
  「プログラム言語は単なる道具でしかない」というのは、
  ある意味自己否定しているようにも思われるかもしれません。&lt;/p&gt;
&lt;p&gt;ですが、プログラム言語自体で提供できる安全機能は
  まだまだ残っていると思っているので、
  ソフトウェアエンジニアの助けになるような安全機能を提供できるように
  今後も開発を続けていきたいと考えています。&lt;/p&gt;
&lt;p&gt;以上。&lt;/p&gt;</content><author><name>ifritJP</name></author><category term="engineering" /></entry><entry><title type="html">emacs26.2 で矢印(→)等の一部のフォントが半角表示されるようになった</title><link href="https://ifritjp.github.io/blog/site/2019/07/19/font.html" rel="alternate" type="text/html" title="emacs26.2 で矢印(→)等の一部のフォントが半角表示されるようになった" /><published>2019-07-19T00:00:00+09:00</published><updated>2019-07-19T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/07/19/font</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/07/19/font.html">&lt;p&gt;emacs のバージョンを 26.2 に変えたことで、
  色々と細かいところの使い勝手が変っている。&lt;/p&gt;
&lt;p&gt;その中で、 &lt;code&gt;→&lt;/code&gt; 等の一部のフォントが半角表示されるようになったのが
  微妙にストレスだったのでちょっと追ってみた。&lt;/p&gt;
&lt;h1&gt;原因&lt;/h1&gt;
&lt;p&gt;原因、と言うよりは起因と言った方が良いかもしれないが、
  &lt;code&gt;→&lt;/code&gt; 等の一部のフォントが半角表示されるようになったのは、
  フォントに &amp;#8220;DejaVu Sans Mono&amp;#8221; を使用していることに起因していた。&lt;/p&gt;
&lt;p&gt;これを &amp;#8220;Bitstream Vera Sans Mono&amp;#8221; に変更することで、現象が治った。&lt;/p&gt;
&lt;p&gt;全く同じ環境で、 emacs 26.2 ではなく、以前使用していたバージョンの emacs だと
  現象は発生しなかった。&lt;/p&gt;
&lt;p&gt;emacs の処理が変ったことが原因であるのはほぼ間違い無いが、
  emacs の何がどう変ってこの現象が発生し、
  どう設定(使用するフォントを変える以外で)すれば、
  現象を修正できたのかは残念ながら分からないまま。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;と、思ったが、次のブログに答えがあった。&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://misohena.jp/blog/2017-09-26-symbol-font-settings-for-emacs25.html&quot;&gt;http://misohena.jp/blog/2017-09-26-symbol-font-settings-for-emacs25.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;詳しくは、上記ブログを確認してもらうとして、
  要点だけ説明すると use-default-font-for-symbols に nil 以外が設定されていると、
  シンボル等の文字のフォントが default フォントを使用するようになるらしい。
  このデフォルト値が t であるため、矢印等の一部のフォントが半角になっていた。&lt;/p&gt;
&lt;p&gt;ということで、
  以下を設定してやれば、使用するフォントを変えなくても全角で表示されるようになる。&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
(setq use-default-font-for-symbols nil)
&lt;/pre&gt;
&lt;p&gt;じゃぁ、どうして &amp;#8220;Bitstream Vera Sans Mono&amp;#8221; に変えると
  全角で表示されたのか？が気になったんで調べてみたが、
  どうやら &amp;#8220;Bitstream Vera Sans Mono&amp;#8221; には矢印などのフォントが
  含まれていなことが原因のようだ。&lt;/p&gt;
&lt;p&gt;fontforge でフォントの中身を見ると、
  &amp;#8220;Bitstream Vera Sans Mono&amp;#8221; には矢印のフォントがなく、
  &amp;#8220;DejaVu Sans Mono&amp;#8221; には矢印のフォントがあることが判った。&lt;/p&gt;
&lt;p&gt;つまり、&amp;#8221;DejaVu Sans Mono&amp;#8221; には矢印のフォントがあるので、それが表示され、
  &amp;#8220;Bitstream Vera Sans Mono&amp;#8221; には矢印のフォントがないので、
  別で設定していた全角のフォントが表示された、ということだろう。&lt;/p&gt;
&lt;p&gt;あぁ、これでストレスが一つ減った。&lt;/p&gt;</content><author><name>ifritJP</name></author><category term="font emacs" /></entry><entry><title type="html">stream は rewind/seek できる？</title><link href="https://ifritjp.github.io/blog/site/2019/07/10/stream.html" rel="alternate" type="text/html" title="stream は rewind/seek できる？" /><published>2019-07-10T00:00:00+09:00</published><updated>2019-07-10T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/07/10/stream</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/07/10/stream.html">&lt;p&gt;&lt;b&gt;これは seekable な stream と none_seekable な stream の使い分けに関する記事です。&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;&lt;b&gt;使い分けが十分出来ている人は読まなくても大丈夫です。&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;皆さんは bitstream という単語をご存知でしょうか？&lt;/p&gt;
&lt;p&gt;AV (Audio&amp;amp;Visual) が好きな人や、
  それらの業界に関係のある人ならそこそこ聞く単語だと思いますが、
  一般的にはあまり馴染の無い単語でしょうか。&lt;/p&gt;
&lt;p&gt;馴染の無い人の為に身近な HDD レコーダを例に挙げて説明すると、
  HDD レコーダはデジタル放送の電波に乗っているデータをそのまま記録していますが、
  このデータが bitstream です。
  HDD レコーダは、デジタル放送の bitstream を HDD に記録し、
  記録した bitstream を再生する装置と言えます。
  もちろん、実際にはそんな単純ではないですが、概ね間違ったことは言ってません。&lt;/p&gt;
&lt;h1&gt;stream&lt;/h1&gt;
&lt;p&gt;プログラムでデータを扱う時、stream という概念を使って制御します。&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;言語&lt;/th&gt;&lt;th&gt;stream (入力)&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Java&lt;/td&gt;&lt;td&gt;InputStream&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Swift&lt;/td&gt;&lt;td&gt;InputStream&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;Go&lt;/td&gt;&lt;td&gt;io.Reader&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;上記は言語毎の入力系 stream の例です。&lt;/p&gt;
&lt;p&gt;ちなみに入力系の stream とは何かというと、
  流れてくるデータを読み出すためのものです。&lt;/p&gt;
&lt;p&gt;例えば、先ほどの HDD レコーダの例で説明すると、&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;デジタル放送の電波に乗っている bitstream を読み取る部分&lt;/li&gt;
  &lt;li&gt;HDD に記録されている bitstream を読み込む部分&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;が入力系の stream です。&lt;/p&gt;
&lt;p&gt;また、上記言語の stream (InputStream,io.Reader)には共通することがあります。&lt;/p&gt;
&lt;p&gt;それは、データの流れが一方通行で遡ることが出来ない、ということです。&lt;/p&gt;
&lt;p&gt;プログラム的に言うと、上記の stream は seek や rewind をサポートしていません。&lt;/p&gt;
&lt;p&gt;これを、先ほどの HDD レコーダの例で説明すると、
  「過去に放送された番組の録画はできない」ということです。&lt;/p&gt;
&lt;p&gt;24 時間全ての番組を常に録画し続けて、
  「1週間前に放送された任意の番組を再生する」機能を持つ HDD レコーダはありますが、
  それはあくまで録画してあるものを再生しているのであって、
  過去に放送された番組を録画することは出来ません。
  もしそれが出来るなら、
  本当の意味でのタイムマシーンを作ることが出来ることと同義になります。&lt;/p&gt;
&lt;p&gt;なお、「過去に放送された番組の録画はできない」ですが、
  「録画した番組」の逆再生などは出来ます。&lt;/p&gt;
&lt;p&gt;先ほど説明した通り、次のどちらもの入力 stream です。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;デジタル放送の電波に乗っている bitstream を読み取る部分
    &lt;ul&gt;
      &lt;li&gt;過去に放送された番組の録画はできない&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;HDD に記録されている bitstream を読み込む部分
    &lt;ul&gt;
      &lt;li&gt;録画した番組は逆再生など出来る&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これはつまり、 stream には次の 2 つのタイプが存在することを意味します。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;流れが一方通行で遡ることが出来ない stream&lt;/li&gt;
  &lt;li&gt;流れを遡ることが出来る stream&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これ以降、上記をそれぞれ none_seekable と seekable とします。&lt;/p&gt;
&lt;h1&gt;none_seekable と seekable の使い分け&lt;/h1&gt;
&lt;p&gt;上記の通り、stream には none_seekable と seekable の 2 つのタイプが存在します。&lt;/p&gt;
&lt;p&gt;では、実際のプログラムでは stream はどう使い分けるべきか？ と考えた場合、
  seekable である必要がない場合は極力 none_seekable を使うべきです。&lt;/p&gt;
&lt;p&gt;なぜならば、
  seekable は none_seekable を包括する概念であり、
  seekable な stream は none_seekable として使用することが出来ますが、
  none_seekable な stream は seekable として使用することが出来ないからです。&lt;/p&gt;
&lt;p&gt;次に、疑似言語を使って説明します。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
fn funcA( data: seekable ) {
  sub( data );
}
fn funcB( data: none_seekable ) {
  sub( data );
}
&lt;/pre&gt;
&lt;p&gt;上記は、 seekable な引数を持つ関数 funcA と、
  none_seekable な引数を持つ関数 funcB を定義する疑似言語コードです。
  また sub() は、 none_seekable な引数を持つ関数とします。&lt;/p&gt;
&lt;p&gt;ここで、この関数 funcA は seekable な stream でしか使用できないのに対し、
  この関数 funcB は seekable, none_seekable どちらでも使用できることになり、
  funcB は funcA よりも汎用性が高いと言えます。&lt;/p&gt;
&lt;p&gt;関数の汎用性が高いことが良いプログラムである、とは一概には言えませんが、
  ミドルウェアなどのライブラリでは、汎用性が高い方が良いとされます。&lt;/p&gt;
&lt;p&gt;つまり、 stream を入力に持つ関数の処理においては、
  seek や rewind の使用は極力避け、
  none_seekable の stream で処理可能にすべきである、と言えます。&lt;/p&gt;
&lt;p&gt;ただし例外として、 seek や rewind を使用しないと目標のパフォーマンスが出ないとか、
  必要なワークメモリが規定を越えてしまう、等の問題がある場合は、
  無理に none_seekable で処理する必要はありません。&lt;/p&gt;
&lt;p&gt;とはいえ、あくまでも原則は、
  seekable ではなく none_seekable で処理できるかどうかを検討するべきです。&lt;/p&gt;
&lt;p&gt;言語の組込みの型として seekable と none_seekable が分かれていない言語は、
  結構あると思います。&lt;/p&gt;
&lt;p&gt;そのような言語でも、
  seekable と none_seekable の考え方自体は有効なので実践してください。&lt;/p&gt;
&lt;h1&gt;none_seekable で処理することのメリット&lt;/h1&gt;
&lt;p&gt;seekable ではなく none_seekable で処理することのメリットとして、
  Web ブラウザでの処理を例に挙げて説明します。&lt;/p&gt;
&lt;p&gt;もしもブラウザの処理が全て seekable であった場合、
  ブラウジングスピードが遅くなることが予想されます。&lt;/p&gt;
&lt;p&gt;なぜなら、Web ブラウザは、サーバから HTML をダウンロードし、
  HTML 内のリンクを抽出し、そのリンクをさらにダウンロードします。
  そしてリンクが画像の場合、画像をデコードして表示します。&lt;/p&gt;
&lt;p&gt;画像のデコード処理が none_seekable であるならば、
  画像データのダウンロード開始と同時にデコード処理が開始でき、
  画像データのダウンロード終了とほぼ同時にデコード処理を完了できます。&lt;/p&gt;
&lt;p&gt;一方でもしも画像のデコード処理が seekable だった場合、
  画像データをダウンロード終了してからデコード処理を行なわなければならず、
  その分タイムロスになります。
  さらに欠点はタイムロスだけでなく、
  画像データの全てをダウンロードして一旦 RAM やストレージに格納しておく必要があり、
  その分のリソースを消費することになります。&lt;/p&gt;
&lt;p&gt;画像データのサイズなんてイマドキのハードウェアスペックなら無視できる、
  という意見もあるかもしれませんが、例えば 8K の低圧縮画像などは軽く数 10MB を越えます。
  こういった画像のデータを全てダウンロードしてからデコードするなんてしてたら、
  無駄にリソースを消費することが分かると思います。&lt;/p&gt;
&lt;p&gt;また、最近はほとんど使われていませんが、
  progressive JPEG なんて画像フォーマットが使われていた時期がありましたが、
  これは none_seekable で処理して始めて意味のあるものです。&lt;/p&gt;
&lt;p&gt;progressive JPEG を簡単に説明すると、
  画像データの一部をダウンロードするだけで、低解像度の画像をデコードできる技術で、
  ダウンロードが進むごとにデコード結果の解像度が上がるというものです。&lt;/p&gt;
&lt;p&gt;これは、ネットワークの通信速度が低速なころに使用されていた画像フォーマットで、
  いまではほとんど使われなくなったものですが、
  none_seekable で処理しなければ全く意味のないものです。&lt;/p&gt;
&lt;p&gt;他にも none_seekable で処理することのメリットとして、
  動画配信に代表されるストリーミングサービスがあります。&lt;/p&gt;
&lt;p&gt;あれも、 none_seekable が前提にあるからこそ可能なサービスです。&lt;/p&gt;
&lt;p&gt;「ストリーミングサービスが none_seekable だ」と書くと
  「Youtube はシークできるぞ」とかツッコミがあると思うので一応補足しておきます。&lt;/p&gt;
&lt;p&gt;たしかに Youtube などの動画配信サービスはシークできるのが当たり前です。
  しかし、通常再生時は none_seekable で処理していて、
  シークなどの操作が入った時だけ、
  サーバからデータをダウンロードしなおして処理しています。
  つまり、基本は none_seekable です。&lt;/p&gt;
&lt;p&gt;もしも動画データが seekable 前提だった場合、
  動画データを全てダウンロードしてからでないと再生できないか、
  seek 処理が大量に発生してサーバ間の通信負荷が非常に高くなることが予想されます。&lt;/p&gt;
&lt;p&gt;また、seekable(randam access) は none_seekable(sequential) と比べて
  非常にパフォーマンスが悪くなるのが一般的です。&lt;/p&gt;
&lt;p&gt;例えば HDD の randam access は sequential と比べて 2 桁以上のパフォーマンス劣化、
  SSD でも 1 桁以上劣化します。
  RAM であっても、randam access することでキャッシュミスが発生しやすくなり、
  パフォーマンス劣化からは逃れられません。
  現代ではほとんど使われませんが、
  テープデバイスなんて使った日には、どれほどかかるか想像すら出来ません。&lt;/p&gt;
&lt;h1&gt;データフォーマット&lt;/h1&gt;
&lt;p&gt;stream を処理する際に、
  それを none_seekable として扱うには、
  stream に流れるデータのフォーマットが none_seekable として
  扱い易い構造になっている必要があります。&lt;/p&gt;
&lt;p&gt;データフォーマットが none_seekable として扱い難い構造の場合、
  上記のように「目標のパフォーマンスが出ない」、「必要なワークメモリが規定を越えてしまう」
  という問題が発生する可能性があります。&lt;/p&gt;
&lt;p&gt;ある程度の大きさになるデータフォーマットを定義する時は、
  必ず none_seekable で処理することを考えて定義しましょう。&lt;/p&gt;
&lt;p&gt;なお、 stream で処理することが多い画像や音声などのデータフォーマットは、
  基本的には none_seekable で処理できるように定義されています。&lt;/p&gt;
&lt;p&gt;もしもそうでなければ、放送や動画配信でデジタルデータを扱うことは出来ません。&lt;/p&gt;
&lt;p&gt;ちなみに、データの encode と decode の none_seekable での扱い易さは、
  相反することがあります。&lt;/p&gt;
&lt;p&gt;その場合、どちらかを優先するか、折衷案の検討が必要です。
  一つ言えることは、作業バッファを 0 にすることはまず不可能なので、
  どの程度の作業バッファサイズなら妥当かを判断することが重要です。&lt;/p&gt;
&lt;h1&gt;例外&lt;/h1&gt;
&lt;p&gt;none_seekable で処理することで、
  ダウンロードとデコードを同時に処理できるため高速に処理できる、と説明しましたが、
  一部例外があります。&lt;/p&gt;
&lt;p&gt;それは、専用ハードウェアを使用してデコードする場合です。&lt;/p&gt;
&lt;p&gt;HDD レコーダなどの家電製品では、
  動画や音声を処理する専用ハードウェアを搭載しています。
  それら専用ハードウェアは、データを渡すと高速に処理して結果を返してくれますが、
  処理するデータは全て揃えてから渡さなければならない、
  という制約があることがほとんどです。&lt;/p&gt;
&lt;p&gt;その場合は、none_seekable でダウンロードとデコードを同時に処理するよりも、
  専用ハードウェアを使用して処理する方が高速に処理できます。&lt;/p&gt;
&lt;p&gt;ただし、当然専用ハードウェアであるため、処理できるデータは限られていますし、
  そのような専用ハードウェアが利用できる環境は限られています。&lt;/p&gt;
&lt;h1&gt;まとめ&lt;/h1&gt;
&lt;p&gt;stream を扱う際は、次を注意する必要があります。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;極力 none_seekable で扱う&lt;/li&gt;
  &lt;li&gt;データフォーマットを決める時点で、 none_seekable で扱えることを考慮する&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;最後に&lt;/h1&gt;
&lt;p&gt;なんでこんなことを書いたかというと、
  最近とある画像コーデックのライブラリを扱うことがあったんですが、
  そのライブラリへの入力が seekable であることを前提としていてムカついた、
  という経験をしたためです。&lt;/p&gt;
&lt;p&gt;データ streaming 処理を行なう場合の基本的な考えなので、
  必ずこれらを考慮に入れて設計するようにお願いします。&lt;/p&gt;
&lt;p&gt;以上。&lt;/p&gt;</content><author><name>ifritJP</name></author><category term="english" /></entry><entry><title type="html">python のクラスを JSON 化</title><link href="https://ifritjp.github.io/blog/site/2019/07/04/python-json.html" rel="alternate" type="text/html" title="python のクラスを JSON 化" /><published>2019-07-04T00:00:00+09:00</published><updated>2019-07-04T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/07/04/python-json</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/07/04/python-json.html">&lt;p&gt;&lt;a href=&quot;https://github.com/ifritJP/game-message-tts&quot;&gt;コレ&lt;/a&gt; を作るにあたって、データの serialize/deserialize の方法を調べた結果、
  &lt;a href=&quot;https://pypi.org/project/marshmallow-dataclass/&quot;&gt;marshmallow_dataclass&lt;/a&gt; に落ち着きました。&lt;/p&gt;
&lt;p&gt;いくつか調べた中で、パッと見、直感的に出来そうだった、というだけの理由ですが。。&lt;/p&gt;
&lt;p&gt;実際、面倒な処理はほとんど無く、 serialize/deserialize が可能になりました。&lt;/p&gt;
&lt;h1&gt;使い型&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://pypi.org/project/marshmallow-dataclass/&quot;&gt;marshmallow_dataclass&lt;/a&gt; は、
  クラスを宣言する際に &lt;code&gt;@dataclass&lt;/code&gt; デコレータを付けて宣言し、
  メンバの型を宣言するのが基本です。&lt;/p&gt;
&lt;p&gt;こんな感じ。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;py&quot;&gt;
@dataclass
class LogItem:
    # ゲームタイトル
    title:str
    # 日付
    date:int
    # テキスト
    text:str
    # テキスト長
    len:int
&lt;/pre&gt;
&lt;p&gt;メンバの宣言が python っぽくないと思う方もいるかもしれませんが、
  静的型付け言語になれていると、こっちの方が馴染み易い気がします。&lt;/p&gt;
&lt;p&gt;JSON 化する場合は、
  次のようにクラスメソッドに JSON 化するクラスのインスタンスを渡すだけです。&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
item = LogItem( &amp;quot;title&amp;quot;, time.time(), &amp;quot;text&amp;quot;, len( &amp;quot;text&amp;quot; ) )
print( LogItem.Schema().dumps( item ).data )
&lt;/pre&gt;
&lt;p&gt;逆に JSON からクラスインスタンスを生成するには、
  次のようにクラスメソッドに渡すだけです。&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
LogItem.Schema().load( json.loads( text ) ).data
&lt;/pre&gt;
&lt;p&gt;とても簡単です。&lt;/p&gt;
&lt;p&gt;ただ、躓いた点があったので、気をつけるべき点として書いておきます。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;python3.7 以降を使用する&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;@dataclass&lt;/code&gt; デコレータを付けたクラスに次を宣言してはならない
    &lt;ul&gt;
      &lt;li&gt;コンストラクタ __init__&lt;/li&gt;
      &lt;li&gt;@staticmethod load()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>ifritJP</name></author><category term="python" /></entry><entry><title type="html">ゲームのメッセージ欄に表示されたメッセージの読み上げシステム</title><link href="https://ifritjp.github.io/blog/site/2019/06/28/text-to-speech.html" rel="alternate" type="text/html" title="ゲームのメッセージ欄に表示されたメッセージの読み上げシステム" /><published>2019-06-28T00:00:00+09:00</published><updated>2019-06-28T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/06/28/text-to-speech</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/06/28/text-to-speech.html">&lt;p&gt;4 月頃から、英語のレベルを上げるため参考書を買って勉強をしている。&lt;/p&gt;
&lt;p&gt;その参考書を使った最低限の基礎英語の復習は終ったので、次のステップに進むことにした。&lt;/p&gt;
&lt;p&gt;基礎が終った後の学習方法には何が良いのか色々と調べてみたが、
  色々な意見があるが最終的には「持続できるものが良い」というのが結論のようだ。&lt;/p&gt;
&lt;p&gt;まぁ、「持続すること」が英語学習で最も難しいことは、
  私自身が何度も挫折した経験があるので認識している。&lt;/p&gt;
&lt;p&gt;そもそも、先日まで復習していた参考書もかなり眠い目をこすりながらやっていて、
  このまま参考書を進めていっても、間違いなくまた挫折することは明らかだった。&lt;/p&gt;
&lt;p&gt;じゃぁ、何が一番持続できるか？と考えた時、自分にはゲームが良いだろう。
  という結論になった。&lt;/p&gt;
&lt;h1&gt;海外ゲームによる英語学習&lt;/h1&gt;
&lt;p&gt;ゲームのジャンルは、いわゆるノベルゲームあるいはアドベンチャーゲーム。
  有名どころで STEINS;GATE と言えば通じるだろうか？
  これなら文章量がハンパないので、勉強量という意味では問題ないだろう。
  「ゲームでの英語学習は効率が悪い」という意見があるが、
  「持続すること」が一番重要なので、「効率の悪さ」はこの際無視することにした。&lt;/p&gt;
&lt;p&gt;ともかく今は、英語の文章を英語のまま解釈できるようになるため、
  英語の文章をひたすら入力していくのが最も重要な期間で、
  その期間を挫折せずにやりすごすためにも、「持続すること」が一番重要と考えている。&lt;/p&gt;
&lt;p&gt;「習うより慣れよ」、脊髄反射できるまでの試練だ。&lt;/p&gt;
&lt;p&gt;そもそも、本当に効率の良い英語学習方法が存在するのであれば
  文科省もバカじゃないんだからその方法を採用しているはず。
  そして、その学習方法に本当に効果があれば、
  日本人の大多数が英語が出来ないまま放置されているはずがない。
  しかし、現実問題として私を含め日本人の大多数が英語が出来ないままである。&lt;/p&gt;
&lt;p&gt;つまり「日本国内における英語学習方法の違いによる効率の差」は、
  ほとんど誤差レベルなんだと思う。&lt;/p&gt;
&lt;p&gt;もちろん、「英語しか話せない人の中で生活すること」と、
  「日本国内で独学で英語を学習する」のとでは、英語の習得効率に明らかな違いはあるだろう。
  しかし、「日本国内で独学で英語を学習する方法」は、
  どのような学習方法であっても、どれも大差ないレベルなんだと思う。&lt;/p&gt;
&lt;h2&gt;海外ゲームによる英語学習における問題&lt;/h2&gt;
&lt;p&gt;ということで、先週辺りから海外のゲームをプレイしているんだが、一つ問題がある。&lt;/p&gt;
&lt;p&gt;その問題とは「reading の経験値しか得られない」ということだ。&lt;/p&gt;
&lt;p&gt;日本のゲームの海外移植版をやるのがとっかかり易いと考えてたが、
  そのゲームの TEXT は英語だが音声は日本語のままだった。
  てっきり海外移植版なら音声も英語になっているものだと思っていたが、完全に想定外だった。&lt;/p&gt;
&lt;p&gt;それならば、海外制作のオリジナルゲームなら音声も英語だろう、と思って探したが、
  そもそも海外制作のノベルゲームやアドベンチャーゲームというジャンルはほとんど無かった。
  あっても、音声がないという状況だ。
  もちろん、他のジャンルのゲームなら英語音声のものはある。
  しかしそのようなゲームは、TEXT の量的問題や、
  そもそも英語とか関係なくゲームが進んでいって、
  ほとんど単にゲームをプレイしているだけになってしまう、という問題がある。&lt;/p&gt;
&lt;p&gt;ちなみに、海外ドラマや映画を学習手段として試したことがあるが、
  アレはスピードが速すぎて、
  自分のレベルではとてもではないけどハードルが高過ぎるという結論になっている。&lt;/p&gt;
&lt;p&gt;自分のペースで進められる、というのが、
  ノベルゲームやアドベンチャーゲームの良いところだ。&lt;/p&gt;
&lt;p&gt;もちろん、内容が面白く持続できるということが前提だが。&lt;/p&gt;
&lt;p&gt;なお、今回海外のゲームを探してみて初めて気が付いたことだが、
  海外でアドベンチャーゲームというと、日本のアドベンチャーゲームとは全く違って、
  アクションゲームがアドベンチャーゲームに分類されていた。&lt;/p&gt;
&lt;p&gt;まぁ「adventure」 は「冒険」なんだから、当然といえば当然だろうが。&lt;/p&gt;
&lt;p&gt;だいぶ前置きが長くなったが、
  そんな訳で、多くの時間を費やして「reading の経験値しか得られない」のは勿体無いので、
  「どうにかしてゲームに音声を付けよう」と思い、今回のツール制作に至った。&lt;/p&gt;
&lt;h1&gt;ゲームに音声を付ける手段&lt;/h1&gt;
&lt;p&gt;ここで想定するゲームは、
  メッセージを表示する領域があり、クリックすることでメッセージが更新されて、
  ストーリーが進んでいくものだ。&lt;/p&gt;
&lt;p&gt;このメッセージを取り出し、機械音声でしゃべらせる。&lt;/p&gt;
&lt;p&gt;もう少し技術的にいうと次になる。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;スクリーンショットでゲーム画面をキャプチャ&lt;/li&gt;
  &lt;li&gt;キャプチャしたゲーム画面からメッセージ領域を判定し&lt;/li&gt;
  &lt;li&gt;メッセージ領域内のメッセージ画像を抽出し&lt;/li&gt;
  &lt;li&gt;抽出したメッセージ画像を OCR にかけて TEXT に変換し&lt;/li&gt;
  &lt;li&gt;変換した TEXT を Text To Speech で音声化する&lt;/li&gt;
  &lt;li&gt;上記を GUI でコントロール&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;メッセージ画像の抽出は OpenCV、 OCR は Tesseract OCR、
  Text To Speech は Windows10 標準の SAPI.SpVoice を利用する。&lt;/p&gt;
&lt;p&gt;クラウドサービスの API を使えば、これらを全て行なってくれるものもありそうだが、
  今回は上記の技術を組み合わせで自前で作成する。&lt;/p&gt;
&lt;p&gt;&lt;i&gt;まぁ、自分で作ること自体も面白そうだし。&lt;/i&gt;&lt;/p&gt;
&lt;p&gt;なお、お手軽に作るため、開発言語は Python とする。&lt;/p&gt;
&lt;p&gt;プログラミング言語として、個人的にはあまり Python は好きではないんだけど、
  手軽でさまざまなライブラリが揃っていて情報量も豊富、という意味では、
  今は Python に敵う言語はないんじゃないかと思う。&lt;/p&gt;
&lt;p&gt;なんだかんだ言っても、プログラミング言語はツールにすぎないので、
  目的の物を簡単に作れるのが一番良い。
  特に趣味で作るケースでは。&lt;/p&gt;
&lt;p&gt;業務で使う場合は、
  「チョット待て、他の言語はちゃんと検討したのか？」と言っておく。&lt;/p&gt;
&lt;p&gt;自分で開発している LuneScript も、
  lua VM 上で動作する大規模アプリを開発するには向いているけど、
  使えるライブラリは皆無(Lua 用ライブラリは使えるけど、まともに使うには module 宣言が必要)
  なので、残念ながらこういう用途には向いていない。&lt;/p&gt;
&lt;p&gt;ちなみに、 cygwin 版 python で作業しようと思ったが、
  pip がどうにもこうにも期待通りに動作しなかったので、
  普通の windows 版 python にした。&lt;/p&gt;
&lt;p&gt;以降では、各技術について補足する。&lt;/p&gt;
&lt;h2&gt;スクリーンショット&lt;/h2&gt;
&lt;p&gt;スクリーンショット用に次をインストールする。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ pip install pywin32
$ pip install Pillow
$ pip install pyscreenshot
&lt;/pre&gt;
&lt;p&gt;pywin32 は、 win32gui で特定の Window の領域を取得するために必要。&lt;/p&gt;
&lt;p&gt;具体的には次のような感じ。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;py&quot;&gt;
def getImageOf( window_title ):
    rect = win32gui.GetWindowRect( win32gui.FindWindow(None,  window_title ) )
    return ImageGrab.grab().crop( rect )
&lt;/pre&gt;
&lt;h2&gt;OpenCV&lt;/h2&gt;
&lt;p&gt;次の処理を OpenCV で行なう。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ゲーム画面からメッセージ領域を判定&lt;/li&gt;
  &lt;li&gt;メッセージ領域内のメッセージ画像を抽出&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ちなみに OpenCV のインストールは次で出来る。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ pip install opencv-python
&lt;/pre&gt;
&lt;h2&gt;OCR (Tesseract OCR)&lt;/h2&gt;
&lt;p&gt;次の処理を Tesseract OCR で行なう。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;抽出したメッセージ画像を OCR にかけて TEXT に変換&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Tesseract OCR は、次の URL からバイナリをダウンロードしてインストールし、&lt;/p&gt;
&lt;p&gt;https://github.com/UB-Mannheim/tesseract/wiki&lt;/p&gt;
&lt;p&gt;さらに python から利用するためのパッケージをインストールする。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ pip3 install pyocr
&lt;/pre&gt;
&lt;h2&gt;Windows10 Text To Speech (SAPI.SpVoice)&lt;/h2&gt;
&lt;p&gt;次の処理を SAPI.SpVoice で行なう。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;変換した TEXT を Text To Speech で音声化する&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mhammond/pywin32/releases&quot;&gt;https://github.com/mhammond/pywin32/releases&lt;/a&gt; から、
  python のバージョンに合う win32com モジュールのインストーラをダウンロードし、
  インストールする。&lt;/p&gt;
&lt;p&gt;SAPI.Speech の制御方法は、次の URL を参考に。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.daniweb.com/programming/software-development/code/217062/text-to-speech-using-com-python&quot;&gt;https://www.daniweb.com/programming/software-development/code/217062/text-to-speech-using-com-python&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;この SAPI.SpVoice の音声は、
  一昔前の合成音声に比べればだいぶマシに聞こえるが、やはり違和感を感じる。&lt;/p&gt;
&lt;p&gt;英語が出来ない自分が、英語の音声に違和感の文句を云うのもどうかと思うが、
  やはりイマドキの最新の Text To Speech 技術と比べると、品質が落ちる。&lt;/p&gt;
&lt;p&gt;そこで、Text To Speech の部分はクラウドサービスを使って違和感の緩和を検討する。
  これについては後日取り上げる。&lt;/p&gt;
&lt;h2&gt;GUI&lt;/h2&gt;
&lt;p&gt;GUI は tkinter を利用する。&lt;/p&gt;
&lt;p&gt;用途は次の通り。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ゲームの Window 指定&lt;/li&gt;
  &lt;li&gt;OCR のトリガ&lt;/li&gt;
  &lt;li&gt;OCR 後のメッセージ表示 &amp;amp; 編集&lt;/li&gt;
  &lt;li&gt;音声再生制御 (再生スピード,音量)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;ログ&lt;/h2&gt;
&lt;p&gt;折角なので、学習の履歴を残す。&lt;/p&gt;
&lt;p&gt;履歴は、日付、OCR 結果、全文字数 で、JSON 形式で残す。&lt;/p&gt;
&lt;h2&gt;欠点&lt;/h2&gt;
&lt;p&gt;このシステムの一番の欠点は、読み上げられる音声に全く感情が入らないってことだろう。
  ゲームのト書部分なら無感情でも問題ないが、
  セリフが無感情で読み上げられるのは、いささか味気ない。
  まぁ、そこは割り切るしかないが。
  今は、クリアに音声が聞こえる事の方が重要だろう。
  感情がどうこういうのは、
  実力が付いてから海外ドラマや映画を見るようにすれば良い話だ。&lt;/p&gt;
&lt;h1&gt;最後に&lt;/h1&gt;
&lt;p&gt;専門知識がなくても、フリーの技術を組合せるだけで、
  これだけのものが作れるようになったというのはスゴい時代になったものだ。&lt;/p&gt;
&lt;p&gt;ちなみにソースは &lt;a href=&quot;https://github.com/ifritJP/game-message-tts.git&quot;&gt;https://github.com/ifritJP/game-message-tts.git&lt;/a&gt; にある。
  興味があれば。&lt;/p&gt;</content><author><name>ifritJP</name></author><category term="english" /></entry><entry><title type="html">Raspberry pi zero w で Bluetooth 色々(ファイル転送:obex、 IP over BT:PAN )</title><link href="https://ifritjp.github.io/blog/site/2019/06/15/rasp0w.html" rel="alternate" type="text/html" title="Raspberry pi zero w で Bluetooth 色々(ファイル転送:obex、 IP over BT:PAN )" /><published>2019-06-15T00:00:00+09:00</published><updated>2019-06-15T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/06/15/rasp0w</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/06/15/rasp0w.html">&lt;p&gt;だいぶ前に買って放置していた Raspberry pi zero w をセットアップしました。&lt;/p&gt;
&lt;p&gt;Raspberry pi zero w と言えば「小型軽量」が売りなんで、
  今回はポータブルな IOT デバイスとして使う事を目的として、
  Bluetooth の機能(ファイル転送、 IP over Bluetooth) のセットアップをしました。&lt;/p&gt;
&lt;p&gt;イマドキ Bluetooth なんて、
  最新のイメージでセットアップすればすぐに使えるだろうと思って余裕でした。
  しかし、実際には目的の機能が動作するまでに、かなりの時間が掛ってしまいました。&lt;/p&gt;
&lt;p&gt;少なくとも、パッケージをインストールするだけでは済まず、
  いくつかのファイルを編集 &amp;amp; コマンド実行が必要です。&lt;/p&gt;
&lt;p&gt;そんな訳で、次に同じことをする時のために備忘録を残しておきます。&lt;/p&gt;
&lt;p&gt;この記事で扱うメインは以下の通りです。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Raspberry pi zero w を USB 接続のみでセットアップ&lt;/li&gt;
  &lt;li&gt;Bluetooth によるファイル送受信機能(OBEX File Transfer)の実現&lt;/li&gt;
  &lt;li&gt;IP over Bluetooth (PAN) による、PC との SSH 接続確立&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;スムースにいけば、 作業時間は 10 〜 20分程度で完了します。
  (OS イメージ書き込みや apt 更新などの待ち時間は除く)&lt;/p&gt;
&lt;p&gt;なお、 Raspberry pi の設定を行なうホスト環境は Ubuntu 18.04.2 LTS とします。&lt;/p&gt;
&lt;p&gt;Ubuntu が Native で動作する PC でも、
  Windows 上の Gest OS の Ubuntu でも構いません。
  ただし、 Windows 10 の subsystem の linux は対象外です。&lt;/p&gt;
&lt;h1&gt;Raspberry pi zero w を USB 接続のみでセットアップ&lt;/h1&gt;
&lt;h2&gt;SD カードに OS Image を書き込む&lt;/h2&gt;
&lt;p&gt;公式サイトから OS Image を落して SD カードに書き込みます。&lt;/p&gt;
&lt;p&gt;今回は Raspbian Stretch with desktop and recommended software の
  2019-04-08 を使用しました。&lt;/p&gt;
&lt;p&gt;以前 raspi で Bluetooth を扱った時、
  Lite では意図する動作にならなかったトラウマがあるため、今回はこれを使用します。&lt;/p&gt;
&lt;p&gt;イメージを書いたら、ssh と IP over USB (RNDIS) を有効化するため、
  SD カードをマウントした直下の次のファイルを編集します。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ssh&lt;/li&gt;
  &lt;li&gt;config.txt&lt;/li&gt;
  &lt;li&gt;cmdline.txt&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;編集内容については、次の URL を参考に。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://qiita.com/mt08/items/ce5e3911d74d7fad4563#%E6%89%8B%E9%A0%86&quot;&gt;https://qiita.com/mt08/items/ce5e3911d74d7fad4563#%E6%89%8B%E9%A0%86&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;念の為要点だけをまとめておくと、&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;空の ssh ファイルを作成&lt;/li&gt;
  &lt;li&gt;config.txt に次を追加&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;example&quot;&gt;
dtoverlay=dwc2
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;cmdline.txt
    &lt;ul&gt;
      &lt;li&gt;rootwaitとquietの間に次を挿入&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;example&quot;&gt;
modules-load=dwc2,g_ether
&lt;/pre&gt;
&lt;h2&gt;RNDIS 設定&lt;/h2&gt;
&lt;p&gt;Ubuntu では、Raspberry pi zero w (以降 raspi) を
  USB (2つある USB コネクタのうち、 HDMI コネクタ側の方)で接続すれば、
  運が良ければ特になにもせずに IP over USB (RNDIS) で raspi と通信可能になります。&lt;/p&gt;
&lt;p&gt;通信可能かどうかは、次の方法で確認できます。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ ip a
&lt;/pre&gt;
&lt;p&gt;ここで enp0s20u1 的なデバイスが表示されていて、
  IP アドレスが取れていることを確認します。&lt;/p&gt;
&lt;p&gt;IP アドレスが取れている場合、次のコマンドで raspi の IP を確認します。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ ip n
&lt;/pre&gt;
&lt;p&gt;同じサブネットのアドレスがあれば、それが raspi の IP。&lt;/p&gt;
&lt;p&gt;raspi の IP が分かったら、 ssh すれば OK。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ ssh -Y pi@10.42.0.100
&lt;/pre&gt;
&lt;p&gt;ちなみにデフォルトパスワードは raspberry.&lt;/p&gt;
&lt;p&gt;大抵の場合、運が良くないので上記の確認では期待した結果にならない。&lt;/p&gt;
&lt;p&gt;そのため、次のネットワーク設定が必要になる。&lt;/p&gt;
&lt;p&gt;まず、ネットワーク設定を行なう前に、現在のネットワークの状況を確認します。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ ip a
&lt;/pre&gt;
&lt;p&gt;このコマンドで表示される「デバイス名」と「MAC アドレス」をメモっておきます。&lt;/p&gt;
&lt;p&gt;メモった後に、次のコマンドを実行します。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ sudo nmtui
&lt;/pre&gt;
&lt;p&gt;起動すると、いくつかの Ethernet 設定がリストで表示されるので、
  編集を選択します。&lt;/p&gt;
&lt;p&gt;編集を選択すると、デバイスの欄に「デバイス名」あるいは「MAC アドレス」が
  表示されているので、
  USB の方の情報が表示されている Ethernet 設定を見つけます。&lt;/p&gt;
&lt;p&gt;設定を見つけたら、一旦その設定自体を消します。
  USB のデバイスに関する設定が複数ある場合は、全て削除します。&lt;/p&gt;
&lt;p&gt;そして、新しく設定を追加します。&lt;/p&gt;
&lt;p&gt;このときの設定内容は次の通りです。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;接続タイプ Ethernet&lt;/li&gt;
  &lt;li&gt;デバイス名を enp0s20u1 &lt;b&gt;(実際のデバイス名に合せる)&lt;/b&gt;&lt;/li&gt;
  &lt;li&gt;IP4 config を share にする&lt;/li&gt;
  &lt;li&gt;Require IPv4 addression for this connection をチェック&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;設定後、connection を activate する。&lt;/p&gt;
&lt;p&gt;これで再度 &lt;code&gt;ip a&lt;/code&gt; から確認してください。
  これでも上手く動作しない場合、
  deactivate と activate を何度か繰り返すと解消されることがあります。&lt;/p&gt;
&lt;p&gt;ちなみに Windows をホストに作業する場合、野良ドライバのインストールが必要です。
  個人的には、Windows への野良ドライバインストールはオススメできません。&lt;/p&gt;
&lt;p&gt;以降は、 raspi に ssh 接続した状態で作業します。&lt;/p&gt;
&lt;p&gt;まずは、次のコマンドで apt を更新しておきます。&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
$ sudo apt-get update
$ sudo apt-get install bluez-tools pulseaudio-module-bluetooth
&lt;/pre&gt;
&lt;p&gt;本来 pulseaudio-module-bluetooth は、 audio sink 用のものなので、
  今回の目的には不要のはずなんですが、
  これがないとペアリング後の接続すら出来なかったので入れておきます。&lt;/p&gt;
&lt;p&gt;次に、 raspi のホスト名を変更します。
  このホスト名が、 bluetooth のペアリングのときに使用されます。&lt;/p&gt;
&lt;p&gt;次のコマンドを実行し、 Network Options -&amp;gt; Hostname で適当に変更します。&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
$ sudo raspi-config
&lt;/pre&gt;
&lt;h1&gt;Bluetooth によるファイル送受信機能(OBEX File Transfer)の実現&lt;/h1&gt;
&lt;p&gt;Bluetooth のファイル送受信には、 追加で obex 系の設定が必要となります。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
$ sudo apt install obexpushd
&lt;/pre&gt;
&lt;p&gt;obex 系の処理を動かすには、 bluetoothd に &amp;#8211;compat オプションを必要です。&lt;/p&gt;
&lt;p&gt;オプションの指定は次のように /etc/init.d/bluetooth に &amp;#8211;compat を追加します。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
#SSD_OPTIONS=&amp;quot;--oknodo --quiet --exec $DAEMON -- $NOPLUGIN_OPTION&amp;quot;
SSD_OPTIONS=&amp;quot;--oknodo --quiet --exec $DAEMON -- --compat $NOPLUGIN_OPTION&amp;quot;
&lt;/pre&gt;
&lt;p&gt;あるいは、
  /etc/systemd/system/bluetooth.target.wants/bluetooth.service に追加するケースもあります。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
#ExecStart=/usr/lib/bluetooth/bluetoothd
ExecStart=/usr/lib/bluetooth/bluetoothd --compat
&lt;/pre&gt;
&lt;p&gt;ファイル編集後 &amp;#8211;compat オプションを反映させます。&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
$ sudo systemctl daemon-reload
$ sudo /etc/init.d/bluetooth restart
$ sudo systemctl restart bluetooth
&lt;/pre&gt;
&lt;p&gt;次に Bluetooth ファイル受信用ディレクトリを作成します。&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
$ mkdir ~/bluetooth
&lt;/pre&gt;
&lt;p&gt;そして次のコマンドを実行します。&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
$ sudo /usr/bin/obexpushd -B -n -o /home/pi/bluetooth
&lt;/pre&gt;
&lt;p&gt;これでホスト PC からファイルを送信すると、 /home/pi/bluetooth にファイルを受信します。&lt;/p&gt;
&lt;p&gt;なお、obexpushd は次のようにサービスとして登録します。&lt;/p&gt;
&lt;p&gt;/etc/systemd/system/bt-obexpushd.service に次の内容をもつファイルを作成。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
[Unit]
Description=Bluetooth obexpushd
After = bluetooth.service

[Service]
ExecStartPre=/bin/sleep 4
ExecStart=/usr/bin/obexpushd -B -n -o /home/pi/bluetooth
Type=simple

[Install]
WantedBy=multi-user.target
&lt;/pre&gt;
&lt;p&gt;サービスを有効化&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
$ sudo systemctl enable bt-obexpushd
$ sudo systemctl start bt-obexpushd
&lt;/pre&gt;
&lt;h1&gt;IP over Bluetooth (PAN) による、PC との SSH 接続確立&lt;/h1&gt;
&lt;p&gt;PAN の設定は、次の URL の回答をそのまま設定すれば OK です。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://raspberrypi.stackexchange.com/questions/29504/how-can-i-set-up-a-bluetooth-pan-connection-with-a-raspberry-pi-and-an-ipod&quot;&gt;https://raspberrypi.stackexchange.com/questions/29504/how-can-i-set-up-a-bluetooth-pan-connection-with-a-raspberry-pi-and-an-ipod&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;なお、上記 URL の内容を設定後、再度ペアリングをやり直してください。&lt;/p&gt;</content><author><name>ifritJP</name></author><category term="LuneScript" /></entry><entry><title type="html">VMWare ディスクイメージが圧縮されないときの対応方法</title><link href="https://ifritjp.github.io/blog/site/2019/05/20/vmware.html" rel="alternate" type="text/html" title="VMWare ディスクイメージが圧縮されないときの対応方法" /><published>2019-05-20T00:00:00+09:00</published><updated>2019-05-20T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/05/20/vmware</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/05/20/vmware.html">&lt;p&gt;VMWare のディスクイメージのサイズは、Gest OS 上のディスクサイズと異なる。&lt;/p&gt;
&lt;p&gt;基本的には、Gest OS 上で実際に使用されているサイズに圧縮された形でホスト OS 上に保持される。&lt;/p&gt;
&lt;p&gt;しかし、 Gest OS 上でファイル作成、削除を繰り返していると、
  Gest OS 上での使用サイズよりも、
  ホスト OS 上でのディスクイメージサイズがかなり大きくなっていることがある。&lt;/p&gt;
&lt;p&gt;このような状態になった時に、ホスト OS 上のディスクイメージサイズを、
  Gest OS 上での使用サイズ程度に削減するツール(vmware-toolbox-cmd)が
  vmware から提供されている。&lt;/p&gt;
&lt;p&gt;通常は、この vmware-toolbox-cmd を使うことで圧縮されるはずなのだが、
  自分の環境では全くサイズが変わらなかった。&lt;/p&gt;
&lt;p&gt;いくつか試した結果、削減出来た方法をメモしておく。&lt;/p&gt;
&lt;h1&gt;Gest OS 上でのディスクのクローン&lt;/h1&gt;
&lt;p&gt;今回実施した方法は Gest OS 上でのディスクのクローンを作成することだ。&lt;/p&gt;
&lt;p&gt;ある意味分かりきった方法かもしれない。&lt;/p&gt;
&lt;p&gt;ただ、クローン作成の方法はファイル単位のコピーではなく、
  &lt;b&gt;dd コマンドによるクローン作成&lt;/b&gt; で上手くいった、
  ということは意外と言えるんじゃないだろうか？&lt;/p&gt;
&lt;p&gt;ファイル単位のコピーだと、コピーにかなり時間がかかると思うが、
  dd コマンドで済んだので、10 GB 近いコピーも比較的短時間でコピーが出来た。&lt;/p&gt;
&lt;p&gt;dd コマンドは、特に何か特別なオプションを付けて実行したのではなく、
  普通に実行しただけだ。&lt;/p&gt;
&lt;p&gt;念の為、作業手順をまとめておく。&lt;/p&gt;
&lt;h2&gt;作業手順&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;クローン先の空のディスクイメージを作成する&lt;/li&gt;
  &lt;li&gt;ディスクイメージを VMWare に登録する&lt;/li&gt;
  &lt;li&gt;Gest OS を起動する&lt;/li&gt;
  &lt;li&gt;vmware-toolbox-cmd を使って圧縮&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;example&quot;&gt;
vmware-toolbox-cmd disk shrinkonly
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;Gest OS 上での圧縮対象ディスクと、クローン先のデバイス名をメモる&lt;/li&gt;
  &lt;li&gt;dd コマンドでクローン作成&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;example&quot;&gt;
dd if=/dev/圧縮対象 of=/dev/クローン先 bs=1M
&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;ここで指定するドライブは、パーティションではなくドライブ全体を指定すること。&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
  &lt;li&gt;Gest OS を shutdown
    &lt;ul&gt;
      &lt;li&gt;ここでクローン先のディスクイメージを見て、
        Gest OS 上の使用量とほぼ同じサイズに削減されていることを確認する。
        もしも削減されていない場合、これ以降の作業には意味はない。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;圧縮対象ディスクイメージを VMWare から除外し、
    代わりにクローンしたイメージを登録する。
    &lt;ul&gt;
      &lt;li&gt;この時クローンイメージを割り付けるハードウェアの ID などが、
        元の圧縮対象ディスクイメージと同じになるように登録する。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Gest OS を起動する。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上の手順により、サイズが圧縮されたクローンのイメージで運用できる。&lt;/p&gt;</content><author><name>ifritJP</name></author><category term="LuneScript" /></entry><entry><title type="html">関数ポインタのオーバーヘッド</title><link href="https://ifritjp.github.io/blog/site/2019/05/19/func-pointer.html" rel="alternate" type="text/html" title="関数ポインタのオーバーヘッド" /><published>2019-05-19T00:00:00+09:00</published><updated>2019-05-19T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/05/19/func-pointer</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/05/19/func-pointer.html">&lt;p&gt;現在 LuneScript の C 言語へのトランスコンパイル処理を対応中だが、
  トランスコンパイルする際に関数ポインタによる関数コールのオーバーヘッドが
  どの程度なのか気になったので調べてみた。&lt;/p&gt;
&lt;h1&gt;結果&lt;/h1&gt;
&lt;p&gt;初めに結果から書くと、&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
関数ポインタによる関数コールのオーバーヘッドは、
通常の関数コールに比べて約 1.267 倍となることが判った。
&lt;/pre&gt;
&lt;p&gt;この数値は、あくまで今回の実験結果であって、
  関数ポインタかどうかの違いだけはなく、他の要因も入ってしまっている。
  また、実行環境によっても差は出てくるだろう。&lt;/p&gt;
&lt;p&gt;しかし、それでも目安程度にはなるだろう。&lt;/p&gt;
&lt;h1&gt;所感&lt;/h1&gt;
&lt;p&gt;論理的に考えて、関数ポインタの関数コールが通常の関数コールに比べて
  遅くなることは理解していたが、これまで調べたことはなかった。
  それが、今回の実験で明かになった。&lt;/p&gt;
&lt;p&gt;個人的にはもっと差が出るかと思ったが、案外少ない結果になった。
  これは、実験用コードが小さ過ぎて全てキャッシュに乗ってしまっているのが一番の要因だとは思う。
  とはいえ、明らかなオーバーヘッドがあることには違いない。&lt;/p&gt;
&lt;p&gt;プログラミングをしていれば感じていることだと思うが、
  プログラムは関数コールの塊だ。&lt;/p&gt;
&lt;p&gt;つまり、関数コールのオーバーヘッドは、
  そのままプログラム全体の性能低下に直結する。&lt;/p&gt;
&lt;p&gt;「関数ポインタ」というと、あまり使わっていないイメージを持つ人も多いかもしれないが、
  オブジェクト指向の「ポリモーフィズム」あるいは「多態性」というと、
  良く使っているイメージがあるのではないだろうか？&lt;/p&gt;
&lt;p&gt;関数ポインタなど動的に動作が変わる処理は、
  目的の制御を実現する上で非常に重要だが、
  コードの把握が難しくなったり、オーバーヘッドによる性能低下を引き起こす可能性がある。&lt;/p&gt;
&lt;p&gt;関数ポインタと通常の関数は、その特性にあわせてどちらを使用するかの検討が必要だ。&lt;/p&gt;
&lt;p&gt;今回の実験結果をうけて、それがより明らかになったと思う。&lt;/p&gt;
&lt;h1&gt;実験詳細&lt;/h1&gt;
&lt;p&gt;ここでは、今回の実験方法について説明する。&lt;/p&gt;
&lt;h2&gt;コード&lt;/h2&gt;
&lt;p&gt;実験用に次の C 言語コードを作成した。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;c&quot;&gt;
void sub( void ) {
}
void func_direct( func_t * pFunc ) {
    sub();
}
void func_indirect( func_t * pFunc ) {
    pFunc();
}
&lt;/pre&gt;
&lt;p&gt;func_direct() は sub() 関数を直接コールする関数で、
  func_indirect() は sub() 関数を関数ポインタでコールする関数だ。&lt;/p&gt;
&lt;p&gt;この両者の関数を実行したときの実行時間を比較している。&lt;/p&gt;
&lt;p&gt;ちなみにコードの全体は次の通りである。&lt;/p&gt;
&lt;pre class=&quot;src&quot; lang=&quot;c&quot;&gt;
#include &amp;lt;sys/time.h&amp;gt;
#include &amp;lt;time.h&amp;gt;
#include &amp;lt;stdio.h&amp;gt;

typedef void (func_t)( void );

double getTime( void ) {
    struct timeval tm;
    gettimeofday( &amp;amp;tm, NULL );
    return tm.tv_sec + tm.tv_usec / 1000000.0;
}
void sub( void ) {
}
void func_direct( func_t * pFunc ) {
    sub();
}
void func_indirect( func_t * pFunc ) {
    pFunc();
}
void func_none( func_t * pFunc ) {
}
int main( int argc, const char * argv[] ) {
    long long loop;
    const char * pMode;

    double prev = getTime();
    switch ( argc ) {
    case 1:
        pMode = &amp;quot;indirect&amp;quot;;
        for ( loop = 0; loop &amp;lt; 1000 * 1000 * 1000 * 2; loop++ ) {
            func_indirect( sub );
        }
        break;
    case 2:
        pMode = &amp;quot;direct&amp;quot;;
        for ( loop = 0; loop &amp;lt; 1000 * 1000 * 1000 * 2; loop++ ) {
            func_direct( sub );
        }
        break;
    case 3:
        pMode = &amp;quot;none&amp;quot;;
        for ( loop = 0; loop &amp;lt; 1000 * 1000 * 1000 * 2; loop++ ) {
            func_none( sub );
        }
        break;
    }
    printf( &amp;quot;%s: time = %g\n&amp;quot;, pMode, getTime() - prev );
    return 0;
}
&lt;/pre&gt;
&lt;p&gt;このプログラムは、コマンドラインの引数によって
  func_direct(), func_indirect(), func_none()  のいずれかを
  所定の回数分実行し、実行時間を表示する。&lt;/p&gt;
&lt;p&gt;ちなみに func_none() は、関数ポインタと通常の関数コールの差を出す際に、
  できるだけ他の要因を除外するために作成した関数だ。&lt;/p&gt;
&lt;h2&gt;計測結果&lt;/h2&gt;
&lt;pre class=&quot;src&quot; lang=&quot;txt&quot;&gt;
indirect: time = 11.4617
indirect: time = 11.2905
indirect: time = 11.2595
indirect: time = 11.3391
indirect: time = 11.3123
direct: time = 10.5253
direct: time = 10.5927
direct: time = 10.5389
direct: time = 10.6043
direct: time = 10.5259
none: time = 7.64467
none: time = 7.60627
none: time = 7.75474
none: time = 7.60123
none: time = 7.63887
&lt;/pre&gt;
&lt;p&gt;これは、コマンドライン引数を変えて上記のプログラムをそれぞれ 5 回ずつ実行した結果だ。&lt;/p&gt;
&lt;p&gt;それぞれを平均すると次のようになる。&lt;/p&gt;
&lt;table&gt;
  &lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;時間(秒)&lt;/th&gt;&lt;th&gt;関数コールの時間(秒)&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;関数ポインタ&lt;/td&gt;&lt;td&gt;11.333&lt;/td&gt;&lt;td&gt;3.683&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;通常関数コール&lt;/td&gt;&lt;td&gt;10.557&lt;/td&gt;&lt;td&gt;2.908&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;関数コールなし&lt;/td&gt;&lt;td&gt;7.649&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;上記の「関数コールの時間」は、計測した時間から「関数コールなし」の時間を引いたものだ。&lt;/p&gt;
&lt;p&gt;つまり、 for 分の制御などの関数ポインタのオーバーヘッドとは直接関係ない処理の時間を引いている。&lt;/p&gt;
&lt;p&gt;この結果をもとに、次の計算をすると&lt;/p&gt;
&lt;p&gt;(/ 3.683 2.908) 1.266506189821183&lt;/p&gt;
&lt;p&gt;関数ポインタによる関数コールのオーバーヘッドは、
  通常の関数コールに比べて &lt;b&gt;約 1.267 倍&lt;/b&gt; となる。&lt;/p&gt;
&lt;p&gt;以上&lt;/p&gt;</content><author><name>ifritJP</name></author><category term="LuneScript" /></entry><entry><title type="html">emacs 更新に伴なう gdb の設定</title><link href="https://ifritjp.github.io/blog/site/2019/05/13/emacs26.html" rel="alternate" type="text/html" title="emacs 更新に伴なう gdb の設定" /><published>2019-05-13T00:00:00+09:00</published><updated>2019-05-13T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/05/13/emacs26</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/05/13/emacs26.html">&lt;p&gt;とある事情で使い続けていた emacs23.4 (2012/1) を、
  先日 emacs26.2 (2019/4) にアップデートした。&lt;/p&gt;
&lt;p&gt;このとき gdb 周りの設定を変更する必要があったので、備忘録としてまとめておく。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;2019-06-12: my-gud-stop, my-gud-mode-func を追加&lt;/b&gt;&lt;/p&gt;
&lt;h1&gt;emacs の gdb 設定&lt;/h1&gt;
&lt;pre class=&quot;src&quot; lang=&quot;el&quot;&gt;
;; gud-overlay-arrow-position が nil だとエラーするので。。
(setq gud-tooltip-display
      &amp;#39;((and gud-overlay-arrow-position
	     (eq (tooltip-event-buffer gud-tooltip-event)
		 (marker-buffer gud-overlay-arrow-position)))))

;; gdb バッファの C-c C-c で、プログラムを停止させる。
(setq gdb-gud-control-all-threads nil)

;; input/output バッファが勝手に表示されるのはウザいので、抑制
(setq gdb-display-io-nopopup t)

;; gdb バッファの C-c C-c ではプログラムが停止しなかったので、修正
(defun my-gud-stop ()
  (interactive)
  (comint-interrupt-subjob)
  (gud-stop-subjob)
  )

;; 上記 my-gud-stop 関数を C-cC-c に登録する関数
(defun my-gud-mode-func ()
  (define-key (current-local-map) &amp;quot;\C-c\C-c&amp;quot; &amp;#39;my-gud-stop)
  )
;; フックに登録
(add-hook &amp;#39;gud-mode-hook &amp;#39;my-gud-mode-func)

&lt;/pre&gt;
&lt;p&gt;以降で、上記の設定について説明する。&lt;/p&gt;
&lt;h2&gt;gud-tooltip-display&lt;/h2&gt;
&lt;p&gt;1 つ目は、単純に gud.el の不具合のような気がするが、
  tooltip を表示する処理を修正している。&lt;/p&gt;
&lt;p&gt;gud-tooltip-display は、 gud で tooltip を表示する処理のようだが、
  この処理で &lt;code&gt;(make-buffer gud-overlay-arrow-position)&lt;/code&gt; を実行している。&lt;/p&gt;
&lt;p&gt;この処理は、 gud-overlay-arrow-position が nil の時にも実行されるケースがあるようで、
  その時にエラーにならないように and を追加している。&lt;/p&gt;
&lt;h2&gt;gdb-gud-control-all-threads&lt;/h2&gt;
&lt;p&gt;gdb-gud-control-all-threads は、
  gud の制御を全スレッドに対して反映させるかどうかのフラグで、
  emacs 23 ではデフォルト nil だった。&lt;/p&gt;
&lt;p&gt;新しい gdb では、 gdb-gud-control-all-threads がデフォルト t になっている。&lt;/p&gt;
&lt;p&gt;gdb-gud-control-all-threads が t だと、
  どうにもこうにも意図したデバッグ制御にならなかったので nil とした。&lt;/p&gt;
&lt;p&gt;なお、 C-c C-c でデバッグ対象プログラムを停止できるが、正常に動作しない場合がある。&lt;/p&gt;
&lt;p&gt;その場合 M-x gud-stop-subjob してから C-c C-c すると、停止する。&lt;/p&gt;
&lt;h2&gt;gdb-display-io-nopopup&lt;/h2&gt;
&lt;p&gt;emacs23.4 の gdb は、
  デバッグ対象プログラムの stdin/out と gdb の制御コマンドを、
  一つのバッファで管理していた。&lt;/p&gt;
&lt;p&gt;しかし、 新しい gdb は stdin/out と、gdb の制御コマンドを別々のバッファで管理している。&lt;/p&gt;
&lt;p&gt;gdb-display-io-nopopup は、
  stdin/out に変化があった際のポップアップ制御を抑制するかどうかのフラグ。&lt;/p&gt;
&lt;p&gt;デフォルトだと t だが、
  これだとソース編集中やステップ実行中に、
  stdin/out のバッファが突然表示されてウザいので nil とした。&lt;/p&gt;
&lt;p&gt;なお、gdb-display-io-nopopup を t とすると、
  M-x gdb 実行時にも stdin/out のバッファが表示されないため、
  stdin/out にアクセスする場合は 自分で C-x b 等で切り替える必要がある。&lt;/p&gt;
&lt;p&gt;ちなみに stdin/out バッファの名前は &lt;code&gt;*input/output of ...*&lt;/code&gt; 。
  ここで &amp;#8230; には、デバッグ対象のファイル名が入る。&lt;/p&gt;
&lt;h2&gt;my-gud-stop&lt;/h2&gt;
&lt;p&gt;emacs23.4 だと C-cC-c でプログラムを停止して (gdb) プロンプトが表示されたのだが、
  emacs26.2 だと C-cC-c でプログラムを停止できない。&lt;/p&gt;
&lt;p&gt;そこで、プログラムを停止する関数を作成している。&lt;/p&gt;
&lt;h2&gt;my-gud-mode-func&lt;/h2&gt;
&lt;p&gt;上記関数を C-cC-c に登録するための関数。&lt;/p&gt;
&lt;p&gt;gud-mode 時にキーバインドを登録するように gud-mode-hook に追加。&lt;/p&gt;
&lt;p&gt;以上。&lt;/p&gt;</content><author><name></name></author><category term="LuneScript" /></entry><entry><title type="html">『エンジニア就職志望者が情報工学科に行くのは間違い』は間違い</title><link href="https://ifritjp.github.io/blog/site/2019/04/18/engineer.html" rel="alternate" type="text/html" title="『エンジニア就職志望者が情報工学科に行くのは間違い』は間違い" /><published>2019-04-18T00:00:00+09:00</published><updated>2019-04-18T00:00:00+09:00</updated><id>https://ifritjp.github.io/blog/site/2019/04/18/engineer</id><content type="html" xml:base="https://ifritjp.github.io/blog/site/2019/04/18/engineer.html">&lt;p&gt;たまたま見つけたブログの記事で気になったものがあったので、
  自分の意見を書いておきます。&lt;/p&gt;
&lt;h1&gt;気になったブログの記事&lt;/h1&gt;
&lt;p&gt;「エンジニア就職志望者が情報工学科に行くのは間違いです！学べることが違います！」&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.torikun.com/entry/engineer-jouhoukougaku&quot;&gt;https://www.torikun.com/entry/engineer-jouhoukougaku&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;この記事を要約すると、&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;大学の情報工学科のプログラミング単位取得だけでは
    学習時間が足りないのでプログラミングスキルを上げるのは難しい。&lt;/li&gt;
  &lt;li&gt;スキルを上げるにはプログラミングスクールがオススメ&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;というモノです。&lt;/p&gt;
&lt;p&gt;まぁ確かに、
  大学の講義・実習だけで十分なプログラミングスキルを身に付けるのは不可能であるのは事実です。&lt;/p&gt;
&lt;p&gt;とはいえ、『エンジニア就職志望者が情報工学科に行くのは間違い』というのは、
  流石に異論があります。&lt;/p&gt;
&lt;p&gt;ブログの著者と自分とで異なる意見になる理由を考えると、&lt;/p&gt;
&lt;p&gt;&lt;b&gt;【「エンジニア」という言葉の定義が違う】&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;から、だと思います。&lt;/p&gt;
&lt;h1&gt;「エンジニア」とは&lt;/h1&gt;
&lt;p&gt;上記の記事では、エンジニアには次の能力が必要だとしています。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;プログラミングスキル&lt;/li&gt;
  &lt;li&gt;コミュニケーション能力&lt;/li&gt;
  &lt;li&gt;マネジメント能力&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;これらは確かに重要です。&lt;/p&gt;
&lt;p&gt;というか、「コミュニケーション能力」や「マネジメント能力」は、
  エンジニアでなくても社会で働くには必要な能力です。&lt;/p&gt;
&lt;p&gt;つまりこの著者は、&lt;/p&gt;
&lt;p&gt;&lt;b&gt;【「エンジニア」に特化して必要な能力は「プログラミングスキル」だけ】&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;と主張しているように読めます。&lt;/p&gt;
&lt;p&gt;これは、私の考えと完全に異なります。&lt;/p&gt;
&lt;p&gt;まず、私が考える「エンジニア」像を説明します。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;エンジニアとは、曖昧なゴールイメージを技術によってスマートな形で実現できる能力を持つ人。&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;例えば「家を建てる」というゴールイメージがあるとします。&lt;/p&gt;
&lt;p&gt;家を建てることは情報系の「エンジニア」の仕事ではないと思いますが、
  あくまで例として考えてください。&lt;/p&gt;
&lt;p&gt;この場合、次のような様々なことを決定し、設計書を作成して建築する必要があります。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;建てる場所&lt;/li&gt;
  &lt;li&gt;予算&lt;/li&gt;
  &lt;li&gt;広さ&lt;/li&gt;
  &lt;li&gt;デザイン&lt;/li&gt;
  &lt;li&gt;機能性&lt;/li&gt;
  &lt;li&gt;耐久性&lt;/li&gt;
  &lt;li&gt;拡張性&lt;/li&gt;
  &lt;li&gt;メンテナンス性&lt;/li&gt;
  &lt;li&gt;建材&lt;/li&gt;
  &lt;li&gt;日程&lt;/li&gt;
  &lt;li&gt;etc&amp;#8230;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;このように、
  曖昧なゴールイメージを実現するために具体的な作業項目に分解し、
  分解された作業の課題を洗い出し、
  課題を解決し、
  イメージを具現化する技術を持つのが、私が考える「エンジニア」です。&lt;/p&gt;
&lt;p&gt;もちろん、現実には一人のエンジニアが全てを担当できる訳ではありません。&lt;/p&gt;
&lt;p&gt;しかし、ブログの著者のような「エンジニア ＝ プログラミングスキルのある人 」では、
  絶対にありません。&lt;/p&gt;
&lt;p&gt;またブログの記事には、次の記載があります。&lt;/p&gt;
&lt;pre class=&quot;example&quot;&gt;
例えば、大学２年生の時にはフーリエ変換という数学の公式を習います。
この技術はパソコンの仕組みを突き詰めて行くと重要になってくる有名な数式です。
微分とか積分とかいろいろ難しい公式を覚えて問題を解いていきます。
エンジニアの方ならおわかりかと思いますが、
エンジニアとして仕事をする上でこのフーリエ変換を使う人はぜんぜんいません。
&lt;/pre&gt;
&lt;p&gt;確かに全てのエンジニアが微分・積分を必要とする訳ではないです。
  しかし、技術の背景を知っているエンジニアと、
  プログラミングしか出来ないプログラマーでは、担当できる範囲が全く違ってきます。&lt;/p&gt;
&lt;p&gt;たとえばディープラーニングなどの技術は、
  プログラミングしか出来ないプログラマーでは &lt;b&gt;絶対&lt;/b&gt; に作り出すことは出来ません。
  様々な知識を持つエンジニアが集結してこそ可能なものです。&lt;/p&gt;
&lt;p&gt;もちろん大学の講義レベルの知識だけで、すぐに何かが実現出来るということはありません。
  しかし、大学の講義はさまざまな技術の基礎そのものであり、
  その基礎を身に付けているかどうかで、その後の応用が出来るかどうかの違いに繋がってきます。&lt;/p&gt;
&lt;p&gt;特に基礎部分は、体系的に学んだ方がより深い理解につながります。
  そして大学の情報工学部の単位は、体系的に学ぶことが出来る構成になっています。&lt;/p&gt;
&lt;p&gt;つまり大学の情報工学部は、『「エンジニア」になるためのもっとも早道である』と言えます。&lt;/p&gt;
&lt;h1&gt;認識が異なる理由&lt;/h1&gt;
&lt;p&gt;では、ブログの著者は何故「エンジニア ＝ プログラミングスキルのある人」という
  認識なのでしょうか？&lt;/p&gt;
&lt;p&gt;あくまで私の想像ですが、これは日本のソフトウェア開発業界の特色によるものだと思います。&lt;/p&gt;
&lt;p&gt;その特色とは、いわゆる「ゼネコン方式」です。&lt;/p&gt;
&lt;p&gt;&lt;b&gt;大手が仕様を決め、実装を外部にアウトソーシングする。&lt;/b&gt;&lt;/p&gt;
&lt;p&gt;ブログ著者にとって「エンジニア」とはアウトソーシング先であり、
  「エンジニアは安い金額で実装さえ出来れば良い」という思考なのではないでしょうか？&lt;/p&gt;
&lt;p&gt;日本には、このような思考が蔓延しているため、
  エンジニアの待遇は良くならないし、
  技術レベルも世界から離される一方なのではないでしょうか？&lt;/p&gt;
&lt;p&gt;なお、ブログ著者のプロフィールを見ると、 IBM Tokyo Lab に務めているとあります。
  いわゆる大手であるのは間違いないでしょう。&lt;/p&gt;
&lt;h1&gt;エンジニア就職志望者はどうあるべきか&lt;/h1&gt;
&lt;p&gt;私の考えは、「エンジニア就職志望者は様々な技術を学ぶべき」です。&lt;/p&gt;
&lt;p&gt;「他人が作った仕様を元に、プログラムだけ組んでいれば幸せ」という人は、
  ブログ著者が主張するようにプログラミングスクールなりに行けば良いと思います。&lt;/p&gt;
&lt;p&gt;ただ、日本のゼネコン方式ソフトウェア開発を請け負う、
  いわゆる SIer の給与は発注元の企業よりもかなり低いのが一般的です。
  それこそ IBM の半分かそれ以下ではないでしょうか？
  そのことは認識しておく必要があります。&lt;/p&gt;
&lt;p&gt;なお、エンジニア志望者が行くべきなのは、情報工学科でなくても良いと思います。&lt;/p&gt;
&lt;p&gt;というのも、私の「エンジニア」の定義は広いので、
  情報工学科では収まりきらないためです。
  何を極めたいかによって、何を学ぶべきかは変ってくるでしょう。&lt;/p&gt;
&lt;p&gt;一つだけ必須技術を上げるならば、それは &lt;b&gt;「英語」&lt;/b&gt; です。&lt;/p&gt;
&lt;p&gt;今後の「エンジニア」業界で、
  日本が世界をリードすることは極一部を除いて無いでしょう。&lt;/p&gt;
&lt;p&gt;つまり、新しい技術は海外から導入することになります。
  その時、その技術の解説は英語であるのが一般的です。&lt;/p&gt;
&lt;p&gt;英語が出来れば、いち早く技術の導入が可能になります。&lt;/p&gt;
&lt;p&gt;まぁ、これは今に始まったことではなく、
  それこそコンピュータサイエンスという言葉が一般化したころから英語が標準でした。&lt;/p&gt;
&lt;p&gt;ただ平成の時代は、&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;今よりは技術の進歩が激しくなく、日本語の翻訳を待っていてもまだどうにかなっていた&lt;/li&gt;
  &lt;li&gt;国内で働いているだけなら、外国人を相手にする機会がほとんどなかった&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;などの理由から「英語は出来た方が良い」というレベルでした。&lt;/p&gt;
&lt;p&gt;しかし現在は、&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;技術の進歩が激しく、日本語の翻訳を待っていたら周回遅れどころか浦島太郎になる&lt;/li&gt;
  &lt;li&gt;ある程度新しい技術を取り入れる場合、国内の日本人だけで開発するのが難しくなった&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;などで、まともな「エンジニア」として働くには、英語はなくてはならない状況です。&lt;/p&gt;
&lt;p&gt;もしもあなたがエンジニアを志す学生で、英語を苦手としているのならば、
  留年してでも英語は習得しておくべきです。&lt;/p&gt;
&lt;p&gt;世界と戦う意思のあるまともな日本の企業でエンジニアとして働くのであれば、
  入社資格として英語のレベルを問われるでしょう。&lt;/p&gt;
&lt;p&gt;逆に英語のレベルを不問とするような会社は、
  世界と戦うことを諦めているか、
  あなたを安く使える労働力と捉えているかのどちらかの可能性が高いです。&lt;/p&gt;
&lt;p&gt;また、英語がまともに出来れば外資系や海外で働くことも選択肢になります。&lt;/p&gt;
&lt;p&gt;英語習得のために大学を 1 年留年したとしても、
  その後のエンジニア人生を考えれば充分おつりがくるでしょう。&lt;/p&gt;
&lt;p&gt;英語が出来ない私だからこそ、
  英語が出来ない現状がどれほどマズいことかを、
  この歳になって身をもって感じています。&lt;/p&gt;
&lt;p&gt;私はこれまで何度も英語の学習に挑戦と挫折を繰り返してきましたが、
  今の状況なって本当にマズいことを実感し、
  ラストチャンスとして人生で何度目かのトライをしています。&lt;/p&gt;
&lt;p&gt;皆さんは、私のような思いをしないで済むように、英語だけは身につけてください。&lt;/p&gt;
&lt;p&gt;もしかしたら、英語よりも中国語の方が良いかもしれませんが、
  それはまだ何ともいえない状況です。&lt;/p&gt;</content><author><name></name></author><category term="LuneScript" /></entry></feed>