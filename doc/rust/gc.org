# -*- coding:utf-8; -*-
#+AUTHOR: ifritJP
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

#+TITLE: 趣味でプログラミング言語開発しているオッサンが Rust の素晴しさを説明してみる

Rust は、実行性能の高さやメモリ安全性等から
C/C++ を代替可能なシステム開発言語の大本命とされている言語です。

ここでは、従来のプログラミング言語と Rust の実行性能とメモリ安全性を比較して、
いかに Rust が先進的なのかを説明します。
Rust の特徴はメモリ安全性以外にも多くのものがありますが、
この記事ではそれらはスコープ外とします。

* 用語説明

この文書内において「ユーザ」とは、
特定のプログラミング言語を使用して開発を行なうエンジニアを指します。


* 言語毎のメモリ制御方式について

ここでは、各言語におけるメモリ制御方式について、
その特徴を説明します。


** C 言語

C 言語は、同一メモリ空間をリニアに扱える言語です。
また、アドレスを直接扱うため、
HEAP メモリの管理もユーザ自身で行なう必要があります。

この特徴により、非常に高い実行性能を実現できるメリットがある一方で、
アクセスするアドレスを 1 つ間違うだけでプログラムが暴走するデメリットがあります。

C 言語を扱うユーザであれば、
NULL アクセスを含め、アドレス絡みの不具合を経験していないユーザはいないでしょう。

C 言語自体は、メモリ安全性を担保する仕組みを一切提供していません。
ユーザが全ての責任を負います。


なお、C 言語の syntax はほとんどそのままマシン語に置き換え可能です。
ある意味、C 言語は非常に素直な言語です。


/「C 言語はマシン語の syntax suger」/

というフレーズを見たことがありますが、まさにその通りです。

(マクロを除けば) C のコードには、隠れた処理というものがありません。
この特徴を好んで、敢えて C 言語を選択する人もいます。


#+BEGIN_COMMENT
現在 C 言語を利用するプロジェクトは、次のものが挙げられます。

- OS カーネルのようにハードウェアの直接制御が必要
- 極限まで実行性能の追求が必要
- CPU のベンダが C 言語しかサポートしていない
- 利用できる ROM/RAM 容量が非常に限られている
- C 言語で開発されていた従来製品のメンテナンス
- ほぼ全ての CPU で動く

これ以外の理由で C 言語を使用しているプロジェクトがあるならば、
手遅れになる前に別の言語の採用を検討すべきです。
#+END_COMMENT

** C++ 言語

C++ 言語は、その名前の通り C 言語を拡張した言語です。

C++ 言語は、C 言語と同様に同一メモリ空間をリニアに扱える言語であり、
C 言語と同じメリットとデメリットを持ちます。

ただし C++ にはスマートポインターを扱うクラスがあるため、
C 言語と比べると安全にメモリを扱えます。

このスマートポインターは、扱いを間違わなければ安全にメモリを扱えます。
しかし、ユーザのスマートポインターの扱いが正しいかどうかを
静的に検出する手段が完全ではないため、メモリ安全性としては不完全です。
あくまでもスマートポインターは、アドレスを直接扱うよりはマシというものです。
そもそも、「扱いを間違わなければ」という条件を付けて良いなら、
C 言語もアドレスの「扱いを間違わなければ」安全です。

また、スマートポインターはクラスのオブジェクトであり、
実行時にカプセル化された処理が動いてメモリ開放制御を行なうため、
実行性能においては、C 言語に劣ります。
C 言語の単なるポインタの受け渡しで済むものに比べると、
スマートポインタのメソッド呼び出しはコストが非常にかかります。
/(だいたいはインライン展開されるのでそこそこ高速に処理されますが)/

例えば単なる代入に見える処理であっても、
実際にはオーバーロードされた処理が動いてます。
さらに、ブロックを抜けた時には、
何も処理を書いてなくてもデストラクタが実行されています。

C++ は C 言語とは違い、コード上に現れない(あるいは認識しづらい)処理が
多くあり、C より実行性能が劣る要因になっています。


#+BEGIN_COMMENT
しかし、次の点から C++ 言語が選択されるケースが多いです。

- スマートポインターによる実行性能の差が
  クリティカルに影響するようなケースはほとんどない
- メモリ管理の大部分をスマートポインターに任せることで
  ユーザの負担が減り、不具合も減る
- C の言語仕様は進化が止っているが、C++ はトレンドを取り入れて進化している
- メモリ管理が GC ではないため、意図しない処理の停止が発生しない
#+END_COMMENT

** GC 系言語

ここでは、前節とは違って特定の言語は挙げずに
メモリ制御を GC に任せている言語について説明します。

GC は、メモリ制御をユーザのプログラムではなく言語側で制御するものです。
ユーザは、メモリ制御をほとんど意識することなくプログラムを作成可能です。

GC を採用するプログラミング言語は、メモリ空間のアドレスを隠蔽できるため、
比較的容易にメモリ安全性を確立できるメリットがあります。

一方で、ユーザプログラムの代わりにメモリの使用状況を確認して、
不要になったメモリを開放する処理が言語のランタイム側に必要になり、
この処理がユーザの意図しないタイミングで発生することで、
致命的な不具合につながる可能性があります。
例えば、NC マシンは非常に高い精度で制御可能ですが、
NC マシン制御中に GC 処理が走ると、その間 NC マシンを制御できなくなり、
精度が保証できなくなってしまいます。
このことから、
リアルタイム制御が必要なシステムに GC 搭載言語の採用は避けられてきました。

GC の方式として代表的なマーク・アンド・スイープは、
全ての変数が参照するオブジェクトから到達可能なオブジェクトにマークを付け、
到達できなかったオブジェクトを開放します。
これはプログラムの規模に比例して時間の掛る処理であり、実行性能に直結します。


とはいえ、多くの場合 GC 処理によるユーザプログラムの停止時間は非常に短いため、
ほとんどのケースでは影響のないものなっています。
特に、インクリメンタル GC は停止時間を短くする制御を取り入れているため、
大部分のアプリケーションにおいては GC 搭載言語のデメリットを考える必要はありません。
なぜなら、 *GC 非搭載言語のデメリットの方が圧倒的に大きい* ためです。

現に、多くのアプリケーションは GC 搭載言語で開発されています。

** Rust

ここから、ようやく Rust の話に入ります。

なぜ Rust が *「C/C++ を代替可能なシステム開発言語の大本命とされている」* のか？

それは Rust のメモリ制御方式に次の特徴があるからです。

- GC を搭載していないのに、メモリ安全性を確立している
- なおかつ、 *実行時ではなくコンパイラ時* に解決しているため、
  C 言語レベルの実行性能を出せる

C++ のメモリ安全性は、C よりもマシだと説明しましたが、
Rust のメモリ安全性はマシではなく最も優れています。
また C++ のスマートポインタや、GC のように実行時に処理が走るのではなく、
コンパイル時に解決します。

よって、リアルタイム処理が必要なケースでも Rust を使用することが出来ます。

では、なぜ Rust はこのようなことが可能なのか？

それは、 Rust を設計した言語開発者が所有権とライフタイムという概念を創造し、
syntax 上に所有権とライフタイムを宣言することで、
静的にメモリ安全性を精査できる仕組みを作り上げたからです。

もう少し具体的に説明すると、所有権とライフタイムによって次が不要になります。

- メモリの開放タイミングが静的に解決できるので、
  スマートポインタのような実行時処理、GC 処理が不要
- syntax 上、同一オブジェクトへの並列書き込みが起りえないので、アクセスに排他制御が不要

なお、Rust のメモリ開放処理は GC と比べて非常にシンプルです。
なぜなら、
所有権を持つ変数が無くなったタイミングでメモリを開放すれば良いだけだからです。

Rust で難しいのは、
ユーザのプログラムに書かれている所有権とライフタイムを完全にトレースする事です。
ユーザがどんなに複雑なフローを書いても、見失うことなく完全にトレースする必要があります。
もしも見失えば、コンパイルされたユーザプログラムの実行時不具合に直結します。

ただ、人間が全てのプログラムにおいてフローを完全にトレースするのは不可能ですが、
コンピュータであれば、一度不具合のないコードを作成すれば、
後は CPU が熱暴走でもしない限りは、
どんな複雑なフローであっても完全にトレースすることが出来ます。
また、どんなに複雑なフローであっても、
結局はシンプルな式の組み合わせに過ぎないので、
圧倒的な計算スピードを誇る CPU には簡単な作業です。

つまり、コンパイラでメモリ安全性を担保するというアプローチは、
非常に理にかなった方法と言えます。

*** Rust の欠点

これだけ書くと、 Rust は非常に素晴しい画期的な言語で、
何も欠点がないように思われるかもしれませんが、
残念ながら全く欠点がない訳でもありません。

代表的な欠点として挙げられるのは、
所有権とライフタイムをユーザが意識しなければならない、ということです。

ソフトウェアエンジニアであればそんなこと当たり前だろ、
と指摘されそうですが、これが結構難しいんです。
UML レベルでは簡単でも、コードレベルで矛盾なく落とし込むのは経験が必要になります。

結局は慣れではあるのですが、
いままで無かった概念なので使いこなすには経験が必要です。
また、Rust にコンパイラにエラーとして弾かれないようにするには、
設計段階で所有権とライフタイムをある程度意識する必要があります。
何も考えないで設計すると、後で設計やりなおし、なんてこともあります。

この辺りはオブジェクト指向初心者が無闇に継承を多用して設計が破綻する現象と、
似ていると思います。

個人的には、
ユーザの負荷が Rust よりも少ない方式のプログラミング言語が
近い将来登場し、さらに我々ユーザが楽できるようになると考えています。

ちなみに、私はソフトウェアエンジニアの仕事を AI に奪われるとは思っていませんｗｗ

* まとめ

各言語の特徴を次の表にまとめます。
  
| 言語 | ユーザへの負担           | 実行性能            | メモリ安全性   |
|------+--------------------------+---------------------+----------------|
| C    | 非常に重い               | 高い                | なし           |
| C++  | Cよりマシ                | Cに劣る             | Cよりマシ      |
| GC   | 軽い                     | GC 処理中に停止する | 排他制御は必要 |
| Rust | コンパイルを通すのが大変 | Cと同レベル         | 安全           |


繰り返しになりますが、Rust の何が素晴しいのかと言うと次の 3 行で表現できます。

- Rust を設計した言語開発者が所有権とライフタイムという概念を創造し
- 所有権とライフタイムを宣言する syntax を定義し
- 静的にメモリ安全性を精査できる仕組みを作り上げた

* さいごに

私は趣味でプログラミング言語開発しています。
/(ちなみに Lua 向けのトランスコンパイラです)/

その言語開発当初は、
Rust のようにコンパイラレベルでメモリ安全性を
担保するものにしようと考えていたんですが、
そうすると動くものがなかなか出来ないので取り敢えず GC にしました。
/(現状は Lua 向けなので強制的に GC になりますが、C も対応予定のためメモリ制御方式の検討が必要)/

しかし、やはり GC だと実行時のコストが気になり、
Rust のコンパイル時の静的処理が如何に優れたものなのかを改めて実感し、
ふとこういう解説記事を読んだことがなかったなぁ、と思い、この記事を作成しました。

Rust が気になっている方々の、Rust 理解の切っ掛けになれば幸いです。

ちなみに、Rust の所有権とライフタイムの具体的な説明については、こちらもどうぞ。

- C/C++エンジニアのための Rust のデータ所有権とライフタイム入門
  - <https://qiita.com/dwarfJP/items/25e74674daa3e893634c>

以上
