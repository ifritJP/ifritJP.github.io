# -*- coding:utf-8 -*-
#+AUTHOR: ifritJP
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

#+TITLE: LuneScript の C 言語トランスコンパイル時の GC 実装を考える

現在 LuneScript から C 言語へのトランスコンパイルを開発中だが、
変換後の C ランライムでは参照カウント型 GC を利用している。

参照カウント型 GC を採用したのは、
*実装が単純* で *GC 開発にかかるコストを抑えられる* ためだ。

参照カウント型には「循環参照のオブジェクトを開放できない」問題があるため、
何か対策を行なう必要があるが、必要になったらその時考えようと思い開発を進めて来た。

そして、ついに *循環参照問題* が発生したので、
とりあえず弱参照対応を考えているんだが、
今ここで弱参照を対応するのではなく、
弱参照が必要ない他の GC に切り替える方が良いんじゃないか？とも思っている。
その方がアプリ開発者としては楽だし。

あらためて GC の情報を集めてみると、次の事が分った。

- OCaml の GC が早いらしい。
- OCaml の GC は、 *ハイブリッドの 世代別/インクリメンタル コレクタ* らしい。
  - https://ocaml.org/learn/tutorials/garbage_collection.ja.html

インクリメンタル GC は、
GC の処理を分割して実行することで 1 度の GC にかかる時間を削減し、
ユーザのプログラムが GC 処理によって停止する時間を少なくするのを目的にしている。
ただ、GC の処理を分割しているため 1 度に処理するよりも多くの処理が必要になり、
トータルの処理時間は一般的に増加する。

LuneScript では GC 開発にかかるコストを抑えたいので、
ハイブリッドの GC ではなく、世代別ガベージコレクションの導入を検討する。

ここでは、世代別ガベージコレクションをランタイムに導入するために、
現在の実装からどう変更するのが一番楽に対応できるかを考えてみる。

なお LuneScript の C ランタイムでは、
各オブジェクトの memory アロケート処理自体はシステムコールを利用し、
システムコールで確保したメモリ領域の開放処理に GC を利用する。
つまり、LuneScript ではコンパクション処理をスコープとしない。

各オブジェクトの memory アロケート処理はパフォーマンスに大きく影響するが、
現状は C 言語へのトランスコンパイルの完成を優先させるためスコープ外とする。

* 世代別ガベージコレクション

世代別ガベージコレクションは、
寿命の長いオブジェクトを寿命の短かいオブジェクトとは別管理にすることで、
使い捨てされる多くのオブジェクトに対する GC の処理量を削減する。

具体的な処理方法を次に示す。

- 小さいサイズのメモリ領域 A と、大きいサイズのメモリ領域 B を用意する。
- メモリ要求があった場合、 A からメモリを確保する。
- 領域 A を使い切った時、領域 A に確保されている全オブジェクトに対して次の処理を行なう。
  - オブジェクトの生存確認を行なう。
  - 生存していない場合、破棄。
- 上記処理により、生存しているオブジェクトが領域 A に残る。
- あるオブジェクトが一定回数破棄されずに残った場合、
  そのオブジェクトは寿命の長いオブジェクトとして B に移動して管理する。
  

上記により、寿命の長いオブジェクトは別領域 B に移るため、
寿命の短かいオブジェクトを管理するメモリ領域 A の GC 処理が軽くなる。

ここでは、
寿命の短かいオブジェクトを管理するメモリ領域 A を minor、
寿命の長いオブジェクトを管理するメモリ領域 B を major とする。



ここで重要なのは次。

- オブジェクトの生存確認をどのように行なうか？
- オブジェクトの管理情報のデータ構造をどうするか？

** オブジェクトの生存確認方法

オブジェクトの生存確認は、
「オブジェクトが参照されているかどうか」である。

「オブジェクトが参照されているかどうか」を確認するために、
参照カウンタ型では参照されている数を管理していた。

しかしこの管理方法だと、
循環参照されているオブジェクトでは参照数が 0 にならない問題がある。

そこで「参照数」ではなく、「参照そのもの」を管理する。

また世代別ガベージコレクションでは、
全オブジェクトの内、 major を除外して minor だけを処理する。

minor のオブジェクトの生存確認方法として、
変数側から辿る方法と、オブジェクト側から辿る方法がある。


*** 変数側から参照オブジェクトを辿る方法

単純に変数側から参照オブジェクトを辿ると
major を含めて辿ることになってしまい効率が悪い。
そこで世代ごとに変数リスト genlist を作成し、世代ごとに分けて管理する。

具体的な処理は次になる。

- 変数へのオブジェクト代入処理
  - 代入先変数の世代と、代入するオブジェクトの世代が異なる場合
    - genlist から代入先変数を除外する
    - 代入先変数、代入するオブジェクトの世代の genlist に追加する
- GC 処理
  - minor 世代の genlist の変数からオブジェクトを辿り、コピー GC をかける。
    - この変数が保持しているオブジェクトが major だった場合、
      この変数を minor 世代の genlist から major 世代の genlist に移動する。
  - 一定回数生き残ったオブジェクトを major に移動する。

**** 問題点

- 大量のメンバを持つオブジェクトの場合、
  major オブジェクトを含めた検査になって効率が悪い
  - これを回避する方法として次が考えられる
    - クラスメンバに関しては、常に major として扱う
      - この場合、クラスメンバが常に major となるためトータルで見ると効率が悪い
    - メンバも一つの変数なので、メンバそれぞれ単独で辿る
      - この場合、 List 型などで List Item の追加、削除が複雑になる。
    - 変数側から辿るのではなく、オブジェクト側から辿る


*** オブジェクトから変数を辿る方法

単純に変数側から参照オブジェクトを辿ると
major を含めて辿ることになってしまい効率が悪い。
そこで世代ごとに変数リスト genlist を作成し、世代ごと分けて管理する。

具体的な処理は次になる。

- 変数へのオブジェクト代入処理
  - 代入先変数の世代と、代入するオブジェクトの世代が異なる場合
    - genlist から代入先変数を除外する
    - 代入先変数、代入するオブジェクトの世代の genlist に追加する
- GC 処理
  - minor 世代の genlist の変数からオブジェクトを辿り、コピー GC をかける。
    - この変数が保持しているオブジェクトが major だった場合、
      この変数を minor 世代の genlist から major 世代の genlist に移動する。
  - 一定回数生き残ったオブジェクトを major に移動する。

**** 問題点

- 大量のメンバを持つオブジェクトの場合、
  major オブジェクトを含めた検査になって効率が悪い
  - これを回避する方法として次が考えられる
    - クラスメンバに関しては、常に major として扱う
      - この場合、クラスメンバが常に major となるためトータルで見ると効率が悪い
    - メンバも一つの変数なので、メンバそれぞれ単独で辿る
      - この場合、 List 型などで List Item の追加、削除が複雑になる。
    - 変数側から辿るのではなく、オブジェクト側から辿る

