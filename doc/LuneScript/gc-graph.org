# -*- coding:utf-8 -*-
#+AUTHOR: ifritJP
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

#+TITLE: gc 検討(図解)

世代別 GC の minor GC の動作。

* 世代別 GC 概要

新しく生成したオブジェクトは使い捨てされる可能性が高いく、
古いオブジェクトは生存期間が長い傾向がある。

この傾向を利用し、新しく生成したオブジェクトと古いオブジェクトとで、
GC の方式を変えて積極的に新しいオブジェクトの未使用オブジェクトを破棄することで、
GC 処理を効率的に行なう。

  
* 原理

  
- 世代別 GC は gcNew と gcFull で分割
  - gcNew は、新しいオブジェクト minor のみを対象とする
  - gcFull は、全てのオブジェクトを対象とする
- 新しく生成したオブジェクトは minor として管理し、
  minor オブジェクトの総数が規定の個数になったタイミングで gcNew を実行する。
- gcNew で minor オブジェクトの生存確認を実行し、
  生存したオブジェクトの生存カウンタをインクリメントする。
- 生存カウンタが一定値に到達したオブジェクトは manor から major に昇格させる


#+BEGIN_SRC dot :file gc.svg
digraph G {
subgraph cluster_full {
style = rounded
label = gcFull

subgraph cluster_minor {
label = "minor/gcNew"
node_0_0 [label="",shape=circle]
node_0_1 [label="",shape=circle]
node_0_2 [label="",shape=circle]
}

subgraph cluster_major {
label = major
node_1_1 [label="",shape=circle]
node_1_2 [label="",shape=circle]
node_1_3 [label="",shape=circle]
node_1_4 [label="",shape=circle]
node_1_5 [label="",shape=circle]
node_1_6 [label="",shape=circle]
node_1_7 [label="",shape=circle]
}
}
node_0_1->node_1_6 [label="promote"];
}
#+END_SRC



** 属性

- 全てのオブジェクトは、minor か major どちらに属するかを示す情報を持つ
- minor から major に昇格するが、 major から minor への降格はない
- minor に属するオブジェクトは、どのシンボルから参照されているかのリストを持つ

- minor に属するオブジェクトを配列で管理

- minor を参照するシンボルは、そのシンボルが変数かメンバかを示す情報を持つ。
  - メンバの場合、そのメンバを保持するオブジェクトを示す情報を持つ


* 手順

- minor リストのオブジェクトに対し次を実行
  - minor オブジェクト ObjM を参照しているシンボルの有無を確認
    - 参照するシンボルが無ければ *破棄*
    - シンボルが変数なら *生存*
    - シンボルがメンバなら、そのメンバを持つオブジェクト OBJ の生存を確認
      - OBJ が major なら、 *生存*
      - OBJ が minor で、生存が確定していない場合、ObjM の判断は保留する
  - 生存が確定したオブジェクトに対し、次の処理を実施
    - 生存カウンタをインクリメント
    - 生存カウンタが一定値に到達した場合、 major に昇格する
    - 生存カウンタが一定値に満たない場合、生存確定リストに追加
  - 破棄するオブジェクトに対し、次の処理を実施
    - そのオブジェクトが持つメンバの参照情報を削除
- 一つでも確定したオブジェクトが存在すれば、生存が確定していないオブジェクトに対して再度実施。
- 一つも確定したオブジェクトがなければ、生存が確定していないオブジェクトを破棄。



** case1

#+BEGIN_SRC dot :file dot1.svg
digraph G {
rankdir = LR;
node_var [shape=record,label="<var1>var1|<var2>var2"];
node_obj1 [shape=record,label="<obj>obj1|<mbr2>mbr2"];
node_obj2 [shape=record,label="<obj>obj2|<mbr3>mbr3|<mbr4>mbr4"];
node_obj3 [shape=record,label="<obj>obj3|<mbr1>mbr1"];
node_obj4 [shape=record,label="<obj>obj4|<mbr>mbr"];

subgraph cluster_obj {
label = "object"
node_obj1:mbr2->node_obj2:obj
node_obj2:mbr3->node_obj3:obj
node_obj2:mbr4->node_obj4:obj
node_obj3:mbr1->node_obj1:obj
}


subgraph cluster_var {
label = "variable"
node_var:var1->node_obj1:obj
node_var:var2->node_obj4:obj
}


}
#+END_SRC

*** gc

#+BEGIN_SRC dot :file dot1-2.svg
digraph G {
rankdir = LR;

subgraph cluster_var {
label = "variable"
node [shape=box]; var1; var2;
}


subgraph cluster_minor {
label = "minor"
node [shape=circle]; obj1; obj2; obj3; obj4;
}


subgraph cluster_mbr {
label = "member"
node [shape=box]; mbr2; mbr3; mbr4; mbr1;
}

obj1->obj2
obj2->obj3
obj3->obj4


var1->obj1 [dir=both]
var2->obj4 [dir=both]

mbr2->obj2 [dir=both]
mbr3->obj3 [dir=both]
mbr4->obj4 [dir=both]
mbr1->obj1 [dir=both]

mbr2->obj1 [style=dashed]
mbr3->obj2 [style=dashed]
mbr4->obj2 [style=dashed]
mbr1->obj3 [style=dashed]

}
#+END_SRC

**** step    
- obj1 は、 var1 で参照されているため *生存*
- obj2 は、 mbr2 で参照されているため、mbr2 を保持する obj1 の生存を確認
  - obj1 は生存しているため *生存*
- obj3 は、 mbr3 で参照されているため、mbr3 を保持する obj2 の生存を確認  
  - obj2 は生存しているため *生存*
- obj4 は、 var2 で参照されているため *生存*
   

** case2

case1 から var1 のスコープが外れる。
  
#+BEGIN_SRC dot :file dot2.svg
digraph G {
rankdir = LR;
node_var [shape=record,label="<var2>var2"];
node_obj1 [shape=record,label="<obj>obj1|<mbr2>mbr2"];
node_obj2 [shape=record,label="<obj>obj2|<mbr3>mbr3|<mbr4>mbr4"];
node_obj3 [shape=record,label="<obj>obj3|<mbr4>mbr4"];
node_obj4 [shape=record,label="<obj>obj4|<mbr>mbr"];

subgraph cluster_obj {
label = "object"
node_obj1:mbr2->node_obj2:obj
node_obj2:mbr3->node_obj3:obj
node_obj2:mbr4->node_obj4:obj
node_obj3:mbr1->node_obj1:obj
}


subgraph cluster_var {
label = "variable"
node_var:var2->node_obj4:obj
}


}
#+END_SRC

*** gc

#+BEGIN_SRC dot :file dot2-2.svg
digraph G {
rankdir = LR;

subgraph cluster_var {
label = "variable"
node [shape=box]; var2;
}


subgraph cluster_minor {
label = "minor"
node [shape=circle]; obj1; obj2; obj3; obj4;
}


subgraph cluster_mbr {
label = "member"
node [shape=box]; mbr2; mbr3; mbr4; mbr1;
}

obj1->obj2
obj2->obj3
obj3->obj4


var2->obj4 [dir=both]

mbr2->obj2 [dir=both]
mbr3->obj3 [dir=both]
mbr4->obj4 [dir=both]
mbr1->obj1 [dir=both]

mbr2->obj1 [style=dashed]
mbr3->obj2 [style=dashed]
mbr4->obj2 [style=dashed]
mbr1->obj3 [style=dashed]

}
#+END_SRC


**** step    

- 1 回目の確認    
  - obj1 は、 mbr1 で参照されているため、mbr1 を保持する obj3 の生存を確認
    - obj3 は未確定のため、保留。
  - obj2 は、 mbr2 で参照されているため、mbr2 を保持する obj1 の生存を確認
    - obj1 は未確定のため、保留。
  - obj3 は、 mbr3 で参照されているため、mbr3 を保持する obj2 の生存を確認
    - obj2 は未確定のため、保留。
  - obj4 は、 var2 から参照されているため *生存*
- 2 回目の確認
  - obj1 は、 mbr1 で参照されているため、mbr1 を保持する obj3 の生存を確認
    - obj3 は未確定のため、保留。
  - obj2 は、 mbr2 で参照されているため、mbr2 を保持する obj1 の生存を確認
    - obj1 は未確定のため、保留。
  - obj3 は、 mbr3 で参照されているため、mbr3 を保持する obj2 の生存を確認
    - obj2 は未確定のため、保留。
  - なにも確定しなかったため、未確定オブジェクトを全て破棄

** gc 実行後

#+BEGIN_SRC dot :file dot2-3.svg
digraph G {
rankdir = LR;
node_var [shape=record,label="<var2>var2"];

subgraph cluster_obj {
label = "object"
node_obj4 [shape=record,label="<obj>obj4|<mbr>mbr"];
}


subgraph cluster_var {
label = "variable"
node_var:var2->node_obj4:obj
}


}
#+END_SRC
