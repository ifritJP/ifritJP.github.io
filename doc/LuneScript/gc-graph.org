# -*- coding:utf-8; -*-
#+AUTHOR: ifritJP
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

#+TITLE: LuneScript の GC 検討(図解)

LuneScript の GC を、参照カウンタ型から世代別 GC に切り替えるための検討。

* 世代別 GC 概要

生成したオブジェクトの生存期間は、次の特性を持つ傾向にある。

- 新しく生成したオブジェクトは使い捨てされる
- ある期間使用され続けたオブジェクトは、そのまま使用され続ける

この傾向を利用し、新しく生成したオブジェクトと古いオブジェクトとで
GC の方式を変えて積極的に新しいオブジェクトの未使用オブジェクトを破棄し、
GC 処理を効率的に行なうのが世代別 GC の戦略だ。

  
* 原理

  
- 世代別 GC は gcNew と gcFull で GC 処理を分割する。
  - gcNew は、新しいオブジェクト minor のみを対象とする
  - gcFull は、全てのオブジェクトを対象とする
- 新しく生成したオブジェクトは minor として管理し、
  minor オブジェクトの総数が規定の個数になったタイミングで gcNew を実行する。
  - gcNew は、 minor オブジェクトの生存確認を実行し、
    生存したオブジェクトの生存カウンタをインクリメントする。
  - 生存カウンタが一定値に到達したオブジェクトは manor から major に昇格させる
- 使用メモリの総サイズが一定に到達したタイミングで gcFull を実行する。
  - gcFull は、全オブジェクトの生存確認を実行する。


#+BEGIN_SRC dot :file gc.svg
digraph G {
subgraph cluster_full {
style = rounded
label = gcFull

subgraph cluster_minor {
label = "minor/gcNew"
node_0_0 [label="obj",shape=circle]
node_0_1 [label="obj",shape=circle]
node_0_2 [label="obj",shape=circle]
}

subgraph cluster_major {
label = major
node_1_1 [label="obj",shape=circle]
node_1_2 [label="obj",shape=circle]
node_1_3 [label="obj",shape=circle]
node_1_4 [label="obj",shape=circle]
node_1_5 [label="obj",shape=circle]
node_1_6 [label="obj",shape=circle]
node_1_7 [label="obj",shape=circle]
}
}
node_0_1->node_1_6 [label="promote"];
}
#+END_SRC



** 属性

- 全オブジェクトは次の状態を持つ
  - minor
  - major
  - 生存未確定
  - 生存確認中
  - 破棄確定
- minor から major に昇格(promote)するが、 major から minor への降格はない
- minor に属するオブジェクトは、次の情報を持つ
  - どのシンボルから参照されているかのリスト
  - gcNew の GC 処理で生存した回数を保持する生存カウンタ

- minor に属するオブジェクトを配列で管理

- minor を参照するシンボルは、そのシンボルが変数かメンバかを示す情報を持つ。
  - メンバの場合、そのメンバを保持するオブジェクトを示す情報を持つ


# サイズを指定するため silent にする。
# exports を none にすると画像生成もなくなるので、 exports は変えない。
#+BEGIN_SRC plantuml :file attrib.svg :results silent
class Object {
int state
MinorObject minor
}
class MinorObject {
int counter
MinorSymbol top
}
class Symbol {
MinorSymbol minor
}
class MinorSymbol {
MinorObject owner
MinorSymbol pNext
MinorSymbol pPrev
}

class MinorPool {
Array<MinorObject> allMinorObj
}

MinorObject o-- "1..*" MinorSymbol
MinorSymbol o-- MinorObject
MinorSymbol o-- MinorSymbol
Symbol *-- "0..1" MinorSymbol
Object *-- "0..1" MinorObject
MinorPool o-- "1..*" MinorObject
#+END_SRC


#+ATTR_HTML: :class "" :width 40%
[[file:attrib.svg]]


** MinorObject を参照する MinorSymbol リスト minorRefList の実現方法

minorRefList の実現方法には、次の 2 つが考えられる。

- MinorSymbol 側に pNext/pPrev のリスト構造を持たせる
- MinorObject 側に MinorSymbol を管理する配列を持たせる

次節ではそれぞれの特徴を述べる

*** MinorSymbol 側に pNext/pPrev のリスト構造を持たせる

*** MinorObject 側に MinorSymbol を管理する配列を持たせる


* gcNew の手順

- minor リストのオブジェクトに対し次を実行
  - minor オブジェクト ObjM を参照しているシンボルの有無を確認
    - 参照するシンボルが無ければ *破棄*
    - シンボルが変数なら *生存*
    - シンボルがメンバなら、そのメンバを持つオブジェクト OBJ の生存を確認
      - OBJ が major なら、 *生存*
      - OBJ が minor で、生存が確定していない場合、ObjM の判断は保留する
  - 生存が確定したオブジェクトに対し、次の処理を実施
    - 生存カウンタをインクリメント
    - 生存カウンタが一定値に到達した場合、 major に昇格する
    - 生存カウンタが一定値に満たない場合、生存確定リストに追加
  - 破棄するオブジェクトに対し、次の処理を実施
    - そのオブジェクトが持つメンバの参照情報を削除
- 一つでも確定したオブジェクトが存在すれば、生存が確定していないオブジェクトに対して再度実施。
- 一つも確定したオブジェクトがなければ、生存が確定していないオブジェクトを破棄。



** case1

#+BEGIN_SRC dot :file dot1.svg
digraph G {
rankdir = LR;
node_var [shape=record,label="<var1>var1|<var2>var2"];
node_obj1 [shape=record,label="<obj>obj1|<mbr2>mbr2"];
node_obj2 [shape=record,label="<obj>obj2|<mbr3>mbr3|<mbr4>mbr4"];
node_obj3 [shape=record,label="<obj>obj3|<mbr1>mbr1"];
node_obj4 [shape=record,label="<obj>obj4|<mbr>mbr"];

subgraph cluster_obj {
label = "object"
node_obj1:mbr2->node_obj2:obj
node_obj2:mbr3->node_obj3:obj
node_obj2:mbr4->node_obj4:obj
node_obj3:mbr1->node_obj1:obj
}


subgraph cluster_var {
label = "variable"
node_var:var1->node_obj1:obj
node_var:var2->node_obj4:obj
}


}
#+END_SRC

*** gc

#+BEGIN_SRC dot :file dot1-2.svg
digraph G {
rankdir = LR;

subgraph cluster_var {
label = "variable"
node [shape=box]; var1; var2;
}


subgraph cluster_minor {
label = "minor"
node [shape=circle]; obj1; obj2; obj3; obj4;
}


subgraph cluster_mbr {
label = "member"
node [shape=box]; mbr2; mbr3; mbr4; mbr1;
}

obj1->obj2
obj2->obj3
obj3->obj4


var1->obj1 [dir=both]
var2->obj4 [dir=both]

mbr2->obj2 [dir=both]
mbr3->obj3 [dir=both]
mbr4->obj4 [dir=both]
mbr1->obj1 [dir=both]

mbr2->obj1 [style=dashed]
mbr3->obj2 [style=dashed]
mbr4->obj2 [style=dashed]
mbr1->obj3 [style=dashed]

}
#+END_SRC

**** step    
- obj1 は、 var1 で参照されているため *生存*
- obj2 は、 mbr2 で参照されているため、mbr2 を保持する obj1 の生存を確認
  - obj1 は生存しているため *生存*
- obj3 は、 mbr3 で参照されているため、mbr3 を保持する obj2 の生存を確認  
  - obj2 は生存しているため *生存*
- obj4 は、 var2 で参照されているため *生存*
   

** case2

case1 から var1 のスコープが外れる。
  
#+BEGIN_SRC dot :file dot2.svg
digraph G {
rankdir = LR;
node_var [shape=record,label="<var2>var2"];
node_obj1 [shape=record,label="<obj>obj1|<mbr2>mbr2"];
node_obj2 [shape=record,label="<obj>obj2|<mbr3>mbr3|<mbr4>mbr4"];
node_obj3 [shape=record,label="<obj>obj3|<mbr4>mbr4"];
node_obj4 [shape=record,label="<obj>obj4|<mbr>mbr"];

subgraph cluster_obj {
label = "object"
node_obj1:mbr2->node_obj2:obj
node_obj2:mbr3->node_obj3:obj
node_obj2:mbr4->node_obj4:obj
node_obj3:mbr1->node_obj1:obj
}


subgraph cluster_var {
label = "variable"
node_var:var2->node_obj4:obj
}


}
#+END_SRC

*** gc

#+BEGIN_SRC dot :file dot2-2.svg
digraph G {
rankdir = LR;

subgraph cluster_var {
label = "variable"
node [shape=box]; var2;
}


subgraph cluster_minor {
label = "minor"
node [shape=circle]; obj1; obj2; obj3; obj4;
}


subgraph cluster_mbr {
label = "member"
node [shape=box]; mbr2; mbr3; mbr4; mbr1;
}

obj1->obj2
obj2->obj3
obj3->obj4


var2->obj4 [dir=both]

mbr2->obj2 [dir=both]
mbr3->obj3 [dir=both]
mbr4->obj4 [dir=both]
mbr1->obj1 [dir=both]

mbr2->obj1 [style=dashed]
mbr3->obj2 [style=dashed]
mbr4->obj2 [style=dashed]
mbr1->obj3 [style=dashed]

}
#+END_SRC


**** step    

- 1 回目の確認    
  - obj1 は、 mbr1 で参照されているため、mbr1 を保持する obj3 の生存を確認
    - obj3 は未確定のため、保留。
  - obj2 は、 mbr2 で参照されているため、mbr2 を保持する obj1 の生存を確認
    - obj1 は未確定のため、保留。
  - obj3 は、 mbr3 で参照されているため、mbr3 を保持する obj2 の生存を確認
    - obj2 は未確定のため、保留。
  - obj4 は、 var2 から参照されているため *生存*
- 2 回目の確認
  - obj1 は、 mbr1 で参照されているため、mbr1 を保持する obj3 の生存を確認
    - obj3 は未確定のため、保留。
  - obj2 は、 mbr2 で参照されているため、mbr2 を保持する obj1 の生存を確認
    - obj1 は未確定のため、保留。
  - obj3 は、 mbr3 で参照されているため、mbr3 を保持する obj2 の生存を確認
    - obj2 は未確定のため、保留。
  - なにも確定しなかったため、未確定オブジェクトを全て破棄

** gc 実行後

#+BEGIN_SRC dot :file dot2-3.svg
digraph G {
rankdir = LR;
node_var [shape=record,label="<var2>var2"];

subgraph cluster_obj {
label = "object"
node_obj4 [shape=record,label="<obj>obj4|<mbr>mbr"];
}


subgraph cluster_var {
label = "variable"
node_var:var2->node_obj4:obj
}


}
#+END_SRC
