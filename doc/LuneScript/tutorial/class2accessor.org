# -*- coding:utf-8 -*-
#+AUTHOR: ifritJP
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

#+TITLE: トランスコンパイラ LuneScript 入門 - accessor 編

今回はメンバの accessor について説明します。

* accessor

メンバの accessor (get,set) を簡単に作成できます。

次に例を示します。

#+BEGIN_SRC lns
class Test {
   pri let val1:int;
   pri let val2:int {pub,pub};
   pri let val3:int {pub};
}
let mut test = new Test( 1, 2, 3 );
print( test.$val2, test.$val3 );  // 2 3
test.set_val2( 10 );
print( test.$val2, test.$val3 );  // 10 3
#+END_SRC

上記例で val2 の定義は、 ~pri let val2:int {pub,pub};~ としています。

この ~{pub,pub}~ は、 val2 の accessor を定義しています。
これは、 getter, setter のアクセス制御を指定します。
この指定によって、次のメソッドが内部的に作成されます。

#+BEGIN_SRC lns
pub fn Test.get_val2(): int {
   return self.val2;
}
pub fn Test.set_val2( val:int ) {
   self.val2 = val;
}
#+END_SRC

getter にアクセスする場合、 $ を使って次のようにアクセスします。

#+BEGIN_SRC lns
let mut test = new Test( 1, 2, 3 );
print( test.$val2, test.$val3 );  // 2 3
#+END_SRC

~test.$val2~ は、 ~test.get_val2()~ のシンタックスシュガーです。

上記の通り、
accessor は「getter のアクセス制御」、「setter のアクセス制御」の順で宣言します。

setter が不要な場合、「setter のアクセス制御」を省略します。

なお、getter が不要で setter が必要な場合は、次のように宣言します。

#+BEGIN_SRC lns
class Test {
   pri let val1:int {non,pub};
}
#+END_SRC

この機能は、 setter を自動で生成しつつ、 getter をカスタマイズする時などに利用できます。


LuneScript の accessor は、普通のメソッドです。
C# のプロパティのような別のものではありません。

* accessor のカスタマイズ

LuneScript の accessor は、 C# のプロパティのようなカスタマイズ機能
(単純な setter/getter ではない処理を実装する機能)は用意していません。

なぜならば、 LuneScript の accessor は、単なるメソッド宣言の簡略化機能であり、
C# のプロパティのような「別物」ではないので、
もしも独自処理を行なう accessor が必要ならばその処理を自分で作成すれば良いためです。

なお、 独自の getter を定義した場合も $ は利用できます。

$val は、get_val() のシンタックスシュガーで、accessor 専用ということではありません。

* まとめ

LuneScript の accessor は次の仕様です。

- メンバ宣言と同時に宣言出来る
- getter, setter の順に宣言する
- getter にアクセスする場合、 メンバ名の前に $ を付加する。
- 独自の accessor は、自前でメソッドを定義する


次回は継承を説明します。
