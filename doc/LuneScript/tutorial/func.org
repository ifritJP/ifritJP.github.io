# -*- coding:utf-8 -*-
#+AUTHOR: ifritJP
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

#+TITLE: トランスコンパイラ LuneScript 入門 - 関数 編

今回は、 LuneScript の関数について説明します。

* 関数

** 関数定義
LuneScript の関数は次のように定義します。

#+BEGIN_SRC lns
fn add_sub( val1:int, val2:int ): int, int {
   return val1 + val2, val1 - val2;
}
print( add_sub( 1, 2 ) ); // 3, -1
#+END_SRC

上記の例は、次の関数を定義しています。

| 関数名       | add  |
| 第一引数名   | val1 |
| 第一引数型   | int  |
| 第二引数名   | val2 |
| 第二引数型   | int  |
| 第一戻り値型 | int  |
| 第二戻り値型 | int  |

** 可変長引数、戻り値

引数、 戻り値に ... を利用することで、
可変長引数、可変長戻り値の関数を定義できます。

... を利用したサンプルを次に示します。

#+BEGIN_SRC lns
fn func( val:int, ... ) : int, int, ... {
   let argList = [ ... ];
   let mut total = val;
   foreach arg in argList {
      when! arg {
         total = total + arg@@int;
      }
   }
   return total, val, ...;
}

print( func( 1, 2, 3, 4 ) ); // 10 1 2 3 4 
#+END_SRC

上記の例では、 可変長引数を処理するために argList にセットし、
それを foreach で列挙しています。

関数本体で ... を使用することで、引数そのものを示します。
ここで ... は、 0 個以上の stem! の値となります。
stem! については後述します。

*** 戻り値

関数の戻り値は return 文を使用します。

関数は、複数の値を返せます。

** 処理が戻らない関数

関数によっては、処理を戻さないものがあります。

次に例を示します。
   
#+BEGIN_SRC lns
fn func(): __ {
   while true {
   }
}
func();
print( 1 ); // error
#+END_SRC

この例では、 func() は無限ループです。
よって、 func() は処理を返さないことになります。

これを明示するため、 func() の戻り値の型は ~__~ となっています。
~__~ は、処理を戻さない関数であることを示します。

これによって、 func() の次の print() 文が処理されないことが分かり、
エラーとなります。

なお、 戻り値型を ~__~ とした関数は、
処理を戻しさないようにしなければなりません。

例えば次のように break すると、ループを抜けてしまうため、
func() から処理が戻ってきます。
このような場合は、エラーとなります。

#+BEGIN_SRC lns
fn func(val:int): __ {
   while true {
      if val == 1 {
         break;
      }
   }
}
#+END_SRC

** 定義場所

関数は、 statement が書ける場所であればどこでも定義可能です。
具体的には次のようにブロック内に定義できます。

#+BEGIN_SRC lns
fn sub():int {
   let mut val = 0;
   {
      {
         fn func(): int {
            return 1;
         }
         val = val + func();
      }
      fn func(): int {
         return 2;
      }
      val = val + func();
   }
   fn func(): int {
      return 3;
   }
   return val + func();
}
print( sub() ); // 6
#+END_SRC

スコープが異なれば、同名関数を定義できます。

** 公開関数

関数も変数と同様、pub を使って外部公開できます。
  
#+BEGIN_SRC lns
pub fn func(): int {
   return 1;
}
#+END_SRC

pub を指定することで、外部からアクセス可能な関数となります。

global も利用できます。

#+BEGIN_SRC lns
global fn func(): int {
   return 1;
}
#+END_SRC

関数の global 宣言には、 変数の global 宣言と同じ制約があります。

 *「global 宣言した関数は、 その関数を宣言したモジュールを import した時に有効になる。」*

関数の外部公開には、次の制約があります。

 *「外部公開する関数は、スクリプトの最上位のスコープに宣言しなければならない」*

** form 型

LuneScript は、関数オブジェクトを値として扱うことが出来ます。
関数オブジェクトの汎用的な型として *form* を利用できます。

次に form の使用例を示します。

#+BEGIN_SRC lns
fn test( val:int ) {
   print( val );
}
fn sub( func:form ) {
  func( 1 );
}
sub( test ); // 1
#+END_SRC

この例は、次の構成となります。

- 関数 test を定義
- 関数 sub は form 型の引数を持つ
- 引数として test を指定して sub を実行
  
これによって、 test 内で test が実行され、 1 が出力されます。

なお、 form 型は次の関数として扱います。

#+BEGIN_SRC lns
fn func(...):... {}
#+END_SRC

*** form 宣言

上記の通り、form は ~fn func(...):... {}~ と同義です。

これによって、全ての関数を form 型として扱うことが出来ますが、
これでは関数の型情報が失なわれてしまいます。

関数の型情報を保ったまま関数オブジェクトを扱うためには、
次のように form 宣言をします。

#+BEGIN_SRC lns
form funcform( val:int ):int;
fn sub( func:funcform ) {
   print( func( 1 ) + 1 );
}
sub( fn ( val:int ):int { return val + 1; } ); // 3
#+END_SRC

この例では、 funcform を form 宣言しています。

form 宣言によって funcform は、引数に int 型の val を持ち、
戻り値に int 型を持つ関数型となります。

** anonymous 関数

anonymous 関数は、名前を持たない関数を定義します。

次は anonymous 関数の例です。

#+BEGIN_SRC lns
fn sub( func:form ) {
  func( 1 );
}
sub( fn ( val:int ) { print( val ); } );  // 1
#+END_SRC

この例では、 anonymous 関数 ~fn ( val:int ) { print( val ); }~ を定義しています。

この anonymous 関数を sub() の引数に渡すことで、 anonymous 関数が実行されます。

anonymous 関数宣言は式です。

** 関数呼び出し

関数呼び出しは、 関数オブジェクトに ~()~ を付けることで行ないます。

関数の仮引数と実引数の型は一致しなければなりません。
なお、省略した実引数は nil として扱います。
もし省略した実引数に対応する仮引数が nilable でなかった場合、エラーとなります。

つまり、次のような関数呼び出しが可能です。

#+BEGIN_SRC lns
fn func( val1:int!, val2:str! ) {
   print( val1, val2 );
}
func( 1, "abc" ); // 1, abc
func( 1 );        // 1, nil
func();           // nil, nil
#+END_SRC

** 関数の制限

LuneScript の関数は、引数の違いによるオーバーロードはできません。

* まとめ

LuneScript の関数をまとめると、

- fn で宣言する
- 複数の戻り値を持てる
- 可変長の引数、戻り値をもてる
- pub, global で外部モジュールに関数を公開する
- 関数オブジェクトの型は、form 型と form 宣言を使用する
- anonymous 関数がある
- 省略した実引数には nil が入る
- 関数オーバーロードはない
  
次回は nilable について説明します。
