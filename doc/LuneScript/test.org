# -*- coding:utf-8 -*-
#+AUTHOR: ifritJP
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

#+TITLE: 開発を始めてからたった2週間でセルフホスティングを実現した独自言語の品質を維持するテスト方法

*Qiita らしい釣りっぽいタイトル* にしてみましたが、
内容は極々普通なことを書いています。
過度な期待はしないでください。
なおこの記事は、言語実装 Advent Calendar 2019 の 12/24 にオープンになる予定ですが、
11 月上旬に書いていることも気にしないでください。


ちなみに、独自言語の開発を始めてから2週間でセルフホスティングしたのは事実です。

- 開発開始 (2018/6/17)

#+BEGIN_SRC txt
commit 7034f58b11c6f4ce70f15a70cbda6e37d7b76c66
Author: ifritJP <15117169+ifritJP@users.noreply.github.com>
Date:   Sun Jun 17 21:44:08 2018 +0900

    Initial commit
#+END_SRC

- セルフホスティング開始 (2018/6/30)

#+BEGIN_SRC txt
commit a0558c8b7e1e298d63d4fe700ea3444ba6ada60d
Author: ifritJP <15117169+ifritJP@users.noreply.github.com>
Date:   Sat Jun 30 18:07:50 2018 +0900

    support to compile the lunescripts by lunescript.
#+END_SRC


その独自言語 LuneScript の紹介はこちら。 https://qiita.com/dwarfJP/items/21d4d4099ab0feb68eaf


LuneScript の宣伝はこの辺にして本題に。

* プログラミング言語のテスト

Qiita の読者であれば、
日々「プログラミング言語」でコーディングしている方がほとんどだと思います。
そして、誰かが仕込んだバグ潰し作業に追われている方も多いでしょう。

そんな日々お世話になっている「プログラミング言語」も
誰かが作ったソフトウェアであるので、いかにバグを出さないか、
という品質コントロールが重要になります。

私は運良く(？)、仕事でプログラミング言語を利用してきた中で
言語のバグに遭遇したことはありません。

/バグの様に思える言語の規格とかはありますが。。。/

プログラミング言語のバグに遭遇してしまった場合、
その対処は数あるソフトウェアバグの中でもかなり厄介な部類になると思います。

/そもそもプログラミング言語のバグだということに辿り着くのが困難。/

ここでは、
私が開発している独自言語のテスト方法について紹介したいと思います。

なお、プログラミング言語は次の 2 つに分類できます。

- コンパイラ型
- インタプリタ型

私が開発している言語はコンパイラ型であるため、
以降はコンパイラ型プログラミング言語のテストについて話をします。


** コンパイラは関数

コンパイラ型プログラミング言語は、
そのプログラミング言語で書かれたコードをマシン語などに変換するのが仕事です。

例えば、

- C 言語のコンパイラは Native コードに変換
- Java のコンパイラは JVM コードに変換
- C# は CIL に変換
- Clang は LLVM-IR に変換し、 LLVM が各種コードに変換

つまりコンパイラとは、
入力を与えると、その入力に応じた出力を返す 1 つの大きな関数と考えられます。

コンパイラを 1 つの関数と考えれば、そのテストは非常に単純です。
様々な入力を与えて、その出力と期待値とを比較すればテストが出来ます。

日頃作成している関数の UNIT TEST と考え方は全く同じです。

** LuneScript のテスト

独自言語の LuneScript では、次のテストを実施しています。

- セルフホスティングしている LuneScript 自身のビルド
- 対応する全構文の正常系
- 対応する全構文の異常系

ここで特に重要なのがセルフホスティングしていることです。

セルフホスティングしていることで、あえてテストコードを書かなくても、
自分自身のコードがそのままテストコードになります。

ある程度の規模で意味のあるテストコードを作成する、
というのは中々骨の折れる作業です。

特に自分以外誰も使っていないような独自言語の場合、
テストのためのコードではなく、ちゃんとした実用的なコードというものが、
github を探せば簡単に出てくる、 *なんてことはない* ので、
ある程度の規模のテストコードというのは貴重になります。

セルフホスティングしていると、
自分自身のコードが貴重なテストコードになるのです。

「自分自身のコードがそのままテストコードになる」と言っても、
それだけでは十分なテストにはなりません。
使用する構文やデザインパターン等に偏りが出てしまい、
網羅性という意味ではイマイチなテストになってしまいます。
また、コンパイルエラーになるようなコードは、
セルフホスティングしている自分自身のコードに仕込んでおけません。
よって、セルフホスティングしている自分自身のコードだけでは
テストケースとして不十分であり、
網羅的に正常系を確認するテストと、
コンパイルエラーを検出する異常系のテストが別途必要になります。

この、正常系と、異常系のテストは、
予め期待値を用意しておくことで、テストの成否を確認出来ます。

一方で、「自分自身のコードをコンパイルした結果が正しいかどうか」、
をどのように判定すれば良いか？が問題です。

普通のテストケースのコードは不変なので、そのコンパイル結果も不変です。
つまり、テストケースと期待値のペアを一度作成すれば、
テストケースを変更しないかぎりは同じ期待値を使い続けられます。

一方で、セルフホスティングしている自分自身のコードは当然変っていきます。
つまり、期待値も常に変わるため、期待値を事前に用意しておくことは不可能です。

では、セルフホスティングしている自分自身のコードのコンパイル結果が正しいかどうかを、
どのように判断するのかというと、 LuneScript では次が成り立つかどうかで判断しています。

: 使用中のコンパイラでのテストケースの結果 == 新しくコンパイルしたコンパイラでのテストケースの結果


これは、使用中のコンパイラが正しい動作をしていることを前提に、
その正しい動作をしている使用中のコンパイラで実行したテストケースの結果と、
新しくコンパイルしたコンパイラで実行したテストケースの結果が同一であるならば、
新しくコンパイルしたコンパイラも正しい、という論理です。


さらに、新しくコンパイルしたコンパイラで、もう一度自分自身をコンパイルしています。
これは、同じコードをコンパイルしたときに、
その出力結果が全く同じ結果になることを確認するために実行しています。

以上をまとめると、 LuneScript のテストは次を実行します。

- 現在使用中のコンパイラ A を使って、セルフホスティングしている自身のコードをコンパイルしコンパイラ B を生成
- コンパイラ B を使って、再度自身のコードをコンパイルしコンパイラ C を生成
- コンパイラ B とコンパイラ C が同一であることを確認
- コンパイラ A の正常系、異常系のテストを実行し、テスト結果を result A に保存
- コンパイラ C の正常系、異常系のテストを実行し、テスト結果を result C に保存
- result A と result C が同一であることを確認

上記テストをパスしたら、コンパイラ C を最新のコンパイラ A として利用します。

このテストにより、
新しくビルドしたコンパイラが正常に動作することを確認でき、
安全に言語の機能拡張を進められます。

* ここまでやっても、バグは残る

独自言語開発で実施しているテストについて紹介しましたが、
残念ながらここまでテストをしてもバグは残ります。

そのバグの原因を多い順に分類すると次のようになります。

- 異常系が検出できないケース
- 本来正常に動作しなければならないのに動作しないケース

上記の 2 つの内、異常系が検出できないケースが圧倒的に多いです。

というのも、
正常系のパスは言語仕様通りのコードを書いて動くことを確認すれば良いのに対し、
異常系のパスは言語仕様から外れたコードを書いてエラーを検出する必要があります。

この「言語仕様から外れる」というのが結構難しく、穴が空いてしまうことが多いです。

最初から完璧なテストを求めるのではなく、
こういう「穴」を見つけ、
それを塞ぐテストケースを追加していき、
再度同じ「穴」が開いた時に検出できるように対応することが
テストでは重要だと考えます。

以上。
