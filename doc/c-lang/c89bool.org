# -*- coding:utf-8 -*-
#+AUTHOR: ifritJP
#+STARTUP: nofold
#+OPTIONS: ^:{}

#+TITLE: C89 での bool の扱い

これは C 言語 Advent Calendar 2018 の記事です。


[[https://qiita.com/advent-calendar/2018/lunescript][LuneScript]] の Advent Calendar 作成の合間に、
ちょっくら C 言語 Advent Calendar にお邪魔します。



「C 言語」といっても、それが何を指すのか明確ではありません。
なぜなら「C 言語」には C89, C90, C99, C11 の規格があるからです。

ただ、日本国内において「C 言語」といった場合は、C89 を指すことが多いように思います。
というか、 C90, C99, C11 の存在を知らないエンジニアが多いのではないでしょうか？

まぁ私自身、普段全く縁の無い複素数の _Complex 型が C99 で追加になっていると言われても、
「へぇ〜」としか思いませんし、規格を意識していないこと自体は珍しくないと思います。

で、この記事の本題は C89 に関するネタです。

2018 年に C89 のネタを書くのもどうかと思いますが、
温故知新ということで時間のある方はお付き合いください。

* C89 でのコードレビューのシーン

次のように引数に与えられた整数が奇数かどうかを判定する関数を作成したとします。

#+BEGIN_SRC c
bool_t isOdd( int val ) {
    if ( ( val % 2 ) == 0 ) {
        return FALSE;
    }
    return TRUE;
}
#+END_SRC

この isOdd() 関数を使って、 1 〜 10 の値の内、
奇数だけを表示するプログラムを作成すると、次のように書けます。

#+BEGIN_SRC c
    int count = 0;
    for ( count = 1; count <= 10; count++ ) {
        if ( isOdd( count ) ) {
            printf( "%d ", count );
        }
    }
#+END_SRC

以前(といってもつい最近ですが)、
上記のようなコードをレビューしたとき、次のような指摘がありました。

 「if ( isOdd( count ) ) ではなく、if ( isOdd( count ) == TRUE ) にすべき」

たぶん多くの方は、「何言ってんの？」と思うのではないでしょうか？

イマドキの言語では、この指摘とは全くの逆で、
「if ( isOdd( count ) == TRUE ) ではなく、if ( isOdd( count ) ) にすべき」のはずです。

しかし C89 においては、その指摘が全くの間違いとは言い切れないというのが実情です。

何がどうしてこう言う指摘がなされてしまうのか、を次で説明します。

* C89 での論理値型の扱い

皆さんご存知の通り、 C89 には論理値型はありません。 (知らない？)

論理値型の _Bool は、C99 で追加されました。

では、「C89 ではどのように論理値を扱うのか？」というと、
各プロジェクト毎に次のような定義をするのが一般的だと思います。

#+BEGIN_SRC c
typedef int bool_t;
#define FALSE 0
#define TRUE 1
#+END_SRC

ここで ~typedef int bool_t;~ ではなく、 ~typedef char bool_t;~ とか、
~typedef enum { FALSE, TRUE } bool_t;~ とか、
いくつかバリエーションはあるかと思いますが、
今回のネタの趣旨とは外れるので、そこはつっこまないでください。

そして、ここから次の論理が導き出されます。

- isOdd() の戻り値型の bool_t は、 C 言語で規定された型ではなく、
  ユーザが定義した型である。
- TRUE/FALSE についても同様である。
- よって、どの場面に置いても「TRUE が 0 以外で、 FALSE が 0 となる」保証はない。
- つまり、isOdd() の結果をそのまま条件として使用するのは危険である。
  
というのが、指摘の根拠です。

まぁ、 bool_t と TRUE/FALSE がユーザ定義であることは確かにその通りです。
しかし、最後の「TRUE が 0 以外で、 FALSE が 0 となる保証がない。」は、
根拠としてあまりにナンセンスです。

「TRUE が 0 以外で、 FALSE が 0 となる保証がない。」がまかり通るなら、
「特に意味なく、なんとなく TRUE/FALSE ってキーワードを定義しちゃった。てへへ」と、
言っているのと同レベルです。

確かに TRUE/FALSE はユーザ定義なので、
C89規格で「TRUE が 0 以外で、 FALSE が 0 」と保証されていません。
しかし、規格としての保証がないにしても、
ユーザ定義自体はプロジェクトでコントロールできるものなので、
プロジェクトで「TRUE が 0 以外で、 FALSE が 0」を保証すれば良いだけの話です。

もしもそれが保証できないなら、そもそも TRUE/FALSE を定義をするべきではありません。

そんな保証すら出来ないものに TRUE/FALSE なんていうあまりにも一般的なキーワードを使うなんて
あってはならないです。

つまり、「if ( isOdd( count ) ) ではなく、if ( isOdd( count ) == TRUE ) にすべき」という
指摘はナンセンスです。
もしもこのような指摘をされた場合は、論理的に反論しましょう。

なお、これが TRUE/FALSE ではなく MODE1/MODE2 を返す関数であれば、
~if ( isOdd( count ) )~ とするのではなく、
~if ( isOdd( count ) == MODE1 )~ で判定するのは当然で、
レビューの指摘はごもっともです。
ついでにいうと、TRUE/FALSE ではなく MODE1/MODE2 を返す関数であれば、
関数名が ~is~ で始まるのも NG だと思いますが。。。

* まとめ

結局この記事でなにが言いたかったかというと、
C89 は論理値型一つとっても、こんなくだらないことが起り得ます。

2018 現在、C89 を使う機会はかなり減っているとは思いますが、
使用する際は十分注意しましょう。
