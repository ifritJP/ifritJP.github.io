#+TITLE: A. LuneScript の言語仕様でミスだったと思っているところ
# -*- coding:utf-8 -*-
#+AUTHOR: ifritJP
#+STARTUP: nofold
#+OPTIONS: ^:{}
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="org-mode-document.css" />

LuneScript は、自分の中で初の本格的なプログラミング言語開発の経験でした。

自分なりにさまざまな言語を調べ、
できるだけ使い勝手の良い言語になるよう設計をしてきましたが、
それでも「ここは良くなかった」と思う点は幾つかあります。

ここではそれらの点を挙げて、どうするべきだったかをまとめます。

LuneScript はトランスコンパイラなので、一般的なプログラミング言語としての話だけでなく、
トランスコンパイラ特有の話も挙げます。

* 基本的な記号(=?=)を、あまり重要でない機能に使ってしまった

LuneScript は、ある文字の文字コードを取得する際に、 =?= を使います。

例えば =a= の文字コード 0x61 を取得するには、以下のように書きます。

#+BEGIN_SRC lns
// @lnsFront: ok
let code = ?a; // (0x61)
#+END_SRC

簡単に文字コードを取得できる、という意味では良いのですが、
「文字コードを取得する」という制御が必要になるケースは、
一般的なプログラミングにはほとんどありません。

そのほとんど使用しないケースに =?= を使ってしまったため、
別の言語機能に記号を紐付けたいときに =?= が使えなくなってしまいました。

ASCII コードで利用可能な記号において、

- パッと見の認識しやすい文字
- キーボードからタイプしやすい文字
- 他のプログラミング言語の基本的な制御で利用されていない文字
  
上記の条件を全て満す記号は次しかありません。 (人によって多少増減すると思います)

: # $ ? \ & @ !

この貴重な記号を、ほとんど使わない機能に割り当ててしまったのは大きな失敗でした。

特に「 =?= の直後の文字のコードを取得する」という仕様では、
~==~ や ~>=~ などの記号の組み合わせの中に =?= を含めて使用することも出来ません。

Parse に影響するような仕様(immediate な文字列表現、数値表現、etc...) をプログラミング言語に取り込む際は、
十分に注意が必要でした。


* トランスコンパイル先の Lua に影響を受け過ぎた

当初の LuneScript は、Lua 専用のトランスコンパイラでした。

当然 LuneScript の想定ユーザは、 Lua プログラマです。

よって、LuneScript は Lua のプログラマが扱い易いように言語仕様を定義しています。

これには次のメリットがあります。

- LuneScript の学習コストが低い
- LuneScript で書いたコードを Lua へ変換する際に、
  多くの場合そのままの形で変換でき、変換後のコードを追い易い

しかし、次のものに関しては、Lua とは異なる仕様にするべきでした。

- List などのインデックスが 0 からではなく 1 から始まる
- =~== や =..= などの独特な演算子
- and or の演算結果
- 多値返却の動作


この中で、最初の 2 個のインデックスと、 =~== や =..= などの独特の演算子に関しては、
他の一般的なプログラム言語との仕様が違うので使い分けしないとならない、
という使い勝手の問題です。

一方で、残りは Lua 以外へのトランスコンパイル処理を考えた時に処理が複雑になってしまう、
という問題です。
処理が複雑になることで、変換後のコードを追い難くなるのと、
変換後のコードの実行時にオーバーヘッドが掛る、ということにつながります。

トランスコンパイラとはいえ一つの独立したプログラム言語であるので、
変換先の言語を意識し過ぎずに、自分が理想とする言語仕様を検討するべきでした。

* immutable のデフォルト

変数やメンバなどの型を宣言する際、 
=&= を型名の前に付けると immutable を示します。
そして、 =&= を付けずに型名だけの場合は mutable です。

#+BEGIN_SRC lns
let val:&List<int> = [ 1, 2 ];  // immutable list
let val:List<int> = [ 1, 2 ];   // mutable list
#+END_SRC

一方で、変数宣言で型推論を使った初期化を行なうと、
=mut= を変数名の前に付けるとその変数と型が mutable になります。
そして、 =mut= を付けないと変数と型が immutable になります。

#+BEGIN_SRC lns
let mut val = [ 1, 2 ];  // mutable list
let val = [ 1, 2 ];   // immutable list
#+END_SRC

修飾子の有無によって型の mutable が変わるのですが、
mut と & とで mutable の動作が逆になってしまっています。

これは、非常に紛らわしいです。

何故こうなってしまったかというと、
当初は Rust のような所有権制御を実現したかったんですが、
所有権制御を実現する前にトランスコンパイラとして動かすことを優先したため、
型の制御を中途半端なまま実装をしてしまい、
その動作が今も残っている、という状況です。

mutable 制御は、現状の仕様のまま残すしかないですが、
所有権制御は何らかの形で実現したいと思っています。

* イマドキではない仕様

LuneScript にはイマドキではない仕様がいくつかありますが、
それらは敢えてそうしています。

- 文の区切りに =;= が必要
- シンボルのアクセス制限


比較的新しい言語では =;= がない方が主流なような気がしますが、
=;= があった方が確実に文が終っていることが、
ぱっと見で、分かり易いと考えているので、あえて必須にしています。

