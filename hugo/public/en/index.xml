<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>tech</title>
    <link>https://ifritjp.github.io/documents/en/</link>
    <description>Recent content on tech</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language><atom:link href="https://ifritjp.github.io/documents/en/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>01. Introduction</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/tutorial2.setup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/tutorial2.setup/</guid>
      <description>This time, it is an introduction about how to introduce LuneScript. LuneScript on Web Browser A LuneScript environment that runs on a web browser is provided for checking LuneScript operations. ../onweb Also, the following sample sources have a case with a Run button. By pressing that button, you can run that sample source. And you can modify the source and run it. It takes several seconds to 10 seconds for</description>
    </item>
    
    <item>
      <title>02. Hello world</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/tutorial3.hello/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/tutorial3.hello/</guid>
      <description>This time, it is an introduction of Hello world using LuneScript.
lnsc command Installing LuneScript installs the lnsc command.
Use the lnsc command as follows:
$ lnsc src.lns exe where src.lns is the path of the script created with LuneScript. exe is an option for lnsc and means to run the specified script.
Hello world Now let&amp;#39;s run the traditional Hello world using LuneScript.
Create a file hello.lns with the following contents:</description>
    </item>
    
    <item>
      <title>03. Cross-compiling between Lua versions</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/crosscompile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/crosscompile/</guid>
      <description>This time I will change the schedule a little and explain LuneScript cross-compilation.
cross compilation &amp;#34;Cross-compiling&amp;#34; here means &amp;#34;cross-compiling&amp;#34; between versions of Lua.
When LuneScript transcompiles to Lua, it will transcompile according to the Lua version running LuneScript.
For example, the following controls are performed.
When running on Lua5.2, bit operations use the bit32 library. When running in Lua5.3, bitwise operations make use of Lua&amp;#39;s built-in operators. Cross-compiling will transcompile the emitted Lua code to the specified Lua version instead of the Lua version running LuneScript.</description>
    </item>
    
    <item>
      <title>04. Values</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/value/</guid>
      <description>This time, I will explain the values that can be handled by LuneScript. value type Here is a correspondence table between the value types that can be handled by LuneScript and the Lua values after the transcompiler. LuneScript Lua go Usage How to define in LuneScript nil, null nil nil nil nil int numerical value LnsInt integer 0 1 2 3 ?A 0x10 -100 real numerical value LnsReal real number</description>
    </item>
    
    <item>
      <title>04.2. Set</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/set/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/set/</guid>
      <description>This section describes how to handle a set of LuneScript values, Set.
Difference between Set and Map A Set manages a set of values, and a Map manages the association between values.
When both are converted to Lua, they are managed as tables, so there is no advantage in using Set over Map in terms of execution speed or memory.
However, using a Set instead of a Map has the following effects:</description>
    </item>
    
    <item>
      <title>04.3 Tuples</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/tuple/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/tuple/</guid>
      <description>This section describes how to handle tuples, which are combinations of values.
Tuples are available since v1.5.3.
tuple constructor A tuple creates an object by writing:
// @lnsFront: ok let obj = (= 1, &amp;#34;abc&amp;#34; ); // 1 &amp;#34;abc&amp;#34; This is a tuple that holds pairs of values 1, &amp;#34;abc&amp;#34;.
A tuple encloses values in (= ).
Must always specify at least one data
Tuple type declaration The above processing omits the type declaration by type inference, but if you do not omit it, write as follows.</description>
    </item>
    
    <item>
      <title>05. enum</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/enum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/enum/</guid>
      <description>In this article, we will discuss enum values in LuneScript.
enum LuneScript enum allows you to name and manage a set of values.
The types of values that can be handled as an enum are as follows.
int real str The range of one enum can be defined from multiple values, but the value types must be the same.
In other words, an enum with int values cannot define real or str values.</description>
    </item>
    
    <item>
      <title>06. match</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/match/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/match/</guid>
      <description>LuneScript supports algebraic data types and pattern matching.
Algebraic data type (alge type) enum types can group int, real, or str values to limit their range.
Algebraic data types, on the other hand, are a more general version of enum types, and can group all types, not just int, real, and str.
Algebraic data types are declared with the alge keyword.
For example:
// @lnsFront: ok class Hoge { pri let val:int {pub}; } alge Test { Val1, Val2( int ), Val3( str ), Val4( Hoge ), Val5( num:int, txt:str ), } This example declares an alge type Test .</description>
    </item>
    
    <item>
      <title>07. Variables</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/variable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/variable/</guid>
      <description>This time, I will explain about LuneScript variables. variable LuneScript is a statically typed language and variables have types. Variables are declared with let like this: // @lnsFront: ok let val:int = 1; The above example declares a variable val with an int of 1 as its initial value. After the variable name, specify the type. Note that if the initial value is set to real 1.0 instead of int</description>
    </item>
    
    <item>
      <title>08. General branch syntax</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/branch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/branch/</guid>
      <description>This time I will explain the general branching syntax of LuneScript. Syntax list LuneScript supports the following general branching syntax. if switch By the way, the reason why I dare to call it &amp;#34;general&amp;#34; branch control here is that there is separate branch control in nilable control. if The if statement is used like this: // @lnsFront: ok let val = 1; if val == 1 { print( &amp;#34;hoge&amp;#34; );</description>
    </item>
    
    <item>
      <title>09. Repetition Syntax</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/loop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/loop/</guid>
      <description>This time I will explain the repeat syntax of LuneScript.
Syntax list LuneScript supports the following repeat syntaxes:
while repeat (to be removed in the future) for apply foreach forsort while, repeat Use while, repeat like this:
// @lnsFront: ok let mut val = 1; while val &amp;lt; 10 { val = val + 1; } print( val ); // 10 repeat { let mut endFlag = false; val = val + 1; if val &amp;gt;= 20 { endFlag = true; } } endFlag; print( val ); // 20 while will process the block while the expression is true, and repeat will process the block while the expression is false.</description>
    </item>
    
    <item>
      <title>10. Functions</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/func/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/func/</guid>
      <description>This time, I will explain the function of LuneScript.
Function definition LuneScript functions are defined like this:
// @lnsFront: ok fn add_sub( val1:int, val2:int ): int, int { return val1 + val2, val1 - val2; } print( add_sub( 1, 2 ) ); // 3, -1 The example above defines the following functions:
definition function name add_sub First argument name val1 First argument type int Second argument name val2 Second argument type int primary return type int Secondary return type int LuneScript can return multiple return values.</description>
    </item>
    
    <item>
      <title>10.2. Multi-value return values</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/multipleretval/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/multipleretval/</guid>
      <description>LuneScript supports multi-valued function return values.
For example, a function can return multiple values like this:
// @lnsFront: ok fn func(): int,int { return 1, 2; } print( func() ); // 1 2 In the example above, func() returns 1 and 2. This multi-valued return value is passed as is as an argument to print().
Multi-valued return values are very useful, but there are still very few languages with multi-valued return values.</description>
    </item>
    
    <item>
      <title>10.3. Omitting Arguments</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/defaultarg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/defaultarg/</guid>
      <description>LuneScript can omit nilable type arguments when calling functions.
For example, the following function func() can be called without arguments.
// @lnsFront: ok fn func( val1:int!, val2:int! ):int { when! val1, val2 { return val1 + val2; } when! val1 { return val1; } when! val2 { return val2; } return 0; } print( func(1,2) ); // 3 print( func(1) ); // 1 print( func() ); // 0 The problem here is that func(1) and func() cannot determine whether they intentionally omitted the argument or forgot to specify it.</description>
    </item>
    
    <item>
      <title>10.4. Variadic Arguments and Return Values</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/arg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/arg/</guid>
      <description>variable length arguments, return value By using … for arguments and return values, functions with variable length arguments and variable length return values can be defined.
Here&amp;#39;s a sample that makes use of …
// @lnsFront: ok fn func( ... ) : int, ... { let argList = [ ... ]; let mut total = 0; foreach arg in argList { when! arg { total = total + arg@@int; } } return total, .</description>
    </item>
    
    <item>
      <title>10.5. Closures</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/closure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/closure/</guid>
      <description>LuneScript supports closures.
// @lnsFront: ok fn func( mut val:int ): form { return fn () { val = val + 1; print( val ); }; } let sub1 = func( 10 ); sub1(##); // 11 sub1(##); // 12 sub1(##); // 13 sub1(##); // 14 let sub2 = func( 100 ); sub2(##); // 101 sub2(##); // 102 sub2(##); // 103 sub2(##); // 104 The above function func() is a function that creates and returns a closure.</description>
    </item>
    
    <item>
      <title>10.6. Error handling</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/error/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/error/</guid>
      <description>This section describes LuneScript error handling.
error handling Currently LuneScript does not support global exits.
If any error occurs, the error should be notified in the return value of the function.
There are two main methods of error notification:
Use nilable and represent errors with nil. Use the alge type __Ret. When to use nilable By using nilable as the return value of a function, you can express the error of that function.</description>
    </item>
    
    <item>
      <title>11. nilable</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/nilable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/nilable/</guid>
      <description>This time I will explain nilable in LuneScript.
What is nilable LuneScript has a value of nil.
As mentioned earlier, variables of type stem can hold any type except nil .
// @lnsFront: error let mut val:stem = 1; val = 1.0; val = &amp;#34;abc&amp;#34;; val = {}; val = []; val = [@]; val = nil; // error So how can we keep nil ? Use stem! instead of stem .</description>
    </item>
    
    <item>
      <title>12. Class basics</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/class1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/class1/</guid>
      <description>LuneScript supports object-oriented programming through classes.
Class specification Classes in LuneScript support:
access control accessor Inheritance abstract override advertise Mapping interface Here is a basic class definition.
minimal class definition A minimal class definition looks like this:
// @lnsFront: ok class Test { } This defines a class called Test.
Note that the class definition must be done in the highest scope.
(2019/6/24) Added support for defining classes within functions.</description>
    </item>
    
    <item>
      <title>13. accessor</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/class2accessor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/class2accessor/</guid>
      <description>This time, I will explain member accessors.
accessor You can easily create accessors (get,set) for members.
For example:
// @lnsFront: ok class Test { pri let val1:int; pri let mut val2:int {pub,pub}; pri let val3:int {pub}; } let mut test = new Test( 1, 2, 3 ); print( test.$val2, test.$val3 ); // 2 3 test.set_val2( 10 ); print( test.$val2, test.$val3 ); // 10 3 The definition of val2 in the above example is pri let val2:int {pub,pub};.</description>
    </item>
    
    <item>
      <title>14. Class Inheritance</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/classinherit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/classinherit/</guid>
      <description>LuneScript supports class inheritance.
class inheritance Here is an example of class inheritance:
// @lnsFront: ok class Super { pub fn func() { print( __func__ ); } } class Sub extend Super { } let sub = new Sub(); sub.func(); // Super.func This is an example of a Super class being inherited by a Sub class.
Inheritance specifies the parent class to inherit from using extend when declaring the class.</description>
    </item>
    
    <item>
      <title>15. Class advertise</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/classadvertise/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/classadvertise/</guid>
      <description>LuneScript allows transparent access to methods of members held by classes.
advertise I think the expression &amp;#34;transparent access&amp;#34; is difficult to convey, so I will explain it with the following example.
// @lnsFront: ok abstract class Test { pub abstract fn foo(): str; pub abstract fn bar(): str; } class TestSub1 extend Test { pub override fn foo(): str { return &amp;#34;foo&amp;#34;; } pub override fn bar(): str { return &amp;#34;bar&amp;#34;; } } class TestSub2 extend Test { pri let sub:TestSub1; advertise sub; pub override fn bar(): str { return &amp;#34;hoge&amp;#34; .</description>
    </item>
    
    <item>
      <title>16. Class override</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/classoverride/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/classoverride/</guid>
      <description>LuneScript supports method overrides.
method override All methods of a class can be overridden.
Rather, overrides cannot currently be suppressed.
Here&amp;#39;s an example method override:
// @lnsFront: ok class Super { pub fn func() { print( __func__ ); } } class Sub extend Super { pub override fn func() { print( __func__ ); } } fn test( obj:Super ) { obj.func(); } test( new Super() ); // Super.func test( new Sub() ); // Sub.</description>
    </item>
    
    <item>
      <title>17. Interface</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/interface/</guid>
      <description>LuneScript does not support multiple inheritance of classes, but does support interfaces.
interface If you&amp;#39;ve used Java or C#, you&amp;#39;ll be familiar with it, but you can think of an interface as a class with limited functionality.
Specifically, interfaces differ from classes in the following ways:
The declaration is an interface, not a class. has no members. All methods are abstract. Therefore, an interface cannot be instantiated by itself. A class that implements an interface has () in its extend A class can implement multiple interfaces Don&amp;#39;t put override on the method of the class that implements the interface.</description>
    </item>
    
    <item>
      <title>18. mapping</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/classmapping/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/classmapping/</guid>
      <description>LuneScript supports converting instances of classes to and from maps.
mapping LuneScript supports converting instances of classes to and from map objects.
Specifically, you can:
Create map object from class instance Creating an instance of a class from a map object This allows you, for example, to generate JSON data from class instances and vice versa.
This feature is called mapping.
To make use of mapping , we need to declare Mapping as an interface to implement when declaring the class.</description>
    </item>
    
    <item>
      <title>19. generics</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/generics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/generics/</guid>
      <description>Here we describe the generics that LuneScript supports.
LuneScript originally supported generics only for the built-in types List/Array/Map, but now supports generics for user-defined functions and classes as well.
function Declare the generics for the function like this:
// @lnsFront: ok fn func&amp;lt;T&amp;gt;( val:T ) : Set&amp;lt;T&amp;gt; { return (@ val); } As you can probably understand by looking at the above sample, when declaring a function, declare it with the function name + &amp;lt;formal type parameter&amp;gt;.</description>
    </item>
    
    <item>
      <title>19.2. generics (two collection types)</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/generics-go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/generics-go/</guid>
      <description>From LuneScript v1.6.0, the handling of collection type generics has increased.
This mainly affects when converting to go , not when using the conversion to lua .
Before explaining this new collection type, let&amp;#39;s explain the old collection type.
Traditional collection type LuneScript supported generics in 2019.
On the other hand, go supports generics since version 1.18 (2022).
And LuneScript supported transcompiling to go in 2020, around this time go 1.</description>
    </item>
    
    <item>
      <title>20. nil conditional operator</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/nilcond/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/nilcond/</guid>
      <description>This time I will explain LuneScript&amp;#39;s nil conditional operator.
Map access For example, if you have the following Map data,
// @lnsFront: ok let json = { &amp;#34;lv1&amp;#34;: { &amp;#34;lv2&amp;#34;: { &amp;#34;lv3&amp;#34;: { &amp;#34;lv4&amp;#34;: { &amp;#34;lv5&amp;#34;: { &amp;#34;val&amp;#34;: 1 } } } } } }; To access the val of lv5 you have to do something like this:
// @lnsFront: skip if! let lv1 = json.lv1 { if! let lv2 = lv1.</description>
    </item>
    
    <item>
      <title>21. import/provide</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/import/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/import/</guid>
      <description>This time, I will explain LuneScript module management.
module Module management in LuneScript is basically the same as in Lua.
Here are the differences from Lua:
Unless otherwise declared, each file is a module. The file name extension is .lns, and the name without .lns is the module name. init.lns is not supported. File names of LuneScript built-in keywords (class, etc.) are not supported. Just in case, I&amp;#39;ll cover the common parts of LuneScript and Lua module management.</description>
    </item>
    
    <item>
      <title>22. require/module</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/require/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/require/</guid>
      <description>This time I will explain how to handle Lua modules from LuneScript.
require Use require() when dealing with Lua modules.
The specification of require() is the same as Lua, but the return value is stem. that is, it has no type information. A proper cast is required.
module As above, require() returns a stem.
Since stem has no type information, it is not very useful.
So we use the module declaration.</description>
    </item>
    
    <item>
      <title>22.1. Semi-automatic generation of glue code</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/glue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/glue/</guid>
      <description>Lua&amp;#39;s external modules have two cases:
A case composed of Lua scripts When using Native Library such as C In order to use Native Library from Lua, glue is needed to bridge the interface for Lua.
LuneScript has a function to generate this glue semi-automatically.
LuneScript&amp;#39;s automatic glue generation function is not a function that automatically generates Lua glue from C/C++ sources such as swig, but a function that automatically generates glue code for modules declared in LuneScript.</description>
    </item>
    
    <item>
      <title>22.2. Linking with Lua</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/lua/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/lua/</guid>
      <description>LuneScript can execute Lua code. However, running Lua code requires some attention. In the following, I will explain points to note when executing Lua code on LuneScript. Run Lua code In LuneScript, Lua code can be executed from within LuneScript by using functions such as _load(). The _load() function has basically the same specifications as lua&amp;#39;s load() function. A sample is shown below. // @lnsFront: ok let code = ```</description>
    </item>
    
    <item>
      <title>23. Build</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/make/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/make/</guid>
      <description>This time, I will explain how to build a project that uses LuneScript.
+LuneScript provides a transcompiler to use from the command line,++We do not provide build tools specifically for LuneScript.++Therefore, the general build method is explained here.
There are the following methods to transcompile LuneScript.
individual build batch build Batch build transcompiles multiple .lns files at once.
individual build To transcompile to Lua, run the following command:
$ lnsc hello.</description>
    </item>
    
    <item>
      <title>24. Macro</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/macro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/macro/</guid>
      <description>This time, I will explain about LuneScript macros.
macro LuneScript supports macros.
Maybe it&amp;#39;s easier to say &amp;#34;metaprogramming&amp;#34; than &amp;#34;macro&amp;#34; these days.
To explain &amp;#34;what is a macro&amp;#34;, I think it will be easier to understand if you explain the difference from a function.
A function is a collection of operations. On the other hand, macros can define multiple function definitions themselves collectively. Of course, what can be defined as a macro is not only function definitions, but almost all processes can be defined.</description>
    </item>
    
    <item>
      <title>25. Cast</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/cast/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/cast/</guid>
      <description>LuneScript offers three types of casting.
@@ @@@ @@= @@ @@ forces a type conversion without checking the type of the source value at runtime.
// @lnsFront: ok let val1:stem = 1; let val2:int = val1@@int; Forced casting can also be performed on values that cannot be converted originally, such as the following.
// @lnsFront: ok let val1:stem = 1; let val2:str[] = val1@@str[]; print( #val2 ); // runtime error The above assigns the value 1 of type int to val1 of type stem and casts it to val2 of type str list.</description>
    </item>
    
    <item>
      <title>26. subfile</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/subfile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/subfile/</guid>
      <description>As the processing of the module grows, the file grows accordingly.
A bloated file is not a good thing, so in such a case the common refactoring is to subdivide the responsibilities of the modules and separate the files for each module.
However, there are many cases where the responsibilities cannot be divided cleanly, or the influence on other modules becomes large when the responsibilities are divided. Subfiles are used as an alternative when module division is not possible.</description>
    </item>
    
    <item>
      <title>27. Lazy Loading</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/lazyloading/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/lazyloading/</guid>
      <description>A project of any size will import multiple modules. And another module is imported within the imported module.
Import in scripting languages means dynamic loading. When you start a script, after all the modules used by the script have been loaded, the script&amp;#39;s main process finally starts.
For example, if there is an import relationship as shown in the following figure, the main mod module will be processed after all related modules have been loaded.</description>
    </item>
    
    <item>
      <title>28. shebang and command line arguments</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/shebang_main/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/shebang_main/</guid>
      <description>LuneScript supports shebangs.
shebang correspondence Shebang is a function that specifies the interpreter to be used by specifying the interpreter to be used as a comment in the first line of a script file often seen in shell scripts, etc., and the specified interpreter is executed when the script file is executed. For example in bash you would specify:
#! /bin/bash In LuneScript, specify:
#! /usr/bin/lnsc -shebang Here, /usr/bin/lnsc must be specified according to the environment.</description>
    </item>
    
    <item>
      <title>29. Recommended directory structure for projects using LuneScript</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/dir/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/dir/</guid>
      <description>LuneScript supports transcompiling to lua and go. On the other hand, lua and go have different directory management methods. This section describes the recommended directory structure that can be used without problems in directory management for either language. premise Here, we will explain on the assumption that you will develop with the following github repositories. github.com/HOGE/PROJ HOGE is any github account name. PROJ is any repository name. Also, the explanation</description>
    </item>
    
    <item>
      <title>80. Transcompiling to Go Language</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/go/</guid>
      <description>LuneScript can be transcompiled to Go as well as Lua as a transcompiled language. With this feature, LuneScript&amp;#39;s self-hosting code is transcompiled into go language code and built with go to speed up LuneScript (approximately 16 times). See below for acceleration. https://ifritjp.github.io/blog2/public/posts/2021/2021-06-28-lunescript-build-time-2000/ However, since the support is limited to the functions required for LuneScript self-hosting, some functions are not supported. However, LuneScript&amp;#39;s self-hosting itself uses most of LuneScript&amp;#39;s features, so</description>
    </item>
    
    <item>
      <title>80.2 Packages when transpiling to Go</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/go_package/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/go_package/</guid>
      <description>Modules that are packaged by go can be used from LuneScript.
package management overview for go go manages packages with go.mod.
This go.mod -managed package is cached in the local directory specified by the environment variable GOPATH .
LuneScript can take advantage of this cached module.
To use the package on github with go, write as follows.
import &amp;#34;github.com/ifritJP/lnshttpd&amp;#34; In the same sense, LuneScript can access go modules.
import To import the .</description>
    </item>
    
    <item>
      <title>80.4 WebAssembly support for LuneScript</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/go_wasm/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/go_wasm/</guid>
      <description>There are two ways to run code created in LuneScript on a web browser.
Transcompile from LuneScript to Lua and run the Lua code with fengari etc. Transcompile from LuneScript to go and convert that go code to WebAssemly Here&amp;#39;s how to convert from go to WebAssemly.
Converting from go to Web Assemblies Converting from go to WebAssemly takes advantage of go functionality.
For the basic flow of how to use WebAssembly in go, please refer to the following official document.</description>
    </item>
    
    <item>
      <title>81. Safe Asynchronous Processing</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/async/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/async/</guid>
      <description>With the support of transcompiling from LuneScript to go language, asynchronous processing by LuneScript is now supported.
It has a simple function to statically eliminate data races.
__Runner interface To do asynchronous processing in LuneScript, implement the __Runner interface.
The __Runner interface is of type: __async is discussed later.
// @lnsFront: skip pub interface __Runner { pub fn run() __async mut; } By implementing this interface, you can take advantage of the new built-in functions __run(), __join().</description>
    </item>
    
    <item>
      <title>81.1 Asynchronous processing (past information)</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/async_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/async_old/</guid>
      <description>With the support of transcompiling from LuneScript to go language, asynchronous processing by LuneScript is now supported. However, this is very experimental content, so please use it only as a reference. Deprecated since 1.3.0. This document will be retained as a past log. LuneScript runtime LuneScript has a runtime to bridge the gap between the LuneScript language specification and the transcompiled language specification. For example, when transcompiling to go, the</description>
    </item>
    
    <item>
      <title>82. Linking with Lua</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/luago/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/luago/</guid>
      <description>LuneScript can execute Lua code.
This feature is preserved even after transpiling to the go language, but there are some caveats.
Be especially careful when combining asynchronous processing with lua code execution.
Luaval As already explained in the link destination, the result of lua is managed by Luaval type.
../lua
This Luaval type data has the following restrictions.
The Lua VM executed when retrieving a certain Luaval type data dataA and the Lua VM executed when accessing that dataA must be the same Lua VM.</description>
    </item>
    
    <item>
      <title>A. BNF</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/ebnf/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/ebnf/</guid>
      <description>&amp;lt;comment&amp;gt; ::= &amp;#34;//&amp;#34; &amp;lt;anytoken_br&amp;gt; | &amp;#34;/*&amp;#34; &amp;lt;anytoken&amp;gt; &amp;#34;*/&amp;#34; &amp;lt;code&amp;gt; ::= [&amp;lt;shebang&amp;gt;] {&amp;lt;code_header&amp;gt;} {&amp;lt;stmt&amp;gt;} &amp;lt;eof&amp;gt; &amp;lt;code_header&amp;gt; ::= &amp;lt;subfile&amp;gt; | &amp;lt;lune_control&amp;gt; | &amp;lt;import&amp;gt; &amp;lt;shebang&amp;gt; ::= &amp;#34;#!&amp;#34; &amp;lt;token&amp;gt; &amp;lt;anytoken_br&amp;gt; &amp;lt;import&amp;gt; ::= &amp;#34;import&amp;#34; &amp;lt;lazy_direct&amp;gt; [ &amp;#34;go&amp;#34; &amp;#34;/&amp;#34; ] &amp;lt;sym&amp;gt; { &amp;lt;import_dlmt&amp;gt; &amp;lt;sym&amp;gt; } [ &amp;#34;as&amp;#34; &amp;lt;sym&amp;gt; ] &amp;#34;;&amp;#34; &amp;lt;import_dlmt&amp;gt; ::= &amp;#34;.&amp;#34; | &amp;#34;:&amp;#34; &amp;lt;subfile&amp;gt; ::= &amp;lt;subfile_owner&amp;gt; | &amp;lt;subfile_sub&amp;gt; &amp;lt;subfile_owner&amp;gt; ::= &amp;#34;subfile&amp;#34; &amp;#34;owner&amp;#34; &amp;lt;module_path&amp;gt; &amp;#34;;&amp;#34; &amp;lt;subfile_sub&amp;gt; ::= { &amp;#34;subfile&amp;#34; &amp;#34;use&amp;#34; &amp;lt;module_path&amp;gt; &amp;#34;;&amp;#34; } &amp;lt;module_path&amp;gt; ::= &amp;lt;sym&amp;gt; { &amp;#34;.</description>
    </item>
    
    <item>
      <title>A. LuneScript running on a web browser</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/onweb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/onweb/</guid>
      <description>A LuneScript environment that runs on a web browser is provided for checking LuneScript operations.
The following two LuneScript environments are available.
Environment using fengari Environment using wasm of golang (latest) Environment using fengari https://ifritjp.github.io/LuneScript-webFront/lnsc_web_frontend/for_fengari/
The above link has three textareas:
For LuneScript code entry For execution result output For converting result output to Lua Enter LuneScript code in the textarea for entering LuneScript code and press the execute button to convert it to Lua and execute it.</description>
    </item>
    
    <item>
      <title>A. Reason for developing Lua transcompiler LuneScript</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/reason/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/reason/</guid>
      <description>Lua is a lightweight language with high execution performance. Lua&amp;#39;s name recognition is low compared to the same scripting languages such as Ruby, Python, and JavaScript, but it can be said that it is one of the most major languages that can be used for system expansion and is easy to embed. In fact, there are many systems that embed Lua.
In terms of execution performance, it is also one of the fastest scripting languages.</description>
    </item>
    
    <item>
      <title>A. Recommendations for transcompiler development</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/recommend/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/recommend/</guid>
      <description>The final article in the LuneScript Primer Advent Calendar takes a different approach and deals with transcompiler development itself.
Reasons for recommending transcompiler development I am developing a transcompiler called LuneScript.
Through this development, I feel that I was able to have a good experience as an engineer.
The reason for developing LuneScript is written in the following article.
../reason
I decided to write this article because I want as many people as possible to experience transcompiler development for the following reasons.</description>
    </item>
    
    <item>
      <title>A. Tag jumping with lnstags (source code tagging system)</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/lnstags/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/lnstags/</guid>
      <description>LuneScript supports tag jumps (source code tag system). What is a tag jump (source code tagging system)? A tag jump provides access to the following information in the source code. Definition position of symbol (class, function, variable etc..) Reference position of symbol (class, function, variable etc..) example An example is shown below. // @lnsFront: ok class Foo { pub fn func() { } } class Bar { pub fn func()</description>
    </item>
    
    <item>
      <title>A.Let&#39;s have more fun in a modern development environment</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/completion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/completion/</guid>
      <description>What editor do you use for Lua development?
A modern feature-packed environment like Lua Development Tools, Atom, VSCode? Or is it a classic environment like emacs or vim?
In either environment, are you unsatisfied with the completion function while coding Lua?
Lua&amp;#39;s completion function is pretty smart in many cases, but there are quite a few cases where completion doesn&amp;#39;t work, right?
Even just checking a little, it seems that completion does not work in the following situations.</description>
    </item>
    
    <item>
      <title>Box edition</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/box/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/box/</guid>
      <description>This is information under consideration. Not currently available. Nilable type As mentioned above, nilable cannot be specified for the actual type parameter of Generics. This restriction causes the following new Test( val ) to fail. // @lnsFront: skip class Test&amp;lt;T&amp;gt; { let val:T; } let val:int! = 1; let test = new Test( val ); // error There are two patterns to avoid this error. Use T! Use the Nilable</description>
    </item>
    
    <item>
      <title>Lua runtime when transpiling to 80.3 Go</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/lua_runtime/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/lua_runtime/</guid>
      <description>LuneScript is a project that started development as a Lua transcompiler. And in order to take advantage of Lua&amp;#39;s assets, LuneScript also supports actions linked with Lua.
This operation that links LuneScript and Lua is also available when transcompiling to go. In other words, it works in conjunction with Go and Lua.
To achieve this, we need to link the Go and Native lua runtimes. Even if the LuneScript code does not use the linked operation with Lua, the Lua runtime function is used internally, so the link with the Lua runtime cannot be separated.</description>
    </item>
    
    <item>
      <title>X. The Importance of Self-Hosting and Test Design in Language Development Quality Control</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/test/</guid>
      <description>If you are looking at this document, I think most of you are coding in a &amp;#34;programming language&amp;#34; every day. And there are probably many people who are busy with bug squashing work that someone else has put in place. The &amp;#34;programming language&amp;#34; that we are indebted to on a daily basis is also software created by someone else, so quality control is important to ensure that no bugs occur.</description>
    </item>
    
    <item>
      <title>Y.1 How to develop LuneScript</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/design/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/design/</guid>
      <description>Describe the development of LuneScript itself.
LuneScript has grown to a decent scale, and I have a hard time remembering it when I have time, so I leave it as a memorandum.
Of course, if other people are interested in developing LuneScript, that&amp;#39;s fine.
Development environment LuneScript development is done on Ubuntu. However, if you use Linux, you can build it if you prepare the environment a little.
Personally, I think Windows is an environment for playing with GUI tools, or an environment for using MS Office, not a programming environment.</description>
    </item>
    
    <item>
      <title>Y.2 Development of LuneScript (type information management)</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/design-2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/design-2/</guid>
      <description>Continuation of LuneScript development. Since the overview of each process in the flow has already been explained, this time we will go into a little internal explanation. type information Data types are important in programming. Especially since LuneScript is a statically typed language, you can understand the importance of data type management. Note that Ast.lns manages LuneScript data types. Some people may quibble about why the type management source is</description>
    </item>
    
    <item>
      <title>Y.3 LuneScript Development (Scopes and Symbols)</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/design-3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/design-3/</guid>
      <description>Continuation of LuneScript development.
Since the overview of each process in the flow has already been explained, this time we will go into a little internal explanation.
scope LuneScript is a common lexical scope.
Also, there are the following types of scopes:
built-in scope global scope In-module scope Built-in scopes manage built-in type symbols such as int and str , and built-in function symbols such as print() and string.format() .</description>
    </item>
    
    <item>
      <title>Z. Transcompile to Go language (exploratory stage)</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/go_study/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/go_study/</guid>
      <description>For information on transcompiling to Go language, please refer to the following article. ../go The information here is old, but I&amp;#39;ll keep it for reference. Considering transcompiling from LuneScript to Go language. This is where you record what you are discussing. aim The goals of transcompiling from LuneScript to Go language are as follows. Speeding up LuneScript LuneScript supports the code completion function, but it becomes heavy and inconvenient for</description>
    </item>
    
  </channel>
</rss>
