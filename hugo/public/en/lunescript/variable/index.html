<!DOCTYPE html>
<html lang="ja-jp">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>07. Variables - tech</title>
<meta name="generator" content="Hugo 0.111.3">
<link href="https://ifritjp.github.io/documentsindex.xml" rel="alternate" type="application/rss+xml">
<link rel="canonical" href="https://ifritjp.github.io/documents/en/lunescript/variable/">
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/theme.min.css">
<script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/chroma.min.css">
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js"></script>
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/custom.css">
<script src="https://ifritjp.github.io/documents/js/bundle.js"></script>
<script src="https://ifritjp.github.io/documents/js/lnsSrcRun.js"></script>
<script src="https://ifritjp.github.io/documents/js/highlight_lns.js"></script>
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/highlight_lns.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script><style>
:root {}
</style>
<meta property="og:title" content="07. Variables" />
<meta property="og:description" content="This time, I will explain about LuneScript variables. variable LuneScript is a statically typed language and variables have types. Variables are declared with let like this: // @lnsFront: ok let val:int = 1; The above example declares a variable val with an int of 1 as its initial value. After the variable name, specify the type. Note that if the initial value is set to real 1.0 instead of int" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ifritjp.github.io/documents/en/lunescript/variable/" /><meta property="article:section" content="LuneScript" />

<meta property="og:site_name" content="tech" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="07. Variables"/>
<meta name="twitter:description" content="This time, I will explain about LuneScript variables. variable LuneScript is a statically typed language and variables have types. Variables are declared with let like this: // @lnsFront: ok let val:int = 1; The above example declares a variable val with an int of 1 as its initial value. After the variable name, specify the type. Note that if the initial value is set to real 1.0 instead of int"/>
<meta itemprop="name" content="07. Variables">
<meta itemprop="description" content="This time, I will explain about LuneScript variables. variable LuneScript is a statically typed language and variables have types. Variables are declared with let like this: // @lnsFront: ok let val:int = 1; The above example declares a variable val with an int of 1 as its initial value. After the variable name, specify the type. Note that if the initial value is set to real 1.0 instead of int">

<meta itemprop="wordCount" content="2780">
<meta itemprop="keywords" content="" />
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4708B8S6ES"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4708B8S6ES');
</script>
</head>
<body><div class="container"><header>
<h1>tech</h1>


[<a href="https://ifritjp.github.io/documents/en/">English</a>]

[<a href="https://ifritjp.github.io/documents/">Japanese</a>]

</header>
<div class="global-menu">
<nav>
<ul>
<li><a href="/documents/">Home</a></li>
<li><a href="https://ifritjp.github.io/blog2/public/">blog</a></li>
<li><a href="https://ifritjp.github.io/LuneScript-webFront/lnsc_web_frontend/for_wasm/">LuneScript on Web</a></li></ul>
</nav>
</div>
<div class="content-container">
<main><h1>07. Variables</h1>

<p>
This time, I will explain about LuneScript variables.</p>
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
variable
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>
LuneScript is a statically typed language and variables have types.</p>
<p>
Variables are declared with let like this:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val:int = 1;</code></pre>
</div>
<p>
The above example declares a variable val with an int of 1 as its initial value.</p>
<p>
After the variable name, specify the type.</p>
<p>
Note that if the initial value is set to real 1.0 instead of int 1, a compilation error will occur because the types are different.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let val:int = 1.0;  // error</code></pre>
</div>
<p>
<del>Also, variable declarations now require an initial value.</del></p>
<p>
<del>This is to prevent access to uninitialized variables.++In the future, let flow analysis determine if a variable holds a value,++I&#39;m thinking of making the initial value unnecessary.</del></p>
<p>
Initialization when declaring variables is not required. A compile error will occur if a variable that has not been initialized is referenced. More on that later.</p>
<p>
Also, type inference is possible even if the variable is not initialized when declared.</p>
<div id="outline-container-headline-2" class="outline-3">
<h3 id="headline-2">
type inference
</h3>
<div id="outline-text-headline-2" class="outline-text-3">
<p>
LuneScript supports type inference.</p>
<p>
You can determine the type of a variable from the initial value you set to it. This allows you to declare variables without specifying their type, like this:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val1 = 1; // int 
let val2 = 1.0; // real
let val3 = &#34;abc&#34;; // str</code></pre>
</div>
<p>
In this case, val1 is treated as int, val2 as real, and val3 as str.</p>
<p>
Examples of when you need to specify the type are:</p>
<ul>
<li>Set the initial value of a nilable type variable to nil</li>
</ul>
<pre class="example">
let mut val:int! = nil;
</pre>
<ul>
<li>Set an immediate empty value (<code class="verbatim">[]</code>, <code class="verbatim">{}</code>, etc.) to the initial value of a list type or map type variable</li>
</ul>
<pre class="example">
let mut val:List&lt;int&gt; = [];
</pre>
<ul>
<li>When setting a subclass instance to a class type variable such as the following, if you want the variable type to be the superclass type</li>
</ul>
<pre class="example">
let val:Super = new Sub();
</pre>
</div>
</div>
<div id="outline-container-headline-3" class="outline-3">
<h3 id="headline-3">
Initializing variables
</h3>
<div id="outline-text-headline-3" class="outline-text-3">
<p>
Referencing an uninitialized variable will result in a compilation error.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
{
   let val;
   print( &#34;%s&#34; ( val ) ); // error
}</code></pre>
</div>
<p>
In <code class="verbatim">print()</code> above, an uninitialized val is accessed, which causes a compilation error.</p>
<div id="outline-container-headline-4" class="outline-4">
<h4 id="headline-4">
Flow analysis
</h4>
<div id="outline-text-headline-4" class="outline-text-4">
<p>
Variable Initialization parses the flow and checks for paths with variable uninitialization.</p>
<p>
For example, the following will result in an error:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func( flag:bool )
{
   let val;
   if flag {
     val = 1;
   }
   print( val ); // error
}</code></pre>
</div>
<p>
The reason for the above error is that if flag is true then val will be initialized, but if it is false then val will not.</p>
<p>
All paths need to be initialized before access, like this:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( flag:bool )
{
   let val;
   if flag {
     val = 1;
   }
   else {
     val = 2;
   }
   print( val ); // ok
}</code></pre>
</div>
<p>
Note that this process is an initialization for the variable val, not a rewrite for val, so there is no need for the mut declaration described later.</p>
<p>
By the way, even if it is a little complicated like the following, we will analyze the flow.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func( kind:int )
{
   let val;
   if kind &lt; 10 {
      if kind &gt; 0 {
         val = 1;
      }
      else {
         if kind == 0 {
            val = 2;
         }
         elseif kind == 1 {
            val = 3;
         }
         // â€» 
      }
   }
   else {
      val = 4;
   }
   print( val ); // error
}</code></pre>
</div>
<p>
I think it&#39;s a little hard to understand, but at the position of * above, the val reference in print is an error because the initialization of val is missing when else.</p>
<p>
Note that an error will also occur at print( val ) in the following cases.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func( flag:bool )
{
   let val;
   fn sub() {
      print( val ); // error
   }
   val = 1;
   sub();
}</code></pre>
</div>
<p>
Normally val is initialized when running <code class="verbatim">sub()</code>, so it shouldn&#39;t be an error, but this is the current design.</p>
</div>
</div>
<div id="outline-container-headline-5" class="outline-4">
<h4 id="headline-5">
type inference
</h4>
<div id="outline-text-headline-5" class="outline-text-4">
<p>
Type inference is possible even if the variable is not initialized when declared.</p>
<p>
However, type inference uses the first type assigned in flow analysis.</p>
<p>
For example, if</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func( flag:bool )
{
   let val;
   if flag {
      val = 1;
   }
   else {
      val = 1.0; // error
   }
}</code></pre>
</div>
<p>
At the first <code>val = 1</code> val is of type int. Then, at the next <code>val = 1.0</code>, an error occurs because it is trying to assign 1.0 of real to int type val.</p>
<p>
In the above case, the error can be avoided by declaring the type when declaring the variable as follows.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( flag:bool )
{
   let val:stem; // stem åž‹ã‚’å®£è¨€
   if flag {
      val = 1;
   }
   else {
      val = &#34;a&#34;;
   }
   print( val );
}</code></pre>
</div>
<p>
There are other cases besides stem where types must be declared. For example, there are cases where you want to use a variable of the superclass type, or you want to use a nilable type variable.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-6" class="outline-3">
<h3 id="headline-6">
shadowing
</h3>
<div id="outline-text-headline-6" class="outline-text-3">
<p>
LuneScript prohibits variable declarations with the same name.</p>
<p>
The same name here refers not only to the same name within the same scope, but also to the same name within the accessible scope.</p>
<p>
Specifically, the following variable declaration will result in an error.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
{
   let val = 1;
   {
      let val = 1;  // error
   }
}</code></pre>
</div>
<p>
I think there are pros and cons to this specification, but I&#39;m sticking to the safe side and making it this specification.</p>
</div>
</div>
<div id="outline-container-headline-7" class="outline-3">
<h3 id="headline-7">
access control
</h3>
<div id="outline-text-headline-7" class="outline-text-3">
<p>
Declared variables are treated as local variables.</p>
<p>
If you want to publish it to an external module, declare it with pub appended like this:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
pub let val = 1;</code></pre>
</div>
<p>
If you want to access variables exposed externally, use import like this:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
import SubModule;
print( SubModule.val );</code></pre>
</div>
<p>
where SubModule is the LuneScript module (SubModule.lns) that declares <code>pub let val = 1;</code>.</p>
<p>
If you want to access this val, you can access it with SubModule.val.</p>
<p>
pub is the basic way to expose variables to external modules, but you can also use global .</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
pub let val1 = 1;
global let val2 = 2;</code></pre>
</div>
<p>
The difference between pub and global is the namespace difference.</p>
<p>
It&#39;s easy to understand if you look at the following example, but this is a sample that accesses the above val1 and val2 from the outside.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
import SubModule;
print( SubModule.val1 );
print( val2 );</code></pre>
</div>
<p>
val1 is accessed as a variable in SubModule&#39;s namespace as SubModule.val1 , but val2 is accessed as a variable in the top-level namespace.</p>
<p>
When developing a system with only LuneScript, I don&#39;t think you should use global (or rather, you should avoid using global ), but when processing in conjunction with other Lua modules, use global I think there are times when you have to.</p>
<p>
For that compatibility, we support global .</p>
<p>
There are the following global restrictions.</p>
<p>
<strong>&#34;Variables declared as global become effective when the module that declares them is imported.&#34;</strong></p>
<p>
For example, in the following example val2 seems to exist in SubModule without any relation,</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
import SubModule;
print( SubModule.val1 );
print( val2 );</code></pre>
</div>
<p>
In the following case, an error occurs because val2 does not exist because SubModule is not imported.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
print( val2 );</code></pre>
</div>
<p>
Also, the variables to be exposed to the outside have the following restrictions.</p>
<p>
<strong>&#34;Variables exposed externally must be declared in the topmost scope of the script&#34;</strong></p>
<p>
For example, val2 below is an error because it is not in the topmost scope.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
pub let val = 1;
{
   pub let val2 = 1; // error
}</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-8" class="outline-3">
<h3 id="headline-8">
mutable
</h3>
<div id="outline-text-headline-8" class="outline-text-3">
<p>
A variable that is simply declared is treated as a variable that cannot be changed.</p>
<p>
For example, <code>val = 2</code> below is an error.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let val = 1;
val = 2; // error</code></pre>
</div>
<p>
If you want to make it a variable variable (mutable), declare it with mut as follows.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut val = 1;
val = 2;</code></pre>
</div>
<p>
It is also possible to assign an initial value after declaring an immutable variable as follows.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val;
val = 1;</code></pre>
</div>
<p>
However, if you set another value after assigning the initial value as follows, an error will occur.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let val;
val = 1;
val = 2; // error</code></pre>
</div>
<div id="outline-container-headline-9" class="outline-4">
<h4 id="headline-9">
immutable types
</h4>
<div id="outline-text-headline-9" class="outline-text-4">
<p>
<strong>As mentioned above, variables that are not declared mut are immutable. Inferred types without a mut declaration are also immutable. For example, in the following case, since list1 is declared mut , it is possible to change List (insert), but list2 is immutable without mut declaration, so the change operation of List will result in an error.</strong></p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let mut list1 = [1];
list1.insert( 2 ); // ok
let list2 = [1];
list2.insert( 2 ); // error</code></pre>
</div>
<p>
An immutable type is denoted as &amp;T by appending &amp; to the original type T. For example, <code class="verbatim">&amp;List&lt;int&gt;</code> represents a list List&lt;int&gt; that cannot be modified. In addition, change operation is not possible, but reference operation such as foreach is possible.</p>
<p>
<code class="verbatim">&amp;List&lt;List&lt;int&gt;&gt;</code> is an immutable list whose elements are <code class="verbatim">List&lt;int&gt;</code> . Here <code class="verbatim">List&lt;int&gt;</code> is mutable because there is no &amp;. So it looks like this:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let list:&amp;List&lt;List&lt;int&gt;&gt; = [[100],[]];
list[1].insert( 1 ); // ok
list.insert( [10] ); // error</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-10" class="outline-4">
<h4 id="headline-10">
Type inference and mutable
</h4>
<div id="outline-text-headline-10" class="outline-text-4">
<p>
As mentioned above, the type of a variable that is not declared mut is immutable.</p>
<p>
But this is with type inference.</p>
<p>
Even a variable that is not declared mut depends on the mutable declaration of that type if the type is specified.</p>
<p>
For example:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let list1:List&lt;int&gt; = [1,2];
let list2:&amp;List&lt;int&gt; = [1,2];
let mut list3 = [1,2];
let list4 = [1,2];
list1.insert( 3 );
list2.insert( 3 ); // error
list3.insert( 3 );
list4.insert( 3 ); // error</code></pre>
</div>
<p>
<code class="verbatim">list2.insert( 3 );</code> and <code class="verbatim">list4.insert( 3 );</code> fail because list2 and list4 become immutable &amp;List&lt;int&gt; .</p>
<p>
There was a bug in this specification before, which has been fixed in ver 1.2.0. Previously, even if the type was specified, the type was immutable if mut was not declared, but the behavior was inferior for variables, members, and arguments, so it has been corrected to the current specification.</p>
<p>
If you want to return to the specification before ver 1.2.0, please specify the option â€“legacy-mutable-control .</p>
<p>
However, this option may be deprecated in the future.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-11" class="outline-3">
<h3 id="headline-11">
multiple declarations
</h3>
<div id="outline-text-headline-11" class="outline-text-3">
<p>
LuneScript is the same as Lua and can return multiple values in function return values.</p>
<p>
To make this return value the initial value of a variable declaration, declare it like this:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
let val1, val2 = func();
let mut val3, mut val4 = func();</code></pre>
</div>
<p>
Declare mut before each variable name.</p>
</div>
</div>
<div id="outline-container-access_check" class="outline-3">
<h3 id="access_check">
access check
</h3>
<div id="outline-text-access_check" class="outline-text-3">
<p>
If you declare a local variable and do not refer to it after setting its value, you will get a warning. On the other hand, class members and function arguments are not subject to access checks.</p>
<p>
The following sample is an example of using only the second value without using the first value of the multi-value return. In this case, warn that val1 containing the first value is not used.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn sub(): int, int {
   return 1, 2;
}
fn func() {
   let val1, val2 = sub(); // warning val1
   print( val2 );
}</code></pre>
</div>
<p>
To suppress warnings for variables declared only to access the second and subsequent values of such a multi-value return, use the &#39;_&#39; symbol, like this:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn sub(): int, int {
   return 1, 2;
}
fn func() {
   let _, val2 = sub(); // ok
   print( val2 );
}</code></pre>
</div>
<p>
Note that variables declared with the &#39;_&#39; symbol cannot be accessed. Accessing it will result in an error.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn sub(): int, int {
   return 1, 2;
}
fn func() {
   let _, val2 = sub();
   print( _ ); // error
   print( val2 );
}</code></pre>
</div>
<p>
Access checks are also performed after updating the value of a variable.</p>
<p>
For example, val1 will be warned if:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func() {
   let mut val1 = 1;
   print( val1 );
   val1 = 2; // warning
}</code></pre>
</div>
<p>
This is because val1 is referenced by print( val1 ) after setting 1 to val1, but val1 is not referenced after updating val1 with <code class="verbatim">val1 = 2</code>.</p>
<div id="outline-container-headline-13" class="outline-4">
<h4 id="headline-13">
Closure access checks
</h4>
<div id="outline-text-headline-13" class="outline-text-4">
<p>
This access check also works with closures.</p>
<p>
In the following sample, <code class="verbatim">val1 = 2</code> is followed by a <code class="verbatim">sub()</code> call, which determines that val1 is being referenced and does not warn.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func() {
   let mut val1 = 1;
   fn sub() {
      print( val1 );
   }
   val1 = 2;
   sub();
}</code></pre>
</div>
<p>
However, there are the following restrictions.</p>
<ul>
<li>
<p>Treat it as if there was a reference to the value at the point of reference, not the function call of the closure</p>
<ul>
<li>For example, assigning a closure function to a variable or passing it as an argument to another function.</li>
</ul>
</li>
<li>
<p>Closure access does not distinguish between references and settings</p>
<ul>
<li>Even if it is only set in the closure function, it is treated as a reference.</li>
</ul>
</li>
</ul>
<p>Closure access checking is an experimental feature.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-14" class="outline-3">
<h3 id="headline-14">
special symbol
</h3>
<div id="outline-text-headline-14" class="outline-text-3">
<p>
The following symbols refer to special values.</p>
<table>
<thead>
<tr>
<th>symbol</th>
<th>value</th>
<th class="align-right"></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__mod__</code></td>
<td>Module name</td>
<td class="align-right"></td>
</tr>
<tr>
<td><code>__func__</code></td>
<td>current function name</td>
<td class="align-right"></td>
</tr>
<tr>
<td><code>__line__</code></td>
<td>current line number</td>
<td class="align-right"></td>
</tr>
</tbody>
</table>
<p>
<strong>Note that the format of names expanded by <code>__mod__</code> and <code>__func__</code> may change in the future.</strong></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-15" class="outline-2">
<h2 id="headline-15">
Type conversion (cast)
</h2>
<div id="outline-text-headline-15" class="outline-text-2">
<p>
Any value other than nil can be assigned to a variable of type stem .</p>
<p>
It has an implicit type conversion.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut val:stem = 1;
val = 1.0;
val = &#34;abc&#34;;
val = {};
val = [];
val = [@];</code></pre>
</div>
<p>
On the other hand, it is an error to assign a stem type value to a different type.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let val1:stem = 1;
let val2:int = val1; // error</code></pre>
</div>
<p>
If you need explicit type conversions, see the following articles:</p>
<p>
<a href="../cast">../cast</a></p>
</div>
</div>
<div id="outline-container-headline-16" class="outline-2">
<h2 id="headline-16">
reference
</h2>
<div id="outline-text-headline-16" class="outline-text-2">
<p>
Variables hold object references except for some (int, real, nil).</p>
<p>
For example:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut list1 = [ 10 ];
let list2 = list1;
list1.insert( 20 );
list1.insert( 30 );
foreach val in list2 {
   print( val ); // 10 20 30
}</code></pre>
</div>
<ul>
<li>Set List&lt;int&gt; type list (<code class="verbatim">[ 10 ]</code>) object reference to list1</li>
<li>Set the reference held by list1 to list2</li>
<li>insert 20, 30 into the list object referenced by list1</li>
<li><code class="verbatim">print()</code> each value of the list object referenced by list2</li>
</ul>
<p><strong>Here, list1 and list2 refer to the same list object, so if you insert 20, 30 into list1 , print( val ) foreaching list2 will print 10 20 30 .</strong></p>
<p>
<strong>Also, if you insert 40 into list2 like this, print( val ) will print 10 20 30 40 because you are inserting 40 into the same list object.</strong></p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut list1 = [ 10 ];
let mut list2 = list1;
list1.insert( 20 );
list1.insert( 30 );
list2.insert( 40 );
foreach val in list2 {
   print( val ); // 10 20 30 40
}</code></pre>
</div>
<p>
If you set list1 to a new list object (<code class="verbatim">[ 100]</code>), print( val ) will print 10 20 30 40 because the list object referenced by list1 and the list object referenced by list2 are different.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut list1 = [ 10 ];
let mut list2 = list1;
list1.insert( 20 );
list1.insert( 30 );
list2.insert( 40 );
list1 = [ 100 ];
foreach val in list2 {
   print( val ); // 10 20 30 40
}</code></pre>
</div>
<p>
The same is true for List&lt;List&lt;int&gt;&gt;.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut list = [ 10, 20 ];
let mut wrapList:List&lt;List&lt;int&gt;&gt; = [];
wrapList.insert( list );
wrapList.insert( list );
wrapList.insert( [ 100, 200 ] );
list[ 1 ] = list[ 1 ] + 1;
print( wrapList[ 1 ][ 1 ], wrapList[ 1 ][ 2 ] ); // 11 20
print( wrapList[ 2 ][ 1 ], wrapList[ 2 ][ 2 ] ); // 11 20
print( wrapList[ 3 ][ 1 ], wrapList[ 3 ][ 2 ] ); // 100 200</code></pre>
</div>
<p>
Add list to wrapList 1st and 2nd, and add new list object to wrapList 3rd. After that, increment list[1] and output the contents of wrapList.</p>
<p>
Here, wrapList[1][1] and wrapList[2][1] point to the same list[1], so the incremented value is output. wrapList[3] is a new list object, so the increment has no effect.</p>
</div>
</div>
<div id="outline-container-headline-17" class="outline-2">
<h2 id="headline-17">
summary
</h2>
<div id="outline-text-headline-17" class="outline-text-2">
<p>
Variables in LuneScript incorporate the following elements:</p>
<ul>
<li>type inference</li>
<li>access control</li>
<li>mutable</li>
<li>multiple declarations</li>
</ul>
<p>It is intended to meet the minimum functionality required when dealing with Lua with static cleanup.</p>
<p>
Next time, I will explain the branch control of LuneScript.</p>
</div>
</div>
<div class="edit-meta">

<br></div><nav class="pagination"><a class="nav nav-prev-2" href="https://ifritjp.github.io/documents/en/lunescript/match/" title="06. match"><i class="fas fa-arrow-left" aria-hidden="true"></i> Prev - 06. match</a>
<a class="nav nav-next-2" href="https://ifritjp.github.io/documents/en/lunescript/branch/" title="08. General branch syntax">Next - 08. General branch syntax <i class="fas fa-arrow-right" aria-hidden="true"></i></a>
</nav><footer><p class="powered">Powered by <a href="https://gohugo.io">Hugo</a>. Theme by <a href="https://themes.gohugo.io/hugo-theme-techdoc/">TechDoc</a>. Designed by <a href="https://github.com/thingsym/hugo-theme-techdoc">Thingsym</a>.</p>
</footer>
</main><div class="sidebar">

<nav class="slide-menu">
<ul>
<li class=""><a href="https://ifritjp.github.io/documents">Home</a></li>

<li class="parent has-sub-menu"><a href="https://ifritjp.github.io/documents/en/lunescript/">Easier Lua development with the transcompiler LuneScript!!<span class="mark opened">-</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/tutorial2.setup/">01. Introduction</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/tutorial3.hello/">02. Hello world</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/crosscompile/">03. Cross-compiling between Lua versions</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/value/">04. Values</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/set/">04.2. Set</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/tuple/">04.3 Tuples</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/enum/">05. enum</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/match/">06. match</a></li>
<li class="active"><a href="https://ifritjp.github.io/documents/en/lunescript/variable/">07. Variables</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/branch/">08. General branch syntax</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/loop/">09. Repetition Syntax</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/func/">10. Functions</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/multipleretval/">10.2. Multi-value return values</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/defaultarg/">10.3. Omitting Arguments</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/arg/">10.4. Variadic Arguments and Return Values</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/closure/">10.5. Closures</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/error/">10.6. Error handling</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/nilable/">11. nilable</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/class1/">12. Class basics</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/class2accessor/">13. accessor</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/classinherit/">14. Class Inheritance</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/classadvertise/">15. Class advertise</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/classoverride/">16. Class override</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/interface/">17. Interface</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/classmapping/">18. mapping</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/generics/">19. generics</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/generics-go/">19.2. generics (two collection types)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/nilcond/">20. nil conditional operator</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/import/">21. import/provide</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/require/">22. require/module</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/glue/">22.1. Semi-automatic generation of glue code</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/lua/">22.2. Linking with Lua</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/make/">23. Build</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/macro/">24. Macro</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/cast/">25. Cast</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/subfile/">26. subfile</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/lazyloading/">27. Lazy Loading</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/shebang_main/">28. shebang and command line arguments</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/dir/">29. Recommended directory structure for projects using LuneScript</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/go/">80. Transcompiling to Go Language</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/go_package/">80.2 Packages when transpiling to Go</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/go_wasm/">80.4 WebAssembly support for LuneScript</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/async/">81. Safe Asynchronous Processing</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/async_old/">81.1 Asynchronous processing (past information)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/luago/">82. Linking with Lua</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/ebnf/">A. BNF</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/onweb/">A. LuneScript running on a web browser</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/reason/">A. Reason for developing Lua transcompiler LuneScript</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/recommend/">A. Recommendations for transcompiler development</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/lnstags/">A. Tag jumping with lnstags (source code tagging system)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/completion/">A.Let&#39;s have more fun in a modern development environment</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/box/">Box edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/lua_runtime/">Lua runtime when transpiling to 80.3 Go</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/test/">X. The Importance of Self-Hosting and Test Design in Language Development Quality Control</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/design/">Y.1 How to develop LuneScript</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/design-2/">Y.2 Development of LuneScript (type information management)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/design-3/">Y.3 LuneScript Development (Scopes and Symbols)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/go_study/">Z. Transcompile to Go language (exploratory stage)</a></li>
</ul>
  
</li>
</ul>
</nav>



<div class="sidebar-footer"></div>
</div>
</div><a href="#" id="backtothetop-fixed" class="backtothetop"
 data-backtothetop-duration="600"
 data-backtothetop-easing="easeOutQuart"
 data-backtothetop-fixed-fadeIn="1000"
 data-backtothetop-fixed-fadeOut="1000"
 data-backtothetop-fixed-bottom="10"
 data-backtothetop-fixed-right="20">
<span class="fa-layers fa-fw">
<i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i>
</span></a>
</div>
</body>
</html>
