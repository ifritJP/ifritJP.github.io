<!DOCTYPE html>
<html lang="ja-jp">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>07. Variables - tech</title>
<meta name="generator" content="Hugo 0.100.1" />
<link href="https://ifritjp.github.io/documentsindex.xml" rel="alternate" type="application/rss+xml">
<link rel="canonical" href="https://ifritjp.github.io/documents/en/lunescript/variable/">
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/theme.min.css">
<script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/chroma.min.css">
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js"></script>
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/custom.css">
<script src="https://ifritjp.github.io/documents/js/bundle.js"></script>
<script src="https://ifritjp.github.io/documents/js/lnsSrcRun.js"></script>
<script src="https://ifritjp.github.io/documents/js/highlight_lns.js"></script>
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/highlight_lns.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script><style>
:root {}
</style>
<meta property="og:title" content="07. Variables" />
<meta property="og:description" content="This time, I will explain the variables of LuneScript. variable LuneScript is a statically typed language, and variables have types. Declare the variable with let as follows: // @lnsFront: ok let val:int = 1; The above example declares a variable val with an int of 1 as the initial value. After the variable name, specify the type. If the initial value is set to 1.0, which is real instead of" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ifritjp.github.io/documents/en/lunescript/variable/" /><meta property="article:section" content="LuneScript" />

<meta property="og:site_name" content="tech" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="07. Variables"/>
<meta name="twitter:description" content="This time, I will explain the variables of LuneScript. variable LuneScript is a statically typed language, and variables have types. Declare the variable with let as follows: // @lnsFront: ok let val:int = 1; The above example declares a variable val with an int of 1 as the initial value. After the variable name, specify the type. If the initial value is set to 1.0, which is real instead of"/>
<meta itemprop="name" content="07. Variables">
<meta itemprop="description" content="This time, I will explain the variables of LuneScript. variable LuneScript is a statically typed language, and variables have types. Declare the variable with let as follows: // @lnsFront: ok let val:int = 1; The above example declares a variable val with an int of 1 as the initial value. After the variable name, specify the type. If the initial value is set to 1.0, which is real instead of">

<meta itemprop="wordCount" content="2821">
<meta itemprop="keywords" content="" />
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4708B8S6ES"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4708B8S6ES');
</script>
</head>
<body><div class="container"><header>
<h1>tech</h1>


[<a href="https://ifritjp.github.io/documents/en/">English</a>]

[<a href="https://ifritjp.github.io/documents/">Japanese</a>]

</header>
<div class="global-menu">
<nav>
<ul>
<li><a href="/documents/">Home</a></li>
<li><a href="https://ifritjp.github.io/blog2/public/">blog</a></li>
<li><a href="https://ifritjp.github.io/LuneScript-webFront/contents/">LuneScript on Web</a></li></ul>
</nav>
</div>
<div class="content-container">
<main><h1>07. Variables</h1>

<p>
This time, I will explain the variables of LuneScript.</p>
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
variable
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>
LuneScript is a statically typed language, and variables have types.</p>
<p>
Declare the variable with let as follows:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val:int = 1;</code></pre>
</div>
<p>
The above example declares a variable val with an int of 1 as the initial value.</p>
<p>
After the variable name, specify the type.</p>
<p>
If the initial value is set to 1.0, which is real instead of 1, which is int, a compile error will occur because the type is different.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let val:int = 1.0;  // error</code></pre>
</div>
<p>
<del>Also, variable declarations now require an initial value.</del></p>
<p>
<del>This is to prevent access to uninitialized variables.++In the future, let flow analysis determine if a variable holds a value,++I am thinking of eliminating the need for initial values.</del></p>
<p>
Initialization at the time of variable declaration is not mandatory. If you refer to a variable that has not been initialized, a compile error will occur. Details will be described later.</p>
<p>
In addition, type inference is possible even if it is not initialized when the variable is declared.</p>
<div id="outline-container-headline-2" class="outline-3">
<h3 id="headline-2">
Type inference
</h3>
<div id="outline-text-headline-2" class="outline-text-3">
<p>
LuneScript supports type inference.</p>
<p>
You can determine the type of a variable from the initial value you set for that variable. This allows you to declare a variable without specifying a type as follows:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val1 = 1; // int 
let val2 = 1.0; // real
let val3 = &#34;abc&#34;; // str</code></pre>
</div>
<p>
In this case, treat val1 as an int, val2 as a real, and val3 as a str.</p>
<p>
You may need to specify the type, for example:</p>
<ul>
<li>Set nil to the initial value of a variable of type nilable</li>
</ul>
<pre class="example">
let mut val:int! = nil;
</pre>
<ul>
<li>Set an immediate empty value (<code class="verbatim">[]</code>, <code class="verbatim">{}</code>, etc.) to the initial value of the list type or map type variable.</li>
</ul>
<pre class="example">
let mut val:List&lt;int&gt; = [];
</pre>
<ul>
<li>When setting an instance of a subclass to a variable of the following class type, if you want to set the variable type to the superclass type</li>
</ul>
<pre class="example">
let val:Super = new Sub();
</pre>
</div>
</div>
<div id="outline-container-headline-3" class="outline-3">
<h3 id="headline-3">
Variable initialization
</h3>
<div id="outline-text-headline-3" class="outline-text-3">
<p>
Accessing uninitialized variables will result in a compilation error.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
{
   let val;
   print( &#34;%s&#34; ( val ) ); // error
}</code></pre>
</div>
<p>
In <code class="verbatim">print()</code> above, I am accessing an uninitialized val, but I get a compile error here.</p>
<div id="outline-container-headline-4" class="outline-4">
<h4 id="headline-4">
Flow analysis
</h4>
<div id="outline-text-headline-4" class="outline-text-4">
<p>
Variable initialization parses the flow and checks for variable uninitialized paths.</p>
<p>
For example, in the following cases, an error will occur.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func( flag:bool )
{
   let val;
   if flag {
     val = 1;
   }
   print( val ); // error
}</code></pre>
</div>
<p>
The cause of the above error is that if flag is true, val is initialized, but if false, val is not initialized.</p>
<p>
All paths must be initialized before they can be accessed, as follows:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( flag:bool )
{
   let val;
   if flag {
     val = 1;
   }
   else {
     val = 2;
   }
   print( val ); // ok
}</code></pre>
</div>
<p>
Note that this process is an initialization for the variable val, not a rewrite for the val, so there is no need to declare the mut, which will be described later.</p>
<p>
By the way, the flow is also analyzed in the following slightly complicated cases.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func( kind:int )
{
   let val;
   if kind &lt; 10 {
      if kind &gt; 0 {
         val = 1;
      }
      else {
         if kind == 0 {
            val = 2;
         }
         elseif kind == 1 {
            val = 3;
         }
         // â€» 
      }
   }
   else {
      val = 4;
   }
   print( val ); // error
}</code></pre>
</div>
<p>
It may be a little difficult to understand, but since the initialization of val is missing at the time of else at the position of * above, the val reference of print will result in an error.</p>
<p>
In the following cases, an error will occur at print (val).</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func( flag:bool )
{
   let val;
   fn sub() {
      print( val ); // error
   }
   val = 1;
   sub();
}</code></pre>
</div>
<p>
Originally, val is initialized when executing <code class="verbatim">sub()</code>, so it should not be an error, but this is the current specification.</p>
</div>
</div>
<div id="outline-container-headline-5" class="outline-4">
<h4 id="headline-5">
Type inference
</h4>
<div id="outline-text-headline-5" class="outline-text-4">
<p>
Type inference is possible even if it is not initialized when the variable is declared.</p>
<p>
However, type inference uses the first type assigned in the flow analysis.</p>
<p>
For example, in the following cases</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func( flag:bool )
{
   let val;
   if flag {
      val = 1;
   }
   else {
      val = 1.0; // error
   }
}</code></pre>
</div>
<p>
In the first <code>val = 1</code>, val is of type int. Then, at the next <code>val = 1.0</code>, an error will occur because you are trying to assign real 1.0 to an int type val.</p>
<p>
In the above cases, you can avoid the error by declaring the type when declaring the variable as follows.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( flag:bool )
{
   let val:stem; // stem åž‹ã‚’å®£è¨€
   if flag {
      val = 1;
   }
   else {
      val = &#34;a&#34;;
   }
   print( val );
}</code></pre>
</div>
<p>
In addition to stem, there are other cases where you need to declare a type. For example, you may want to use a variable of type superclass, or you may want to use a variable of type nilable.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-6" class="outline-3">
<h3 id="headline-6">
shadowing
</h3>
<div id="outline-text-headline-6" class="outline-text-3">
<p>
LuneScript prohibits variable declarations with the same name.</p>
<p>
Here, the same name means not only the same name within the same scope but also the same name within an accessible scope.</p>
<p>
Specifically, the following variable declaration will result in an error.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
{
   let val = 1;
   {
      let val = 1;  // error
   }
}</code></pre>
</div>
<p>
I think there are pros and cons to this specification, but I&#39;ve made it to the safety side.</p>
</div>
</div>
<div id="outline-container-headline-7" class="outline-3">
<h3 id="headline-7">
Access control
</h3>
<div id="outline-text-headline-7" class="outline-text-3">
<p>
The declared variable is treated as a local variable.</p>
<p>
If you want to publish to an external module, declare it with pub as follows.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
pub let val = 1;</code></pre>
</div>
<p>
To access an externally exposed variable, use import as follows:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
import SubModule;
print( SubModule.val );</code></pre>
</div>
<p>
Where SubModule is the LuneScript module (SubModule.lns) that declares <code>pub let val = 1;</code>.</p>
<p>
If you want to access this val, you can access it by typing SubModule.val.</p>
<p>
The basic way to expose variables to external modules is pub, but you can also use global.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
pub let val1 = 1;
global let val2 = 2;</code></pre>
</div>
<p>
The difference between pub and global is the namespace difference.</p>
<p>
As you can see from the following example, this is a sample of accessing val1 and val2 from the outside.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
import SubModule;
print( SubModule.val1 );
print( val2 );</code></pre>
</div>
<p>
val1 is accessed as SubModule.val1 as a variable in the SubModule namespace, while val2 is accessed as a variable in the top-level namespace.</p>
<p>
When developing a system with LuneScript alone, it is unlikely that you will use global (or you should avoid using global), but when working with other Lua modules, use global. I think there are times when you have to do it.</p>
<p>
Global is supported for the purpose of maintaining such compatibility.</p>
<p>
The global restrictions are as follows.</p>
<p>
<strong>&#34;A variable declared global is valid when you import a module that declares the variable.&#34;</strong></p>
<p>
For example, in the following example, val2 seems to exist in SubModule for nothing,</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
import SubModule;
print( SubModule.val1 );
print( val2 );</code></pre>
</div>
<p>
In the following case, since SubModule has not been imported, val2 does not exist and an error occurs.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
print( val2 );</code></pre>
</div>
<p>
In addition, variables that are exposed to the outside have the following restrictions.</p>
<p>
<strong>&#34;Variables exposed to the outside must be declared in the highest scope of the script.&#34;</strong></p>
<p>
For example, the following val2 will result in an error because it is not the highest scope.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
pub let val = 1;
{
   pub let val2 = 1; // error
}</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-8" class="outline-3">
<h3 id="headline-8">
mutable
</h3>
<div id="outline-text-headline-8" class="outline-text-3">
<p>
A variable that is simply declared is treated as a variable that cannot be changed.</p>
<p>
For example, the following <code>val = 2</code> will result in an error.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let val = 1;
val = 2; // error</code></pre>
</div>
<p>
If it is a mutable variable, declare it with mut as follows.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut val = 1;
val = 2;</code></pre>
</div>
<p>
You can also assign the initial value after declaring the immutable variable as follows.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val;
val = 1;</code></pre>
</div>
<p>
However, if you set an additional value after substituting the initial value as shown below, an error will occur.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let val;
val = 1;
val = 2; // error</code></pre>
</div>
<div id="outline-container-headline-9" class="outline-4">
<h4 id="headline-9">
immutable type
</h4>
<div id="outline-text-headline-9" class="outline-text-4">
<p>
<strong>As mentioned above, variables that are not declared mut are immutable. In addition, type inferred types without a mut declaration are also immutable. For example, in the following case, list1 is declared mut, so it is possible to insert the List, but list2 is immutable without declaring mut, so the operation to change the List is an error.</strong></p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let mut list1 = [1];
list1.insert( 2 ); // ok
let list2 = [1];
list2.insert( 2 ); // error</code></pre>
</div>
<p>
Immutable types are represented as &amp; T by adding &amp; to the original type T. For example, <code class="verbatim">&amp;List&lt;int&gt;</code> represents a list &lt;int&gt; that cannot be modified. You cannot change it, but you can refer to it such as foreach.</p>
<p>
<code class="verbatim">&amp;List&lt;List&lt;int&gt;&gt;</code> is an immutable list with <code class="verbatim">List&lt;int&gt;</code> as an element. Where <code class="verbatim">List&lt;int&gt;</code> is mutable because it does not have a &amp;. That is, it looks like this:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let list:&amp;List&lt;List&lt;int&gt;&gt; = [[100],[]];
list[1].insert( 1 ); // ok
list.insert( [10] ); // error</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-10" class="outline-4">
<h4 id="headline-10">
Type inference and mutable
</h4>
<div id="outline-text-headline-10" class="outline-text-4">
<p>
As mentioned above, the type of variable that is not declared mut is immutable.</p>
<p>
However, this is the case when using type inference.</p>
<p>
Variables that are not mut-declared depend on the mutable declaration for that type, if the type is explicitly stated.</p>
<p>
For example, in the following cases</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let list1:List&lt;int&gt; = [1,2];
let list2:&amp;List&lt;int&gt; = [1,2];
let mut list3 = [1,2];
let list4 = [1,2];
list1.insert( 3 );
list2.insert( 3 ); // error
list3.insert( 3 );
list4.insert( 3 ); // error</code></pre>
</div>
<p>
<code class="verbatim">list2.insert( 3 );</code> and <code class="verbatim">list4.insert( 3 );</code> are in error because list2 and list4 are immutable &amp; List &lt;int&gt;.</p>
<p>
In addition, this specification has a problem before, and it has been fixed in ver 1.2.0. Previously, even if the type was specified, it was an immutable type if mut was not declared, but its behavior was inferior in variables, members, and arguments, so it has been corrected to the current specification.</p>
<p>
If you want to revert to the specifications of ver 1.2.0 or earlier, specify the option â€“legacy-mutable-control.</p>
<p>
However, this option may be deprecated in the future.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-11" class="outline-3">
<h3 id="headline-11">
Multiple declarations
</h3>
<div id="outline-text-headline-11" class="outline-text-3">
<p>
LuneScript, like Lua, can return multiple values for a function&#39;s return value.</p>
<p>
To use this return value as the initial value of the variable declaration, declare as follows.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
let val1, val2 = func();
let mut val3, mut val4 = func();</code></pre>
</div>
<p>
mut is declared before each variable name.</p>
</div>
</div>
<div id="outline-container-access_check" class="outline-3">
<h3 id="access_check">
Access check
</h3>
<div id="outline-text-access_check" class="outline-text-3">
<p>
If you do not refer to the declared local variable after setting the value, a warning is output. On the other hand, class members and function arguments are not subject to access checks.</p>
<p>
The following sample is an example of using only the second value without using the first value for multivalued returns. In this case, it warns that val1, which stores the first value, is not being used.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn sub(): int, int {
   return 1, 2;
}
fn func() {
   let val1, val2 = sub(); // warning val1
   print( val2 );
}</code></pre>
</div>
<p>
To avoid warning for variables declared only to access the second and subsequent values of such multivalued returns, use the&#39;_&#39; symbol as follows:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn sub(): int, int {
   return 1, 2;
}
fn func() {
   let _, val2 = sub(); // ok
   print( val2 );
}</code></pre>
</div>
<p>
Note that variables declared with the&#39;_&#39;symbol cannot be accessed. An error will occur if you access it.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn sub(): int, int {
   return 1, 2;
}
fn func() {
   let _, val2 = sub();
   print( _ ); // error
   print( val2 );
}</code></pre>
</div>
<p>
The access check is also performed after updating the value of the variable.</p>
<p>
For example, val1 is warned if:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func() {
   let mut val1 = 1;
   print( val1 );
   val1 = 2; // warning
}</code></pre>
</div>
<p>
This is because print (val1) references val1 after setting val1 to 1, but then <code class="verbatim">val1 = 2</code> updates val1 and then does not reference val1.</p>
<div id="outline-container-headline-13" class="outline-4">
<h4 id="headline-13">
Closure access check
</h4>
<div id="outline-text-headline-13" class="outline-text-4">
<p>
This access check also works with closures.</p>
<p>
The following sample does not warn after <code class="verbatim">val1 = 2</code>, judging that it refers to val1 due to the call of <code class="verbatim">sub()</code>.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func() {
   let mut val1 = 1;
   fn sub() {
      print( val1 );
   }
   val1 = 2;
   sub();
}</code></pre>
</div>
<p>
However, there are the following restrictions.</p>
<ul>
<li>
<p>Treat as if there was a value reference at the time of reference, not a closure function call</p>
<ul>
<li>For example, it processes when a closure function is assigned to a variable or passed to an argument of another function.</li>
</ul>
</li>
<li>
<p>Access by closure does not distinguish between reference and setting</p>
<ul>
<li>Even if it is set only in the closure function, it is treated as a reference.</li>
</ul>
</li>
</ul>
<p>Closure access checking is an experimental feature.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-14" class="outline-3">
<h3 id="headline-14">
Special symbol
</h3>
<div id="outline-text-headline-14" class="outline-text-3">
<p>
The following symbols point to special values.</p>
<table>
<thead>
<tr>
<th>symbol</th>
<th>value</th>
<th class="align-right"></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__mod__</code></td>
<td>Module name</td>
<td class="align-right"></td>
</tr>
<tr>
<td><code>__func__</code></td>
<td>Current function name</td>
<td class="align-right"></td>
</tr>
<tr>
<td><code>__line__</code></td>
<td>Current line number</td>
<td class="align-right"></td>
</tr>
</tbody>
</table>
<p>
<strong>The format of the names expanded by <code>__mod__</code> and <code>__func__</code> may change in the future.</strong></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-15" class="outline-2">
<h2 id="headline-15">
Type conversion (cast)
</h2>
<div id="outline-text-headline-15" class="outline-text-2">
<p>
All values except nil can be assigned to variables of type stem.</p>
<p>
It has an implicit type conversion.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut val:stem = 1;
val = 1.0;
val = &#34;abc&#34;;
val = {};
val = [];
val = [@];</code></pre>
</div>
<p>
On the other hand, assigning a stem type value to a different type will result in an error.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let val1:stem = 1;
let val2:int = val1; // error</code></pre>
</div>
<p>
If you need explicit type conversion, see the following articles:</p>
<p>
<a href="../cast">../cast</a></p>
</div>
</div>
<div id="outline-container-headline-16" class="outline-2">
<h2 id="headline-16">
reference
</h2>
<div id="outline-text-headline-16" class="outline-text-2">
<p>
Variables hold object references except for some (int, real, nil).</p>
<p>
For example, in the following cases</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut list1 = [ 10 ];
let list2 = list1;
list1.insert( 20 );
list1.insert( 30 );
foreach val in list2 {
   print( val ); // 10 20 30
}</code></pre>
</div>
<ul>
<li>Set list1 to a reference to a List &lt;int&gt; type list (<code class="verbatim">[ 10 ]</code>) object</li>
<li>Set list2 to the reference held by list1</li>
<li>Insert 20, 30 into the list object referenced by list1</li>
<li><code class="verbatim">print()</code> for each value of the list object referenced by list2</li>
</ul>
<p><strong>Here, list1 and list2 refer to the same list object, so if you insert 20, 30 into list1, print (val) foreaching list2 will print 10 20 30.</strong></p>
<p>
<strong>Also, if you insert 40 into list2 as follows, print (val) prints 10 20 30 40 because you insert 40 into the same list object.</strong></p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut list1 = [ 10 ];
let mut list2 = list1;
list1.insert( 20 );
list1.insert( 30 );
list2.insert( 40 );
foreach val in list2 {
   print( val ); // 10 20 30 40
}</code></pre>
</div>
<p>
If you set list1 to a new list object (<code class="verbatim">[ 100]</code>), print (val) prints 10 20 30 40 because the list object referenced by list1 and the list object referenced by list2 are different.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut list1 = [ 10 ];
let mut list2 = list1;
list1.insert( 20 );
list1.insert( 30 );
list2.insert( 40 );
list1 = [ 100 ];
foreach val in list2 {
   print( val ); // 10 20 30 40
}</code></pre>
</div>
<p>
This is also the case for List &lt;List &lt;int &gt;&gt;.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut list = [ 10, 20 ];
let mut wrapList:List&lt;List&lt;int&gt;&gt; = [];
wrapList.insert( list );
wrapList.insert( list );
wrapList.insert( [ 100, 200 ] );
list[ 1 ] = list[ 1 ] + 1;
print( wrapList[ 1 ][ 1 ], wrapList[ 1 ][ 2 ] ); // 11 20
print( wrapList[ 2 ][ 1 ], wrapList[ 2 ][ 2 ] ); // 11 20
print( wrapList[ 3 ][ 1 ], wrapList[ 3 ][ 2 ] ); // 100 200</code></pre>
</div>
<p>
I&#39;ve added a list to the 1st and 2nd of the wrapList, and a new list object to the 3rd of the wrapList. After that, after incrementing list [1], the contents of wrapList are output.</p>
<p>
Here, wrapList [1] [1] and wrapList [2] [1] point to the same list [1], so the incremented value is output. Since wrapList [3] will be a new list object, it will not be affected by the increment.</p>
</div>
</div>
<div id="outline-container-headline-17" class="outline-2">
<h2 id="headline-17">
summary
</h2>
<div id="outline-text-headline-17" class="outline-text-2">
<p>
LuneScript variables incorporate the following elements:</p>
<ul>
<li>Type inference</li>
<li>Access control</li>
<li>mutable</li>
<li>Multiple declarations</li>
</ul>
<p>I&#39;m going to have the minimum functionality needed to handle Lua with static cleanup.</p>
<p>
Next time, I will explain the branch control of LuneScript.</p>
</div>
</div>
<div class="edit-meta">

<br></div><nav class="pagination"><a class="nav nav-prev-2" href="https://ifritjp.github.io/documents/en/lunescript/match/" title="06. match edition"><i class="fas fa-arrow-left" aria-hidden="true"></i> Prev - 06. match edition</a>
<a class="nav nav-next-2" href="https://ifritjp.github.io/documents/en/lunescript/branch/" title="08. General branch syntax">Next - 08. General branch syntax <i class="fas fa-arrow-right" aria-hidden="true"></i></a>
</nav><footer><p class="powered">Powered by <a href="https://gohugo.io">Hugo</a>. Theme by <a href="https://themes.gohugo.io/hugo-theme-techdoc/">TechDoc</a>. Designed by <a href="https://github.com/thingsym/hugo-theme-techdoc">Thingsym</a>.</p>
</footer>
</main><div class="sidebar">

<nav class="slide-menu">
<ul>
<li class=""><a href="https://ifritjp.github.io/documents">Home</a></li>

<li class="parent has-sub-menu"><a href="https://ifritjp.github.io/documents/en/lunescript/">Making Lua easier with the transcompiler LuneScript !!<span class="mark opened">-</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/tutorial2.setup/"></a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/go/">@ .1 Transcompile to Go language</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/lua_runtime/">@ .1.3 Lua runtime when transcompiled to Go</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/async/">@ .2 Safe asynchronous processing</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/async_old/">@ .2.1 Asynchronous processing O (past information)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/go_package/">@ 1.2 Package when transcompiling to Go language</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/luago/">@ 3. Collaboration with Lua</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/tutorial3.hello/">02. Hello world</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/crosscompile/">03. Cross-compiling between Lua versions</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/value/">04. Value</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/set/">04.2. Set</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/enum/">05. enum edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/match/">06. match edition</a></li>
<li class="active"><a href="https://ifritjp.github.io/documents/en/lunescript/variable/">07. Variables</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/branch/">08. General branch syntax</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/loop/">09. Repeated syntax</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/func/">10. Functions</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/multipleretval/">10.2. Multi-valued return value</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/defaultarg/">10.3. Omission of arguments</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/arg/">10.4. Variadic argument, return value</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/closure/">10.5. Closure</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/nilable/">11. nilable edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/class1/">12. Class Basics</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/class2accessor/">13. accessor edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/classinherit/">14. Class inheritance</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/classadvertise/">15. Class advertise</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/classoverride/">16. Class override</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/interface/">17. Interface</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/classmapping/">18. mapping</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/generics/">19. generics edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/nilcond/">20. nil conditional operator edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/import/">21. import / provide</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/require/">22. require / module edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/glue/">22.1. Semi-automatic generation of glue code</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/lua/">22.2. Cooperation with Lua</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/make/">23. Build</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/macro/">24. Macro edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/cast/">25. Cast edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/subfile/">26. subfile edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/lazyloading/">27. Delayed loading</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/shebang_main/">28. shebang and command line arguments</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/dir/">29. Recommended directory structure for projects that use LuneScript</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/completion/">A. Let&#39;s have more fun in an exciting development environment</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/onweb/">A. LuneScript running on a web browser</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/lnstags/">A. Tag jump by lnstags (source code tag system)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/recommend/">A. Transcompiler development recommendations</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/reason/">A. Why Lua&#39;s transcompiler LuneScript was developed</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/box/">Box edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/go_study/">Transcompile to Z. Go language (under consideration)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/test/">X. Importance of self-hosting and test design in quality control of language development</a></li>
</ul>
  
</li>
</ul>
</nav>



<div class="sidebar-footer"></div>
</div>
</div><a href="#" id="backtothetop-fixed" class="backtothetop"
 data-backtothetop-duration="600"
 data-backtothetop-easing="easeOutQuart"
 data-backtothetop-fixed-fadeIn="1000"
 data-backtothetop-fixed-fadeOut="1000"
 data-backtothetop-fixed-bottom="10"
 data-backtothetop-fixed-right="20">
<span class="fa-layers fa-fw">
<i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i>
</span></a>
</div>
</body>
</html>
