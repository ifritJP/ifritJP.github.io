<!DOCTYPE html>
<html lang="ja-jp">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>19. generics - tech</title>
<meta name="generator" content="Hugo 0.109.0">
<link href="https://ifritjp.github.io/documentsindex.xml" rel="alternate" type="application/rss+xml">
<link rel="canonical" href="https://ifritjp.github.io/documents/en/lunescript/generics/">
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/theme.min.css">
<script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/chroma.min.css">
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js"></script>
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/custom.css">
<script src="https://ifritjp.github.io/documents/js/bundle.js"></script>
<script src="https://ifritjp.github.io/documents/js/lnsSrcRun.js"></script>
<script src="https://ifritjp.github.io/documents/js/highlight_lns.js"></script>
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/highlight_lns.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script><style>
:root {}
</style>
<meta property="og:title" content="19. generics" />
<meta property="og:description" content="Here we describe the generics that LuneScript supports.
LuneScript originally supported generics only for the built-in types List/Array/Map, but now supports generics for user-defined functions and classes as well.
function Declare the generics for the function like this:
// @lnsFront: ok fn func&lt;T&gt;( val:T ) : Set&lt;T&gt; { return (@ val); } As you can probably understand by looking at the above sample, when declaring a function, declare it with the function name &#43; &lt;formal type parameter&gt;." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ifritjp.github.io/documents/en/lunescript/generics/" /><meta property="article:section" content="LuneScript" />

<meta property="og:site_name" content="tech" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="19. generics"/>
<meta name="twitter:description" content="Here we describe the generics that LuneScript supports.
LuneScript originally supported generics only for the built-in types List/Array/Map, but now supports generics for user-defined functions and classes as well.
function Declare the generics for the function like this:
// @lnsFront: ok fn func&lt;T&gt;( val:T ) : Set&lt;T&gt; { return (@ val); } As you can probably understand by looking at the above sample, when declaring a function, declare it with the function name &#43; &lt;formal type parameter&gt;."/>
<meta itemprop="name" content="19. generics">
<meta itemprop="description" content="Here we describe the generics that LuneScript supports.
LuneScript originally supported generics only for the built-in types List/Array/Map, but now supports generics for user-defined functions and classes as well.
function Declare the generics for the function like this:
// @lnsFront: ok fn func&lt;T&gt;( val:T ) : Set&lt;T&gt; { return (@ val); } As you can probably understand by looking at the above sample, when declaring a function, declare it with the function name &#43; &lt;formal type parameter&gt;.">

<meta itemprop="wordCount" content="1691">
<meta itemprop="keywords" content="" />
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4708B8S6ES"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4708B8S6ES');
</script>
</head>
<body><div class="container"><header>
<h1>tech</h1>


[<a href="https://ifritjp.github.io/documents/en/">English</a>]

[<a href="https://ifritjp.github.io/documents/">Japanese</a>]

</header>
<div class="global-menu">
<nav>
<ul>
<li><a href="/documents/">Home</a></li>
<li><a href="https://ifritjp.github.io/blog2/public/">blog</a></li>
<li><a href="https://ifritjp.github.io/LuneScript-webFront/lnsc_web_frontend/for_wasm/">LuneScript on Web</a></li></ul>
</nav>
</div>
<div class="content-container">
<main><h1>19. generics</h1>

<p>
Here we describe the generics that LuneScript supports.</p>
<p>
LuneScript originally supported generics only for the built-in types List/Array/Map, but now supports generics for user-defined functions and classes as well.</p>
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
function
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>
Declare the generics for the function like this:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func&lt;T&gt;( val:T ) : Set&lt;T&gt; {
   return (@ val);
}</code></pre>
</div>
<p>
As you can probably understand by looking at the above sample, when declaring a function, declare it with the function name + <code>&lt;formal type parameter&gt;</code>.</p>
<p>
where func&lt;T&gt;() is a function that produces a Set&lt;T&gt; with the values of its arguments.</p>
<p>
You can specify multiple formal type parameters.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func&lt;T1,T2&gt;( val1:T1, val2:T2 ) : Set&lt;T1&gt;, List&lt;T2&gt; {
   return (@ val1), [ val2 ];
}</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
nilable, mutable
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<p>
Formal type parameters have the same concept of nilable and mutable as ordinary types.</p>
<p>
This allows you to write something like:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func1&lt;T&gt;( val:T ) : T {
   return val;
}
fn func2&lt;T&gt;( val:T ) : &amp;T {
   return val;
}
fn func3&lt;T&gt;( val:T ) : T! {
   return val;
}
let mut test1 = func1( [ 1, 2 ] );
test1.insert( 1 );
let mut test2 = func2( [ 1, 2 ] );
test2.insert( 1 ); // error test2 is not mutable
let mut test3 = func3( [ 1, 2 ] );
test3.insert( 1 ); // error test3 is nilable</code></pre>
</div>
<ul>
<li>func1 returns its argument in plain type T .</li>
<li>func2 returns its argument in immutable type &amp;T.</li>
<li>func3 returns its argument as nilable type T!.</li>
</ul>
<p>As a result, <code class="verbatim">test1.insert()</code> is possible, but test2 and test3 will result in compilation errors.</p>
<p>
Note that nilable and mutable can be used when using formal type parameters, but cannot be used when declaring formal type parameter names. In other words, <code>func1&lt;T!&gt;</code> like this is an error:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func1&lt;T!&gt;( val:T ) : T {
   return val;
}</code></pre>
</div>
<p>
Also, nilable cannot be used for formal type parameters. In other words, it will error if:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func1&lt;T&gt;( val:T ) : T {
   return val;
}
let val:int! = 1;
print( func1( val ) ); // error type mismatch</code></pre>
</div>
<p>
In this example, func1( val ) gives an int! to func1() , but the val of <code>func1&lt;T&gt;(val:T)</code> is T , and the formal type parameter cannot be nilable, so it is an error.</p>
<p>
If you want to do something like this, declare it like this:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func1&lt;T&gt;( val:T! ) : T {
   return unwrap val;
}
let val:int! = 1;
print( func1( val ) ); // ok</code></pre>
</div>
<p>
In other words, <code>fn func1&lt;T&gt;( val:T! )</code> declares that the argument of func1() is nilable.</p>
<p>
However, not being able to handle nilable values can be inconvenient. We provide Nilable&lt;T&gt; for such cases.</p>
<p>
We will discuss this separately at a later date.</p>
<div id="outline-container-headline-3" class="outline-3">
<h3 id="headline-3">
sample
</h3>
<div id="outline-text-headline-3" class="outline-text-3">
<p>
Using generics, you can write something like this:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func&lt;T&gt;( val:T ) : Set&lt;T&gt; {
   return (@ val);
}
foreach val in func( &#34;foo&#34; ) {
   print( val .. &#34;bar&#34; );  // foobar
}
foreach val in func( 1 ) {
   print( val + 100 );  // 101
}</code></pre>
</div>
<p>
func( &#34;foo&#34; ) produces a Set&lt;str&gt; of (@ &#34;foo&#34; ) and func( 1 ) produces a Set&lt;int&gt; of (@ 1 ) .</p>
<p>
As you can see above, the type parameters are determined according to the arguments called.</p>
<div id="outline-container-headline-4" class="outline-4">
<h4 id="headline-4">
effect
</h4>
<div id="outline-text-headline-4" class="outline-text-4">
<p>
By using stem instead of generics, similar processing can be described as follows.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( val:stem ) : Set&lt;stem&gt; {
   return (@ val);
}
foreach val in func( &#34;foo&#34; ) {
   print( val@@str .. &#34;bar&#34; );
}
foreach val in func( 1 ) {
   print( val@@int + 100 );
}</code></pre>
</div>
<p>
However, in this case, type information such as str and int will be rounded to stem . Casting <code>@@str</code> or <code>@@int</code> is necessary because it will be rounded to the stem.</p>
<p>
Casting is inconvenient and, above all, extremely dangerous.</p>
<p>
Generics allow safe access without casts.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-5" class="outline-2">
<h2 id="headline-5">
class
</h2>
<div id="outline-text-headline-5" class="outline-text-2">
<p>
Declare your class&#39;s Generics like this:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test&lt;T&gt; {
   let val:T;
   pub fn func() : List&lt;T&gt; {
      return [ self.val ];
   }
}</code></pre>
</div>
<p>
For classes, specify the formal type parameters when specifying the name of the class declaration.</p>
<p>
When declaring a method outside the class declaration, declaration of formal type parameters is unnecessary as follows.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
pub fn Test.func2() : Set&lt;T&gt; {
   return (@ self.val );
}</code></pre>
</div>
<p>
Create an instance of the Generics class like this:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
let test = new Test&lt;str&gt;( &#34;abc&#34; );</code></pre>
</div>
<p>
In addition, if all formal parameters are used for the arguments of the constructor, it is possible to omit the actual type parameters as follows.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
let test = new Test( &#34;abc&#34; );</code></pre>
</div>
<p>
<strong>The interface is not generics aware.</strong></p>
</div>
</div>
<div id="outline-container-headline-6" class="outline-2">
<h2 id="headline-6">
method
</h2>
<div id="outline-text-headline-6" class="outline-text-2">
<p>
A method can have both class formal type parameters and method formal type parameters.</p>
<p>
The following sample <code class="verbatim">Test.func()</code> method has a class formal type parameter T and a method formal type parameter T2.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test&lt;T&gt; {
   let val:T;
   pub fn func&lt;T2&gt;(val:T2) : Map&lt;T,T2&gt; {
      return { self.val: val };
   }
}
let test = new Test( &#34;abc&#34;);
foreach val, key in test.func( 1 ) {
   print( key .. &#34;xyz&#34;, val + 10 );
}
foreach val, key in test.func( &#34;ABC&#34; ) {
   print( key .. &#34;xyz&#34;, val .. &#34;XYZ&#34; );
}</code></pre>
</div>
<div id="outline-container-headline-7" class="outline-3">
<h3 id="headline-7">
Overriding methods with type parameters as return values
</h3>
<div id="outline-text-headline-7" class="outline-text-3">
<p>
It is not possible to override a method func whose return value has a type parameter like the following.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
class Super&lt;T&gt; {
   let val:T;
   pub fn func():T {
      return self.val;
   }
}
class Sub extend Super&lt;int&gt; {
   pub override fn func(): int { // error
      return 1;
   }
}</code></pre>
</div>
<p>
Overriding such a method requires a special declaration of the type parameter of the inheriting class.</p>
<p>
For example:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Super&lt;T&gt; {
   let val:T;
   pub fn func():T {
      return self.val;
   }
}
class Sub extend Super&lt;A=int&gt; {  // A=int
   pub override fn func(): A {
      return 1;
   }
}</code></pre>
</div>
<p>
In this example, the Sub class inherits from <code class="verbatim">Super&lt;T&gt;</code> as <code class="verbatim">Super&lt;A=int&gt;</code>.</p>
<p>
This <code class="verbatim">Super&lt;A=int&gt;</code> declares that the type parameter int is used as the A type. And specify A as the return type of the overriding func().</p>
<p>
This allows you to override methods that have type parameters as return values.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-8" class="outline-2">
<h2 id="headline-8">
Constraints on type parameters
</h2>
<div id="outline-text-headline-8" class="outline-text-2">
<p>
An actual type parameter can be any type except nil .</p>
<p>
For this reason, operations on formal parameter type values within generics classes and functions are limited to type-independent operations such as <code>==</code> and <code class="verbatim">~=</code>.</p>
<p>
With this, it is not possible to write effective processing in the processing within Generics.</p>
<p>
So we use type parameter constraints.</p>
<div id="outline-container-headline-9" class="outline-3">
<h3 id="headline-9">
sample
</h3>
<div id="outline-text-headline-9" class="outline-text-3">
<p>
Here is a sample type parameter constraint:</p>
<p>
Here, the declaration <code>class Test&lt;T:Val&gt;</code> restricts the formal type parameter of the Test class to the Val class.</p>
<p>
This allows you to call the method <code class="verbatim">func()</code> of the Val class on the value of val within the <code class="verbatim">Test.sub()</code> method.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
abstract class Val {
   pub abstract fn func(): str;
}
class Test&lt;T:Val&gt; {
   let val:T;
   pub fn sub() {
      print( &#34;this is &#34; .. self.val.func() );
   }
}</code></pre>
</div>
<p>
Here is an example using this Test class.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
abstract class Val {
   pub abstract fn func(): str;
}
class Test&lt;T:Val&gt; {
   let val:T;
   pub fn sub() {
      print( &#34;this is &#34; .. self.val.func() );
   }
}

class Val1 extend Val {
   pub override fn func(): str {
      return &#34;val1&#34;;
   }
}

class Val2 extend Val {
   pub override fn func(): str {
      return  &#34;val2&#34;;
   }
}

fn func1( test:Test&lt;Val1&gt; ) {
   test.sub();
}
fn func2( test:Test&lt;Val2&gt; ) {
   test.sub();
}

func1( new Test( new Val1() ) );  // this is val1
func2( new Test( new Val2() ) );  // this is val2</code></pre>
</div>
<p>
The configuration for this sample is:</p>
<ul>
<li>Val1 and Val2 classes are classes that inherit Val class</li>
<li>The <code class="verbatim">func()</code> function has an argument test of type Test and calls the <code class="verbatim">test.sub()</code> method.</li>
<li><code>new Test( new Val1() )</code> and <code>new Test( new Val2() )</code> generate Test type instances of the real type parameters of Val1 and Val2 and call the <code class="verbatim">func()</code> function.</li>
</ul>
<p>As a result, <code class="verbatim">Val1.func()</code> and <code class="verbatim">Val2.func()</code> are called and <code>this is val1</code> and <code>this is val2</code> are output.</p>
<p>
Note that T of <code>Test&lt;T:Val&gt;</code> must be Val, so specifying <code>new Test&lt;&#34;abc&#34;&gt;</code>, for example, will result in an error.</p>
<p>
Because &#34;abc&#34; is of type str and str is not of type Val.</p>
<p>
By the way, the syntax of formal type parameter constraint is the same as extend of class.</p>
<p>
So:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
class Hoge&lt;T:SuperClass(IF,...)&gt; {
}</code></pre>
</div>
<p>
where SuperClass is the class and IF is the interface.</p>
<p>
SuperClass and IF are optional.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-10" class="outline-2">
<h2 id="headline-10">
Mapping of generics class
</h2>
<div id="outline-text-headline-10" class="outline-text-2">
<p>
LuneScript has a Mapping function that converts class instances to Map objects.</p>
<p>
Regarding Mapping, please refer to the following article:</p>
<p>
<a href="../classmapping">../classmapping</a></p>
<p>
To map a class, the class must extend the Mapping interface.</p>
<p>
Here is a simple example.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test&lt;T&gt; extend (Mapping) {
   let txt:str;
   pub fn func( val:T ) {
      print( self.txt, val );
   }
}

let test = new Test&lt;int&gt;( &#34;hoge&#34; );
let map = test._toMap();
if! let test2 = Test&lt;int&gt;._fromMap( map ) {
   test2.func( 1 );
}</code></pre>
</div>
<p>
The Test&lt;T&gt; class extends Mapping. This makes the Test&lt;T&gt; class Mappable.</p>
<p>
The above case is no different from normal non-Generics classes. This is because it does not have a formal parameter type member.</p>
<p>
It is an error to have a member of a formal type parameter type as follows.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
class Test&lt;T&gt; extend (Mapping) {
   let txt:T;
}</code></pre>
</div>
<p>
This is because, in order for a class to extend Mapping, all members of the class must be mappable, whereas the formal type parameter T, which is the type of member txt, can be any type other than nilable. because it can be</p>
<p>
To avoid this, place a Mapping constraint on the formal type parameter that you use as the type of the member.</p>
<p>
Specifically, it is <code>Test&lt;T:(Mapping)&gt;</code> as follows.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test&lt;T:(Mapping)&gt; extend (Mapping) {
   let val:T {pub};
}

let test = new Test( &#34;abc&#34; );
let map = test._toMap();
if! let test2 = Test&lt;str&gt;._fromMap( map ) {
   print( test2.$val .. &#34;xyz&#34; );
}</code></pre>
</div>
<p>
This makes the Generics class Mappable.</p>
</div>
</div>
<div class="edit-meta">

<br></div><nav class="pagination"><a class="nav nav-prev-2" href="https://ifritjp.github.io/documents/en/lunescript/classmapping/" title="18. mapping"><i class="fas fa-arrow-left" aria-hidden="true"></i> Prev - 18. mapping</a>
<a class="nav nav-next-2" href="https://ifritjp.github.io/documents/en/lunescript/generics-go/" title="19.2. generics (two collection types)">Next - 19.2. generics (two collection types) <i class="fas fa-arrow-right" aria-hidden="true"></i></a>
</nav><footer><p class="powered">Powered by <a href="https://gohugo.io">Hugo</a>. Theme by <a href="https://themes.gohugo.io/hugo-theme-techdoc/">TechDoc</a>. Designed by <a href="https://github.com/thingsym/hugo-theme-techdoc">Thingsym</a>.</p>
</footer>
</main><div class="sidebar">

<nav class="slide-menu">
<ul>
<li class=""><a href="https://ifritjp.github.io/documents">Home</a></li>

<li class="parent has-sub-menu"><a href="https://ifritjp.github.io/documents/en/lunescript/">Easier Lua development with the transcompiler LuneScript!!<span class="mark opened">-</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/tutorial2.setup/">01. Introduction</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/tutorial3.hello/">02. Hello world</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/crosscompile/">03. Cross-compiling between Lua versions</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/value/">04. Values</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/set/">04.2. Set</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/tuple/">04.3 Tuples</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/enum/">05. enum</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/match/">06. match</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/variable/">07. Variables</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/branch/">08. General branch syntax</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/loop/">09. Repetition Syntax</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/func/">10. Functions</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/multipleretval/">10.2. Multi-value return values</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/defaultarg/">10.3. Omitting Arguments</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/arg/">10.4. Variadic Arguments and Return Values</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/closure/">10.5. Closures</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/error/">10.6. Error handling</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/nilable/">11. nilable</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/class1/">12. Class basics</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/class2accessor/">13. accessor</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/classinherit/">14. Class Inheritance</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/classadvertise/">15. Class advertise</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/classoverride/">16. Class override</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/interface/">17. Interface</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/classmapping/">18. mapping</a></li>
<li class="active"><a href="https://ifritjp.github.io/documents/en/lunescript/generics/">19. generics</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/generics-go/">19.2. generics (two collection types)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/nilcond/">20. nil conditional operator</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/import/">21. import/provide</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/require/">22. require/module</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/glue/">22.1. Semi-automatic generation of glue code</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/lua/">22.2. Linking with Lua</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/make/">23. Build</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/macro/">24. Macro</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/cast/">25. Cast</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/subfile/">26. subfile</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/lazyloading/">27. Lazy Loading</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/shebang_main/">28. shebang and command line arguments</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/dir/">29. Recommended directory structure for projects using LuneScript</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/go/">80. Transcompiling to Go Language</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/go_package/">80.2 Packages when transpiling to Go</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/go_wasm/">80.4 WebAssembly support for LuneScript</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/async/">81. Safe Asynchronous Processing</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/async_old/">81.1 Asynchronous processing (past information)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/luago/">82. Linking with Lua</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/ebnf/">A. BNF</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/onweb/">A. LuneScript running on a web browser</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/reason/">A. Reason for developing Lua transcompiler LuneScript</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/recommend/">A. Recommendations for transcompiler development</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/lnstags/">A. Tag jumping with lnstags (source code tagging system)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/completion/">A.Let&#39;s have more fun in a modern development environment</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/box/">Box edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/lua_runtime/">Lua runtime when transpiling to 80.3 Go</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/test/">X. The Importance of Self-Hosting and Test Design in Language Development Quality Control</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/design/">Y.1 How to develop LuneScript</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/design-2/">Y.2 Development of LuneScript (type information management)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/design-3/">Y.3 LuneScript Development (Scopes and Symbols)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/go_study/">Z. Transcompile to Go language (exploratory stage)</a></li>
</ul>
  
</li>
</ul>
</nav>



<div class="sidebar-footer"></div>
</div>
</div><a href="#" id="backtothetop-fixed" class="backtothetop"
 data-backtothetop-duration="600"
 data-backtothetop-easing="easeOutQuart"
 data-backtothetop-fixed-fadeIn="1000"
 data-backtothetop-fixed-fadeOut="1000"
 data-backtothetop-fixed-bottom="10"
 data-backtothetop-fixed-right="20">
<span class="fa-layers fa-fw">
<i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i>
</span></a>
</div>
</body>
</html>
