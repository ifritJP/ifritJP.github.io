<!DOCTYPE html>
<html lang="ja-jp">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>12. Class Basics - tech</title>
<meta name="generator" content="Hugo 0.109.0">
<link href="https://ifritjp.github.io/documentsindex.xml" rel="alternate" type="application/rss+xml">
<link rel="canonical" href="https://ifritjp.github.io/documents/en/lunescript/class1/">
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/theme.min.css">
<script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/chroma.min.css">
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js"></script>
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/custom.css">
<script src="https://ifritjp.github.io/documents/js/bundle.js"></script>
<script src="https://ifritjp.github.io/documents/js/lnsSrcRun.js"></script>
<script src="https://ifritjp.github.io/documents/js/highlight_lns.js"></script>
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/highlight_lns.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script><style>
:root {}
</style>
<meta property="og:title" content="12. Class Basics" />
<meta property="og:description" content="LuneScript supports object-oriented programming with classes.
Class specifications LuneScript classes support the following:
Access control accessor Inheritance abstract override advertise Mapping interface This time, I will explain the basic class definition.
Minimum class definition The minimum class definition is as follows.
// @lnsFront: ok class Test { } It defines a class called Test.
Note that the class definition must be done in the highest scope.
(2019/6/24) Added support for class definition in functions." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ifritjp.github.io/documents/en/lunescript/class1/" /><meta property="article:section" content="LuneScript" />

<meta property="og:site_name" content="tech" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="12. Class Basics"/>
<meta name="twitter:description" content="LuneScript supports object-oriented programming with classes.
Class specifications LuneScript classes support the following:
Access control accessor Inheritance abstract override advertise Mapping interface This time, I will explain the basic class definition.
Minimum class definition The minimum class definition is as follows.
// @lnsFront: ok class Test { } It defines a class called Test.
Note that the class definition must be done in the highest scope.
(2019/6/24) Added support for class definition in functions."/>
<meta itemprop="name" content="12. Class Basics">
<meta itemprop="description" content="LuneScript supports object-oriented programming with classes.
Class specifications LuneScript classes support the following:
Access control accessor Inheritance abstract override advertise Mapping interface This time, I will explain the basic class definition.
Minimum class definition The minimum class definition is as follows.
// @lnsFront: ok class Test { } It defines a class called Test.
Note that the class definition must be done in the highest scope.
(2019/6/24) Added support for class definition in functions.">

<meta itemprop="wordCount" content="2333">
<meta itemprop="keywords" content="" />
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4708B8S6ES"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4708B8S6ES');
</script>
</head>
<body><div class="container"><header>
<h1>tech</h1>


[<a href="https://ifritjp.github.io/documents/en/">English</a>]

[<a href="https://ifritjp.github.io/documents/">Japanese</a>]

</header>
<div class="global-menu">
<nav>
<ul>
<li><a href="/documents/">Home</a></li>
<li><a href="https://ifritjp.github.io/blog2/public/">blog</a></li>
<li><a href="https://ifritjp.github.io/LuneScript-webFront/lnsc_web_frontend/for_fengari/">LuneScript on Web</a></li></ul>
</nav>
</div>
<div class="content-container">
<main><h1>12. Class Basics</h1>

<p>
LuneScript supports object-oriented programming with classes.</p>
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
Class specifications
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>
LuneScript classes support the following:</p>
<ul>
<li>Access control</li>
<li>accessor</li>
<li>Inheritance</li>
<li>abstract</li>
<li>override</li>
<li>advertise</li>
<li>Mapping</li>
<li>interface  </li>
</ul>
<p>This time, I will explain the basic class definition.</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
Minimum class definition
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<p>
The minimum class definition is as follows.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
}</code></pre>
</div>
<p>
It defines a class called Test.</p>
<p>
<del>Note that the class definition must be done in the highest scope.</del></p>
<p>
<strong>(2019/6/24) Added support for class definition in functions. However, classes that can be exposed to the outside must be declared in the highest scope.</strong></p>
<div id="outline-container-headline-3" class="outline-3">
<h3 id="headline-3">
External disclosure
</h3>
<div id="outline-text-headline-3" class="outline-text-3">
<p>
To expose the class to an external module, add pub as follows:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
pub class Test {
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-4" class="outline-2">
<h2 id="headline-4">
Instance generation
</h2>
<div id="outline-text-headline-4" class="outline-text-2">
<p>
Instantiation of a class uses the new operator as follows:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
}
let test = new Test();</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-5" class="outline-2">
<h2 id="headline-5">
Method definition
</h2>
<div id="outline-text-headline-5" class="outline-text-2">
<p>
The method definition is almost the same as the function definition.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pub fn func() {
      print( __func__ );
   }
}
let test = new Test();
test.func();  // Test.func</code></pre>
</div>
<p>
Note that the method cannot be set to form type.</p>
<p>
For example, the following <code>sub( test.func )</code> will fail.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
class Test {
   pub fn func() {
      print( __func__ );
   }
}
fn sub( foo:form ) {
   foo();
}

let test = new Test();
sub( test.func );  // error</code></pre>
</div>
<p>
To avoid this error, create an anonymous function and pass it to <code class="verbatim">sub()</code> as follows:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pub fn func() {
      print( __func__ );
   }
}
fn sub( foo:form ) {
   foo();
}

let test = new Test();
sub( fn() { test.func(); } );</code></pre>
</div>
<div id="outline-container-headline-6" class="outline-3">
<h3 id="headline-6">
Access control
</h3>
<div id="outline-text-headline-6" class="outline-text-3">
<p>
There are three types of access control:</p>
<table>
<thead>
<tr>
<th>kinds</th>
<th>meaning</th>
<th class="align-right"></th>
</tr>
</thead>
<tbody>
<tr>
<td>pub</td>
<td>External disclosure</td>
<td class="align-right"></td>
</tr>
<tr>
<td>local</td>
<td>Published in the same module</td>
<td class="align-right"></td>
</tr>
<tr>
<td>pro</td>
<td>Publish to subclass</td>
<td class="align-right"></td>
</tr>
<tr>
<td>pri</td>
<td>private</td>
<td class="align-right"></td>
</tr>
</tbody>
</table>
<p>
If not specified, the default is pri.</p>
</div>
</div>
<div id="outline-container-headline-7" class="outline-3">
<h3 id="headline-7">
self symbol
</h3>
<div id="outline-text-headline-7" class="outline-text-3">
<p>
You can use the self symbol in the method.</p>
<p>
The self symbol represents an instance of itself.</p>
<p>
In the following example, the public method sub calls the private method <code class="verbatim">func()</code> using self.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   fn func() {
      print( __func__ );
   }
   pub fn sub() {
      self.func();
   }
}
let test = new Test();
test.sub();  // Test.func</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-8" class="outline-3">
<h3 id="headline-8">
Separatism
</h3>
<div id="outline-text-headline-8" class="outline-text-3">
<p>
The method can be defined separately from the class definition.</p>
<p>
The method definition above can also be written as follows.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
}
pub fn Test.func() {
   print( __func__ );
}
let test = new Test();
test.func();  // Test.func</code></pre>
</div>
<p>
However, the method of the class defined in another module cannot be defined in the module being imported.</p>
</div>
</div>
<div id="outline-container-headline-9" class="outline-3">
<h3 id="headline-9">
prototype declaration
</h3>
<div id="outline-text-headline-9" class="outline-text-3">
<p>
Method definitions can also separate the actual definition by declaring only the type within the class definition.</p>
<p>
The following example prototypes <code class="verbatim">func()</code> and separates the actual definition.</p>
<p>
Prototyping <code class="verbatim">func()</code> allows you to call <code class="verbatim">func()</code> within = sub () =.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   fn func();
   pub fn sub() {
      self.func();
   }
}
pub fn Test.func() {
   print( __func__ );
}
let test = new Test();
test.sub();  // Test.func</code></pre>
</div>
<p>
Of course, the prototype declaration and the actual method type must match.</p>
</div>
</div>
<div id="outline-container-headline-10" class="outline-3">
<h3 id="headline-10">
Class method definition
</h3>
<div id="outline-text-headline-10" class="outline-text-3">
<p>
Normal methods cannot be executed without an instance because they are associated with an instance, but class methods associated with a class can be executed without an instance.</p>
<p>
To define a class method, simply add static to the method definition.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pub static fn sfunc() {
      print( __func__ );
   }
}
Test.sfunc(); // Test.sfunc</code></pre>
</div>
<p>
<strong>Class methods are only available in classes defined in the highest scope.</strong></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-11" class="outline-2">
<h2 id="headline-11">
Member definition
</h2>
<div id="outline-text-headline-11" class="outline-text-2">
<p>
Member definitions are similar to variable definitions, with the following differences:</p>
<ul>
<li>Initial value cannot be set at the time of declaration</li>
<li>Access control added</li>
<li>accessor can be specified</li>
</ul>
<p>The following is an example of member definition.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pri let val1:int;
   pri let val2:int;
   pri let val3:int;
   pub fn func() {
      print( self.val1, self.val2, self.val3 );
   }

}
let test = new Test( 1, 2, 3 );
test.func(); // 1 2 3</code></pre>
</div>
<p>
Class Test has val1, val2, val3 as members.</p>
<p>
The definition of val1 is <code>pri let val1:int;</code>.</p>
<p>
I don&#39;t think this is a problem because it&#39;s just a regular variable declaration with pri.</p>
<p>
pri is access control and has the same meaning as the method definition.</p>
</div>
</div>
<div id="outline-container-headline-12" class="outline-2">
<h2 id="headline-12">
mutable
</h2>
<div id="outline-text-headline-12" class="outline-text-2">
<p>
Members and methods also have mutable and immutable.</p>
<p>
The differences between the methods mutable and immutable are as follows:</p>
<ul>
<li>A mutable method is a method whose members can be changed.</li>
<li>Immutable methods are methods whose members cannot be changed</li>
</ul>
<p>The following are examples of mutable members and methods.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pri let mut val1:int;
   pri let val2:int;
   pub fn func() {
      print( self.val1, self.val2 );
   }
   pub fn add( val:int ) mut {
      self.val1 = self.val1 + val;
   }
}
let mut test = new Test( 1, 2 );
test.func(); // 1 2
test.add( 10 );
test.func(); // 11 2</code></pre>
</div>
<p>
In this example, val1 is mutable and val2 is immutable. Also, <code class="verbatim">func()</code> is immutable and <code class="verbatim">add()</code> is mutable.</p>
<p>
<strong>Mutable methods declare mut after the argument is declared.</strong></p>
<p>
The mutable method <code class="verbatim">add()</code> sets the value in member val1. It can be built without error.</p>
<p>
So what happens if you remove the mut declaration of method <code class="verbatim">add()</code> as follows?</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
class Test {
   pri let mut val1:int;
   pri let val2:int;
   pub fn func() {
      print( self.val1, self.val2 );
   }
   pub fn add( val:int ) {
      self.val1 = self.val1 + val;  // error
   }
}</code></pre>
</div>
<p>
The above example will result in an error.</p>
<p>
If you try to change a member from within a method that is not mutable, you will get an error.</p>
<p>
You will also get an error if:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
class Test {
   pri let mut val:int;
   pub fn increment() mut {
      self.val = self.val + 1;
   }
   pub fn func() {
      self.increment(); // error
   }
}</code></pre>
</div>
<p>
In the above example, <code class="verbatim">func()</code> calls <code class="verbatim">increment()</code>, but immutable methods cannot call mutable methods.</p>
</div>
</div>
<div id="outline-container-headline-13" class="outline-2">
<h2 id="headline-13">
allmut member
</h2>
<div id="outline-text-headline-13" class="outline-text-2">
<p>
As mentioned earlier, if a class member is mutable, but the instance of that class is immutable, then that member is immutable.</p>
<p>
In the following example, the mutable member val is accessed from within the <code class="verbatim">func()</code> method, but since the <code class="verbatim">func()</code> method is immutable, the val is also immutable and an error occurs.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
class Test {
   pri let mut val:int;
   pub fn func() {
      self.val = self.val + 1;  // error
   }
}</code></pre>
</div>
<p>
mutablity is a necessary concept to prevent unintended changes in value. On the other hand, it is a very strict rule that no member can be changed from an immutable method.</p>
<p>
If this rule is applied, it will be difficult to design in the following cases, for example.</p>
<ul>
<li>Consider a class Data that manages read-only data by associating it with a key</li>
<li>In the Data class, define a method <code class="verbatim">get()</code> that returns the associated data when a key is given as an argument.</li>
<li>The Data instance that registered all the data to be managed should be immutable to prevent unnecessary changes.</li>
</ul>
<p>I think this is a general idea.</p>
<p>
Then, suppose that the following specifications are added after the development progresses.</p>
<ul>
<li>In order to speed up the processing of the above <code class="verbatim">get()</code> method, the previous argument key and the data associated with that key are cached.</li>
</ul>
<p>This process of &#34;cache the previous argument key and the data associated with that key&#34; will rewrite the data. That is, it must be mutable, not immutable.</p>
<p>
On the other hand, Data instances have already been declared immutable in many places. In other words, it cannot be cached.</p>
<p>
Allmut is used in such cases. allmut declares a member mutablity and is always mutable independent of the instance mutablity.</p>
<p>
The following is a sample of allmut.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pri let allmut val:int;
   pub fn func() {
      self.val = self.val + 1;  // ok
   }
}</code></pre>
</div>
<p>
By declaring <code>pri let allmut val:int;</code> in this way, val will always be mutable. This makes it possible to rewrite val from the immutable method <code class="verbatim">func()</code>.</p>
<p>
<strong>However, allmut is just a remedy and should not be overused.</strong></p>
<p>
<strong>In particular, when performing asynchronous programming with go described later, safety is not guaranteed if allmut is present.</strong></p>
</div>
</div>
<div id="outline-container-headline-14" class="outline-2">
<h2 id="headline-14">
Constructor definition
</h2>
<div id="outline-text-headline-14" class="outline-text-2">
<p>
The constructor can be defined with __init.</p>
<p>
Constructors differ from method definitions in the following ways:</p>
<ul>
<li>The constructor name must be __init.</li>
<li>The return type cannot be specified.</li>
<li>The constructor definition must come after all member definitions.</li>
<li>
<p>If you inherit from a class, you must first execute the constructor for that class.</p>
<ul>
<li>Execution of the constructor of the super class uses <code class="verbatim">super()</code>.</li>
</ul>
</li>
<li>
<p>The constructor must initialize all members.</p>
<ul>
<li>If you do not explicitly initialize members of type nilable, the default value is nil.</li>
</ul>
</li>
<li>
<p>The method defined in the class can be accessed only after all the members have been initialized by the process in the constructor.</p>
<ul>
<li>However, static methods and methods of super class can be accessed.</li>
<li>Also, the method can be accessed from the function object defined in the constructor.</li>
</ul>
</li>
<li>You cannot call a method that just declares a prototype from within the constructor.</li>
<li>You cannot return in the constructor.</li>
</ul>
<p>The following is an example of the constructor.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pri let val1:int;
   pri let val2:int;
   pub fn __init() {
      self.val1 = 0;
      self.val2 = 0;
   }
}
let test = new Test();</code></pre>
</div>
<p>
The constructor can also set initial values for immutable members.</p>
<div id="outline-container-headline-15" class="outline-3">
<h3 id="headline-15">
Constructor arguments
</h3>
<div id="outline-text-headline-15" class="outline-text-3">
<p>
The constructor can have arguments. This argument is given by the new operator.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pri let val1:int;
   pri let val2:int;
   pub fn __init( val1:int, val2:int ) {
      self.val1 = val1 + 10;
      self.val2 = val2 + 10;
   }
   pub fn func() {
      print( self.val1, self.val2 );
   }
}
let test = new Test( 1, 2 );
test.func(); // 11 12</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-16" class="outline-3">
<h3 id="headline-16">
Default constructor
</h3>
<div id="outline-text-headline-16" class="outline-text-3">
<p>
If you do not define a constructor, a constructor that sets all members is automatically generated. This constructor is called the default constructor.</p>
<p>
The default constructor has arguments to set all members. The order of the arguments is the order in which the members of the class are declared.</p>
<p>
The following class declaration does not declare a constructor, so a default constructor is generated internally.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pri let val1:int;
   pri let val2:int;
}</code></pre>
</div>
<p>
Its default constructor is defined as:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
   pub fn __init( val1:int, val2:int ) {
      self.val1 = val1;
      self.val2 = val2;
   }</code></pre>
</div>
<p>
The default constructor access control is pub.</p>
<div id="outline-container-headline-17" class="outline-4">
<h4 id="headline-17">
Default constructor for derived classes
</h4>
<div id="outline-text-headline-17" class="outline-text-4">
<p>
There are two types of default constructors for derived classes: old and current.</p>
<div id="outline-container-headline-18" class="outline-5">
<h5 id="headline-18">
Current format
</h5>
<div id="outline-text-headline-18" class="outline-text-5">
<p>
The current form default constructor for a derived class Sub is:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pro let val:int;
}
class Sub extend Test {
   let val2:int;
   pub fn func() {
      print( self.val, self.val2 );
   }
}
let sub = new Sub( 1, 2 );
sub.func(); // 1, 2</code></pre>
</div>
<p>
Like <code>new Sub( 1, 2 )</code> above, it is an argument of the constructor of the super class + all members of the derived class.</p>
</div>
</div>
<div id="outline-container-headline-19" class="outline-5">
<h5 id="headline-19">
Old format
</h5>
<div id="outline-text-headline-19" class="outline-text-5">
<p>
The old-style default constructor for a derived class Sub is:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pro let val:int!;
}
class Sub extend Test {
   let val2:int;
   _lune_control default__init_old;
   pub fn func() {
      print( self.val, self.val2 );
   }
}
let sub = new Sub( 2 );
sub.func(); // nil, 2</code></pre>
</div>
<p>
It will be all members of the derived class, as in <code>new Sub( 2 )</code> above.</p>
<p>
In the old format, all arguments of the super class must be nilable. You also need to declare in <code>_lune_control default__init_old;</code> that you want to use the old-style default constructor. This declaration must be declared after declaring all members.</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-20" class="outline-4">
<h4 id="headline-20">
Explicit default constructor
</h4>
<div id="outline-text-headline-20" class="outline-text-4">
<p>
The default constructor is generated internally if you do not define a constructor.</p>
<p>
However, this behavior becomes a problem when writing the following processing.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
class Test {
   pri let mut val:int {pub};
   pub static fn create(): Test {
      return new Test( 1 );  // error
   }
}</code></pre>
</div>
<p>
The above instantiates the Test class within the <code class="verbatim">create()</code> method, but fails with no constructor declaration.</p>
<p>
Originally, the default constructor is generated because there is no constructor definition, but since the timing to define the default constructor is done at the end of the class definition, the <code class="verbatim">create()</code> method in the class definition does not have a constructor.</p>
<p>
In such cases, explicitly declare to use the default constructor.</p>
<p>
Here is an example:</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pri let mut val:int {pub};
   _lune_control default__init;
   pub static fn create(): Test {
      return new Test( 1 );
   }
}</code></pre>
</div>
<p>
By declaring <code>_lune_control default__init;</code>, you can specify the use of the default constructor, and the default constructor will be generated at this time.</p>
<p>
Note that <code>_lune_control default__init;</code> must be declared after all members, just like a regular constructor.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-21" class="outline-2">
<h2 id="headline-21">
Class members
</h2>
<div id="outline-text-headline-21" class="outline-text-2">
<p>
Just as a method has a class method, a member has a class member.</p>
<p>
Just add static to the class member definition.</p>
<p>
Class members are initialized in the __init block.</p>
<p>
The following is an example of a class member definition.</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pri static let val1:int;
   pri static let val2:int;

   __init {
      Test.val1 = 1;
      Test.val2 = 1;
   }
}</code></pre>
</div>
<p>
The __init block has the following restrictions:</p>
<ul>
<li>
<p>The __init block definition must come after all class member definitions.</p>
<ul>
<li>If you do not explicitly initialize members of type nilable, the default value is nil.</li>
</ul>
</li>
<li>The __init block must initialize all members.</li>
<li>You cannot return inside the __init block.</li>
<li>You can call class methods from the __init block, but the class methods you call must be declared before the __init block.</li>
</ul>
</div>
</div>
<div id="outline-container-headline-22" class="outline-2">
<h2 id="headline-22">
summary
</h2>
<div id="outline-text-headline-22" class="outline-text-2">
<p>
LuneScript class definitions support the following:</p>
<ul>
<li>Define a class with the keyword class</li>
<li>Instance creation is new</li>
<li>Access control possible</li>
<li>Access yourself with the self symbol</li>
<li>Separate class definition and method definition</li>
<li>prototype declaration</li>
<li>Static class methods, class members</li>
<li>The constructor is __init</li>
<li>If you do not create a constructor, a default constructor will be created</li>
</ul>
<p>Next time, I will explain how to generate an accessor.</p>
</div>
</div>
<div class="edit-meta">

<br></div><nav class="pagination"><a class="nav nav-prev-2" href="https://ifritjp.github.io/documents/en/lunescript/nilable/" title="11. nilable edition"><i class="fas fa-arrow-left" aria-hidden="true"></i> Prev - 11. nilable edition</a>
<a class="nav nav-next-2" href="https://ifritjp.github.io/documents/en/lunescript/class2accessor/" title="13. accessor edition">Next - 13. accessor edition <i class="fas fa-arrow-right" aria-hidden="true"></i></a>
</nav><footer><p class="powered">Powered by <a href="https://gohugo.io">Hugo</a>. Theme by <a href="https://themes.gohugo.io/hugo-theme-techdoc/">TechDoc</a>. Designed by <a href="https://github.com/thingsym/hugo-theme-techdoc">Thingsym</a>.</p>
</footer>
</main><div class="sidebar">

<nav class="slide-menu">
<ul>
<li class=""><a href="https://ifritjp.github.io/documents">Home</a></li>

<li class="parent has-sub-menu"><a href="https://ifritjp.github.io/documents/en/lunescript/">Making Lua easier with the transcompiler LuneScript !!<span class="mark opened">-</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/tutorial2.setup/">01. Introduction</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/tutorial3.hello/">02. Hello world</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/crosscompile/">03. Cross-compiling between Lua versions</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/value/">04. Value</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/set/">04.2. Set</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/enum/">05. enum edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/match/">06. match edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/variable/">07. Variables</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/branch/">08. General branch syntax</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/loop/">09. Repeated syntax</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/func/">10. Functions</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/multipleretval/">10.2. Multi-valued return value</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/defaultarg/">10.3. Omission of arguments</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/arg/">10.4. Variadic argument, return value</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/closure/">10.5. Closure</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/nilable/">11. nilable edition</a></li>
<li class="active"><a href="https://ifritjp.github.io/documents/en/lunescript/class1/">12. Class Basics</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/class2accessor/">13. accessor edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/classinherit/">14. Class inheritance</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/classadvertise/">15. Class advertise</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/classoverride/">16. Class override</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/interface/">17. Interface</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/classmapping/">18. mapping</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/generics/">19. generics edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/nilcond/">20. nil conditional operator edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/import/">21. import / provide</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/require/">22. require / module edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/glue/">22.1. Semi-automatic generation of glue code</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/lua/">22.2. Cooperation with Lua</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/make/">23. Build</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/macro/">24. Macro edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/cast/">25. Cast edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/subfile/">26. subfile edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/lazyloading/">27. Delayed loading</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/shebang_main/">28. shebang and command line arguments</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/dir/">29. Recommended directory structure for projects that use LuneScript</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/go/">80. Transcompile to Go language</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/go_package/">80.2 Package when transcompiling to Go language</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/lua_runtime/">80.3 Lua runtime when transcompiled to Go</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/async/">81. Safe asynchronous processing</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/async_old/">81.1 Asynchronous processing O (past information)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/luago/">82. Collaboration with Lua</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/completion/">A. Let&#39;s have more fun in an exciting development environment</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/onweb/">A. LuneScript running on a web browser</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/lnstags/">A. Tag jump by lnstags (source code tag system)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/recommend/">A. Transcompiler development recommendations</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/reason/">A. Why Lua&#39;s transcompiler LuneScript was developed</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/box/">Box edition</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/go_study/">Transcompile to Z. Go language (under consideration)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/en/lunescript/test/">X. Importance of self-hosting and test design in quality control of language development</a></li>
</ul>
  
</li>
</ul>
</nav>



<div class="sidebar-footer"></div>
</div>
</div><a href="#" id="backtothetop-fixed" class="backtothetop"
 data-backtothetop-duration="600"
 data-backtothetop-easing="easeOutQuart"
 data-backtothetop-fixed-fadeIn="1000"
 data-backtothetop-fixed-fadeOut="1000"
 data-backtothetop-fixed-bottom="10"
 data-backtothetop-fixed-right="20">
<span class="fa-layers fa-fw">
<i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i>
</span></a>
</div>
</body>
</html>
