<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Making Lua easier with the transcompiler LuneScript !! on tech</title>
    <link>https://ifritjp.github.io/documents/en/lunescript/</link>
    <description>Recent content in Making Lua easier with the transcompiler LuneScript !! on tech</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja-jp</language><atom:link href="https://ifritjp.github.io/documents/en/lunescript/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>01. Introduction</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/tutorial2.setup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/tutorial2.setup/</guid>
      <description>This time, I will introduce how to install LuneScript. LuneScript on Web Browser To check the operation of LuneScript, we have prepared a LuneScript environment that runs on a web browser. ../onweb In addition, the following sample sources may have a Run button. You can run the sample source by pressing that button. And you can modify the source and run it. It takes a few seconds to 10 seconds</description>
    </item>
    
    <item>
      <title>02. Hello world</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/tutorial3.hello/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/tutorial3.hello/</guid>
      <description>This time, I would like to introduce Hello world using LuneScript.
lnsc command Installing LuneScript installs the lnsc command.
Use the lnsc command as follows.
$ lnsc src.lns exe Where src.lns is the path of the script created by LuneScript. exe is an option of lnsc, which means to execute the specified script.
Hello world Now let&amp;#39;s use LuneScript to run the traditional Hello world.
Create a file hello.lns with the following content:</description>
    </item>
    
    <item>
      <title>03. Cross-compiling between Lua versions</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/crosscompile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/crosscompile/</guid>
      <description>This time, I&amp;#39;ll change the schedule a little and explain the cross-compilation of LuneScript.
Cross-compile &amp;#34;Cross-compilation&amp;#34; here means &amp;#34;cross-compilation&amp;#34; between versions of Lua.
When transcompiling to Lua, LuneScript transcompiles according to the version of Lua running LuneScript.
For example, the following control is performed.
When running on Lua5.2, bitwise operations use the bit32 library. When running on Lua5.3, bitwise operations use Lua&amp;#39;s built-in operators. Cross-compiling transcompiles the output Lua code to the specified Lua version instead of the version of Lua running LuneScript.</description>
    </item>
    
    <item>
      <title>04. Value</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/value/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/value/</guid>
      <description>This time, I will explain the values that can be handled by LuneScript. Value type The correspondence table between the value types that can be handled by LuneScript and the Lua values after transcompiler is shown. LuneScript Lua go Use How to define in LuneScript nil, null nil nil nil nil int Numerical value LnsInt integer 0 1 2 3 ?A 0x10 -100 real Numerical value LnsReal Real number 0.0</description>
    </item>
    
    <item>
      <title>04.2. Set</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/set/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/set/</guid>
      <description>This section describes how to handle the LuneScript value set Set.
Difference between Set and Map Set manages the set of values, and Map manages the association of values.
When both are converted to Lua, they are managed as a table, so using Set is not superior to Map in terms of execution speed and memory.
Using Set instead of Map has the following effects:
Clarify the use of data No need to deal with Map value in vain Easy to write literal values Set and Map are the same in the following ways:</description>
    </item>
    
    <item>
      <title>05. enum edition</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/enum/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/enum/</guid>
      <description>This time, I will explain the enum value of LuneScript.
enum LuneScript enums allow you to name and manage sets of values.
The types of values that can be handled as enums are as follows.
int real str The range of an enum can be defined from multiple values, but the value types must be the same.
That is, an enum with an int value cannot define a real or str value.</description>
    </item>
    
    <item>
      <title>06. match edition</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/match/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/match/</guid>
      <description>LuneScript supports algebraic data types and pattern matching.
Algebraic data type (alge type) The enum type can limit the range by grouping int, real, or str values.
On the other hand, the algebraic data type is a more general version of the enum type, and all types can be grouped, not limited to int, real, and str.
Algebraic data types are declared with the alge keyword.
Here is an example:</description>
    </item>
    
    <item>
      <title>07. Variables</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/variable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/variable/</guid>
      <description>This time, I will explain the variables of LuneScript. variable LuneScript is a statically typed language, and variables have types. Declare the variable with let as follows: // @lnsFront: ok let val:int = 1; The above example declares a variable val with an int of 1 as the initial value. After the variable name, specify the type. If the initial value is set to 1.0, which is real instead of</description>
    </item>
    
    <item>
      <title>08. General branch syntax</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/branch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/branch/</guid>
      <description>This time, I will explain the general branching syntax of LuneScript. Syntax list LuneScript supports the following general branching syntax: if switch By the way, the reason why we use &amp;#34;general&amp;#34; branch control here is that there is a separate branch control in the nilable control. if Use the if statement as follows: // @lnsFront: ok let val = 1; if val == 1 { print( &amp;#34;hoge&amp;#34; ); } elseif</description>
    </item>
    
    <item>
      <title>09. Repeated syntax</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/loop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/loop/</guid>
      <description>This time, I will explain the iterative syntax of LuneScript.
Syntax list LuneScript supports the following iterative syntax:
while repeat (to be deleted in the future) for apply foreach forsort while, repeat While and repeat are used as follows.
// @lnsFront: ok let mut val = 1; while val &amp;lt; 10 { val = val + 1; } print( val ); // 10 repeat { let mut endFlag = false; val = val + 1; if val &amp;gt;= 20 { endFlag = true; } } endFlag; print( val ); // 20 while processes the block while the expression holds, and repeat processes the block while the expression fails.</description>
    </item>
    
    <item>
      <title>10. Functions</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/func/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/func/</guid>
      <description>This time, I will explain the functions of LuneScript.
Function definition The LuneScript function is defined as follows:
// @lnsFront: ok fn add_sub( val1:int, val2:int ): int, int { return val1 + val2, val1 - val2; } print( add_sub( 1, 2 ) ); // 3, -1 The above example defines the following function:
Definition Function name add_sub First argument name val1 First argument type int Second argument name val2 Second argument type int First return type int Second return type int LuneScript can return multiple return values.</description>
    </item>
    
    <item>
      <title>10.2. Multi-valued return value</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/multipleretval/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/multipleretval/</guid>
      <description>LuneScript supports multi-valued function return values.
For example, a function can return multiple values:
// @lnsFront: ok fn func(): int,int { return 1, 2; } print( func() ); // 1 2 In the sample above, func() returns 1 and 2. This multi-valued return value is passed as it is as an argument of print().
Multi-valued return values are very useful, but there are still few languages that have multi-valued return values.</description>
    </item>
    
    <item>
      <title>10.3. Omission of arguments</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/defaultarg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/defaultarg/</guid>
      <description>In LuneScript, nilable type arguments can be omitted when calling a function.
For example, the following function func() can be called with no arguments.
// @lnsFront: ok fn func( val1:int!, val2:int! ):int { when! val1, val2 { return val1 + val2; } when! val1 { return val1; } when! val2 { return val2; } return 0; } print( func(1,2) ); // 3 print( func(1) ); // 1 print( func() ); // 0 The problem here is that func(1) and func() cannot determine whether they intentionally omitted the argument or forgot to specify it.</description>
    </item>
    
    <item>
      <title>10.4. Variadic argument, return value</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/arg/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/arg/</guid>
      <description>Variadic argument, return value You can define variadic and variadic functions by using … for arguments and return values.
The following is a sample using ….
// @lnsFront: ok fn func( ... ) : int, ... { let argList = [ ... ]; let mut total = 0; foreach arg in argList { when! arg { total = total + arg@@int; } } return total, ...; } print( func( 1, 2, 3, 4 ) ); // 10 1 2 3 4 In the above example, we define and execute a function func () that sums the values of the given variadic arguments and returns the sum and the given variadic arguments.</description>
    </item>
    
    <item>
      <title>10.5. Closure</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/closure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/closure/</guid>
      <description>LuneScript supports closures.
// @lnsFront: ok fn func( mut val:int ): form { return fn () { val = val + 1; print( val ); }; } let sub1 = func( 10 ); sub1(##); // 11 sub1(##); // 12 sub1(##); // 13 sub1(##); // 14 let sub2 = func( 100 ); sub2(##); // 101 sub2(##); // 102 sub2(##); // 103 sub2(##); // 104 The above function func() is a function that creates and returns closures.</description>
    </item>
    
    <item>
      <title>11. nilable edition</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/nilable/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/nilable/</guid>
      <description>This time, I will explain about nilable of LuneScript.
What is nilable LuneScript has a value of nil.
As mentioned earlier, variables of type stem can hold all types except nil.
// @lnsFront: error let mut val:stem = 1; val = 1.0; val = &amp;#34;abc&amp;#34;; val = {}; val = []; val = [@]; val = nil; // error So how can we keep nil? Use stem! Instead of stem.</description>
    </item>
    
    <item>
      <title>12. Class Basics</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/class1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/class1/</guid>
      <description>LuneScript supports object-oriented programming with classes.
Class specifications LuneScript classes support the following:
Access control accessor Inheritance abstract override advertise Mapping interface This time, I will explain the basic class definition.
Minimum class definition The minimum class definition is as follows.
// @lnsFront: ok class Test { } It defines a class called Test.
Note that the class definition must be done in the highest scope.
(2019/6/24) Added support for class definition in functions.</description>
    </item>
    
    <item>
      <title>13. accessor edition</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/class2accessor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/class2accessor/</guid>
      <description>This time, I will explain about the member accessor.
accessor You can easily create accessors (get, set) for members.
Here is an example:
// @lnsFront: ok class Test { pri let val1:int; pri let mut val2:int {pub,pub}; pri let val3:int {pub}; } let mut test = new Test( 1, 2, 3 ); print( test.$val2, test.$val3 ); // 2 3 test.set_val2( 10 ); print( test.$val2, test.$val3 ); // 10 3 In the above example, the definition of val2 is pri let val2:int {pub,pub};.</description>
    </item>
    
    <item>
      <title>14. Class inheritance</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/classinherit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/classinherit/</guid>
      <description>LuneScript supports class inheritance.
Class inheritance The following is an example of class inheritance.
// @lnsFront: ok class Super { pub fn func() { print( __func__ ); } } class Sub extend Super { } let sub = new Sub(); sub.func(); // Super.func This is an example where the Sub class inherits from the Super class.
Inheritance uses extend when declaring a class to specify the parent class to inherit.</description>
    </item>
    
    <item>
      <title>15. Class advertise</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/classadvertise/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/classadvertise/</guid>
      <description>LuneScript allows transparent access to the member methods held by the class.
advertise I think the expression &amp;#34;transparent access&amp;#34; is difficult to convey, so I will explain it with the following example.
// @lnsFront: ok abstract class Test { pub abstract fn foo(): str; pub abstract fn bar(): str; } class TestSub1 extend Test { pub override fn foo(): str { return &amp;#34;foo&amp;#34;; } pub override fn bar(): str { return &amp;#34;bar&amp;#34;; } } class TestSub2 extend Test { pri let sub:TestSub1; advertise sub; pub override fn bar(): str { return &amp;#34;hoge&amp;#34; .</description>
    </item>
    
    <item>
      <title>16. Class override</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/classoverride/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/classoverride/</guid>
      <description>LuneScript supports method overrides.
Method override All class methods can be overridden.
Rather, it is currently not possible to suppress override.
The following is an example of method override.
// @lnsFront: ok class Super { pub fn func() { print( __func__ ); } } class Sub extend Super { pub override fn func() { print( __func__ ); } } fn test( obj:Super ) { obj.func(); } test( new Super() ); // Super.</description>
    </item>
    
    <item>
      <title>17. Interface</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/interface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/interface/</guid>
      <description>LuneScript does not support multiple inheritance of classes, but instead supports interfaces.
interface If you&amp;#39;re using Java or C #, you&amp;#39;re probably familiar with it, but you can think of an interface as a class with limited functionality.
Specifically, interfaces differ from classes in the following ways:
The declaration is interface, not class. I can&amp;#39;t have a member. All methods are abstract. Therefore, an instance cannot be created by the interface alone.</description>
    </item>
    
    <item>
      <title>18. mapping</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/classmapping/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/classmapping/</guid>
      <description>LuneScript supports mutual conversion between class instances and maps.
mapping LuneScript supports mutual conversion between class instances and map objects.
Specifically, you can:
Creating a map object from an instance of a class Creating an instance of a class from a map object This allows you, for example, to generate JSON data from an instance of a class, or vice versa.
This feature is called mapping.
To use mapping, you need to declare Mapping as the interface to implement when declaring the class.</description>
    </item>
    
    <item>
      <title>19. generics edition</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/generics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/generics/</guid>
      <description>This section describes the generics that LuneScript supports.
LuneScript initially supported Generics only for built-in Lists / Arrays / Maps, but it also supports Generics for user-defined functions and classes.
function The function Generics is declared as follows:
// @lnsFront: ok fn func&amp;lt;T&amp;gt;( val:T ) : Set&amp;lt;T&amp;gt; { return (@ val); } As you can see from the above sample, when declaring a function, declare it with the function name + &amp;lt;Temporary parameter&amp;gt;.</description>
    </item>
    
    <item>
      <title>20. nil conditional operator edition</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/nilcond/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/nilcond/</guid>
      <description>This time, I will explain the nil conditional operator of LuneScript.
Map access For example, if you have the following Map data,
// @lnsFront: ok let json = { &amp;#34;lv1&amp;#34;: { &amp;#34;lv2&amp;#34;: { &amp;#34;lv3&amp;#34;: { &amp;#34;lv4&amp;#34;: { &amp;#34;lv5&amp;#34;: { &amp;#34;val&amp;#34;: 1 } } } } } }; To access the val of lv5, you need to do the following:
// @lnsFront: skip if! let lv1 = json.lv1 { if! let lv2 = lv1.</description>
    </item>
    
    <item>
      <title>21. import / provide</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/import/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/import/</guid>
      <description>This time, I will explain the module management of LuneScript.
module Module management in LuneScript is basically the same as Lua.
The differences from Lua are listed below.
Unless otherwise declared, each file is a module. The extension of the file name is .lns, and the name excluding .lns is the module name. init.lns is not supported. LuneScript built-in keywords (class, etc.) file names are not supported. To be on the safe side, here&amp;#39;s what LuneScript and Lua have in common with module management.</description>
    </item>
    
    <item>
      <title>22. require / module edition</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/require/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/require/</guid>
      <description>This time, I will explain how to handle Lua modules from LuneScript.
require Use require() when working with Lua modules.
The specification of require() is the same as Lua, but the return value is stem. That is, it has no type information. Casting is required as appropriate.
module As mentioned above, = require () = returns stem.
Since stem has no type information, it is not easy to use.</description>
    </item>
    
    <item>
      <title>22.1. Semi-automatic generation of glue code</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/glue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/glue/</guid>
      <description>There are two cases of Lua&amp;#39;s external modules:
Case consisting of Lua script Case of using Native Library such as C To use the Native Library from Lua, you need a glue that bridges the interface for Lua.
LuneScript has the ability to generate this glue semi-automatically.
The LuneScript glue automatic generation function is not a function that automatically generates Lua glue from a source such as C / C ++ represented by swig, but a function that automatically generates the glue code of a module declared as a module in LuneScript.</description>
    </item>
    
    <item>
      <title>22.2. Cooperation with Lua</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/lua/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/lua/</guid>
      <description>LuneScript can execute Lua code. However, there are a few things to keep in mind when running Lua code. The following are some things to keep in mind when running Lua code on LuneScript. Run Lua code In LuneScript, you can execute Lua code from within LuneScript by using the _load() function and so on. The _load() function has basically the same specifications as the lua load() function. A sample</description>
    </item>
    
    <item>
      <title>23. Build</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/make/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/make/</guid>
      <description>This time, I will explain how to build a project using LuneScript.
+ LuneScript provides a transcompiler for use from the command line,++We do not provide a build tool dedicated to LuneScript.++Therefore, here we will explain the general build method.
You can transcompile LuneScript in the following ways:
Individual build Batch build Batch builds transcompile multiple .lns files at once.
Individual build To transcompile to Lua, run the following command:</description>
    </item>
    
    <item>
      <title>24. Macro edition</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/macro/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/macro/</guid>
      <description>This time, I will explain about LuneScript macros.
macro LuneScript supports macros.
Perhaps it makes more sense these days to say metaprogramming rather than macros.
To explain &amp;#34;what is a macro&amp;#34;, it is easier to explain the difference from a function.
A function is a collection of certain processes. On the other hand, macros can define multiple function definitions themselves together. Of course, you can define not only function definitions but almost all processes that can be defined as macros.</description>
    </item>
    
    <item>
      <title>25. Cast edition</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/cast/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/cast/</guid>
      <description>LuneScript provides three types of casts.
@@ @@@ @@= @@ @@ forces a type conversion without checking the type of the source value at runtime.
// @lnsFront: ok let val1:stem = 1; let val2:int = val1@@int; The following values that cannot be converted can also be forcibly cast.
// @lnsFront: ok let val1:stem = 1; let val2:str[] = val1@@str[]; print( #val2 ); // runtime error The above assigns the value 1 of type int to val1 of stem type and casts it to val2 of str list type.</description>
    </item>
    
    <item>
      <title>26. subfile edition</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/subfile/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/subfile/</guid>
      <description>As the processing of the module increases, the file grows accordingly.
Since it is not good for file bloat, in such a case, it is a general refactoring to subdivide the responsibility of the module and separate the file for each module.
However, it is often the case that the responsibilities cannot be divided neatly, or that the division has a large effect on other modules. As an alternative means when it is not possible to deal with module division in this way, subfile is created.</description>
    </item>
    
    <item>
      <title>27. Delayed loading</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/lazyloading/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/lazyloading/</guid>
      <description>For a project of some size, you will be importing multiple modules. And I am importing another module within the imported module.
Import in a scripting language means dynamic loading. When you start a script, the main processing of the script finally starts after all the modules used by the script are loaded.
For example, if there is an import relationship as shown in the following figure, the processing of the main mod module will be performed after all the related modules have been loaded.</description>
    </item>
    
    <item>
      <title>28. shebang and command line arguments</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/shebang_main/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/shebang_main/</guid>
      <description>LuneScript supports shebang.
Shebang compatible Shebang is a function that executes the specified interpreter when the script file is executed by specifying the interpreter to be used in the comment on the first line of the script file that is often seen in shell scripts. For example, in bash, specify as follows.
#! /bin/bash In LuneScript, specify:
#! /usr/bin/lnsc -shebang Here, /usr/bin/lnsc needs to be specified according to the environment.</description>
    </item>
    
    <item>
      <title>29. Recommended directory structure for projects that use LuneScript</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/dir/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/dir/</guid>
      <description>LuneScript supports transcompiling to lua and go. On the other hand, lua and go have different directory management methods. This section describes the recommended directory structure so that you can use it in directory management in either language without any problems. Premise The explanation here assumes that you are developing with the following github repository. github.com/HOGE/PROJ HOGE is any github account name. PROJ is any repository name. In addition, the</description>
    </item>
    
    <item>
      <title>80. Transcompile to Go language</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/go/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/go/</guid>
      <description>LuneScript can be transcompiled to Go as well as Lua as the language to transcompile. This feature makes LuneScript faster (about 16 times faster) by transcompiling LuneScript&amp;#39;s self-hosting code into go language code and building it with go. See below for speedups. https://ifritjp.github.io/blog2/public/posts/2021/2021-06-28-lunescript-build-time-2000/ However, some features are not supported because the support is limited to the features required for LuneScript self-hosting. That said, LuneScript&amp;#39;s self-hosting itself uses most of LuneScript&amp;#39;s</description>
    </item>
    
    <item>
      <title>80.2 Package when transcompiling to Go language</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/go_package/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/go_package/</guid>
      <description>Modules packaged with go are available from LuneScript.
go package management overview go manages packages with go.mod.
Packages managed by this go.mod are cached in the local directory specified by the environment variable GOPATH.
LuneScript can take advantage of this cached module.
To use the package on github with go, write as follows.
import &amp;#34;github.com/ifritJP/lnshttpd&amp;#34; LuneScript can access the go modules in the same way.
import To import the .</description>
    </item>
    
    <item>
      <title>80.3 Lua runtime when transcompiled to Go</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/lua_runtime/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/lua_runtime/</guid>
      <description>LuneScript is a project that started development as a Lua transcompiler. And to take advantage of Lua&amp;#39;s assets, LuneScript also supports working with Lua.
This behavior of linking LuneScript and Lua is also available when transcompiled to go. In other words, Go and Lua work together.
To achieve this, we need a link between the Go and Native lua runtimes. Even if you do not use the Lua linkage operation in the LuaScript code, you cannot separate the link of the Lua runtime because it uses the Lua runtime function internally.</description>
    </item>
    
    <item>
      <title>81. Safe asynchronous processing</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/async/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/async/</guid>
      <description>Taking the opportunity of transcompiling from LuneScript to go language, asynchronous processing by LuneScript is supported.
It has a simple function to statically eliminate data conflicts.
__Runner interface To do asynchronous processing with LuneScript, implement the __Runner interface.
The __Runner interface is of the following type: __async will be discussed later.
// @lnsFront: skip pub interface __Runner { pub fn run() __async mut; } If you implement this interface, you can use the new built-in functions __run() and __join().</description>
    </item>
    
    <item>
      <title>81.1 Asynchronous processing O (past information)</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/async_old/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/async_old/</guid>
      <description>Taking the opportunity of transcompiling from LuneScript to go language, asynchronous processing by LuneScript is supported. However, this is a very experimental content and should be used as a reference only. Abolished from 1.3.0. Keep this document as a past log. LuneScript runtime LuneScript has a runtime to bridge the gap between the LuneScript language specification and the language specification to which it is transcompiled. For example, when transcompiling to</description>
    </item>
    
    <item>
      <title>82. Collaboration with Lua</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/luago/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/luago/</guid>
      <description>LuneScript can execute Lua code.
This feature is preserved after transcompiling to the go language, but there are a few things to keep in mind.
Be especially careful with the combination of asynchronous processing and lua code execution.
Luaval As already explained in the link, the result executed by lua is managed by Luaval type.
../lua
This Luaval type data has the following restrictions.
The Lua VM that you run to get the data dataA of type Luaval and the Lua VM that you run to access that dataA must be the same Lua VM.</description>
    </item>
    
    <item>
      <title>A. Let&#39;s have more fun in an exciting development environment</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/completion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/completion/</guid>
      <description>What editors do you use to develop Lua?
Is it an environment full of crazy features like Lua Development Tools, Atom, VSCode? Or is it a classic environment such as emacs or vim?
In either environment, are you dissatisfied with the completion features while coding Lua?
Lua&amp;#39;s completion feature is often pretty smart, but it&amp;#39;s quite possible that it doesn&amp;#39;t work, right?
Even with a little confirmation, the complement does not seem to work in the next scene.</description>
    </item>
    
    <item>
      <title>A. LuneScript running on a web browser</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/onweb/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/onweb/</guid>
      <description>To check the operation of LuneScript, we have prepared a LuneScript environment that runs on a web browser.
&amp;lt;https://ifritjp.github.io/LuneScript-webFront/lnsc_web_frontend/for_fengari/
The link above has three textareas:
For LuneScript code input For execution result output For output of conversion result to Lua Enter the LuneScript code in the textarea for LuneScript code input and press the execute button to convert and execute it to Lua.
All LuneScript processing is running on the browser.</description>
    </item>
    
    <item>
      <title>A. Tag jump by lnstags (source code tag system)</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/lnstags/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/lnstags/</guid>
      <description>LuneScript supports tag jump (source code tag system). What is Tag Jump (Source Code Tag System)? Tag jumps provide access to the following information in the source code: Definition position of symbols (classes, functions, variables etc ..) Reference position of symbols (classes, functions, variables etc ..) example An example is shown below. // @lnsFront: ok class Foo { pub fn func() { } } class Bar { pub fn func()</description>
    </item>
    
    <item>
      <title>A. Transcompiler development recommendations</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/recommend/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/recommend/</guid>
      <description>The final article on the Advent Calendar introductory to LuneScript will change the mindset and deal with transcompiler development itself.
Reasons for promoting transcompiler development I am developing a transcompiler called LuneScript.
Through this development, I feel that I have had a good experience as an engineer.
The reason for developing LuneScript is described in the next article.
../reason
I decided to write this article because I wanted many people to experience transcompiler development for the following reasons.</description>
    </item>
    
    <item>
      <title>A. Why Lua&#39;s transcompiler LuneScript was developed</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/reason/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/reason/</guid>
      <description>Lua is a lightweight, high-performance language. Lua&amp;#39;s name recognition is low compared to the same scripting languages such as Ruby, Python, and JavaScript, but it can be said to be one of the most major and easy-to-embed languages that can be used to extend the system. In fact, there are many systems that incorporate Lua.
Also, in terms of execution performance, it is in the high-speed category as a scripting language.</description>
    </item>
    
    <item>
      <title>Box edition</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/box/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/box/</guid>
      <description>This is information under consideration. Currently not available. Nilable type As mentioned earlier, you cannot specify nilable as a generics real-type parameter. Due to this limitation, the following new Test( val ) will result in an error. // @lnsFront: skip class Test&amp;lt;T&amp;gt; { let val:T; } let val:int! = 1; let test = new Test( val ); // error There are two patterns to avoid this error. Use T! Use</description>
    </item>
    
    <item>
      <title>Transcompile to Z. Go language (under consideration)</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/go_study/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/go_study/</guid>
      <description>For transcompiling support for Go language, refer to the following article. ../go The information here is out of date, but I&amp;#39;ll leave it for reference only. Considering transcompiling from LuneScript to Go language. Here, the content under consideration is recorded. aim The aim of transcompiling from LuneScript to the Go language is as follows. Speed up LuneScript LuneScript supports code completion, but large code is heavy and unusable. By speeding</description>
    </item>
    
    <item>
      <title>X. Importance of self-hosting and test design in quality control of language development</title>
      <link>https://ifritjp.github.io/documents/en/lunescript/test/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://ifritjp.github.io/documents/en/lunescript/test/</guid>
      <description>If you&amp;#39;re looking at this document, you&amp;#39;re probably coding in a &amp;#34;programming language&amp;#34; every day. And many of you are busy crushing bugs that someone has put in. Since the &amp;#34;programming language&amp;#34; that is taken care of every day is also software made by someone, quality control of how to prevent bugs is important. I&amp;#39;m lucky (?), And I&amp;#39;ve never run into a language bug while using a programming language</description>
    </item>
    
  </channel>
</rss>
