<!DOCTYPE html>
<html lang="ja-jp">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>クラス 基本 編 - 公開技術情報</title>
<meta name="generator" content="Hugo 0.68.3" />
<link href="https://ifritjp.github.io/documentsindex.xml" rel="alternate" type="application/rss+xml">
<link rel="canonical" href="https://ifritjp.github.io/documents/lunescript/class1/">
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/theme.min.css">
<script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/chroma.min.css">
<script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js"></script>
<script src="https://ifritjp.github.io/documents/js/bundle.js"></script><style>
:root {}
</style>
<meta property="og:title" content="クラス 基本 編" />
<meta property="og:description" content="LuneScript は、クラスによるオブジェクト指向プログラミングをサポートします。 クラスの仕様 LuneScript のクラスは、次をサポートします。 アクセス制御 accessor 継承 abstract override advertise Mapping interface" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ifritjp.github.io/documents/lunescript/class1/" />
<meta property="og:image" content="https://ifritjp.github.io/documents/images/og-image.png"/>
<meta property="og:site_name" content="公開技術情報" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://ifritjp.github.io/documents/images/og-image.png"/>

<meta name="twitter:title" content="クラス 基本 編"/>
<meta name="twitter:description" content="LuneScript は、クラスによるオブジェクト指向プログラミングをサポートします。 クラスの仕様 LuneScript のクラスは、次をサポートします。 アクセス制御 accessor 継承 abstract override advertise Mapping interface"/>
<meta itemprop="name" content="クラス 基本 編">
<meta itemprop="description" content="LuneScript は、クラスによるオブジェクト指向プログラミングをサポートします。 クラスの仕様 LuneScript のクラスは、次をサポートします。 アクセス制御 accessor 継承 abstract override advertise Mapping interface">

<meta itemprop="wordCount" content="4595">
<meta itemprop="image" content="https://ifritjp.github.io/documents/images/og-image.png"/>



<meta itemprop="keywords" content="" /></head>
<body><div class="container"><header>
<h1>公開技術情報</h1>

</header>
<div class="global-menu">
<nav>
<ul>
<li><a href="/documents/">Home</a></li></ul>
</nav>
</div>
<div class="content-container">
<main><h1>クラス 基本 編</h1>

<p>
LuneScript は、クラスによるオブジェクト指向プログラミングをサポートします。
</p>
<h2 id="headline-1">
クラスの仕様
</h2>
<p>
LuneScript のクラスは、次をサポートします。
</p>
<ul>
<li>
<p>
アクセス制御  
</p>
</li>
<li>
<p>
accessor
</p>
</li>
<li>
<p>
継承
</p>
</li>
<li>
<p>
abstract
</p>
</li>
<li>
<p>
override
</p>
</li>
<li>
<p>
advertise
</p>
</li>
<li>
<p>
Mapping
</p>
</li>
<li>
<p>
interface  
</p>
</li>
</ul>
<p>
今回は基本的なクラス定義を説明します。
</p>
<h2 id="headline-2">
最小のクラス定義
</h2>
<p>
最小のクラス定義は次のように行ないます。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
}</code></pre>
</div>
<p>
これは Test というクラスを定義しています。
</p>
<p>
<del>なお、クラス定義は最上位のスコープで行なう必要があります。</del>
</p>
<p>
<strong>(2019/6/24) 関数内でもクラス定義できるように対応しました。
ただし、外部公開可能なクラスは最上位のスコープで宣言する必要があります。</strong>
</p>
<h3 id="headline-3">
外部公開
</h3>
<p>
クラスを外部モジュールに公開するには、
次のように pub を付加します。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">pub class Test {
}</code></pre>
</div>
<h2 id="headline-4">
インスタンス生成
</h2>
<p>
クラスのインスタンス生成は、次のように new 演算子を使用します。
</p>
<div class="src src-lsn">
<pre><code class="language-lsn" data-lang="lsn">class Test {
}
let test = new Test();</code></pre>
</div>
<h2 id="headline-5">
メソッド定義
</h2>
<p>
メソッド定義は、ほぼ関数定義と同じです。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
   pub fn func() {
      print( __func__ );
   }
}
let test = new Test();
test.func();  // Test.func</code></pre>
</div>
<p>
なお、メソッドは form 型にはセットできません。
</p>
<p>
例えば、次の <code>sub( test.func )</code> はエラーします。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
   pub fn func() {
      print( __func__ );
   }
}
fn sub( foo:form ) {
   foo();
}

let test = new Test();
sub( test.func );  // error</code></pre>
</div>
<p>
これをエラーしないようにするには、
次のように anonymous 関数を作成して sub() に渡します。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
   pub fn func() {
      print( __func__ );
   }
}
fn sub( foo:form ) {
   foo();
}

let test = new Test();
sub( fn() { test.func(); } );</code></pre>
</div>
<h3 id="headline-6">
アクセス制御
</h3>
<p>
アクセス制御は次の 3 つです。
</p>
<table>
<thead>
<tr>
<th>種別</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>pub</td>
<td>外部公開</td>
</tr>
<tr>
<td>local</td>
<td>同一モジュール内に公開</td>
</tr>
<tr>
<td>pro</td>
<td>サブクラスに公開</td>
</tr>
<tr>
<td>pri</td>
<td>非公開</td>
</tr>
</tbody>
</table>
<p>
指定しない場合、デフォルトは pri です。
</p>
<h3 id="headline-7">
self シンボル
</h3>
<p>
メソッド内では、 self シンボルを利用できます。
</p>
<p>
self シンボルは、自分自身のインスタンスを表します。
</p>
<p>
次の例では、公開メソッドの sub から、
非公開メソッドの func() を self 使用してコールしています。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
   fn func() {
      print( __func__ );
   }
   pub fn sub() {
      self.func();
   }
}
let test = new Test();
test.sub();  // Test.func</code></pre>
</div>
<h3 id="headline-8">
分離定義
</h3>
<p>
メソッドは、クラス定義と分離して定義することが出来ます。
</p>
<p>
先ほどのメソッド定義は、次のようにも書けます。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
}
pub fn Test.func() {
   print( __func__ );
}
let test = new Test();
test.func();  // Test.func</code></pre>
</div>
<p>
ただし、別モジュールで定義しているクラスのメソッドを、
import しているモジュール内で定義することは出来ません。
</p>
<h3 id="headline-9">
プロトタイプ宣言
</h3>
<p>
メソッド定義は、クラス定義内に型だけを宣言し、実定義を分離することもできます。
</p>
<p>
次の例では、 func() をプロトタイプ宣言し、実定義を分離しています。
</p>
<p>
func() をプロトタイプ宣言することで、sub() 内で func() のコールが可能になります。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
   fn func();
   pub fn sub() {
      self.func();
   }
}
pub fn Test.func() {
   print( __func__ );
}
let test = new Test();
test.sub();  // Test.func</code></pre>
</div>
<p>
当然、プロトタイプ宣言と実定義のメソッドの型は、一致させる必要があります。
</p>
<h3 id="headline-10">
クラスメソッド定義
</h3>
<p>
通常のメソッドはインスタンスに紐付いているためインスタンスがないと実行できませんが、
クラスに紐付いたクラスメソッドはインスタンスがなくても実行できます。
</p>
<p>
クラスメソッドの定義は、メソッド定義に static を付加するだけです。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
   pub static fn sfunc() {
      print( __func__ );
   }
}
Test.sfunc(); // Test.sfunc</code></pre>
</div>
<h2 id="headline-11">
メンバ定義
</h2>
<p>
メンバ定義は、ほぼ変数定義と同じですが、次の違いがあります。
</p>
<ul>
<li>
<p>
初期値の設定が出来ない
</p>
</li>
<li>
<p>
アクセス制御が追加
</p>
</li>
<li>
<p>
accessor 指定が可能
</p>
</li>
</ul>
<p>
次にメンバ定義の例を示します。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
   pri let val1:int;
   pri let val2:int;
   pri let val3:int;
   pub fn func() {
      print( self.val1, self.val2, self.val3 );
   }

}
let test = new Test( 1, 2, 3 );
test.func(); // 1 2 3</code></pre>
</div>
<p>
クラス Test は、 val1, val2, val3 をメンバに持ちます。
</p>
<p>
val1 の定義は <code>pri let val1:int;</code> となっています。
</p>
<p>
これは、 これは通常の変数宣言に pri が付いただけなので問題ないと思います。
</p>
<p>
pri はアクセス制御で、意味はメソッド定義と同じです。
</p>
<h2 id="headline-12">
mutable
</h2>
<p>
メンバ、メソッドにも mutable と immutable があります。
</p>
<p>
メソッドの mutable と immutable の違いは次の通りです。
</p>
<ul>
<li>
<p>
mutable なメソッドは、メンバを変更可能なメソッド
</p>
</li>
<li>
<p>
immutable なメソッドは、メンバを変更不可能なメソッド
</p>
</li>
</ul>
<p>
次に mutable なメンバ、メソッドの例を示します。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
   pri let mut val1:int;
   pri let val2:int;
   pub fn func() {
      print( self.val1, self.val2 );
   }
   pub fn add( val:int ) mut {
      self.val1 = self.val1 + val;
   }
}
let mut test = new Test( 1, 2 );
test.func(); // 1 2
test.add( 10 );
test.func(); // 11 2</code></pre>
</div>
<p>
この例では、val1 が mutable で val2 が immutable です。
また func() が immutable で、 add() が mutable です。
</p>
<p>
mutable なメソッドは、引数宣言後に <strong>mut</strong> を宣言します。
</p>
<p>
mutable のメソッド add() は、 メンバ val1 に値をセットしています。
これはエラーせずにビルド可能です。
</p>
<p>
では、次のように メソッド add() の mut 宣言を外した場合はどうなるかというと。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
   pri let mut val1:int;
   pri let val2:int;
   pub fn func() {
      print( self.val1, self.val2 );
   }
   pub fn add( val:int ) {
      self.val1 = self.val1 + val;  // error
   }
}</code></pre>
</div>
<p>
上記の例は、エラーとなります。
</p>
<p>
mutable でないメソッド内からメンバを変更しようとした場合、エラーします。
</p>
<p>
次の場合もエラーします。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
   pri let mut val:int;
   pub fn increment() mut {
      self.val = self.val + 1;
   }
   pub fn func() {
      self.increment(); // error
   }
}</code></pre>
</div>
<p>
上記の例では、 func() から increment() をコールしていますが、
immutable なメソッドから mutable なメソッドのコールは出来ません。
</p>
<h2 id="headline-13">
allmut メンバ
</h2>
<p>
前述の通り、 あるクラスのメンバが mutable であっても、
そのクラスのインスタンスが immutable である場合、
そのメンバは immutable となります。
</p>
<p>
次の例では、 func() メソッド内から mutable なメンバ val にアクセスしていますが、
func() メソッドは immutable であるため val もまた immutable となり、エラーします。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
   pri let mut val:int;
   pub fn func() {
      self.val = self.val + 1;  // error
   }
}</code></pre>
</div>
<p>
mutablity は、意図しないタイミングでの値の変化を防止するために必要な概念です。
一方で、 immutable なメソッドからはいかなるメンバも変更できない、
というのは非常に厳しいルールです。
</p>
<p>
このルールが適応されてしまうと、
例えば次のような場合、設計が難しくなってしまいます。
</p>
<ul>
<li>
<p>
キーに紐付けて、読み取り専用データを管理するクラス Data を考える
</p>
</li>
<li>
<p>
Data クラスには、引数にキーを与えると、紐付けられたデータを返すメソッド get() を定義する
</p>
</li>
<li>
<p>
管理する全てのデータを登録した Data インスタンスは、不要な変更を防ぐため immutable とする
</p>
</li>
</ul>
<p>
これは一般的な考え型だと思います。
</p>
<p>
そして、開発が進んでから次の仕様を追加するとします。
</p>
<ul>
<li>
<p>
上記 get() メソッドの処理を高速化するため、
直前の引数キーと、そのキーに紐付けされたデータをキャッシュする
</p>
</li>
</ul>
<p>
この「直前の引数キーと、そのキーに紐付けされたデータをキャッシュする」という処理は、
データを書き換えることになります。
つまり、 immutable ではなく mutable である必要があります。
</p>
<p>
一方で、既に Data インスタンスは多くの箇所で immutable として宣言されています。
つまり、キャッシュすることが出来ません。
</p>
<p>
このような場合に利用するのが allmut です。
allmut は、メンバの mutablity を宣言し、
インスタンスの mutablity とは独立して常に mutable となります。
</p>
<p>
次に allmut のサンプルを示します。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
   pri let allmut val:int;
   pub fn func() {
      self.val = self.val + 1;  // ok
   }
}</code></pre>
</div>
<p>
このように <code>pri let allmut val:int;</code>  と宣言することで、
val は常に mutable となります。
これにより、 immutable なメソッド func() から、
val を書き換えることが可能となります。
</p>
<h2 id="headline-14">
コンストラクタ定義
</h2>
<p>
コンストラクタは __init で定義できます。
</p>
<p>
コンストラクタは、メソッド定義と次の点で異なります。
</p>
<ul>
<li>
<p>
コンストラクタ名は __init でなければならない。
</p>
</li>
<li>
<p>
戻り値の型を指定できない。
</p>
</li>
<li>
<p>
コンストラクタの定義は、全メンバ定義の後にしなければならない。
</p>
</li>
<li>
<p>
コンストラクタは、全メンバを初期化しなければならない。
</p>
<ul>
<li>
<p>
nilable 型のメンバを明示的に初期化しない場合、 初期値 nil となります。
</p>
</li>
</ul>
</li>
<li>
<p>
コンストラクタ内の処理で全メンバを初期化してからでなければ、
そのクラスで定義するメソッドにアクセスできない。
</p>
<ul>
<li>
<p>
ただし static メソッド、 super クラスのメソッドにはアクセス可能。
</p>
</li>
<li>
<p>
また、コンストラクタ内ので定義した関数オブジェクトからはメソッドにアクセス可能。
</p>
</li>
</ul>
</li>
<li>
<p>
コンストラクタ内からは、プロトタイプ宣言しただけのメソッドはコールできない。
</p>
</li>
<li>
<p>
コンストラクタ内で return できない。
</p>
</li>
</ul>
<p>
次にコンストラクタの例を示します。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
   pri let val1:int;
   pri let val2:int;
   pub fn __init() {
      self.val1 = 0;
      self.val2 = 0;
   }
}
let test = new Test();</code></pre>
</div>
<p>
なお、コンストラクタでは immutable なメンバにも初期値を設定可能です。
</p>
<h3 id="headline-15">
コンストラクタの引数
</h3>
<p>
コンストラクタは引数を持てます。
この引数は、new 演算子によって与えられます。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
   pri let val1:int;
   pri let val2:int;
   pub fn __init( val1:int, val2:int ) {
      self.val1 = val1 + 10;
      self.val2 = val2 + 10;
   }
   pub fn func() {
      print( self.val1, self.val2 );
   }
}
let test = new Test( 1, 2 );
test.func(); // 11 12</code></pre>
</div>
<h3 id="headline-16">
デフォルトコンストラクタ
</h3>
<p>
コンストラクタを定義しない場合、
自動的に全メンバを設定するコンストラクタが生成されます。
このコンストラクタをデフォルトコンストラクタと言います。
</p>
<p>
デフォルトコンストラクタは、全メンバを設定するための引数を持ちます。
引数の順番は、クラスのメンバの宣言順です。
</p>
<p>
次のクラス宣言には、コンストラクタが宣言されていないため、
デフォルトコンストラクタが内部的に生成されます。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
   pri let val1:int;
   pri let val2:int;
}</code></pre>
</div>
<p>
そのデフォルトコンストラクタは、次のように定義されます。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">   pub fn __init( val1:int, val2:int ) {
      self.val1 = val1;
      self.val2 = val2;
   }</code></pre>
</div>
<p>
デフォルトコンストラクタのアクセス制御は pub です。
</p>
<h4 id="headline-17">
派生クラスのデフォルトコンストラクタ
</h4>
<p>
派生クラスのデフォルトコンストラクタは、旧形式と現形式の 2 種類あります。
</p>
<h5 id="headline-18">
現形式
</h5>
<p>
次のような派生クラス Sub の現形式デフォルトコンストラクタは、
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
   pro let val:int;
}
class Sub extend Test {
   let val2:int;
   pub fn func() {
      print( self.val, self.val2 );
   }
}
let sub = new Sub( 1, 2 );
sub.func(); // 1, 2</code></pre>
</div>
<p>
上記の <code>new Sub( 1, 2 )</code> ように、
super クラスのコンストラクタの引数 + 派生クラスの全メンバになります。
</p>
<h5 id="headline-19">
旧形式
</h5>
<p>
次のような派生クラス Sub の旧形式デフォルトコンストラクタは、
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
   pro let val:int!;
}
class Sub extend Test {
   let val2:int;
   _lune_control default__init_old;
   pub fn func() {
      print( self.val, self.val2 );
   }
}
let sub = new Sub( 2 );
sub.func(); // nil, 2</code></pre>
</div>
<p>
上記の <code>new Sub( 2 )</code> ように、
派生クラスの全メンバになります。
</p>
<p>
なお旧形式では、 super クラスの全ての引数は nilable でなければならないです。
また、 <code>_lune_control default__init_old;</code> で旧形式のデフォルトコンストラクタを
使用することを宣言する必要があります。
この宣言は、全メンバを宣言した後に宣言する必要があります。
</p>
<h4 id="headline-20">
デフォルトコンストラクタの明示
</h4>
<p>
デフォルトコンストラクタは、
コンストラクタを定義しないと内部的に生成されます。
</p>
<p>
しかしこの振舞いは、次のような処理を書いた時に問題になります。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
   pri let mut val:int {pub};
   pub static fn create(): Test {
      return new Test( 1 );  // error
   }
}</code></pre>
</div>
<p>
上記は、 create() メソッド内で Test クラスのインスタンスを生成していますが、
コンストラクタの宣言がないとしてエラーします。
</p>
<p>
本来ならば、コンストラクタの定義がないのでデフォルトコンストラクタが
生成されるのですが、
デフォルトコンストラクタを定義するタイミングは、クラス定義終了時に行なうため、
クラス定義内の create() メソッドでは、コンストラクタがありません。
</p>
<p>
このような場合、明示的にデフォルトコンストラクタを使用することを宣言します。
</p>
<p>
次に例を示します。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
   pri let mut val:int {pub};
   _lune_control default__init;
   pub static fn create(): Test {
      return new Test( 1 );
   }
}</code></pre>
</div>
<p>
<code>_lune_control default__init;</code> を宣言すると、
デフォルトコンストラクタの使用を明示でき、
このタイミングでデフォルトコンストラクタが生成されます。
</p>
<p>
なお <code>_lune_control default__init;</code> は、通常のコンストラクタと同じように、
全メンバの後に宣言する必要があります。
</p>
<h2 id="headline-21">
クラスメンバ
</h2>
<p>
メソッドにクラスメソッドがあるように、メンバにもクラスメンバがあります。
</p>
<p>
クラスメンバの定義も static を付けるだけです。
</p>
<p>
クラスメンバの初期化は __init ブロックで行ないます。
</p>
<p>
次はクラスメンバ定義の例です。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">class Test {
   pri static let val1:int;
   pri static let val2:int;

   __init {
      Test.val1 = 1;
      Test.val2 = 1;
   }
}</code></pre>
</div>
<p>
__init ブロックは、次の制限があります。
</p>
<ul>
<li>
<p>
__init ブロックの定義は、全クラスメンバ定義の後にしなければならない。
</p>
<ul>
<li>
<p>
nilable 型のメンバを明示的に初期化しない場合、 初期値 nil となります。
</p>
</li>
</ul>
</li>
<li>
<p>
__init ブロックは、全メンバを初期化しなければならない。
</p>
</li>
<li>
<p>
__init ブロック内で return できない。
</p>
</li>
<li>
<p>
__init ブロックからクラスメソッドをコールできるが、コールするクラスメソッドは、 
__init ブロックより前に宣言しなければならない。
</p>
</li>
</ul>
<h2 id="headline-22">
まとめ
</h2>
<p>
LuneScript のクラス定義は、次をサポートします。
</p>
<ul>
<li>
<p>
キーワード class でクラスを定義する
</p>
</li>
<li>
<p>
インスタンス生成は new
</p>
</li>
<li>
<p>
アクセス制御可能  
</p>
</li>
<li>
<p>
self シンボルで自分自身にアクセス
</p>
</li>
<li>
<p>
クラス定義とメソッド定義を分離可能
</p>
</li>
<li>
<p>
プロトタイプ宣言
</p>
</li>
<li>
<p>
static でクラスメソッド、クラスメンバ
</p>
</li>
<li>
<p>
コンストラクタは __init
</p>
</li>
<li>
<p>
コンストラクタを作成しない場合はデフォルトコンストラクタが作られる
</p>
</li>
</ul>
<p>
次回は、 accessor の生成方法について説明します。
</p>
<div class="edit-meta">

<br></div><nav class="pagination"><a class="nav nav-prev" href="https://ifritjp.github.io/documents/lunescript/classoverride/" title="クラス override 編"><i class="fas fa-arrow-left" aria-hidden="true"></i> Prev - クラス override 編</a>
<a class="nav nav-next" href="https://ifritjp.github.io/documents/lunescript/classinherit/" title="クラス 継承 編">Next - クラス 継承 編 <i class="fas fa-arrow-right" aria-hidden="true"></i></a>
</nav><footer><p class="powered">Powered by <a href="https://gohugo.io">Hugo</a>. Theme by <a href="https://themes.gohugo.io/hugo-theme-techdoc/">TechDoc</a>. Designed by <a href="https://github.com/thingsym/hugo-theme-techdoc">Thingsym</a>.</p>
</footer>
</main><div class="sidebar">

<nav class="slide-menu">
<ul>
<li class=""><a href="https://ifritjp.github.io/documents">Home</a></li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/lua/">C/C&#43;&#43; 言語プログラマのための Lua 入門リファレンス<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/lua/interface/">C インタフェース編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lua/detail/">C インタフェース詳細編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lua/anti-pattern/">Lua でやりがちなミス</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lua/pointer/">ポインタ編</a></li>
</ul>
  
</li>

<li class="parent has-sub-menu"><a href="https://ifritjp.github.io/documents/lunescript/">トランスコンパイラ LuneScript で Lua の開発をもっと楽に!!<span class="mark opened">-</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/class2accessor/">accessor 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/box/">Box 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/enum/">enum 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/generics/">generics 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/tutorial3.hello/">Hello world</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/import/">import/provide 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/introduce2/">Lua のトランスコンパイラ LuneScript の紹介 2</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/introduce3/">Lua のトランスコンパイラ LuneScript の紹介 3</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/crosscompile/">Lua バージョン間のクロスコンパイル</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/classmapping/">mapping 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/match/">match 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/nilcond/">nil 条件演算子 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/nilable/">nilable 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/require/">require/module 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/set/">Set 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/tutorial1/">はじめに</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/completion/">イマドキな開発環境でもっと楽しよう</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/interface/">インタフェース 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/cast/">キャスト 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/classadvertise/">クラス advertise 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/classoverride/">クラス override 編</a></li>
<li class="active"><a href="https://ifritjp.github.io/documents/lunescript/class1/">クラス 基本 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/classinherit/">クラス 継承 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/recommend/">トランスコンパイラ開発のすゝめ</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/make/">ビルド 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/macro/">マクロ 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/branch/">一般分岐構文 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/value/">値編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/arg/">可変長引数、戻り値 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/variable/">変数 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/multipleretval/">多値の戻り値</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/tutorial2.setup/">導入編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/defaultarg/">引数の省略 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/loop/">繰り返し構文 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/func/">関数 編</a></li>
</ul>
  
</li>
</ul>
</nav>



<div class="sidebar-footer"></div>
</div>
</div><a href="#" id="backtothetop-fixed" class="backtothetop"
 data-backtothetop-duration="600"
 data-backtothetop-easing="easeOutQuart"
 data-backtothetop-fixed-fadeIn="1000"
 data-backtothetop-fixed-fadeOut="1000"
 data-backtothetop-fixed-bottom="10"
 data-backtothetop-fixed-right="20">
<span class="fa-layers fa-fw">
<i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i>
</span></a>
</div>
</body>
</html>
