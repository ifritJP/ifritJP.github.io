<!DOCTYPE html>
<html lang="ja-jp">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>全文検索用結合ファイル - 公開技術情報</title>
<meta name="generator" content="Hugo 0.100.1" />
<link href="https://ifritjp.github.io/documentsindex.xml" rel="alternate" type="application/rss+xml">
<link rel="canonical" href="https://ifritjp.github.io/documents/lunescript/all/">
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/theme.min.css">
<script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/chroma.min.css">
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js"></script>
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/custom.css">
<script src="https://ifritjp.github.io/documents/js/bundle.js"></script>
<script src="https://ifritjp.github.io/documents/js/lnsSrcRun.js"></script>
<script src="https://ifritjp.github.io/documents/js/highlight_lns.js"></script>
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/highlight_lns.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script><style>
:root {}
</style>
<meta property="og:title" content="全文検索用結合ファイル" />
<meta property="og:description" content="全文検索し易いように、LuneScript 解説ドキュメントを結合したものです。 LuneScript 入門リファレンス トランスコンパイラ LuneScript で Lua の開発をもっと楽に!" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ifritjp.github.io/documents/lunescript/all/" /><meta property="article:section" content="LuneScript" />

<meta property="og:site_name" content="公開技術情報" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="全文検索用結合ファイル"/>
<meta name="twitter:description" content="全文検索し易いように、LuneScript 解説ドキュメントを結合したものです。 LuneScript 入門リファレンス トランスコンパイラ LuneScript で Lua の開発をもっと楽に!"/>
<meta itemprop="name" content="全文検索用結合ファイル">
<meta itemprop="description" content="全文検索し易いように、LuneScript 解説ドキュメントを結合したものです。 LuneScript 入門リファレンス トランスコンパイラ LuneScript で Lua の開発をもっと楽に!">

<meta itemprop="wordCount" content="106969">
<meta itemprop="keywords" content="" />
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4708B8S6ES"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4708B8S6ES');
</script>
</head>
<body><div class="container"><header>
<h1>公開技術情報</h1>


[<a href="https://ifritjp.github.io/documents/en/">English</a>]

[<a href="https://ifritjp.github.io/documents/">Japanese</a>]

</header>
<div class="global-menu">
<nav>
<ul>
<li><a href="/documents/">Home</a></li>
<li><a href="https://ifritjp.github.io/blog2/public/">blog</a></li>
<li><a href="https://ifritjp.github.io/LuneScript-webFront/contents/">LuneScript on Web</a></li></ul>
</nav>
</div>
<div class="content-container">
<main><h1>全文検索用結合ファイル</h1>

<p>
全文検索し易いように、LuneScript 解説ドキュメントを結合したものです。</p>
<hr>
<p>
LuneScript 入門リファレンス</p>
<hr>
<div id="outline-container-_index_ja" class="outline-2">
<h2 id="_index_ja">
<strong>トランスコンパイラ LuneScript で Lua の開発をもっと楽に!!</strong>
</h2>
<div id="outline-text-_index_ja" class="outline-text-2">
<p>
<strong>TypeScriptからLuaに変換する TypeScriptToLua があります。</strong> </p>
<p>
&lt;<a href="https://typescripttolua.github.io/">https://typescripttolua.github.io/</a>&gt;</p>
<p>
<strong>LuneScript の今後については以下を参照してください。</strong></p>
<p>
&lt;<a href="https://ifritjp.github.io/blog2/public/posts/2021/2021-05-26-lunescript-plan/">https://ifritjp.github.io/blog2/public/posts/2021/2021-05-26-lunescript-plan/</a>&gt;</p>
<hr>
<p>
Lua は非常にコンパクトな言語でありながら、高い潜在能力を持つ言語です。</p>
<p>
プログラムに組み込まれる言語としては、
最も使い易い言語の一つと言っても良いと思います。</p>
<p>
ただ「プログラムに組み込まれる言語としては使い易い」とはいえ、
イマドキの言語と比べると、いろいろと気になるところがあるのも事実です。</p>
<p>
一方で、Lua をイマドキの言語に近づけるための機能進化は、
「コンパクト」という Lua の大きな特徴の一つとトレードオフになる可能性があります。</p>
<p>
そこで、 Lua 自体には手を加えずに、
Lua の気になる箇所をカバー出来るトランスコンパイラ LuneScript を紹介します。</p>
<div id="outline-container-headline-2" class="outline-3">
<h3 id="headline-2">
LuneScript とは
</h3>
<div id="outline-text-headline-2" class="outline-text-3">
<p>
LuneScript とは、前述の通り Lua の気になる点をカバーする言語で、
LuneScript で開発したコードを Lua のコードに変換することが可能な
トランスコンパイラです。</p>
<p>
LuneScript は、次の特徴を持ちます。</p>
<ul>
<li>NULL 安全 (null safety)。</li>
<li>静的型付け言語であるため、型チェックにより単純なミスをコンパイル時に発見可能。</li>
<li>型推論により、型宣言の手間を最小化。</li>
<li>generics により、型情報を保ったままの処理が可能。</li>
<li>言語の文法としてクラス定義を対応。</li>
<li>パターンマッチ対応。 (match)</li>
<li>遅延ロードによるロード時間短縮。</li>
<li>構造化データと非構造化データとの相互変換。 (Mapping)</li>
<li>マクロ により、ポリモーフィズム等の動的処理に頼らないデザインを実現可能。</li>
<li>変数の初期化漏れを検知</li>
<li>Lua と go へのトランスコンパイル。</li>
<li>JSON と互換なデータ表現をサポート。</li>
<li>トランスコンパイルした Lua コードは、外部ライブラリを前提とせずに単体で動作可能。</li>
<li>トランスコンパイルした Lua コードは、LuneScript で書いた処理そのままが出力されるので、
性能劣化がない。</li>
<li>既存の Lua の外部モジュールを LuneScript から利用可能。</li>
<li>
<p>LuneScript は Lua 上で動作し、Lua 標準モジュール以外を必要としないため、導入が簡単。</p>
<ul>
<li>go 版 LuneScript を利用すると、トランスコンパイル時間を 1/20 に短縮可能。</li>
</ul>
</li>
<li>LuneScript から変換した Lua モジュールを、 他の Lua モジュールから利用可能。</li>
<li>
<p>Lua5.1 〜 5.4 をサポート。</p>
<ul>
<li>Lua5.1 については次を参照してください。</li>
<li><a href="#crosscompile">#crosscompile</a></li>
</ul>
</li>
<li>LuneScript はセルフホスティングで開発している。</li>
<li>emacs でのコード補完に対応</li>
<li>
<p>lnstags によるタグジャンプに対応</p>
<ul>
<li><a href="#lnstags">#lnstags</a></li>
</ul>
</li>
<li>glue コードの自動生成に対応</li>
<li>Lua と C の syntax を基調としているため、学習コストが低い。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-3" class="outline-3">
<h3 id="headline-3">
LuneScript の使用方法
</h3>
<div id="outline-text-headline-3" class="outline-text-3">
<p>
LuneScript は github で開発しています。</p>
<p>
&lt;<a href="https://github.com/ifritJP/LuneScript">https://github.com/ifritJP/LuneScript</a>&gt;</p>
<p>
導入方法は次を参照してください。</p>
<ul>
<li>
<p>導入編</p>
<ul>
<li><a href="#tutorial2_setup">#tutorial2_setup</a></li>
</ul>
</li>
</ul>
<div id="outline-container-headline-4" class="outline-4">
<h4 id="headline-4">
コマンド
</h4>
<div id="outline-text-headline-4" class="outline-text-4">
<p>
LuneScript を導入すると、lnsc コマンドがインストールされます。</p>
<p>
lnsc コマンドの使用方法については、次の記事を参考にしてください。</p>
<ul>
<li>
<p>Hello world</p>
<ul>
<li><a href="#tutorial3_hello">#tutorial3_hello</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-5" class="outline-4">
<h4 id="headline-5">
Lua バージョン間のクロスコンパイル
</h4>
<div id="outline-text-headline-5" class="outline-text-4">
<p>
LuneScript は Lua のバージョン間クロスコンパイルをサポートします。
次の記事を参考にしてください。</p>
<ul>
<li>
<p>Lua バージョン間のクロスコンパイル</p>
<ul>
<li><a href="#crosscompile">#crosscompile</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-6" class="outline-3">
<h3 id="headline-6">
LuneScript の仕様
</h3>
<div id="outline-text-headline-6" class="outline-text-3">
<p>
ここでは LuneScript の仕様について説明します。</p>
<div id="outline-container-headline-7" class="outline-4">
<h4 id="headline-7">
値と型
</h4>
<div id="outline-text-headline-7" class="outline-text-4">
<p>
LuneScript で扱う値と型については次の記事を参考にしてください。</p>
<ul>
<li>
<p>値編</p>
<ul>
<li><a href="#value">#value</a></li>
</ul>
</li>
<li>
<p>enum 編</p>
<ul>
<li><a href="#enum">#enum</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-8" class="outline-4">
<h4 id="headline-8">
コメント
</h4>
<div id="outline-text-headline-8" class="outline-text-4">
<p>
コメントは C++ スタイルを採用。
一行コメント <code>//</code> 、 複数行コメント <code>/* */</code> を指定可能。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
// 行末までコメント
/* ここから〜
ここまでコメント*/</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-9" class="outline-4">
<h4 id="headline-9">
演算子
</h4>
<div id="outline-text-headline-9" class="outline-text-4">
<p>
原則的に、演算子 は Lua と同じものを利用する。</p>
<p>
Lua5.3 の //(切り捨て除算) は、LuneScript では 1 行コメントとなるので注意すること。</p>
<p>
なお LuneScript では、 int 同士の / は自動的に切り捨て除算となる。</p>
</div>
</div>
<div id="outline-container-headline-10" class="outline-4">
<h4 id="headline-10">
変数宣言
</h4>
<div id="outline-text-headline-10" class="outline-text-4">
<p>
LuneScript の変数については次の記事を参考にしてください。</p>
<ul>
<li>
<p>変数 編</p>
<ul>
<li><a href="#variable">#variable</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-11" class="outline-4">
<h4 id="headline-11">
一般制御文
</h4>
<div id="outline-text-headline-11" class="outline-text-4">
<p>
LuneScript の制御文については次を参考にしてください。</p>
<ul>
<li>
<p>一般分岐</p>
<ul>
<li><a href="#branch">#branch</a></li>
</ul>
</li>
<li>
<p>繰り返し構文 編</p>
<ul>
<li><a href="#loop">#loop</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-12" class="outline-4">
<h4 id="headline-12">
関数宣言
</h4>
<div id="outline-text-headline-12" class="outline-text-4">
<p>
LuneScript の関数については、次を参考にしてください。</p>
<ul>
<li>
<p>関数 編</p>
<ul>
<li><a href="#func">#func</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-13" class="outline-4">
<h4 id="headline-13">
nilable
</h4>
<div id="outline-text-headline-13" class="outline-text-4">
<p>
LuneScript は nil 安全 (NULL 安全) な言語です。</p>
<p>
LuneScript の nil 安全を実現する nilable については、
次を参考にしてください。</p>
<ul>
<li>
<p>nilable 編</p>
<ul>
<li><a href="#nilable">#nilable</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-14" class="outline-4">
<h4 id="headline-14">
クラス
</h4>
<div id="outline-text-headline-14" class="outline-text-4">
<p>
LuneScript はオブジェクト指向プログラミングのためのクラスをサポートします。</p>
<p>
LuneScript のクラスは、次の制約を持ちます。</p>
<ul>
<li>多重継承はサポートしない。</li>
<li><del>generics はサポートしない。</del></li>
<li>
<p>全てがオーバーライド可能なメソッドとなる。</p>
<ul>
<li>オーバーライドの抑制はできない。</li>
</ul>
</li>
<li>
<p>継承間で引数の異なる同名メソッドは定義できない。</p>
<ul>
<li>ただし、コンストラクタは例外で同じ名前( __init )。</li>
</ul>
</li>
</ul>
<p>
次の記事を参考にしてください。</p>
<ul>
<li>
<p>クラス 基本 編</p>
<ul>
<li><a href="#class1">#class1</a></li>
</ul>
</li>
<li>
<p>accessor 編</p>
<ul>
<li><a href="#class2accessor">#class2accessor</a></li>
</ul>
</li>
<li>
<p>クラス 継承 編</p>
<ul>
<li><a href="#classinherit">#classinherit</a></li>
</ul>
</li>
<li>
<p>クラス advertise 編</p>
<ul>
<li><a href="#classadvertise">#classadvertise</a></li>
</ul>
</li>
<li>
<p>クラス override 編</p>
<ul>
<li><a href="#classoverride">#classoverride</a></li>
</ul>
</li>
<li>
<p>インタフェース 編</p>
<ul>
<li><a href="#interface">#interface</a></li>
</ul>
</li>
</ul>
<div id="outline-container-headline-15" class="outline-5">
<h5 id="headline-15">
プロトタイプ宣言
</h5>
<div id="outline-text-headline-15" class="outline-text-5">
<p>
LuneScript は、スクリプトの上から順に解析する。</p>
<p>
スクリプトで参照するシンボルは、事前に定義されている必要がある。
例えばクラス TEST 型の変数を宣言するには、事前にクラス TEST を定義する必要がある。</p>
<p>
また、相互に参照するクラスを定義するには、
どちらかをプロトタイプ宣言する必要がある。</p>
<p>
次は、 ClassA, ClassB がそれぞれを相互参照する時の例である。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
pub class Super {
}
pub proto class ClassB extend Super;
pub class ClassA {
  let val: ClassB;
}
pub class ClassB extend Super{
  let val: ClassA;
}</code></pre>
</div>
<p>
proto は上記のように宣言する。</p>
<p>
プロトタイプ宣言と実際の定義において、
pub や extend など同じものを宣言しなければならない。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-16" class="outline-4">
<h4 id="headline-16">
Mapping
</h4>
<div id="outline-text-headline-16" class="outline-text-4">
<p>
LuneScript のクラスインスタンスは、
Map オブジェクトとの相互変換が可能である。</p>
<p>
これを Mapping と呼ぶ。</p>
<p>
Mapping については次を参考にしてください。</p>
<ul>
<li>
<p>mapping 編</p>
<ul>
<li><a href="#classmapping">#classmapping</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-17" class="outline-4">
<h4 id="headline-17">
Generics
</h4>
<div id="outline-text-headline-17" class="outline-text-4">
<p>
LuneScript は Generics をサポートします。</p>
<p>
詳しくは次を参照してください。</p>
<ul>
<li>
<p>generics 編</p>
<ul>
<li><a href="#generics">#generics</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-18" class="outline-4">
<h4 id="headline-18">
nil 条件演算子
</h4>
<div id="outline-text-headline-18" class="outline-text-4">
<p>
nilable の値を簡単に扱う方法として、 nil 条件演算子をサポートしています。</p>
<ul>
<li>
<p>nil 条件演算子 編</p>
<ul>
<li><a href="#nilcond">#nilcond</a>   </li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-19" class="outline-4">
<h4 id="headline-19">
モジュール
</h4>
<div id="outline-text-headline-19" class="outline-text-4">
<p>
LuneScript のモジュール管理については、次を参考にしてください。</p>
<ul>
<li>
<p>import/provide 編  </p>
<ul>
<li><a href="#import">#import</a></li>
</ul>
</li>
<li>
<p>require/module 編    </p>
<ul>
<li><a href="#require">#require</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-20" class="outline-3">
<h3 id="headline-20">
ビルド
</h3>
<div id="outline-text-headline-20" class="outline-text-3">
<p>
LuneScript を使用したプロジェクトをビルドする方法については、次を参考にしてください。</p>
<ul>
<li>
<p>ビルド 編</p>
<ul>
<li><a href="#make">#make</a>  </li>
</ul>
</li>
</ul>
<div id="outline-container-headline-21" class="outline-4">
<h4 id="headline-21">
_lune.lua モジュール
</h4>
<div id="outline-text-headline-21" class="outline-text-4">
<p>
前述している通り LuneScript で Lua へトランスコンパイルしたファイルは、
Lua コマンドでそのまま実行できます。
この時、外部モジュールを必要としません。</p>
<p>
これは、トランスコンパイルした Lua コード内に、
処理に必要なコードを全て含めていることを示します。</p>
<p>
例えば次の処理コードをトランスコンパイルすると、</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( val:int! ):int {
   return 1 + unwrap val default 0;
}</code></pre>
</div>
<p>
Lua コードは次のようにだいぶ長くなります。</p>
<div class="src src-lua -n">
<pre tabindex="0"><code class="language-lua -n" data-lang="lua -n">--mini.lns
local _moduleObj = {}
local __mod__ = &#39;mini&#39;
if not _ENV._lune then
   _lune = {}
end
function _lune.unwrap( val )
   if val == nil then
      __luneScript:error( &#39;unwrap val is nil&#39; )
   end
   return val
end 
function _lune.unwrapDefault( val, defval )
   if val == nil then
      return defval
   end
   return val
end

local function func( val )
   return 1 + _lune.unwrapDefault( val, 0)
end

return _moduleObj</code></pre>
</div>
<p>
この 4 〜 18 行目が unwrap に必要な処理となります。
なお、このコードは全ての Lua ファイルに出力されます。</p>
<p>
このコード自体は共通処理であるため、
トランスコンパイルする際に <strong>-r</strong> オプションを指定することで、
別モジュールとして require して共通処理をまとめることができます。</p>
<p>
具体的には次のように -r オプションを指定します。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ lua lune/base/base.lua -r src.lns save</span></span></code></pre></div>
</div>
<p>
この -r オプションを指定した場合、上記のコードは次のように変換され、
かなりスッキリします。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="c1">--mini.lns</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">_moduleObj</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">__mod__</span> <span class="o">=</span> <span class="s1">&#39;mini&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">_lune</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span> <span class="s2">&#34;lune.base._lune&#34;</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="kr">function</span> <span class="nf">func</span><span class="p">(</span> <span class="n">val</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="kr">return</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">_lune.unwrapDefault</span><span class="p">(</span> <span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">return</span> <span class="n">_moduleObj</span></span></span></code></pre></div>
</div>
<p>
なお、require( &#34;lune.base._lune&#34; ) が挿入されるため、
このモジュールがロード出来るようにセットしておく必要があります。
トランスコンパイラが動作する環境であれば意識する必要はありませんが、
変換後の Lua ソースをどこか別の環境で実行するような場合は注意が必要です。</p>
</div>
</div>
<div id="outline-container-headline-22" class="outline-4">
<h4 id="headline-22">
マクロ
</h4>
<div id="outline-text-headline-22" class="outline-text-4">
<p>
LuneScript は簡易的なマクロを採用する。</p>
<div id="outline-container-headline-23" class="outline-5">
<h5 id="headline-23">
マクロの意義
</h5>
<div id="outline-text-headline-23" class="outline-text-5">
<p>
マクロは通常の関数と比べて幾つかの制限がある。
またマクロで行なえる処理は、オブジェクト指向を駆使することで実現できることが多い。</p>
<p>
では、マクロを使う意義は何か？</p>
<p>
それは、「マクロを使うことで静的に動作が確定する」ことである。</p>
<p>
同じ処理をオブジェクト指向で実現した場合、動的な処理となってしまう。
一方、マクロで実現すれば、静的な処理となる。</p>
<p>
これの何が嬉しいのか？</p>
<p>
それは、静的型付け言語が動的型付け言語よりも優れている点と同じである。</p>
<p>
静的に決まる情報を静的に処理することで、静的に解析できる。</p>
<p>
例えば、オブジェクト指向の関数オーバーライドの大部分は、
マクロを利用することで静的に解決することができる。
動的な関数オーバーライドではなく、静的な関数呼び出しにすることで、
ソースコードを追い易くなる。</p>
<p>
無闇にマクロを多用するは良くないが、
安易に関数オーバーライドなどの動的処理にするのも理想ではない。</p>
<p>
動的処理とマクロは適宜使い分けが必要である。</p>
</div>
</div>
<div id="outline-container-headline-24" class="outline-5">
<h5 id="headline-24">
マクロ定義
</h5>
<div id="outline-text-headline-24" class="outline-text-5">
<p>
マクロ定義については次の記事を参考にしてください。</p>
<ul>
<li>
<p>マクロ 編</p>
<ul>
<li><a href="#macro">#macro</a></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-25" class="outline-4">
<h4 id="headline-25">
補足
</h4>
<div id="outline-text-headline-25" class="outline-text-4">
<p>
補足記事は、ここにリンクを追加していきます。</p>
<ul>
<li>
<p>Lua のトランスコンパイラ LuneScript の紹介 2 </p>
<ul>
<li>subfile, module, nil 条件演算子 の紹介</li>
<li><a href="#introduce2">#introduce2</a></li>
</ul>
</li>
<li>
<p>Lua のトランスコンパイラ LuneScript のイマドキな開発環境でもっと楽しよう</p>
<ul>
<li>補完、syntax チェック、subfile の検索</li>
<li><a href="#completion">#completion</a></li>
</ul>
</li>
</ul>
<p>
このページからリンクしていない記事は、サイドバーから辿ってください。</p>
<hr>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-tutorial2_setup_ja" class="outline-2">
<h2 id="tutorial2_setup_ja">
<strong>導入編</strong>
</h2>
<div id="outline-text-tutorial2_setup_ja" class="outline-text-2">
<p>
今回は、 LuneScript の導入方法についての紹介です。</p>
<div id="outline-container-headline-27" class="outline-3">
<h3 id="headline-27">
LuneScript on Web Browser 
</h3>
<div id="outline-text-headline-27" class="outline-text-3">
<p>
LuneScript の動作確認用に、Web ブラウザ上で動作する LuneScript 環境を用意しています。</p>
<p>
<a href="#onweb">#onweb</a></p>
<p>
また、以降のサンプルソースには Run ボタンを持つケースがあります。
そのボタンを押すことで、そのサンプルソースを実行できます。
そして、そのソースを修正して実行することもできます。</p>
<p>
Run ボタンを押してからサンプルを実行するまでに、
初回は数秒から 10 秒程度時間がかかります
(時間はネットワーク環境、端末スペックに依存します)。
これは、ブラウザ上に Lua VM と、LuneScript コンパイラをロードするためです。</p>
<p>
一旦ロードした後に再度実行する場合、
このロード処理が行なわれないため瞬時に実行できます。</p>
</div>
</div>
<div id="outline-container-headline-28" class="outline-3">
<h3 id="headline-28">
LuneScript の導入方法
</h3>
<div id="outline-text-headline-28" class="outline-text-3">
<p>
LuneScript は、次の 2 つの提供方法を用意しています。</p>
<ul>
<li>単独で実行可能なシングルバイナリの go バージョン</li>
<li>Lua のスクリプトとして動作する Lua バージョン</li>
</ul>
<div id="outline-container-headline-29" class="outline-4">
<h4 id="headline-29">
go バージョン
</h4>
<div id="outline-text-headline-29" class="outline-text-4">
<p>
git に登録しているソースから LuneScript を
ビルドするための Dockerfile を用意しています。</p>
<p>
https://github.com/ifritJP/LuneScript/tree/master/src/test/docker/compose</p>
<ul>
<li>linux/build/Dockerfile</li>
<li>alpine/build/Dockerfile</li>
</ul>
<p>次を実行すると、LuneScript/src に Linux 用の lnsc が生成されます。</p>
<pre class="example">
$ git clone --depth 1 https://github.com/ifritJP/LuneScript
$ cd LuneScript/src
$ sudo docker build -t linux_lns test/docker/compose/linux/build
$ sudo docker run --rm -v $PWD:/local linux_lns cp /usr/bin/lnsc /local/lnsc
</pre>
<p>
lnsc に PATH を通してください。</p>
<p>
なお、 proxy 環境下では docker build 時に以下のように proxy を指定してください。</p>
<pre class="example">
$ sudo docker build -t linux_lns test/docker/compose/linux/build --build-arg PROXY=http://proxy.hoge/
</pre>
<p>
go 版の LuneScript 導入は以上です。</p>
</div>
</div>
<div id="outline-container-headline-30" class="outline-4">
<h4 id="headline-30">
Lua バージョン
</h4>
<div id="outline-text-headline-30" class="outline-text-4">
<p>
<strong>Lun 版の LuneScript は、 go 版と比べてトランスコンパイル時間が非常に長いです。</strong>
<strong>go 版を利用することを推奨します。</strong></p>
<p>
LuneScript は Lua のトランスコンパイラです。
また、LuneScript 自体も Lua のスクリプトとして動作します。</p>
<p>
よって、 Lua 版の LuneScript には Lua の実行環境が必要です。</p>
<p>
なお、 LuneScript が対応している Lua のバージョンは 5.1, 5.2, 5.3, 5.4 です。</p>
<p>
ただし Lua 5.1 で利用する場合、幾つかの制限があります。
具体的な制限の内容については、別の記事で説明します。</p>
<p>
追記: 12/10 (<strong>Lua 5.1</strong> 対応について)</p>
<p>
システムにデフォルトでインストールされている Lua のバージョンは、
多くの場合 5.1 系です。</p>
<p>
次のコマンドでインストールされている Lua のバージョンを確認してください。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ lua -v</span></span></code></pre></div>
</div>
<div id="outline-container-headline-31" class="outline-5">
<h5 id="headline-31">
Lua の導入
</h5>
<div id="outline-text-headline-31" class="outline-text-5">
<p>
Lua は次の URL からダウンロードできます。</p>
<p>
http://www.lua.org/download.html</p>
<p>
Linux であれば、パッケージ管理で簡単に導入できますが、
Lua のバージョンには注意してください。</p>
<p>
例えば ubuntu 等の apt 系のパッケージ管理では、次のコマンドで導入できます。</p>
<div class="src src-sh">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ sudo apt install lua5.3</span></span></code></pre></div>
</div>
<div id="outline-container-headline-32" class="outline-6">
<h6 id="headline-32">
Windows の場合
</h6>
<div id="outline-text-headline-32" class="outline-text-6">
<p>
Windows では、cygwin 版 Lua が必要です。</p>
<p>
トランスコンパイル後の Lua コードは、 cygwin 版でなくとも動作します。</p>
<p>
しかし、LuneScript 自体は linux 環境を想定しているため cygwin が必要になります。</p>
<p>
必ず cygwin 版 Lua を用意してください。</p>
<p>
<del>Windows Subsystem for Linux で動作するかどうかは、後程確認します。</del></p>
<p>
WSL2 で動作するので、 cygwin 版ではなく WSL2 でも可能です。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-33" class="outline-5">
<h5 id="headline-33">
LuneScript の導入
</h5>
<div id="outline-text-headline-33" class="outline-text-5">
<p>
前述している通り、LuneScript は Lua のスクリプトとして動作します。</p>
<p>
Lua のモジュール管理は非常に単純で、
Lua が管理するモジュールディレクトリにファイルを置くだけです。</p>
<p>
LuneScript のモジュールは、github に公開しています。</p>
<p>
https://github.com/ifritJP/LuneScript</p>
<p>
手動でファイルコピーすることでもセットアップできますが、
以降では LuneScript の setup.lua を使ったセットアップ方法について説明します。</p>
<p>
手動でファイルコピーする方法は、 Lua のモジュール管理を熟知していないと難しいです。</p>
<div id="outline-container-headline-34" class="outline-6">
<h6 id="headline-34">
LuneScript の導入方法
</h6>
<div id="outline-text-headline-34" class="outline-text-6">
<p>
LuneScript の setup.lua を実行します。</p>
<p>
手順は次の通りです。</p>
<div class="src src-sh">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ git clone https://github.com/ifritJP/LuneScript.git
</span></span><span class="line"><span class="cl">$ <span class="nb">cd</span> LuneScript/src
</span></span><span class="line"><span class="cl">$ lua5.3 setup.lua -d
</span></span><span class="line"><span class="cl">$ sudo make install</span></span></code></pre></div>
</div>
<p>
これにより、 LuneScript がモジュールディレクトリにインストールされます。</p>
<p>
LuneScript をインストールする Lua のモジュールディレクトリを指定したい場合、
<code>lua5.3 setup.lua -d</code> の -d を外して実行してください。</p>
</div>
</div>
<div id="outline-container-headline-35" class="outline-6">
<h6 id="headline-35">
Lua が管理するモジュールディレクトリ
</h6>
<div id="outline-text-headline-35" class="outline-text-6">
<p>
Lua が管理するモジュールディレクトリは次のコマンドで確認できます。</p>
<div class="src src-sh">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ lua5.3 -e <span class="s1">&#39;print( package.path )&#39;</span></span></span></code></pre></div>
</div>
<p>
上記コマンドの結果は、次のようになります。 (環境によって異なります)</p>
<div class="src src-sh">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">/usr/local/share/lua/5.3/?.lua<span class="p">;</span>/usr/local/share/lua/5.3/?/init.lua<span class="p">;</span>/usr/local/lib/lua/5.3/?.lua<span class="p">;</span>/usr/local/lib/lua/5.3/?/init.lua<span class="p">;</span>/usr/share/lua/5.3/?.lua<span class="p">;</span>/usr/share/lua/5.3/?/init.lua<span class="p">;</span>./?.lua<span class="p">;</span>./?/init.lua</span></span></code></pre></div>
</div>
<p>
これを ; で区切ると次になります。</p>
<ul>
<li><code class="verbatim">/usr/local/share/lua/5.3/?.lua</code></li>
<li><code class="verbatim">/usr/local/share/lua/5.3/?/init.lua</code></li>
<li><code class="verbatim">/usr/local/lib/lua/5.3/?.lua</code></li>
<li><code class="verbatim">/usr/local/lib/lua/5.3/?/init.lua</code></li>
<li><code class="verbatim">/usr/share/lua/5.3/?.lua</code></li>
<li><code class="verbatim">/usr/share/lua/5.3/?/init.lua</code></li>
<li><code class="verbatim">./?.lua</code></li>
<li><code class="verbatim">./?/init.lua</code></li>
</ul>
<p>細かい説明は省きますが、
次のディレクトリが Lua が管理するモジュールディレクトリになります。</p>
<ul>
<li><code class="verbatim">/usr/local/share/lua/5.3</code></li>
<li><code class="verbatim">/usr/local/lib/lua/5.3</code></li>
<li><code class="verbatim">/usr/share/lua/5.3</code></li>
<li><code class="verbatim">./</code></li>
</ul>
<p><strong>ディレクトリは環境によって異なります。</strong></p>
<p>
環境変数によってもモジュールディレクトリを指定することは出来ますが、
ここでの説明は割愛します。</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-36" class="outline-3">
<h3 id="headline-36">
emacs の設定
</h3>
<div id="outline-text-headline-36" class="outline-text-3">
<p>
LuneScript は、emacs で開発するための emacs lisp を提供しています。</p>
<p>
次の設定をしてください。</p>
<div class="src src-lisp">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lisp" data-lang="lisp"><span class="line"><span class="cl">  <span class="p">(</span><span class="nv">add-to-list</span> <span class="ss">&#39;load-path</span> <span class="s">&#34;my-lune-path&#34;</span><span class="p">)</span>  <span class="c1">;;; clone した LuneScript のパスを指定</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="k">setq</span> <span class="nv">lns-lua-command</span> <span class="s">&#34;/usr/local/bin/lua&#34;</span><span class="p">)</span>  <span class="c1">;;; lua のパス</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nf">require</span> <span class="ss">&#39;lns-conf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nf">require</span> <span class="ss">&#39;lns-flymake</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nf">require</span> <span class="ss">&#39;lns-company-mode</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="p">(</span><span class="nf">require</span> <span class="ss">&#39;lns-helm</span><span class="p">)</span></span></span></code></pre></div>
</div>
<p>
これにより、次が利用できます。</p>
<ul>
<li>.lns ファイルのインデント、色付け</li>
<li>flymake による構文チェック</li>
<li>company-mode による補完</li>
</ul>
<p>構文チェックは flymake と flycheck をサポートしています。
flycheck を利用したい場合 lns-flymake ではなく、 lns-flycheck を require してください。</p>
<p>
helm, company-mode, flycheck, flymake は、別途 M-x package-install してください。</p>
</div>
</div>
<div id="outline-container-headline-37" class="outline-3">
<h3 id="headline-37">
プロジェクトファイル
</h3>
<div id="outline-text-headline-37" class="outline-text-3">
<p>
LuneScript は、モジュール管理にディレクトリ階層を利用します。
よって、 LuneScript でトランスコンパイルを行なう際の
カレントディレクトリは重要になります。</p>
<p>
トランスコンパイルを行なう際のカレントディレクトリに、
次の名前のファイルを置くことで、
プロジェクトファイルとして扱います。</p>
<pre class="example">
lune.js
</pre>
<p>
特にエディタで LuneScript のソースを編集する場合、
その LuneScript ソースのプロジェクトディレクトリが何処なのか認識するために、
このファイルが検索されるので、
必ず上記ファイルを生成してください。</p>
<div id="outline-container-headline-38" class="outline-4">
<h4 id="headline-38">
プロジェクトファイルのフォーマット
</h4>
<div id="outline-text-headline-38" class="outline-text-4">
<p>
プロジェクトファイルは JSON 形式です。</p>
<p>
最低限、次の内容を持つ lune.js ファイルを作成してください。</p>
<div class="src src-js">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">{}</span></span></span></code></pre></div>
</div>
<p>
このファイルを置いたディレクトリが、モジュールの起点ディレクトリとなります。</p>
<p>
例えば次のようなディレクトリ構成の場合、</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">foo/
</span></span><span class="line"><span class="cl">foo/lune.js
</span></span><span class="line"><span class="cl">foo/bar/
</span></span><span class="line"><span class="cl">foo/bar/mod1.lns</span></span></code></pre></div>
</div>
<p>
bar.mod1 が、mod1.lns のモジュールパスとなります。</p>
</div>
</div>
<div id="outline-container-headline-39" class="outline-4">
<h4 id="headline-39">
コマンドラインオプション追加
</h4>
<div id="outline-text-headline-39" class="outline-text-4">
<p>
プロジェクトファイルに、
LuneScript のコマンドラインオプションを設定しておくことで、
トランスコンパイル時にプロジェクトファイルに設定されている
コマンドラインオプションを使用します。</p>
<p>
コマンドラインオプションの設定は、
次のように <code class="verbatim">cmd_option</code> キーで文字列リストを設定します。</p>
<div class="src src-js">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;cmd_option&#34;</span><span class="o">:</span> <span class="p">[</span> <span class="s2">&#34;--valid-luaval&#34;</span> <span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-40" class="outline-3">
<h3 id="headline-40">
まとめ
</h3>
<div id="outline-text-headline-40" class="outline-text-3">
<p>
Lua のモジュール管理は非常に単純なため、簡単に導入ができます。  </p>
<p>
次回は LuneScript による Hello World について紹介します。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-tutorial3_hello_ja" class="outline-2">
<h2 id="tutorial3_hello_ja">
<strong>Hello world</strong>
</h2>
<div id="outline-text-tutorial3_hello_ja" class="outline-text-2">
<p>
今回は、 LuneScript を使った Hello world の紹介です。</p>
<div id="outline-container-headline-42" class="outline-3">
<h3 id="headline-42">
lnsc コマンド
</h3>
<div id="outline-text-headline-42" class="outline-text-3">
<p>
LuneScript を導入すると、lnsc コマンドがインストールされます。</p>
<p>
lnsc コマンドは次のように利用します。</p>
<div class="src src-sh">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ lnsc src.lns exe</span></span></code></pre></div>
</div>
<p>
ここで src.lns は、 LuneScript で作成したスクリプトのパスです。
exe は lnsc のオプションで、 指定したスクリプトを実行することを意味します。</p>
</div>
</div>
<div id="outline-container-headline-43" class="outline-3">
<h3 id="headline-43">
Hello world 
</h3>
<div id="outline-text-headline-43" class="outline-text-3">
<p>
では LuneScript を使って、伝統の Hello world を実行してみましょう。</p>
<p>
次の内容を持つファイル hello.lns を作成してください。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
print( &#34;Hello world.&#34; );</code></pre>
</div>
<p>
そして、次のコマンドを実行します。</p>
<div class="src src-sh">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ lnsc hello.lns exe</span></span></code></pre></div>
</div>
<p>
これで &#34;Hello world&#34; が出力されました。</p>
<p>
これだけだと面白くもなんともないので、もう少し話を続けます。</p>
<p>
まずは、 hello.lns を次のように少し変更します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let txt = &#34;world&#34;;
print( &#34;Hello %s.&#34; ( txt ) );</code></pre>
</div>
<p>
このスクリプトの結果も <code>Hello world.</code> になります。</p>
<p>
では、次のコマンドを実行してみてください。</p>
<div class="src src-sh">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ lnsc hello.lns lua</span></span></code></pre></div>
</div>
<p>
次が出力されたと思います。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="c1">--hello.lns</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">_moduleObj</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">__mod__</span> <span class="o">=</span> <span class="s1">&#39;hello&#39;</span>
</span></span><span class="line"><span class="cl"><span class="kr">if</span> <span class="ow">not</span> <span class="n">_lune</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">   <span class="n">_lune</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">txt</span> <span class="o">=</span> <span class="s2">&#34;world&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">string.format</span><span class="p">(</span> <span class="s2">&#34;Hello %s.&#34;</span><span class="p">,</span> <span class="n">txt</span><span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">return</span> <span class="n">_moduleObj</span></span></span></code></pre></div>
</div>
<p>
これは hello.lns を Lua に変換したコードです。</p>
<p>
なんだかゴチャゴチャしていますが、
<code>print( string.format( &#34;Hello %s.&#34;, txt) )</code> が出力されているのが分かると思います。</p>
<p>
これは、 LuneScript で書いた <code>print( &#34;Hello %s.&#34; ( txt ) )</code> が、
Lua にトランスコンパイルする際に
<code>print( string.format( &#34;Hello %s.&#34;, txt) )</code> に展開されていることを示します。</p>
<p>
では、次のコマンドを実行してください。</p>
<div class="src src-sh">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ lnsc hello.lns save</span></span></code></pre></div>
</div>
<p>
これによって、 hello.lua ファイルが作成されました。
hello.lua ファイルの内容は、先ほど出力した Lua のコードと同じものです。</p>
<p>
では、次のコマンドで hello.lua を実行してください。</p>
<div class="src src-sh">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ lua5.3 hello.lua</span></span></code></pre></div>
</div>
<p>
<code>Hello world.</code> が出力されているでしょう。
Lua にトランスコンパイルしたコードは、
LuneScript に依存しない Lua のコードになります。</p>
<p>
最初に実行した <code>lnsc hello.lns exe</code> は、
LuneScript のスクリプトをトランスコンパイルし、実行まで行なうコマンドです。</p>
<p>
次に実行した <code>lnsc hello.lns lua</code> は、
LuneScript のスクリプトをトランスコンパイルし、Lua コードを標準出力するコマンドです。</p>
<p>
最後に実行した <code>lnsc hello.lns save</code> は、
LuneScript のスクリプトをトランスコンパイルし、Lua コードを保存するコマンドです。</p>
<p>
このドキュメントでは exe を利用しつつ、
変換後のコードを確認する際は save コマンドを利用していきます。</p>
<div id="outline-container-headline-44" class="outline-4">
<h4 id="headline-44">
Main 関数
</h4>
<div id="outline-text-headline-44" class="outline-text-4">
<p>
main 関数を定義することで、コマンドラインオプションを処理できます。</p>
<p>
以下を参照してください。</p>
<p>
<a href="#shebang_main">#shebang_main</a></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-45" class="outline-3">
<h3 id="headline-45">
エラーメッセージ
</h3>
<div id="outline-text-headline-45" class="outline-text-3">
<p>
LuneScript では、 区切り記号 <code class="verbatim">;</code> が必須です。
次のように <code class="verbatim">;</code> を終端に入れていないとエラーになります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
print( &#34;Hello world.&#34; )</code></pre>
</div>
<p>
このとき、以下のエラーメッセージが出力されます。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">mini.lns:1:23: error: EOF
</span></span><span class="line"><span class="cl">lua5.3: ./lune/base/Util.lua:176: has error
</span></span><span class="line"><span class="cl">stack traceback:
</span></span><span class="line"><span class="cl">	[C]: in function &#39;error&#39;
</span></span><span class="line"><span class="cl">	./lune/base/Util.lua:176: in function &#39;lune.base.Util.err&#39;
</span></span><span class="line"><span class="cl">	./lune/base/TransUnit.lua:3465: in method &#39;error&#39;
</span></span><span class="line"><span class="cl">	./lune/base/TransUnit.lua:3538: in method &#39;getToken&#39;
</span></span><span class="line"><span class="cl">	./lune/base/TransUnit.lua:11641: in method &#39;analyzeStatement&#39;
</span></span><span class="line"><span class="cl">	./lune/base/TransUnit.lua:3710: in method &#39;analyzeStatementList&#39;
</span></span><span class="line"><span class="cl">	./lune/base/TransUnit.lua:5430: in function &lt;./lune/base/TransUnit.lua:5393&gt;
</span></span><span class="line"><span class="cl">	(...tail calls...)
</span></span><span class="line"><span class="cl">	./lune/base/front.lua:848: in method &#39;loadFileToLuaCode&#39;
</span></span><span class="line"><span class="cl">	./lune/base/front.lua:914: in method &#39;loadFile&#39;
</span></span><span class="line"><span class="cl">	./lune/base/front.lua:1066: in method &#39;loadModule&#39;
</span></span><span class="line"><span class="cl">	./lune/base/front.lua:1709: in method &#39;exec&#39;
</span></span><span class="line"><span class="cl">	./lune/base/front.lua:1744: in function &#39;lune.base.front.exec&#39;
</span></span><span class="line"><span class="cl">	lune/base/base.lua:1: in main chunk
</span></span><span class="line"><span class="cl">	[C]: in ?</span></span></code></pre></div>
</div>
<p>
このエラー出力において、次のメッセージがコンパイルエラーを示します。</p>
<pre class="example">
mini.lns:1:23: error: EOF
</pre>
<p>
このエラーは、 mini.lns の 1 行目の 23 バイト目で、
予期しない EOF エラーが発生したことを示しています。</p>
<p>
これ以外のエラー出力は、 LuneScript 内部のエラーです。
LuneScript 内部のエラー出力を抑制するには、
次のオプション (diag –nodebug) を指定します。</p>
<div class="src src-sh">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ lnsc hello.lns exe diag --nodebug
</span></span><span class="line"><span class="cl">mini.lns:1:23: error: EOF
</span></span><span class="line"><span class="cl">has error</span></span></code></pre></div>
</div>
<p>
現在のバージョンでは、デフォルトで内部エラー出力を抑制しています。</p>
<p>
内部エラー出力を有効にする場合は –debug オプションを指定します。</p>
</div>
</div>
<div id="outline-container-headline-46" class="outline-3">
<h3 id="headline-46">
ランタイム
</h3>
<div id="outline-text-headline-46" class="outline-text-3">
<p>
ちょっと Hello world をネタにしている記事にしては重い内容ですが、
出力した Lua のコードを見たついでにランタイムについて説明します。</p>
<p>
LuneScript から Lua に出力したコードには、
そのコードを動作させるために必要なランタイムが付加されます。</p>
<p>
例えば、次の LuneScript のコードを Lua に変換すると、</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn add( val:int! ):int {
   return 10 + unwrap val default 0;
}
print( add( 1 ) ); // 11
print( add( nil ) ); // 10</code></pre>
</div>
<p>
次のようになります。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="c1">--mini.lns</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">_moduleObj</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">__mod__</span> <span class="o">=</span> <span class="s1">&#39;mini&#39;</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">_lune</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kr">if</span> <span class="n">_lune1</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">   <span class="n">_lune</span> <span class="o">=</span> <span class="n">_lune1</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kr">function</span> <span class="nc">_lune</span><span class="p">.</span><span class="nf">unwrap</span><span class="p">(</span> <span class="n">val</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="kr">if</span> <span class="n">val</span> <span class="o">==</span> <span class="kc">nil</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">      <span class="n">__luneScript</span><span class="p">:</span><span class="n">error</span><span class="p">(</span> <span class="s1">&#39;unwrap val is nil&#39;</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="kr">end</span>
</span></span><span class="line"><span class="cl">   <span class="kr">return</span> <span class="n">val</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kr">function</span> <span class="nc">_lune</span><span class="p">.</span><span class="nf">unwrapDefault</span><span class="p">(</span> <span class="n">val</span><span class="p">,</span> <span class="n">defval</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="kr">if</span> <span class="n">val</span> <span class="o">==</span> <span class="kc">nil</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">      <span class="kr">return</span> <span class="n">defval</span>
</span></span><span class="line"><span class="cl">   <span class="kr">end</span>
</span></span><span class="line"><span class="cl">   <span class="kr">return</span> <span class="n">val</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">if</span> <span class="ow">not</span> <span class="n">_lune1</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">   <span class="n">_lune1</span> <span class="o">=</span> <span class="n">_lune</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="kr">function</span> <span class="nf">add</span><span class="p">(</span> <span class="n">val</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kr">return</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">_lune.unwrapDefault</span><span class="p">(</span> <span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">add</span><span class="p">(</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">add</span><span class="p">(</span> <span class="kc">nil</span> <span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">return</span> <span class="n">_moduleObj</span></span></span></code></pre></div>
</div>
<p>
そこそこの量のランタイムが出力されていることが分かると思います。
ちなみに、 <code class="verbatim">local function add( val )</code> より上が、ランタイムです。</p>
<p>
変換元の LuneScript のコードの内容によって挿入されるランタイムが増減します。
ランタイム全てを出力すると、サイズは約 10KB となっています。</p>
<p>
このランタイムは、変換した全ての Lua コードに出力されます。</p>
<p>
Lua コードにランタイムのコードが挿入されることが気になる場合、
lnsc のコマンドラインオプションに <code class="verbatim">-r</code> を指定することで、
次のようにランタイムの展開を <code class="verbatim">require</code> に置き換えることが出来ます。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="c1">--mini.lns</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">_moduleObj</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">__mod__</span> <span class="o">=</span> <span class="s1">&#39;mini&#39;</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">_lune</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span> <span class="s2">&#34;lune.base._lune1&#34;</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">if</span> <span class="ow">not</span> <span class="n">_lune1</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">   <span class="n">_lune1</span> <span class="o">=</span> <span class="n">_lune</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="kr">function</span> <span class="nf">add</span><span class="p">(</span> <span class="n">val</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kr">return</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">_lune.unwrapDefault</span><span class="p">(</span> <span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">add</span><span class="p">(</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">add</span><span class="p">(</span> <span class="kc">nil</span> <span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">return</span> <span class="n">_moduleObj</span></span></span></code></pre></div>
</div>
<p>
ただしこの場合、
lune.base._lune1 を require することになるので、
lune.base._lune1 がロードできるようにロードパスを通しておく必要があります。</p>
<p>
ここで、 _lune1 の 1 はランタイムのバージョンを示します。</p>
<p>
Lua 版の LuneScript が動作している環境であれば気にする必要はないですが、
変換した Lua コードだけを別の環境で動かす場合は注意が必要です。</p>
<p>
なお、 <code class="verbatim">-r</code> オプションの代わりに <code class="verbatim">--runtime mod</code> オプションを指定することで、</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="c1">--mini.lns</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">_moduleObj</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">__mod__</span> <span class="o">=</span> <span class="s1">&#39;mini&#39;</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">_lune</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span> <span class="s2">&#34;mod&#34;</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">if</span> <span class="ow">not</span> <span class="n">_lune1</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">   <span class="n">_lune1</span> <span class="o">=</span> <span class="n">_lune</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="kr">function</span> <span class="nf">add</span><span class="p">(</span> <span class="n">val</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kr">return</span> <span class="mi">10</span> <span class="o">+</span> <span class="n">_lune.unwrapDefault</span><span class="p">(</span> <span class="n">val</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">add</span><span class="p">(</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">add</span><span class="p">(</span> <span class="kc">nil</span> <span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">return</span> <span class="n">_moduleObj</span></span></span></code></pre></div>
</div>
<p>
上記のように lune.base._lune をロードする代わりに、
指定の mod モジュールに切り替えることが出来ます。</p>
<p>
LuneScript のバージョンが変わると、LuneScript のランタイムも変わることがあります。
もしも、異なるバージョンの LuneScript で変換した Lua モジュールが混在する場合、
デフォルトの lune.base._lune を使用すると正常に動作しないことがあります。</p>
<p>
これを避けるために、 –runtime オプションを利用して、
意図しないバージョンのランタイムがロードされることを防止します。</p>
<p>
なお、コマンドラインに <code class="verbatim">-mklunemod path</code> を指定することで、
指定の path にランタイムのモジュールファイルを生成します。</p>
</div>
</div>
<div id="outline-container-headline-47" class="outline-3">
<h3 id="headline-47">
コメント
</h3>
<div id="outline-text-headline-47" class="outline-text-3">
<p>
LuneScript におけるコメントは、 <code>//</code> と <code>/* */</code> です。  </p>
<p>
<code>//</code> は行末までをコメントとし、
<code>/* */</code> は複数行をコメントとして扱います。</p>
<p>
次回は LuneScript で扱う値について説明します。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-crosscompile_ja" class="outline-2">
<h2 id="crosscompile_ja">
<strong>Lua バージョン間のクロスコンパイル</strong>
</h2>
<div id="outline-text-crosscompile_ja" class="outline-text-2">
<p>
今回は少し予定を変更して、LuneScript のクロスコンパイルについて説明します。</p>
<div id="outline-container-headline-49" class="outline-3">
<h3 id="headline-49">
クロスコンパイル
</h3>
<div id="outline-text-headline-49" class="outline-text-3">
<p>
ここでいう「クロスコンパイル」とは、
Lua のバージョン間の「クロスコンパイル」という意味です。</p>
<p>
LuneScript は、Lua へのトランスコンパイルを行なう際、
LuneScript を実行している Lua のバージョンに合せたトランスコンパイルを行ないます。</p>
<p>
例えば、次のような制御を行ないます。</p>
<ul>
<li>Lua5.2 で実行している場合、ビット演算は bit32 ライブラリを利用する。</li>
<li>Lua5.3 で実行している場合、ビット演算は Lua の組込み演算子を利用する。</li>
</ul>
<p>クロスコンパイルは、出力する Lua のコードを、
LuneScript を実行している Lua のバージョンではなく、
指定の Lua バージョンにトランスコンパイルします。</p>
<p>
これにより、次のようなことが可能になります。</p>
<p>
  「LuneScript は Lua5.3 で実行し、トランスコンパイル先は Lua5.1 にする」</p>
<div id="outline-container-headline-50" class="outline-4">
<h4 id="headline-50">
使用方法  
</h4>
<div id="outline-text-headline-50" class="outline-text-4">
<p>
使用方法は、次のように -ol オプションでバージョンを指定するだけです。</p>
<div class="src src-sh">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ lnsc src.lns lua -ol <span class="m">51</span></span></span></code></pre></div>
</div>
<p>
上記の例は src.lns を lua5.1 用にトランスコンパイルし、
結果を stdout に出力します。</p>
<p>
-ol オプションに指定する値は、次の通りです。</p>
<table>
<thead>
<tr>
<th class="align-right">オプション</th>
<th>バージョン</th>
</tr>
</thead>
<tbody>
<tr>
<td class="align-right">51</td>
<td>Lua5.1</td>
</tr>
<tr>
<td class="align-right">52</td>
<td>Lua5.2</td>
</tr>
<tr>
<td class="align-right">53</td>
<td>Lua5.3</td>
</tr>
</tbody>
</table>
<p>
-ol オプションは、 save, lua で指定可能です。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-51" class="outline-3">
<h3 id="headline-51">
LuneScript の Lua5.1 対応
</h3>
<div id="outline-text-headline-51" class="outline-text-3">
<p>
これまで LuneScript は、実行に Lua5.2, Lua5.3 が必要でしたが、
上記クロスコンパイル対応によって、 Lua5.1 でも実行できるようになりました。</p>
<p>
LuneScript は、それ自体を LuneScript で開発するセルフホスティングであるため、
LuneScript 自体をクロスコンパイルすることで Lua5.1 対応しました。</p>
<p>
LuneScript で開発することにより、「生産性を上げる」ということ以外にも、
「Lua のバージョン違いを <strong>ある程度</strong> 吸収できる」というメリットがあります。</p>
<p>
ただし、吸収できるのはあくまでも <strong>ある程度</strong> です。</p>
<p>
Lua5.1 は、次節で説明する制限があります。</p>
<div id="outline-container-headline-52" class="outline-4">
<h4 id="headline-52">
Lua5.1 の制限
</h4>
<div id="outline-text-headline-52" class="outline-text-4">
<p>
LuneScript のコードを Lua5.1 にトランスコンパイルする場合、次の制限があります。</p>
<p>
<em>LuneScript の制限というよりは、 Lua5.1 の制限とも言えますが。。</em></p>
<ul>
<li>クラスのデストラクタが使用できない。</li>
<li>ビット演算が使用できない。  </li>
<li><code class="verbatim">find()</code> などの文字クラスに %g が利用できない。</li>
<li><code class="verbatim">string.format()</code> の書式に %s, %q を指定した場合、
文字列以外を指定できない。</li>
</ul>
<p>上記において、デストラクタ、ビット演算に関しては、
コンパイル時にエラー出力しますが、
%g, %s, %q に関しては、コンパイル時にエラーを出力しませんので注意が必要です。</p>
<p>
ただし、 %s, %q に関しては、次のパターンではトランスコンパイル時に、
<code class="verbatim">tostring()</code> を付加することでエラーしないように回避しています。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
print( string.format( &#34;%d,%s,%s,%s&#34;,  1, 1.0, {}, [] ) );</code></pre>
</div>
<p>
上記のように、リテラルな文字列を使った format 書式は、
%s とそれに対応するデータの型を見て、
str でなければ次のように <code class="verbatim">tostring()</code> を付加します。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">string.format</span><span class="p">(</span> <span class="s2">&#34;%d,%s,%s,%s&#34;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tostring</span><span class="p">(</span> <span class="mf">1.0</span><span class="p">),</span> <span class="n">tostring</span><span class="p">(</span> <span class="p">{}),</span> <span class="n">tostring</span><span class="p">(</span> <span class="p">{})</span> <span class="p">)</span> <span class="p">)</span></span></span></code></pre></div>
</div>
<p>
この変換が可能なのは、リテラル文字列を利用している時だけです。</p>
<p>
例えば、次の場合は変換できません。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let formatTxt = &#34;%d,%s,%s,%s&#34;;
print( string.format( formatTxt,  1, 1.0, {}, [] ) );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-53" class="outline-3">
<h3 id="headline-53">
まとめ
</h3>
<div id="outline-text-headline-53" class="outline-text-3">
<p>
LuneScript は、 Lua のバージョン間のクロスコンパイルをサポートします。</p>
<p>
これにより Lua5.1, Lua5.2, Lua5.3 での、実行をサポートします。</p>
<p>
ただし、 Lua5.1 には制限があります。</p>
<p>
次回はクラスについて説明します。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-value_ja" class="outline-2">
<h2 id="value_ja">
<strong>値編</strong>
</h2>
<div id="outline-text-value_ja" class="outline-text-2">
<p>
今回は、 LuneScript で扱える値について説明します。</p>
<div id="outline-container-headline-55" class="outline-3">
<h3 id="headline-55">
値の型
</h3>
<div id="outline-text-headline-55" class="outline-text-3">
<p>
LuneScript で扱える値の型と、トランスコンパイラ後の Lua の値との対応表を示します。</p>
<table>
<thead>
<tr>
<th>LuneScript</th>
<th>Lua</th>
<th>go</th>
<th>用途</th>
<th>LuneScript での定義方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>nil, null</td>
<td>nil</td>
<td>nil</td>
<td>nil</td>
<td>nil</td>
</tr>
<tr>
<td>int</td>
<td>数値</td>
<td>LnsInt</td>
<td>整数</td>
<td>0 1 2 3 ?A 0x10 -100</td>
</tr>
<tr>
<td>real</td>
<td>数値</td>
<td>LnsReal</td>
<td>実数</td>
<td>0.0 1.0 0.001</td>
</tr>
<tr>
<td>str</td>
<td>文字列</td>
<td>string</td>
<td>文字列, バイナリデータ</td>
<td>&#34;abc&#34; &#39;def&#39;  ```hij```</td>
</tr>
<tr>
<td>bool</td>
<td>真偽値</td>
<td>bool</td>
<td>真偽値</td>
<td>true false</td>
</tr>
<tr>
<td>List</td>
<td>テーブル</td>
<td>LnsList</td>
<td>リスト</td>
<td>[1, 2, 3 ]</td>
</tr>
<tr>
<td><del>Array</del></td>
<td><del>テーブル</del></td>
<td></td>
<td><del>配列(固定長)</del></td>
<td><del>[@ 1, 2, 3 ]</del></td>
</tr>
<tr>
<td>Map</td>
<td>テーブル</td>
<td>LnsMap</td>
<td>マップ</td>
<td>{ &#34;A&#34;:1, &#34;BC&#34;: 100 }</td>
</tr>
<tr>
<td>Set</td>
<td>テーブル</td>
<td>LnsSet</td>
<td>セット</td>
<td>(@ 1, 2, 3)</td>
</tr>
<tr>
<td>class</td>
<td>テーブル</td>
<td>struct</td>
<td>クラス</td>
<td>class Test {}</td>
</tr>
<tr>
<td>interface</td>
<td>テーブル</td>
<td>interface</td>
<td>インタフェース</td>
<td>interface Test {}</td>
</tr>
<tr>
<td>fn</td>
<td>function</td>
<td>func</td>
<td>関数</td>
<td>fn func() {}</td>
</tr>
<tr>
<td>enum</td>
<td>数値、文字列</td>
<td>const</td>
<td>enum</td>
<td>enum Test { }</td>
</tr>
<tr>
<td>alge</td>
<td>テーブル</td>
<td>struct</td>
<td>代数データ</td>
<td>alge Test { }</td>
</tr>
<tr>
<td>Luaval</td>
<td>Lua の値</td>
<td>Lns_luaValue</td>
<td>Lua の値そのものを</td>
<td></td>
</tr>
<tr>
<td>stem</td>
<td>値</td>
<td>LnsAny</td>
<td>nil 以外の全ての値を保持可能な型</td>
<td></td>
</tr>
</tbody>
</table>
<p>
<strong>2019/3</strong> Set 追加。
<strong>2020/10</strong> Luaval 追加</p>
<p>
上記の通り、 LuneScript では Lua の値を細分化してそれぞれを個別の型として扱います。</p>
<p>
細分化の意図は、 Lua の次の仕様を改善することです。</p>
<ul>
<li>Lua の数値は全て実数であり、
慣れていないと数値が実数であることによる不具合が生じる。
例えば <code>10/3</code> の Lua の計算結果は、3 ではなく 3.3333 となる。</li>
<li>
<p>Lua のテーブルは、全てのキーが自然数となる <strong>シーケンス</strong> と、
キーが自然数とならない <strong>非シーケンス</strong> に分かれる。</p>
<ul>
<li>
<p>この違いによって、テーブル内のデータを列挙する際の関数が 
ipairs と pairs に分かれており、使い分けが必要になる。</p>
<ul>
<li>pairs だけを使っていれば問題ないとも言えるが。。。</li>
</ul>
</li>
<li>テーブルのサイズを取得する <code>#</code> 演算子は、シーケンスのサイズを返すものであり、
非シーケンスのサイズを返さないため、紛らわしい。</li>
</ul>
</li>
</ul>
<div id="outline-container-headline-56" class="outline-4">
<h4 id="headline-56">
nil
</h4>
<div id="outline-text-headline-56" class="outline-text-4">
<p>
nil は、 Lua の nil と同じです。</p>
<p>
LuneScript では null も利用できます。</p>
<p>
null は nil の alias です。</p>
<p>
null のサポートにより、 LuneScript で JSON をそのまま扱うことができます。</p>
</div>
</div>
<div id="outline-container-headline-57" class="outline-4">
<h4 id="headline-57">
整数、 実数
</h4>
<div id="outline-text-headline-57" class="outline-text-4">
<p>
LuneScript は、整数と実数を分けて扱います。</p>
<p>
これにより 10/3 は 3 となり、 10/3.0 は 3.3333… となります。</p>
<p>
型名はそれぞれ次の通りです。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val:int = 1;      // 整数 int
let val2:real = 1.5;  // 実数 real</code></pre>
</div>
<div id="outline-container-headline-58" class="outline-5">
<h5 id="headline-58">
数値リテラル
</h5>
<div id="outline-text-headline-58" class="outline-text-5">
<p>
数値リテラルは C89 ライクなものを採用します。</p>
<ul>
<li>整数は 10 進数と 16 進数表現をサポート</li>
<li>実数は 10 進数と e による指数表現。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-59" class="outline-5">
<h5 id="headline-59">
文字
</h5>
<div id="outline-text-headline-59" class="outline-text-5">
<p>
LuneScript は、
<code>?</code> を使用することで <code>?</code> に続く文字のコードを、
int 型の immediate な値として扱えます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
print( ?a ); // 97  (0x61)</code></pre>
</div>
<p>
なお、 &#39; や &#34; の文字のコードを得る場合、
?\&#39; のように \ でエスケープする必要があります。</p>
<p>
この方法で取得可能なコードは 1 バイトだけです。
例えば ? に続く文字が UTF-8 などのマルチバイトコードだった場合、
先頭の 1 バイトを取得し 2 バイト以降は LuneScript のコードとして解析し、
parse エラーします。</p>
</div>
</div>
<div id="outline-container-headline-60" class="outline-5">
<h5 id="headline-60">
四則演算
</h5>
<div id="outline-text-headline-60" class="outline-text-5">
<p>
数値の四則演算は Lua と同じものを採用します。</p>
<p>
2項演算の結果は次の通り型が変わります。</p>
<ul>
<li>int と int の演算結果は int になる。</li>
<li>real と real の演算結果は real になる。</li>
<li>int と real の演算結果は real になる。</li>
</ul>
<p>ただし、 int と int の演算結果が int の範囲外になった場合、
実行時の内部的な値としては real になりますが、LuneScript 上の型は int のままです。
演算結果を int に丸めるには、 <code>@@int</code> でキャストする必要があります。</p>
<p>
go にトランスコンパイルした場合、 内部的にも int のままです。</p>
</div>
</div>
<div id="outline-container-headline-61" class="outline-5">
<h5 id="headline-61">
ビット演算
</h5>
<div id="outline-text-headline-61" class="outline-text-5">
<p>
ビット演算をサポートします。
Lua5.1 では使用できません。</p>
<p>
ビット長は Lua5.2 では 32bit となります。
Lua5.3 のビット長は、環境に依存します。</p>
<ul>
<li>論理積 (&amp;)</li>
</ul>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
print( 1 &amp; 3 == 1 );</code></pre>
</div>
<ul>
<li>論理和  (|)</li>
</ul>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
print( 1 | 2 == 3 );</code></pre>
</div>
<ul>
<li>排他的論理和 (~)</li>
</ul>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
print( 1 ~ 3 == 2 );</code></pre>
</div>
<ul>
<li>論理シフト(左) (|&lt;&lt;)</li>
</ul>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
print( 1 |&lt;&lt; 2 == 4 );</code></pre>
</div>
<ul>
<li>論理シフト(右) (|&gt;&gt;)</li>
</ul>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
print( 0x10 |&gt;&gt; 2 == 4 );</code></pre>
</div>
<ul>
<li>ビット反転 (~)</li>
</ul>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
print( ~2 == 0xfffffffd );</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-62" class="outline-4">
<h4 id="headline-62">
文字列
</h4>
<div id="outline-text-headline-62" class="outline-text-4">
<p>
&#34; か &#39; で囲むと文字列になります。
&#34;&#34; 内では &#39; が使用でき、 &#39;&#39; 内では &#34; が使用できます。</p>
<p>
なお、 &#34;&#34;, &#39;&#39; は改行を含めることはできません。
改行を含める場合は &#34;\n&#34; とします。</p>
<p>
\n を使用せずに複数行の文字列を定義するには ``` を使用します。
`````` 内の \n は、改行ではなくそのまま \n として文字列になります。</p>
<p>
文字列内の特定位置の文字を取得するには、 [N] を使用します。
ここで指定する N は、文字列先頭が 1 を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let txt = &#34;abc&#34;;
print( txt[ 2 ] );  // 98</code></pre>
</div>
<p>
N が文字列長を越えた場合の動作は、 <strong>未定義</strong> です。</p>
<p>
文字列長は # で取得します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
print( #&#34;abc&#34; ); // 3</code></pre>
</div>
<p>
型名は次の通り str です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val:str = &#34;abc&#34;; // 文字列 str</code></pre>
</div>
<div id="outline-container-headline-63" class="outline-5">
<h5 id="headline-63">
連結
</h5>
<div id="outline-text-headline-63" class="outline-text-5">
<p>
文字列の連結は <code class="verbatim">..</code> で行ないます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
print( &#34;abc&#34; .. &#34;efg&#34; );  // abcdefg</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-64" class="outline-5">
<h5 id="headline-64">
書式文字列
</h5>
<div id="outline-text-headline-64" class="outline-text-5">
<p>
以下で書式を指定して文字列を生成できます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
print( &#34;%s %d %d&#34; (&#34;abc&#34;, 1, 2) ); // abc 1 2</code></pre>
</div>
<p>
文字列リテラルの直後に () で値を指定します。</p>
<p>
書式などの情報は Lua の <code class="verbatim">string.format</code> API を参照してください。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-65" class="outline-4">
<h4 id="headline-65">
真偽値(bool)
</h4>
<div id="outline-text-headline-65" class="outline-text-4">
<p>
true, false をもちます。    </p>
<p>
型名は、次の通り bool です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val:bool = true; // bool</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-66" class="outline-4">
<h4 id="headline-66">
リスト
</h4>
<div id="outline-text-headline-66" class="outline-text-4">
<p>
リストは値を追加、削除可能な型です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut list:List&lt;int&gt; = [];
list.insert( 1 ); // [ 1 ]
list.insert( 2 ); // [ 1, 2 ]
list.insert( 3 ); // [ 1, 2, 3 ]
list.remove(); // [ 1, 2 ]
print( list[1] ); // 1</code></pre>
</div>
<p>
リストの要素には [index] でアクセスします。
リストの先頭の index は 1 です。
リストの範囲外をアクセスした場合の動作は <strong>未定義</strong> です。</p>
<p>
<em>当初の LuneScript は、 lua のトランスコンパイラとして開発を始めたため、</em>
<em>lua との互換性を重視し index を 1 からにしましたが、</em>
<em>今となってはこれは失敗だったと思っています。。</em></p>
<p>
リストの長さを取得するのは <code>#</code> です。
例えば <code>#list</code> は、 リスト型の変数 list の長さを取得します。</p>
<p>
値の追加は Lua と同じで <code class="verbatim">insert()</code>, 削除は <code class="verbatim">remove()</code> です。</p>
<p>
型名は、次の通り List&lt;T&gt; です。
ここで T は、リストが保持する要素の型を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val:List&lt;int&gt; = [1,2];</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-67" class="outline-4">
<h4 id="headline-67">
Map   
</h4>
<div id="outline-text-headline-67" class="outline-text-4">
<p>
Map のリテラルは JSON フォーマットを拡張したフォーマットです。</p>
<p>
次のように JSON フォーマットを扱えます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let map = {
   &#34;val1&#34;: 1,
   &#34;val2&#34;: 2,
   &#34;val3&#34;: 3
};
print( map.val1, map.val2, map.val3 ); // 1 2 3</code></pre>
</div>
<p>
次の点で JSON と違います。</p>
<ul>
<li>キーと値に nil 以外の全ての値を使用できる</li>
</ul>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut test:Map&lt;int,int&gt; = {};
let map = {
   1: &#34;val1&#34;,
   2.0: &#34;val2&#34;,
   test: &#34;val3&#34;
};
print( map[ 1 ], map[ 2.0 ], map[ test ] ); // val1 val2 val3</code></pre>
</div>
<p>
また、 null を nil の alias としているため、
JSON そのものを扱うことが出来ます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut map:Map&lt;str,int&gt; = {};
map[ &#34;abc&#34; ] = 1;
map.xyz = 10;</code></pre>
</div>
<p>
Map の要素には [key] でアクセスします。
key の型が str の場合、 .key としてもアクセスできます。</p>
<p>
例えば、次の [ &#34;abc&#34; ] と .abc は同じ要素にアクセスするため、
次の例の print は true を出力します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
print( map[ &#34;abc&#34; ] == map.abc ); // true</code></pre>
</div>
<p>
なお、マップに対して <code>#</code> 演算子は使用できません。</p>
<p>
Map の型名は、次の通り Map&lt;K,V&gt; です。
ここで K はキーの型、V はキーに紐付ける値の型です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val:Map&lt;str,int&gt; = { &#34;abc&#34;:123 };</code></pre>
</div>
<div id="outline-container-headline-68" class="outline-5">
<h5 id="headline-68">
値の削除
</h5>
<div id="outline-text-headline-68" class="outline-text-5">
<p>
前述している通り、 Map は nil の値を持てません。
これを利用し値に nil をセットすることで、 Map から削除できます。</p>
<p>
例えば以下は、 キー &#34;abc&#34; に対して 123 が登録されている val に対し、
abc に nil をセットします。
これによって、 val から abc が削除されます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val:Map&lt;str,int&gt; = { &#34;abc&#34;:123 };
val.abc = nil;
let mut total = 0;
foreach _ in val {
    total = total + 1;
}
print( total ); // 1</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-69" class="outline-5">
<h5 id="headline-69">
nilable のセット
</h5>
<div id="outline-text-headline-69" class="outline-text-5">
<p>
Map への nil 以外の nilable の値の代入は推奨しません。
今後、エラーとする予定です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val:Map&lt;str,int&gt; = { &#34;abc&#34;:123 };
fn func( work:int! ) {
   val.abc = work;  // warrning
}
func( 1 );</code></pre>
</div>
<p>
これは、Map への nilable の設定は、それが値のセットなのか、
削除なのかが不明確になってしまうためです。</p>
<p>
なお、 immediate の nil のセット自体は今後もサポートします。</p>
</div>
</div>
<div id="outline-container-headline-70" class="outline-5">
<h5 id="headline-70">
Map の注意
</h5>
<div id="outline-text-headline-70" class="outline-text-5">
<p>
Map を扱う際、次を注意してください。</p>
<div id="outline-container-headline-71" class="outline-6">
<h6 id="headline-71">
マップのキーは、 int と real を区別することが出来ません。
</h6>
<div id="outline-text-headline-71" class="outline-text-6">
<p>
具体的には、下記の例で <code>map[1]</code> と <code>map[1.0]</code> が、何を返すかは <strong>未定義</strong> です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let map = {
   1: &#34;val1&#34;,
   1.0: &#34;val2&#34;,
};
print( map[ 1 ], map[ 1.0 ] );</code></pre>
</div>
<p>
これは Lua 仕様由来の制限です。</p>
<p>
なお、 go にトランスコンパイルした場合、
int と real は区別されます。</p>
</div>
</div>
<div id="outline-container-headline-72" class="outline-6">
<h6 id="headline-72">
キーに int, real, str 以外を使用した場合の、キーの同値判定
</h6>
<div id="outline-text-headline-72" class="outline-text-6">
<p>
次の例において、 list1, list2 はどちらも int の 1 を要素に持つリストです。
この list1 をキーとして、 &#34;aaa&#34; を map に登録します。</p>
<p>
そして、 list1, list2 をキーとして、 map から値を取得すると、
その結果は aaa と nil となります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut map:Map&lt;&amp;List&lt;int&gt;,str&gt; = {};
let list1 = [ 1 ];
let list2 = [ 1 ];
map[ list1 ] = &#34;aaa&#34;;
print( map[ list1 ], map[ list2 ] );  // aaa nil</code></pre>
</div>
<p>
これは、 list1 と list2 が異なるキーとして判定されるためです。</p>
<p>
int, real, str 以外を map のキーに使用した場合、
そのキーが等しいかどうかは、同じオブジェクトである必要があります。</p>
</div>
</div>
<div id="outline-container-headline-73" class="outline-6">
<h6 id="headline-73">
nilable
</h6>
<div id="outline-text-headline-73" class="outline-text-6">
<p>
前述の通り、Map の要素へのアクセスは次のように行なえます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let map = {
   &#34;val1&#34;: 1,
   &#34;val2&#34;: 2,
   &#34;val3&#34;: 3
};
print( map.val1, map.val2, map.val3 ); // 1 2 3</code></pre>
</div>
<p>
ここで、map.val1 は <strong>nilable</strong> になり、
そのままでは本来のデータである int の 1 としては扱えません。</p>
<p>
つまり、次のように <code class="verbatim">map.val1 + 1</code> を実行することはできません。</p>
<pre class="example">
print( map.val1 +1 )
</pre>
<p>
nilable については、以下を参照してください。</p>
<p>
<a href="#nilable">#nilable</a></p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-74" class="outline-4">
<h4 id="headline-74">
Set
</h4>
<div id="outline-text-headline-74" class="outline-text-4">
<p>
値の集合を扱います。</p>
<p>
詳しくは次の記事を参照してください。</p>
<p>
<a href="#set/">#set/</a></p>
</div>
</div>
<div id="outline-container-headline-75" class="outline-4">
<h4 id="headline-75">
generics
</h4>
<div id="outline-text-headline-75" class="outline-text-4">
<p>
List, Array, Map は generics 対応しています。</p>
<p>
例えば、そえぞれ次のように宣言します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let list:List&lt;int&gt; = [];  // int を要素に持つリスト
let array:Array&lt;real&gt; = [@];  // real を要素に持つ配列
let map:Map&lt;str,int&gt; = {}; // str をキー、int を値に持つマップ</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-76" class="outline-4">
<h4 id="headline-76">
コレクションの型
</h4>
<div id="outline-text-headline-76" class="outline-text-4">
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let list = [ 1, 2, 3 ];
let map = { &#34;A&#34;: 10, &#34;B&#34;: 11, &#34;C&#34;: 12 };</code></pre>
</div>
<p>
リストやマップなどのコレクションは、上記のようにリテラルを宣言できます。
この時生成される リスト、マップの型は、 構成する値によって決まります。</p>
<p>
コレクションのコンストラクタで利用される値が全て同じ型なら、
そのコレクションの型は、その値の型となります。</p>
<p>
例えば上記サンプルの <code>[ 1, 2, 3 ]</code> は <code class="verbatim">List&lt;int&gt;</code> となります。</p>
<p>
コレクションのコンストラクタで利用される値が異なれば、
そのコレクションの型は stem となります。</p>
<p>
具体的には、次のようになります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let list1 = [ 1, 2, 3 ];			// List&lt;int&gt;
let list2 = [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ];			// List&lt;str&gt;
let list3 = [ &#39;a&#39;, 1, &#39;c&#39; ];			// List&lt;stem&gt;
let map1 = { &#34;A&#34;: 10, &#34;B&#34;: 11, &#34;C&#34;: 12 };	// Map&lt;str,int&gt;
let map2 = { &#34;A&#34;: 10, &#34;B&#34;: 11, &#34;C&#34;: 12 };	// Map&lt;str,int&gt;
let map3 = { &#34;a&#34;: &#39;z&#39;, &#34;b&#34;: &#39;y&#39;, &#34;c&#34;: &#39;x&#39; };	// Map&lt;str,str&gt;
let map4 = { &#34;a&#34;: 1, &#34;b&#34;: &#39;Z&#39; };		// Map&lt;str,stem&gt;</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-77" class="outline-4">
<h4 id="headline-77">
継承関係のある複数クラスを混在したコレクションのコンストラクタ
</h4>
<div id="outline-text-headline-77" class="outline-text-4">
<p>
継承関係のある複数クラスを混在したコレクションのコンストラクタは、
型推論が解決できずにエラーすることがあります。</p>
<p>
その場合は、型を明示してください。</p>
<p>
次のサンプルを示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
class Test {
}
class Sub extend Test {
}
{
   let mut val1 = [ [ new Test() ], [ new Sub() ] ]; // error
   let mut val2:List&lt;List&lt;Test&gt;&gt; = [ [ new Test() ], [ new Sub() ] ]; // ok
   let mut val3 = [ [ new Test() ], [ new Test() ] ]; // ok
   let mut val4 = [ [ new Sub() ], [ new Sub() ] ]; // ok
}</code></pre>
</div>
<p>
ここで、型推論を利用している val1 はエラーになります。
一方で、型を明示している val2 は OK です。
val3, val4 は、クラスを混在していないため、型推論できます。</p>
</div>
</div>
<div id="outline-container-headline-78" class="outline-4">
<h4 id="headline-78">
enum
</h4>
<div id="outline-text-headline-78" class="outline-text-4">
<p>
LuneScript は enum に対応しています。</p>
<p>
詳細は次のリンク先の記事を参照してください。</p>
<p>
<a href="#enum/">#enum/</a></p>
</div>
</div>
<div id="outline-container-headline-79" class="outline-4">
<h4 id="headline-79">
Luaval
</h4>
<div id="outline-text-headline-79" class="outline-text-4">
<p>
LuneScript は Lua のコードを実行できます。
Lua コードの実行結果は、
int, real, bool, str に関しては内部的に変換を行ないますが
それ以外の値は変換せずに Lua の値として処理します。</p>
<p>
その Lua の値を保持するのが Luaval です。</p>
<p>
詳細は以下を参照してください。</p>
<p>
<a href="#lua/">#lua/</a></p>
</div>
</div>
<div id="outline-container-headline-80" class="outline-4">
<h4 id="headline-80">
stem
</h4>
<div id="outline-text-headline-80" class="outline-text-4">
<p>
stem は、nil 以外の全ての値を保持できる型です。</p>
<p>
LuneScript は、静的型付け言語であり、
想定する型と異なる値を与えらた場合はコンパイルエラーします。</p>
<p>
対して stem 型は、nil 以外の全ての型を扱える型なので、
nil 以外のどのような値を与えられてもコンパイルエラーしません。</p>
<p>
stem! は nil を含む全ての値を扱える型です。
Lua の変数そのものと考えて問題ありません。</p>
<p>
なお、一旦 stem 型に変換すると元の型に戻すにはキャストが必要です。</p>
<p>
キャストについては、次のリンク先を参照してください。</p>
<p>
<a href="#cast/">#cast/</a></p>
</div>
</div>
<div id="outline-container-headline-81" class="outline-4">
<h4 id="headline-81">
form
</h4>
<div id="outline-text-headline-81" class="outline-text-4">
<p>
form は関数オブジェクトを扱う型です。</p>
<p>
関数については後述します。</p>
<hr>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-set_ja" class="outline-2">
<h2 id="set_ja">
<strong>Set 編</strong>
</h2>
<div id="outline-text-set_ja" class="outline-text-2">
<p>
ここでは LuneScript の値の集合 Set の扱いについて説明します。</p>
<div id="outline-container-headline-83" class="outline-3">
<h3 id="headline-83">
Set と Map の違い
</h3>
<div id="outline-text-headline-83" class="outline-text-3">
<p>
Set は値の集合を管理し、 Map は値と値の紐付けを管理します。</p>
<p>
どちらも Lua に変換した場合、テーブルとして管理するため、
Map よりも Set を使った方が実行速度やメモリ面で優位ということはありません。</p>
<p>
しかし、Map ではなく Set を使うことで、次の効果があります。</p>
<ul>
<li>データの用途が明確になる</li>
<li>無駄に Map の value を扱う必要がない</li>
<li>リテラルな値が書き易い</li>
</ul>
<p>次の点において Set と Map は同じです。  </p>
<ul>
<li>格納する値の順序を保持しません。</li>
<li>nilable は格納できません。  </li>
</ul>
</div>
</div>
<div id="outline-container-headline-84" class="outline-3">
<h3 id="headline-84">
Set のコンストラクタ
</h3>
<div id="outline-text-headline-84" class="outline-text-3">
<p>
Set は次のように書くことでデータを生成します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let obj = (@ 1, 2, 3, 4 ); // 1 2 3 4</code></pre>
</div>
<p>
これは、1,2,3,4 のデータを保持する Set です。</p>
<p>
Set は <code>(@ )</code> で値を括ります。</p>
<p>
なお、上記処理は型推論により型宣言を省略していますが、
省略しない場合は次のように書きます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let obj:Set&lt;int&gt; = (@ 1, 2, 3, 4 ); // 1 2 3 4</code></pre>
</div>
<p>
<code>Set&lt;int&gt;</code> は、要素が int である Set を宣言します。</p>
<p>
空の Set を使用する場合は、型推論できないため型を明示する必要があります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let obj:Set&lt;int&gt; = (@);</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-85" class="outline-3">
<h3 id="headline-85">
Set の操作
</h3>
<div id="outline-text-headline-85" class="outline-text-3">
<p>
次の操作をサポートします。</p>
<ul>
<li>
<p>追加</p>
<ul>
<li><code class="verbatim">add()</code></li>
</ul>
</li>
<li>
<p>削除</p>
<ul>
<li><code class="verbatim">del()</code></li>
</ul>
</li>
<li>
<p>有無確認 </p>
<ul>
<li><code class="verbatim">has()</code></li>
</ul>
</li>
<li>
<p>要素数取得 </p>
<ul>
<li><code class="verbatim">len()</code></li>
</ul>
</li>
<li>
<p>複製 </p>
<ul>
<li><code class="verbatim">clone()</code></li>
</ul>
</li>
</ul>
<p>Set への値の追加、削除は次のように行ないます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut obj = (@ 1, 2, 3, 4 );
obj.add( 0 );  // 0 1 2 3 4
obj.del( 2 );  // 0 1 3 4</code></pre>
</div>
<p>
Set で管理する値の有無確認は、次のように行ないます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let obj = (@ 1, 2, 3, 4 );
print( obj.has( 0 ) );  // false
print( obj.has( 1 ) );  // true</code></pre>
</div>
<p>
<code class="verbatim">Set</code> は、 <code class="verbatim">len()</code> メソッドで要素の数を取得できます。
ただし、 <code class="verbatim">len()</code> メソッドは要素を列挙して数を計算するため、計算量はサイズに比例します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut obj = (@ 1, 2, 3, 4 );
print( obj.len() );</code></pre>
</div>
<p>
同じ Set を生成するには <code class="verbatim">clone()</code> を使用します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let obj = (@ 1, 2, 3, 4 );
let obj2 = obj.clone();</code></pre>
</div>
<p>
clone は、要素を shallow コピーします。</p>
</div>
</div>
<div id="outline-container-headline-86" class="outline-3">
<h3 id="headline-86">
Set 間の操作
</h3>
<div id="outline-text-headline-86" class="outline-text-3">
<p>
次の操作をサポートします。</p>
<ul>
<li>
<p>合成  </p>
<ul>
<li><code class="verbatim">or()</code></li>
<li>二つの集合の和を残す</li>
</ul>
</li>
<li>
<p>共通  </p>
<ul>
<li><code class="verbatim">and()</code></li>
<li>二つの集合の共通部分を残す</li>
</ul>
</li>
<li>
<p>差分 </p>
<ul>
<li><code class="verbatim">sub()</code></li>
<li>現在の集合から引数の集合と共通しない部分を残す</li>
</ul>
</li>
</ul>
<p>なお、この操作は対象の Set の内容を書き変えます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let set1 = (@  1, 2, 3 );
let set2 = (@  2, 3, 4 );
let set3 = set1.clone().or(set2);   // 1 2 3 4
let set4 = set1.clone().and(set2);  // 2 3 
let set5 = set1.clone().sub(set2);  // 1</code></pre>
</div>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-enum_ja" class="outline-2">
<h2 id="enum_ja">
<strong>enum 編</strong>
</h2>
<div id="outline-text-enum_ja" class="outline-text-2">
<p>
今回は、 LuneScript の enum 値について説明します。</p>
<div id="outline-container-headline-88" class="outline-3">
<h3 id="headline-88">
enum
</h3>
<div id="outline-text-headline-88" class="outline-text-3">
<p>
LuneScript の enum は、値の集合に名前を付けて管理することが出来ます。</p>
<p>
enum として扱える値の型は次の通りです。</p>
<ul>
<li>int</li>
<li>real</li>
<li>str  </li>
</ul>
<p>1 つの enum の値域は、複数の値から定義できますが、
値の型は統一する必要があります。</p>
<p>
つまり、 int の値を持つ enum は、 real や str の値は定義できません。</p>
<div id="outline-container-headline-89" class="outline-4">
<h4 id="headline-89">
定義方法
</h4>
<div id="outline-text-headline-89" class="outline-text-4">
<p>
enum は次のように定義します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
enum TestEnum {
  val0,
  val1,
  val2,
}
print( TestEnum.val0, TestEnum.val1, TestEnum.val2 );  // 0, 1, 2</code></pre>
</div>
<p>
この例では、 val0, val1, val2 を定義し、それぞれ 0, 1, 2 となります。</p>
<p>
enum の値を指定する場合は、次のように定義します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
enum TestEnum {
  val0 = 10,
  val1,
  val2 = 20,
}
print( TestEnum.val0, TestEnum.val1, TestEnum.val2 ); // 10, 11, 20</code></pre>
</div>
<p>
enum の値を省略した場合、次に従って値を assign します。</p>
<ul>
<li>直前の enum 値に 1 を加算した値を assign する。</li>
<li>先頭の enum 値は 0 </li>
</ul>
<p>なお、 enum 値に文字列を assign する場合、値を省略することは出来ません。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
enum TestEnum {
  val0 = &#34;abc&#34;,
  val1 = &#34;def&#34;,
  val2 = &#34;ghi&#34;,
}
print( TestEnum.val0, TestEnum.val1, TestEnum.val2 ); // abc def ghi</code></pre>
</div>
<p>
enum 値に設定する値には、式を指定出来ます。
ただし、この式は immediate な値だけを使用している必要があります。</p>
<p>
例えば次のような場合、</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func(): int {
  return 100;
}
enum TestEnum {
  val0,
  val1 = val0 + 10,  // 10
  val2 = func(),     // error
}</code></pre>
</div>
<p>
<code>val = val0 + 10</code> は、 immediate な値を利用しているため指定可能ですが、
<code>val2 = func()</code> は、 immediate な値ではないためエラーとなります。</p>
</div>
</div>
<div id="outline-container-headline-90" class="outline-4">
<h4 id="headline-90">
使用方法
</h4>
<div id="outline-text-headline-90" class="outline-text-4">
<p>
定義した enum は、次のように型として利用できます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
enum TestEnum {
  val0,
  val1,
  val2,
}
fn func( val:TestEnum ): int {
   return val + 100;
}
print( func( TestEnum.val1 ) ); // 101</code></pre>
</div>
<p>
ここで <code class="verbatim">func()</code> の引数 val は TestEnum 型です。
これにより、 <code class="verbatim">func()</code> の引数 val は単なる int ではなく、
値域が制限された int とすることが出来ます。</p>
<p>
enum 値を指定する場合は、
<code>TestEnum.val</code> のように <code>enum 型シンボル.enum 値シンボル</code> となります。</p>
</div>
</div>
<div id="outline-container-headline-91" class="outline-4">
<h4 id="headline-91">
省略指定
</h4>
<div id="outline-text-headline-91" class="outline-text-4">
<p>
基本的に enum 値を指定するには、
<code>enum 型シンボル.enum 値シンボル</code> となりますが、
代入先の型が enum 型であることが分っている場合、
<code>enum 型シンボル</code> を省略することが出来ます。</p>
<p>
例えば次の場合、 <code class="verbatim">func()</code> の引数は TestEnum 型であることが分っているので、
TestEnum.val1 ではなく、 .val1 として指定できます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
enum TestEnum {
  val0,
  val1,
  val2,
}
fn func( val:TestEnum ): int {
   return val + 100;
}
print( func( .val1 ) ); // 101</code></pre>
</div>
<p>
なお、 外部モジュールで定義されている enum 型を省略指定する場合、
その外部モジュールを import している必要があります。</p>
<p>
import については後日説明します。</p>
</div>
</div>
<div id="outline-container-headline-92" class="outline-4">
<h4 id="headline-92">
enum 値の変換
</h4>
<div id="outline-text-headline-92" class="outline-text-4">
<p>
enum 値は、enum 値として以外に、定義した値としても利用できます。</p>
<p>
これは上の例の val + 100 を見ると分かると思いますが、
val は TestEnum で定義した enum 値ですが、それは 0, 1, 2 のいずれかでもあります。
(上の例では val1 を渡しているので 1 になる)。
よって <code>val + 100</code> は、 1 + 100 となり結果的に 101 となります。</p>
<p>
一方で次の例を見てください。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
enum TestEnum {
  val0,
  val1,
  val2,
}
fn func( val:TestEnum ): int {
   return val + 100;
}
let val = 1;
func( val ); // error</code></pre>
</div>
<p>
この例の <code>func( val )</code> はエラーとなります。</p>
<p>
この場合 val は 1 で、 TestEnum において val1 が 1 となりますが、
val の型が int であり、 TestEnum とは型が異なるためエラーとなります。</p>
<p>
enum 値に assign している型の値から、
対応する enum 値に変換するには、次のように <code class="verbatim">_from()</code> 関数を利用します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
enum TestEnum {
  val0,
  val1,
  val2,
}
fn func( val:TestEnum ): int {
   return val + 100;
}
let val = 1;
func( unwrap TestEnum._from( val ) );</code></pre>
</div>
<p>
ここで <code>func( unwrap TestEnum._from( val ) )</code> は、
<code class="verbatim">TestEnum._from()</code> によって val に対応する TestEnum の enum 値 TestEnum.val1 を取得し、
それを <code class="verbatim">func()</code> に渡しています。</p>
<p>
unwrap については後日説明します。</p>
</div>
</div>
<div id="outline-container-headline-93" class="outline-4">
<h4 id="headline-93">
enum 値名
</h4>
<div id="outline-text-headline-93" class="outline-text-4">
<p>
enum 値はシンボルに値を assign します。</p>
<p>
enum 値は $_txt によって、このシンボル名を動的に取得できます。</p>
<p>
例えば次の場合、TestEnum.val1 が出力されます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
enum TestEnum {
  val0,
  val1,
  val2,
}
fn func( val:TestEnum ) {
   print( val.$_txt ); 
}
func( .val1 ); // TestEnum.val1</code></pre>
</div>
<p>
<code class="verbatim">$_txt</code> によって、 enum 値のシンボル名を取得しています。</p>
<p>
$ については後述しますが、関数呼び出しのシンタックスシュガーです。</p>
<div id="outline-container-headline-94" class="outline-5">
<h5 id="headline-94">
$_txt の注意点
</h5>
<div id="outline-text-headline-94" class="outline-text-5">
<p>
<code class="verbatim">$_txt</code> には次の注意点があります。</p>
<p>
<strong>「同値の enum 値が複数存在する場合、 $_txt がどの enum 値のシンボル名を返すか未定義」</strong></p>
<p>
例えば次の場合、 <code class="verbatim">print()</code> が <code class="verbatim">TestEnum.val1</code>, <code class="verbatim">TestEnum.val2</code> のどれを出力するかは未定義です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
enum TestEnum {
  val0,
  val1 = 10,
  val2 = 10,
}
fn func( val:TestEnum ) {
   print( val.$_txt ); 
}
func( .val1 ); // TestEnum.???</code></pre>
</div>
<p>
また、 <strong>$_txt によって得られる文字列フォーマットは将来変更する可能性があります。</strong>
<code class="verbatim">$_txt</code> は、ログ出力目的の使用に制限し、
<code class="verbatim">$_txt</code> の結果によって処理を切り替えるようなコードを書かないでください。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-95" class="outline-4">
<h4 id="headline-95">
全 enum 値リスト
</h4>
<div id="outline-text-headline-95" class="outline-text-4">
<p>
$_allList で、enum が定義している全 enum のリストを取得できます。</p>
<p>
例えば次のコードの場合、 </p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
enum TestEnum {
  val0,
  val1,
  val2,
}
foreach val in TestEnum.$_allList {
   print( val.$_txt );
}</code></pre>
</div>
<p>
次を出力します。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">TestEnum.val0
</span></span><span class="line"><span class="cl">TestEnum.val1
</span></span><span class="line"><span class="cl">TestEnum.val2</span></span></code></pre></div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-96" class="outline-3">
<h3 id="headline-96">
代数的データ型
</h3>
<div id="outline-text-headline-96" class="outline-text-3">
<p>
enum 型は、 int, real, str のいずれか一種類の型をグルーピングして、
値域を制限できますが、複数の型をグルーピングすることは出来ません。
代数的データ型は enum 型をより一般的にしたもので、
int, real, str に限らず全ての型をグルーピングすることが出来ます。</p>
<p>
詳しくは次の記事で説明しています。</p>
<p>
<a href="#match">#match</a></p>
</div>
</div>
<div id="outline-container-headline-97" class="outline-3">
<h3 id="headline-97">
まとめ
</h3>
<div id="outline-text-headline-97" class="outline-text-3">
<p>
enum を利用することで、値域を簡単に定義することが出来、
enum を楽に扱うイマドキな手段を提供しています。</p>
<p>
次回は、変数について説明します。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-match_ja" class="outline-2">
<h2 id="match_ja">
<strong>match 編</strong>
</h2>
<div id="outline-text-match_ja" class="outline-text-2">
<p>
LuneScript は、代数的データ型とパターンマッチをサポートします。</p>
<div id="outline-container-headline-99" class="outline-3">
<h3 id="headline-99">
代数的データ型 (alge型)
</h3>
<div id="outline-text-headline-99" class="outline-text-3">
<p>
enum 型は、 int, real, str のいずれかの値をグルーピングして、値域を制限できます。</p>
<p>
一方、代数的データ型は enum 型をより一般的にしたもので、
int, real, str に限らず全ての型をグルーピングすることが出来ます。</p>
<p>
代数的データ型は alge キーワードで宣言します。</p>
<p>
次に例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Hoge {
   pri let val:int {pub};
}
alge Test {
   Val1,
   Val2( int ),
   Val3( str ),
   Val4( Hoge ),
   Val5( num:int, txt:str ),
}</code></pre>
</div>
<p>
この例では、 alge 型 Test を宣言しています。</p>
<p>
Test は、 Val1 〜 Val5 までの値域を持ちます。
また、 Val1 〜 Val5 はそれぞれ次のパラメータを持ちます。</p>
<table>
<thead>
<tr>
<th>値</th>
<th>パラメータ</th>
</tr>
</thead>
<tbody>
<tr>
<td>Val1</td>
<td>なし</td>
</tr>
<tr>
<td>Val2</td>
<td>int</td>
</tr>
<tr>
<td>Val3</td>
<td>str</td>
</tr>
<tr>
<td>Val4</td>
<td>Hoge</td>
</tr>
<tr>
<td>Val5</td>
<td>int, str</td>
</tr>
</tbody>
</table>
<p>
パラメータの型に制限はありません。
この例の場合、 Val4 は Hoge クラス型をパラメータに持ちます。</p>
<p>
パラメータの個数も制限はありません。
この例の場合、 Val5 は int と str をパラメータに持ちます。</p>
<p>
パラメータには、型だけ指定する方法と、名前と型を指定する方法があります。
この例の場合、 Val2 から Val4 は型だけ指定し、 Val5 はパラメータ名と型を指定しています。
パラメータ名は、そのパラメータの意味を明瞭にする効果があるだけです。</p>
<p>
この alge 型の値を使用する場合、次のように書きます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
let val1 = Test.Val1;
let val2 = Test.Val2( 1 );
let val3 = Test.Val3( &#34;abc&#34; );
let val4 = Test.Val4( new Hoge( 100 ) );
let val5 = Test.Val5( 10, &#34;xyz&#34; );</code></pre>
</div>
<p>
それぞれの意味は次になります。</p>
<ul>
<li>val1 は Test.Val1</li>
<li>val2 は 1 をパラメータに持つ Test.Val2</li>
<li>val3 は &#34;abc&#34; をパラメータに持つ Test.Val3 </li>
<li>val4 は new Hoge( 100 ) をパラメータに持つ Test.Val4</li>
<li>val5 は 10, &#34;xyz&#34; をパラメータに持つ Test.Val5</li>
</ul>
</div>
</div>
<div id="outline-container-headline-100" class="outline-3">
<h3 id="headline-100">
match
</h3>
<div id="outline-text-headline-100" class="outline-text-3">
<p>
enum 型は、次のように元の値と同じように使用できます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
enum TestEnum {
  val0,
  val1,
  val2,
}
fn func( val:TestEnum ): int {
   return val + 100;
}
let val = 1;
func( unwrap TestEnum._from( val ) );</code></pre>
</div>
<p>
この例では、 関数 <code class="verbatim">func()</code> 内で TestEnum 型の値 + 100 をしていますが、
これは TestEnum 型が int の数値としても利用できることを示しています。</p>
<p>
一方で alge 型の値は、特別な処理が必要です。
その処理が match です。</p>
<p>
次に match の例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Hoge {
   pri let val:int {pub};
}

alge Test {
   Val1,
   Val2( int ),
   Val3( str ),
   Val4( Hoge ),
   Val5( int, str ),
}

fn func( test:Test ) {
   match test {
      case .Val1 {
         print( test.$_txt );
      }
      case .Val2( x ) {
         print( test.$_txt, x );
      }
      case .Val3( x ) {
         print( test.$_txt, x );
      }
      case .Val4( x ) {
         print( test.$_txt, x.$val );
      }
      case .Val5( x, y ) {
         print( test.$_txt, x, y );
      }
   }
}

func( Test.Val1 ); // Test.Val1
func( Test.Val2( 1 ) ); // Test.Val2 1
func( Test.Val3( &#34;abc&#34; ) ); // Test.Val3 abc
func( Test.Val4( new Hoge( 100 ) ) ); // Test.Val4  100
func( Test.Val5( 10, &#34;xyz&#34; ) ); // Test.Val5 10 xyz</code></pre>
</div>
<p>
この例では、 <code class="verbatim">func()</code> 関数内で match を実行しています。</p>
<p>
case によって Val1 〜 Val5 を分岐しています。
また Val2 〜 Val5 は、それぞれパラメータを受け取る変数を宣言しています。</p>
<p>
例えば <code class="verbatim">func( Test.Val2( 1 ) )</code> は、 <code>Test.Val2( 1 )</code> を <code class="verbatim">func()</code> に渡しています。
ここで <code class="verbatim">func()</code> 内の match の <code>case .Val2( x )</code> にマッチします。
そして、 x には 1 がセットされ、 <code>print( test.$_txt, x )</code> が実行されます。</p>
<p>
ここで <code>test.$_txt</code> は、 値域の Val2 を示す &#34;Test.Val2&#34; の文字列が展開されます。</p>
<p>
match は、 switch と同様に default と _default、そして _match を利用できます。</p>
</div>
</div>
<div id="outline-container-headline-101" class="outline-3">
<h3 id="headline-101">
alge 型の省略表記
</h3>
<div id="outline-text-headline-101" class="outline-text-3">
<p>
alge 型も enum 型と同じように省略表記を利用できます。</p>
<p>
次のような alge 型の Test と、その Test を引数に持つ関数があった場合、</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
alge Test {
   Val1,
   Val2,
   Val3( int ),
}
fn func( test:Test ) {
   print( test );
}</code></pre>
</div>
<p>
<code class="verbatim">func()</code> をコールする際、次のように Test を省略可能です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
func( .Val1 );
func( .Val2 );
func( .Val3( 10 ) );</code></pre>
</div>
<p>
なお、 外部モジュールで定義されている alge 型を省略指定する場合、
その外部モジュールを import している必要があります。</p>
</div>
</div>
<div id="outline-container-headline-102" class="outline-3">
<h3 id="headline-102">
alge型 の比較
</h3>
<div id="outline-text-headline-102" class="outline-text-3">
<p>
パラメータを持たない単純な alge 型の値は、次のように比較することが出来ます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
alge Test {
   Val1,
   Val2,
   Val3( int ),
}
fn func( test:Test ) {
   if test == .Val1 {
      print( &#34;Val1&#34; );
   }
   elseif test == .Val2 {
      print( &#34;Val2&#34; );
   }
   elseif test == .Val3(1) {  // error
      print( &#34;Val3&#34; );
   }
   else {
      print( &#34;no&#34; );
   }
}
func( .Val1 ); // Val1
func( .Val2 ); // Val2</code></pre>
</div>
<p>
なお、パラメータを持つ値 (上記の場合 Val3) は、
同じパラメータを与えても異なる値になるため注意が必要です。
ちなみに、上記の <code>test == .Val3(1)</code> はエラーとなります。
なぜならば、この式の結果は必ず「false」となるため、
コンパイルエラーとすることで、実行時に意図しない結果になることを防ぎます。</p>
</div>
</div>
<div id="outline-container-headline-103" class="outline-3">
<h3 id="headline-103">
alge の使用例
</h3>
<div id="outline-text-headline-103" class="outline-text-3">
<p>
alge を使うと JSON 構造を次のように書くことが出来ます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
alge JsonVal {
   JNull,
   JBool(bool),
   JInt(int),
   JReal(real),
   JStr(str),
   JArray(List&lt;JsonVal&gt;),
   JObj(Map&lt;str,JsonVal&gt;),
}
fn dumpJson( stream:oStream, jval:JsonVal ) {
   match jval {
      case .JNull {
         stream.write( &#34;null&#34; );
      }
      case .JBool( val ) {
         stream.write( &#34;%s&#34; (val) );
      }     
      case .JInt( val ) {
         stream.write( &#34;%d&#34; (val ) );
      }        
      case .JReal( val ) {
         stream.write( &#34;%g&#34; (val ) );
      }        
      case .JStr( val ) {
         stream.write( &#39;&#34;%s&#34;&#39; (val ) );
      }        
      case .JArray( list ) {
         stream.write( &#34;[&#34; );
         foreach val, index in list {
            if index &gt; 1 {
               stream.write( &#34;,&#34; );
            }
            dumpJson( stream, val );
         }
         stream.write( &#34;]&#34; );
      }        
      case .JObj( map ) {
         stream.write( &#34;{&#34; );
         let mut cont = false;
         foreach val, key in map {
            if cont {
               stream.write( &#39;,&#39; );
            }
            else {
               cont = true;
            }
            stream.write( &#39;&#34;%s&#34;:&#39; (key) );
            dumpJson( stream, val );
         }
         stream.write( &#34;}&#34; );
      }
   }
}
dumpJson( io.stdout,
          JsonVal.JObj( { &#34;foo&#34;: JsonVal.JInt( 1 ),
                          &#34;bar&#34;: JsonVal.JStr( &#34;abc&#34; ) } ) );</code></pre>
</div>
<p>
alge を使用せずにキャストや継承などを利用すれば同じことは出来ます。
しかし、キャストはもちろん、継承にも欠点があります。</p>
<p>
alge も万能ではありませんが、
幾つかの場面ではキャストや継承を使用するよりも、
より良い選択肢になると思います。</p>
<p>
次回はインタフェースを説明します。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-variable_ja" class="outline-2">
<h2 id="variable_ja">
<strong>変数 編</strong>
</h2>
<div id="outline-text-variable_ja" class="outline-text-2">
<p>
今回は LuneScript の変数について説明します。</p>
<div id="outline-container-headline-105" class="outline-3">
<h3 id="headline-105">
変数
</h3>
<div id="outline-text-headline-105" class="outline-text-3">
<p>
LuneScript は静的型付け言語であり、変数は型を持ちます。</p>
<p>
変数は、次のように let で宣言します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val:int = 1;</code></pre>
</div>
<p>
上記の例は、初期値として int の 1 を持つ変数 val を宣言しています。</p>
<p>
変数名の後には、型を指定します。</p>
<p>
なお、初期値が int の 1 ではなく、
real の 1.0 をセットすると、型が違うためコンパイルエラーになります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let val:int = 1.0;  // error</code></pre>
</div>
<p>
<del>また、現在は変数宣言には初期値が必須です。</del></p>
<p>
<del>これは、未初期化変数へのアクセスを防ぐためです。</del>
<del>将来的には、変数が値を保持しているかどうかをフロー解析で判断できるようにして、
初期値不要にすることを考えています。</del></p>
<p>
変数宣言時の初期化は必須ではありません。
なお、初期化していない変数を参照した場合、コンパイルエラーになります。
詳しくは後述します。</p>
<p>
また、変数宣言時に初期化しない場合でも、型推論は可能です。</p>
<div id="outline-container-headline-106" class="outline-4">
<h4 id="headline-106">
型推論
</h4>
<div id="outline-text-headline-106" class="outline-text-4">
<p>
LuneScript は型推論をサポートしています。</p>
<p>
変数にセットする初期値から、その変数の型を決定できます。
これによって、次のように型を指定せずに変数を宣言できます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val1 = 1; // int 
let val2 = 1.0; // real
let val3 = &#34;abc&#34;; // str</code></pre>
</div>
<p>
この場合、 val1 は int, val2 は real, val3 は str であるとして処理します。</p>
<p>
型を明示する必要があるのは、次の場合などです。</p>
<ul>
<li>
<p>nilable 型の変数の初期値に nil を設定する</p>
<pre class="example">
let mut val:int! = nil;
</pre>
</li>
<li>
<p>リスト型や、マップ型の変数の初期値に、 immediate な空の値 (<code class="verbatim">[]</code>, <code class="verbatim">{}</code> など)を設定する</p>
<pre class="example">
let mut val:List&lt;int&gt; = [];
</pre>
</li>
<li>
<p>次のようなクラス型の変数にサブクラスのインスタンスを設定する際、変数の型をスーパークラスの型としたい場合</p>
<pre class="example">
let val:Super = new Sub();
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-107" class="outline-4">
<h4 id="headline-107">
変数の初期化
</h4>
<div id="outline-text-headline-107" class="outline-text-4">
<p>
初期化していない変数を参照すると、コンパイルエラーになります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
{
   let val;
   print( &#34;%s&#34; ( val ) ); // error
}</code></pre>
</div>
<p>
上記の <code class="verbatim">print()</code> では、未初期化の val にアクセスしていますが、
ここでコンパイルエラーになります。</p>
<div id="outline-container-headline-108" class="outline-5">
<h5 id="headline-108">
フロー解析
</h5>
<div id="outline-text-headline-108" class="outline-text-5">
<p>
変数初期化は、フローを解析して変数未初期化のパスがないかチェックします。</p>
<p>
例えば次の場合、エラーになります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func( flag:bool )
{
   let val;
   if flag {
     val = 1;
   }
   print( val ); // error
}</code></pre>
</div>
<p>
上記エラーの原因は、 flag が true の場合は val が初期化されますが、
false の場合は val が初期化されないためです。</p>
<p>
次のように、アクセスする前に全てのパスで初期化をする必要があります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( flag:bool )
{
   let val;
   if flag {
     val = 1;
   }
   else {
     val = 2;
   }
   print( val ); // ok
}</code></pre>
</div>
<p>
なおこの処理は、 変数 val に対する初期化であり、
val に対する書き換えではないため、
後述する mut 宣言の必要はありません。</p>
<p>
ちなみに次のような少し複雑な場合も、フローを解析します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func( kind:int )
{
   let val;
   if kind &lt; 10 {
      if kind &gt; 0 {
         val = 1;
      }
      else {
         if kind == 0 {
            val = 2;
         }
         elseif kind == 1 {
            val = 3;
         }
         // ※ 
      }
   }
   else {
      val = 4;
   }
   print( val ); // error
}</code></pre>
</div>
<p>
少し分かり難いと思いますが、
上記 ※ の位置で else の時に val の初期化が抜けているため、print の val 参照がエラーとなります。</p>
<p>
なお、次の場合も print( val ) の箇所でエラーになります。 </p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func( flag:bool )
{
   let val;
   fn sub() {
      print( val ); // error
   }
   val = 1;
   sub();
}</code></pre>
</div>
<p>
本来は <code class="verbatim">sub()</code> を実行する時には val が初期化されるので、
エラーになるべきではないですが、これは現在の仕様です。</p>
</div>
</div>
<div id="outline-container-headline-109" class="outline-5">
<h5 id="headline-109">
型推論
</h5>
<div id="outline-text-headline-109" class="outline-text-5">
<p>
変数宣言時に初期化しない場合も、型推論は可能です。</p>
<p>
ただし、型推論はフロー解析で最初に代入された型が使用されます。</p>
<p>
例えば次の場合は、</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func( flag:bool )
{
   let val;
   if flag {
      val = 1;
   }
   else {
      val = 1.0; // error
   }
}</code></pre>
</div>
<p>
最初の <code>val = 1</code> で val は int 型になります。
そして、次の <code>val = 1.0</code> の時には、
int 型の val に real の 1.0 を代入しようとしているため、
エラーとなります。</p>
<p>
上記のような場合は、次のように変数宣言時に型を宣言することで、
エラーを回避できます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( flag:bool )
{
   let val:stem; // stem 型を宣言
   if flag {
      val = 1;
   }
   else {
      val = &#34;a&#34;;
   }
   print( val );
}</code></pre>
</div>
<p>
stem 以外にも、型を宣言しなければならないケースはあります。
例えばスーパークラスの型の変数を利用したい場合や、
nilable 型の変数を利用したい場合などがあります。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-110" class="outline-4">
<h4 id="headline-110">
shadowing
</h4>
<div id="outline-text-headline-110" class="outline-text-4">
<p>
LuneScript では、 同名の変数宣言を禁止しています。</p>
<p>
ここで同名とは、同一スコープ内での同名に限らず、
アクセス可能なスコープ内での同名を指します。</p>
<p>
具体的には、次の変数宣言はエラーとなります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
{
   let val = 1;
   {
      let val = 1;  // error
   }
}</code></pre>
</div>
<p>
この仕様は賛否別れると思いますが、安全側に振ってこの仕様にしています。</p>
</div>
</div>
<div id="outline-container-headline-111" class="outline-4">
<h4 id="headline-111">
アクセス制御
</h4>
<div id="outline-text-headline-111" class="outline-text-4">
<p>
宣言した変数は、ローカル変数として処理されます。</p>
<p>
外部のモジュールに公開したい場合は、次のように pub を付加して宣言します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
pub let val = 1;</code></pre>
</div>
<p>
外部公開されている変数にアクセスする場合、次のように import を使用します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
import SubModule;
print( SubModule.val );</code></pre>
</div>
<p>
ここで、
SubModule は <code>pub let val = 1;</code> を宣言している LuneScript のモジュール(SubModule.lns)です。</p>
<p>
この val にアクセスする場合、SubModule.val とすることでアクセスできます。</p>
<p>
変数を外部モジュールに公開する方法としては pub が基本ですが、
もう一つ global を使うことも出来ます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
pub let val1 = 1;
global let val2 = 2;</code></pre>
</div>
<p>
pub と global の違いは、 名前空間の違いです。</p>
<p>
次の例を見ると分かり易いと思いますが、
これは上記 val1, val2 を外部からアクセスしているサンプルです。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
import SubModule;
print( SubModule.val1 );
print( val2 );</code></pre>
</div>
<p>
val1 は、 SubModule.val1 として SubModule の名前空間内の変数としてアクセスしますが、
val2 は、最上位の名前空間の変数としてアクセスします。</p>
<p>
LuneScript だけでシステムを開発する際は、 
global を利用することはまず無いと思います(というか global の使用を避けるべきです)が、
他の Lua モジュールと連携して処理する際は、
global を使用せざるを得ないこともあると思います。</p>
<p>
そのような互換性を保つことを目的として、 global をサポートしています。</p>
<p>
なお global の制約として、次があります。</p>
<p>
 <strong>「global 宣言した変数は、 その変数を宣言したモジュールを import した時に有効になる。」</strong></p>
<p>
例えば次の例では val2 は、 SubModule になんの関係もなく存在しているように見えますが、</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
import SubModule;
print( SubModule.val1 );
print( val2 );</code></pre>
</div>
<p>
次の場合 SubModule を import していないため、val2 は存在しないのでエラーとなります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
print( val2 );</code></pre>
</div>
<p>
また外部公開する変数には、次の制約があります。</p>
<p>
 <strong>「外部公開する変数は、スクリプトの最上位のスコープに宣言しなければならない」</strong></p>
<p>
例えば、次の val2 は最上位のスコープではないためエラーとなります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
pub let val = 1;
{
   pub let val2 = 1; // error
}</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-112" class="outline-4">
<h4 id="headline-112">
mutable
</h4>
<div id="outline-text-headline-112" class="outline-text-4">
<p>
単に宣言した変数は、変更禁止の変数として扱います。</p>
<p>
例えば、次の <code>val = 2</code> はエラーとなります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let val = 1;
val = 2; // error</code></pre>
</div>
<p>
可変な変数(mutable)とする場合、次のように mut で宣言します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut val = 1;
val = 2;</code></pre>
</div>
<p>
なお、次のように immutable の変数を宣言した後に初期値を代入することもできます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val;
val = 1;</code></pre>
</div>
<p>
ただし、次のように初期値を代入した後にさらに値をセットするとエラーになります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let val;
val = 1;
val = 2; // error</code></pre>
</div>
<div id="outline-container-headline-113" class="outline-5">
<h5 id="headline-113">
immutable な型
</h5>
<div id="outline-text-headline-113" class="outline-text-5">
<p>
上記の通り、mut 宣言しない変数は immutable になります。
さらに mut 宣言せずに <strong>型推論された型</strong> も immutable になります。
例えば次の場合、
list1 は mut 宣言しているため List の変更操作(insert)が可能ですが、
list2 は mut 宣言せずに immutable であるため List の変更操作はエラーになります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let mut list1 = [1];
list1.insert( 2 ); // ok
let list2 = [1];
list2.insert( 2 ); // error</code></pre>
</div>
<p>
immutable な型は、元の型 T に &amp; を付けて &amp;T として表記します。
例えば <code class="verbatim">&amp;List&lt;int&gt;</code> は、 変更操作できないリスト List&lt;int&gt; を表します。
なお、変更操作は出来ませんが、 foreach などの参照操作は出来ます。</p>
<p>
<code class="verbatim">&amp;List&lt;List&lt;int&gt;&gt;</code> は、 <code class="verbatim">List&lt;int&gt;</code> を要素に持つ immutable なリストです。
ここで <code class="verbatim">List&lt;int&gt;</code> は &amp; が付いていないため mutable です。
つまり、次のようになります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let list:&amp;List&lt;List&lt;int&gt;&gt; = [[100],[]];
list[1].insert( 1 ); // ok
list.insert( [10] ); // error</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-114" class="outline-5">
<h5 id="headline-114">
型推論と mutable
</h5>
<div id="outline-text-headline-114" class="outline-text-5">
<p>
前述の通り、 mut 宣言していない変数の型は immutable になります。</p>
<p>
ただし、これは型推論を利用した場合です。</p>
<p>
mut 宣言していない変数でも、型を明示している場合は、
その型の mutable 宣言に依存します。</p>
<p>
例えば以下の場合、</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let list1:List&lt;int&gt; = [1,2];
let list2:&amp;List&lt;int&gt; = [1,2];
let mut list3 = [1,2];
let list4 = [1,2];
list1.insert( 3 );
list2.insert( 3 ); // error
list3.insert( 3 );
list4.insert( 3 ); // error</code></pre>
</div>
<p>
list2 と list4 が immutable な &amp;List&lt;int&gt; になるため、
<code class="verbatim">list2.insert( 3 );</code> と <code class="verbatim">list4.insert( 3 );</code> がエラーになります。</p>
<p>
なお、以前この仕様は不具合があり、ver 1.2.0 で修正しています。
以前は、型を明示した場合も mut 宣言しない場合は immutable な型になっていましたが、
その挙動が変数、メンバ、引数で劣なっていたため、
現状の仕様に修正しています。</p>
<p>
もしも ver 1.2.0 以前の仕様に戻したい場合、
オプション –legacy-mutable-control を指定してください。</p>
<p>
ただし、このオプションは将来廃止する可能性があります。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-115" class="outline-4">
<h4 id="headline-115">
複数宣言
</h4>
<div id="outline-text-headline-115" class="outline-text-4">
<p>
LuneScript は、 Lua と同じで関数の戻り値に複数の値を返せます。</p>
<p>
この戻り値を変数宣言の初期値とするには、次のように宣言します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
let val1, val2 = func();
let mut val3, mut val4 = func();</code></pre>
</div>
<p>
mut は各変数名の前に宣言します。</p>
</div>
</div>
<div id="outline-container-access_check" class="outline-4">
<h4 id="access_check">
アクセスチェック
</h4>
<div id="outline-text-access_check" class="outline-text-4">
<p>
宣言したローカル変数に対し、
値を設定した後にその変数を参照しないと、警告を出力します。
一方で、クラスのメンバや、関数の引数などはアクセスチェックの対象になりません。</p>
<p>
次のサンプルは、
多値返却の 1 番目の値を使用せずに 2 番目の値だけを使用する場合の例です。
この場合、1 番目の値を格納している val1 が使用されていないことを警告します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn sub(): int, int {
   return 1, 2;
}
fn func() {
   let val1, val2 = sub(); // warning val1
   print( val2 );
}</code></pre>
</div>
<p>
このような多値返却の 2 番目以降の値にアクセスするためだけに宣言した変数に対して、
警告を出さないようにするには、次のように &#39;_&#39; シンボルを使用します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn sub(): int, int {
   return 1, 2;
}
fn func() {
   let _, val2 = sub(); // ok
   print( val2 );
}</code></pre>
</div>
<p>
なお、 &#39;_&#39; シンボルで宣言した変数にはアクセスできません。
アクセスするとエラーになります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn sub(): int, int {
   return 1, 2;
}
fn func() {
   let _, val2 = sub();
   print( _ ); // error
   print( val2 );
}</code></pre>
</div>
<p>
アクセスチェックは、変数の値を更新した後にも行なう。</p>
<p>
例えば次の場合、 val1 は警告される。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func() {
   let mut val1 = 1;
   print( val1 );
   val1 = 2; // warning
}</code></pre>
</div>
<p>
これは、 val1 に 1 をセット後に print( val1 ) で val1 を参照しているが、
次に <code class="verbatim">val1 = 2</code> で val1 を更新後に val1 を参照していないためである。</p>
<div id="outline-container-headline-117" class="outline-5">
<h5 id="headline-117">
クロージャのアクセスチェック
</h5>
<div id="outline-text-headline-117" class="outline-text-5">
<p>
このアクセスチェックはクロージャでも動作する。</p>
<p>
次のサンプルは  <code class="verbatim">val1 = 2</code> 後、
<code class="verbatim">sub()</code> のコールがあることで val1 を参照していると判断して警告しない。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func() {
   let mut val1 = 1;
   fn sub() {
      print( val1 );
   }
   val1 = 2;
   sub();
}</code></pre>
</div>
<p>
ただし、次の制限がある。</p>
<ul>
<li>
<p><strong>クロージャの関数コールではなく、参照した時点で、値の参照があったものとして処理する</strong></p>
<ul>
<li>例えば、クロージャ関数を変数に代入したり、別の関数の引数に渡した時点で処理する。</li>
</ul>
</li>
<li>
<p><strong>クロージャによるアクセスは参照、設定を区別しない</strong></p>
<ul>
<li>クロージャ関数内で設定しかしていない場合も参照として扱う。</li>
</ul>
</li>
</ul>
<p>クロージャのアクセスチェックについては実験的な機能である。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-118" class="outline-4">
<h4 id="headline-118">
特殊シンボル
</h4>
<div id="outline-text-headline-118" class="outline-text-4">
<p>
次のシンボルは、特殊な値を指します。</p>
<table>
<thead>
<tr>
<th>シンボル</th>
<th>値</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__mod__</code></td>
<td>モジュール名</td>
</tr>
<tr>
<td><code>__func__</code></td>
<td>現在の関数名</td>
</tr>
<tr>
<td><code>__line__</code></td>
<td>現在の行番号</td>
</tr>
</tbody>
</table>
<p>
なお、 <code>__mod__</code>, <code>__func__</code> が展開する名前の書式は、
<strong>将来変更する可能性</strong> があります。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-119" class="outline-3">
<h3 id="headline-119">
型変換(キャスト)
</h3>
<div id="outline-text-headline-119" class="outline-text-3">
<p>
nil 以外の全ての値は、 stem 型の変数に代入できます。</p>
<p>
これには、暗黙的な型変換が行なわれています。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut val:stem = 1;
val = 1.0;
val = &#34;abc&#34;;
val = {};
val = [];
val = [@];</code></pre>
</div>
<p>
一方、 stem 型の値から異なる型への代入はエラーします。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let val1:stem = 1;
let val2:int = val1; // error</code></pre>
</div>
<p>
明示的な型変換が必要な場合は、次の記事を参照してください。</p>
<p>
<a href="#cast">#cast</a></p>
</div>
</div>
<div id="outline-container-headline-120" class="outline-3">
<h3 id="headline-120">
参照
</h3>
<div id="outline-text-headline-120" class="outline-text-3">
<p>
変数は、 一部(int,real,nil)を除いてオブジェクトの参照を保持します。</p>
<p>
例えば次の場合、 </p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut list1 = [ 10 ];
let list2 = list1;
list1.insert( 20 );
list1.insert( 30 );
foreach val in list2 {
   print( val ); // 10 20 30
}</code></pre>
</div>
<ul>
<li><strong>list1</strong> に List&lt;int&gt;  型のリスト (<code class="verbatim">[ 10 ]</code>)オブジェクトの参照をセット</li>
<li><strong>list2</strong> に <strong>list1</strong> が保持する参照をセット</li>
<li><strong>list1</strong> が参照するリストオブジェクトに 20, 30 を insert</li>
<li><strong>list2</strong> が参照するリストオブジェクトの各値を <code class="verbatim">print()</code></li>
</ul>
<p>ここで、 list1 と list2 は <strong>同じリストオブジェクト</strong> を参照しているため、
list1 に 20, 30 を insert すると、
list2 を foreach した print( val ) は 10 20 30 を出力します。</p>
<p>
また、次のように list2 に 40 を insert した場合、
<strong>同じリストオブジェクト</strong> に 40 を挿入するため、
print( val ) は 10 20 30 40 を出力します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut list1 = [ 10 ];
let mut list2 = list1;
list1.insert( 20 );
list1.insert( 30 );
list2.insert( 40 );
foreach val in list2 {
   print( val ); // 10 20 30 40
}</code></pre>
</div>
<p>
list1 に新しいリストオブジェクト (<code class="verbatim">[ 100]</code>) をセットした場合、
list1 が参照するリストオブジェクトと、
list2 が参照するリストオブジェクトは異なるため、
print( val ) は 10 20 30 40 を出力します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut list1 = [ 10 ];
let mut list2 = list1;
list1.insert( 20 );
list1.insert( 30 );
list2.insert( 40 );
list1 = [ 100 ];
foreach val in list2 {
   print( val ); // 10 20 30 40
}</code></pre>
</div>
<p>
これは、 List&lt;List&lt;int&gt;&gt; の場合も同じです。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut list = [ 10, 20 ];
let mut wrapList:List&lt;List&lt;int&gt;&gt; = [];
wrapList.insert( list );
wrapList.insert( list );
wrapList.insert( [ 100, 200 ] );
list[ 1 ] = list[ 1 ] + 1;
print( wrapList[ 1 ][ 1 ], wrapList[ 1 ][ 2 ] ); // 11 20
print( wrapList[ 2 ][ 1 ], wrapList[ 2 ][ 2 ] ); // 11 20
print( wrapList[ 3 ][ 1 ], wrapList[ 3 ][ 2 ] ); // 100 200</code></pre>
</div>
<p>
wrapList の 1, 2 番目に list を追加し、
wrapList の 3 番目に新しいリストオブジェクトを追加している。
その後 list[1]をインクリメント後、wrapList の中身を出力する。</p>
<p>
ここで、 wrapList[1][1] と wrapList[2][1] は、同じ list[1] を指すため、
インクリメントされた値が出力される。
wrapList[3] は新しいリストオブジェクトになるため、インクリメントの影響はない。</p>
</div>
</div>
<div id="outline-container-headline-121" class="outline-3">
<h3 id="headline-121">
まとめ
</h3>
<div id="outline-text-headline-121" class="outline-text-3">
<p>
LuneScript の変数には、次の要素を取り入れています。</p>
<ul>
<li>型推論</li>
<li>アクセス制御</li>
<li>mutable</li>
<li>複数宣言</li>
</ul>
<p>Lua を静的片付けで扱う際に必要となる、最低限の機能を満しているつもりです。</p>
<p>
次回は、 LuneScript の分岐制御について説明します。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-branch_ja" class="outline-2">
<h2 id="branch_ja">
<strong>一般分岐構文 編</strong>
</h2>
<div id="outline-text-branch_ja" class="outline-text-2">
<p>
今回は LuneScript の一般分岐構文について説明します。</p>
<div id="outline-container-headline-123" class="outline-3">
<h3 id="headline-123">
構文一覧
</h3>
<div id="outline-text-headline-123" class="outline-text-3">
<p>
LuneScript は、次の一般分岐構文をサポートします。</p>
<ul>
<li>if</li>
<li>switch</li>
</ul>
<p>ちなみに、ここであえて「一般」分岐制御としているのは、
nilable 制御で別途分岐制御があるためです。</p>
<div id="outline-container-headline-124" class="outline-4">
<h4 id="headline-124">
if
</h4>
<div id="outline-text-headline-124" class="outline-text-4">
<p>
if 文は、次のように使用します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val = 1;
if val == 1 {
   print( &#34;hoge&#34; );
}
elseif val == 2 {
   print( &#34;foo&#34; );
}
else {
   print( &#34;bar&#34; );
}</code></pre>
</div>
<p>
説明は不要かと思いますが、次のように処理されます。</p>
<ul>
<li>if の式が成立している場合、 if のブロックが実行される。</li>
<li>if の式が不成立で elseif の式が成立している場合、elseif のブロックが実行される。</li>
<li>全ての式が不成立の場合、else のブロックが実行される。</li>
<li>elseif は複数存在しても良い。</li>
<li>elseif, else は存在しなくてもよい。  </li>
<li>式が <strong>「不成立」</strong> する条件は、その式の結果が nil か false の時。</li>
</ul>
<div id="outline-container-headline-125" class="outline-5">
<h5 id="headline-125">
bool 値との比較
</h5>
<div id="outline-text-headline-125" class="outline-text-5">
<p>
LuneScript では、 bool 値との比較を推奨していません。</p>
<p>
具体的には次のようなオペレーションを推奨しません。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
   let val1 = true;
   if val1 == true {
   }
   if val1 == false {
   }
   if val1 ~= false {
   }
   if val1 ~= true {
   }</code></pre>
</div>
<p>
上記のオペレーションは、近い将来廃止予定です。</p>
<p>
現在は、コンパイル時に warning メッセージを出力します。</p>
<p>
bool の真偽値によって処理を切り替える場合、
次のようにしてください。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let exp = true;
if exp {
   print( &#34;exp is true&#34; );
}
else {
   print( &#34;exp is false&#34; );
}
if not exp {
   print( &#34;exp is false&#34; );
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-126" class="outline-4">
<h4 id="headline-126">
switch
</h4>
<div id="outline-text-headline-126" class="outline-text-4">
<p>
switch 文は次のように使用します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val = 1;
switch val {
   case 1 {
      print( &#34;hoge&#34; );
   }
   case 2 {
      print( &#34;foo&#34; );
   }
   default {
      print( &#34;bar&#34; );
   }
}</code></pre>
</div>
<p>
なおこのサンプルは、上記 if のサンプルと同義です。</p>
<p>
switch の case には、次のように複数の式を書けます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val = 1;
switch val {
   case 10, 20, 30 {
      print( &#34;hoge&#34; );
   }
   default {
      print( &#34;bar&#34; );
   }
}</code></pre>
</div>
<p>
これは次の if 文と同義で、いづれかの値に一致すると、そのブロックを実行します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val = 1;
if val == 10 or val == 20 or val == 30 {
   print( &#34;hoge&#34; );
}
else {
   print( &#34;bar&#34; );
}</code></pre>
</div>
<p>
switch 文で注意すべき点は、 C 言語などと違い break が不要であることです。</p>
<p>
例えば次の break は、 switch 文を抜けるのではなく for 文を抜けることになります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
for count = 1, 10 {
   switch count {
      case 5 {
         break;
      }
   }
}</code></pre>
</div>
<div id="outline-container-headline-127" class="outline-5">
<h5 id="headline-127">
enum 値のフロー解析
</h5>
<div id="outline-text-headline-127" class="outline-text-5">
<p>
switch 条件が enum 値の場合、
case 文で全ての enum 値が指定されているかどうかをチェックしてフロー解析します。</p>
<p>
例えば次の場合、
<code class="verbatim">func()</code> 関数内の switch 文の後にある <code class="verbatim">print()</code> 文は到達不可のエラーとなります。
これは、 enum 値 Val の全ての値( Val1, Val2 ) のケースに
return が指定されているためです。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
enum Val {
   Val1,
   Val2,
}
fn func( val:Val ) {
   switch val {
      case .Val1 {
         return;
      }
      case .Val2 {
         return;
      }
   }
   print( work ); // error : 全ての enum 値の case があり、 return している
}</code></pre>
</div>
<p>
また、全ての enum 値に対する case が指定されていて、
さらに default も指定されている場合、
その default には到達しないため warning となります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
enum Val {
   Val1,
   Val2,
}
fn func( val:Val ) {
   switch val {
      case .Val1 {
         return;
      }
      case .Val2 {
         return;
      }
      default { // warning : ここには到達しない
         return;
      }
   }
}</code></pre>
</div>
<div id="outline-container-headline-128" class="outline-6">
<h6 id="headline-128">
fail safe default
</h6>
<div id="outline-text-headline-128" class="outline-text-6">
<p>
上記の通り、 全ての enum 値に対する case が指定されていて、
さらに default も指定されている場合、
その default には到達しないため warning となります。</p>
<p>
しかし、 default を fail safe として使用している場合、
default を指定しておきたい時もあります。</p>
<p>
そのような場合は、 default ではなく _default を指定することで、
warning を抑制できます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
enum Val {
   Val1,
   Val2,
}
fn func( val:Val ) {
   switch val {
      case .Val1 {
         return;
      }
      case .Val2 {
         return;
      }
      _default { // ここには到達しないが、 warning は出力されない
         return;
      }
   }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-_switch" class="outline-5">
<h5 id="_switch">
全 case 強制の switch
</h5>
<div id="outline-text-_switch" class="outline-text-5">
<p>
enum 値を条件にする switch において、
全ての enum 値に対する case を必ず宣言させたい時、
次のように _switch を使用できる。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
enum Val {
   Val1,
   Val2,
}
fn func( val:Val ) {
   _switch val {
      case .Val1 {
         return;
      }
      case .Val2 {
         return;
      }
   }
}</code></pre>
</div>
<p>
_switch では、 enum に対する case に抜けがあるとコンパイルエラーする。
また、 default は使用できない。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
enum Val {
   Val1,
   Val2,
}
fn func( val:Val ) {
   _switch val { // error
      case .Val1 {
         return;
      }
   }
}</code></pre>
</div>
<p>
_switch を利用することで、 enum 値 が開発途中で増えた際に、
switch-case 文の対応抜け漏れを確実に検出することができる。</p>
<p>
match-case でも、同様に _match が利用可能である。 </p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-130" class="outline-3">
<h3 id="headline-130">
まとめ
</h3>
<div id="outline-text-headline-130" class="outline-text-3">
<p>
LuneScript の一般分岐構文は、 if と switch があります。</p>
<p>
goto はありません。</p>
<p>
次回は、繰り返し制御について説明します。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-loop_ja" class="outline-2">
<h2 id="loop_ja">
<strong>繰り返し構文 編</strong>
</h2>
<div id="outline-text-loop_ja" class="outline-text-2">
<p>
今回は LuneScript の繰り返し構文について説明します。</p>
<div id="outline-container-headline-132" class="outline-3">
<h3 id="headline-132">
構文一覧
</h3>
<div id="outline-text-headline-132" class="outline-text-3">
<p>
LuneScript は、次の繰り返し構文をサポートします。</p>
<ul>
<li>while</li>
<li>repeat (<strong>将来削除予定</strong>)</li>
<li>for</li>
<li>apply</li>
<li>foreach</li>
<li>forsort  </li>
</ul>
<div id="outline-container-headline-133" class="outline-4">
<h4 id="headline-133">
while, repeat
</h4>
<div id="outline-text-headline-133" class="outline-text-4">
<p>
while, repeat は次のように利用します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut val = 1;
while val &lt; 10 {
   val = val + 1;
}
print( val ); // 10
repeat {
   let mut endFlag = false;
   val = val + 1;
   if val &gt;= 20 {
      endFlag = true;
   }
} endFlag;
print( val ); // 20</code></pre>
</div>
<p>
while は式が成立している間、ブロックを処理し、
repeat は式が不成立の間、ブロックを処理します。</p>
<p>
repeat の式では、ブロック内部のスコープの変数を利用できます。</p>
<p>
<strong>なお、repeat は将来削除予定です。</strong></p>
</div>
</div>
<div id="outline-container-headline-134" class="outline-4">
<h4 id="headline-134">
無限ループ
</h4>
<div id="outline-text-headline-134" class="outline-text-4">
<p>
無限ループを利用する場合、 while true {} を使用してください。
ここで true は immediate な値である必要があります。</p>
<p>
例えば次のように immediate な値ではなく変数を使用している場合、
処理上は無限ループしますが、
フロー解析においては無限ループとは扱いません。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
let flag = true;
while flag {
}</code></pre>
</div>
<p>
無限ループと見做されないことに何の問題があるかというと、
意図したフロー解析ができなくなる、ということです。</p>
<p>
例えば次のような場合、
LuneScript では無限ループの後の <code class="verbatim">print()</code> 文は処理されないということを判定します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
while true {
}
print( &#34;hoge&#34; );</code></pre>
</div>
<p>
しかし、上記の true が immediate な値でない場合、
無限ループではないと判断し、 <code class="verbatim">print()</code> 文は処理される可能性があるものとします。</p>
<p>
処理されないはずのものが処理されるものとして判定されてしまうと、
本来コンパイルエラーとなるものがエラーにならず、コードの不具合を見逃す可能性があります。</p>
<p>
必ず無限ループには、 immediate な true を使用してください。</p>
<p>
なお、 repeat {} false も無限ループとしては扱っていません。</p>
<p>
Rust のように無限ループ専用の命令を用意する方が良いかとも思いましたが、
現状はこの仕様となっています。</p>
</div>
</div>
<div id="outline-container-headline-135" class="outline-4">
<h4 id="headline-135">
for
</h4>
<div id="outline-text-headline-135" class="outline-text-4">
<p>
次のように利用します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
for count = 1, 10, 1 {
  print( count );
}</code></pre>
</div>
<p>
基本的に Lua と同じ仕様です。
上記の例では count を 1 から 10 まで 1 ずつインクリメントしてブロックを処理します。</p>
<p>
注意が必要なのは、 1, 10, 1 という値は、
for 開始時に一度だけ評価されるということです。</p>
<p>
つまり、次のようなことをやると、期待と異なる動作になります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut addVal = 1;
for count = 1, 10, addVal {
  addVal = addVal + 1;
  print( count );
}</code></pre>
</div>
<p>
なお、 <strong>インクリメントする値を省略した場合は 1 が利用されます。</strong></p>
</div>
</div>
<div id="outline-container-headline-136" class="outline-4">
<h4 id="headline-136">
apply
</h4>
<div id="outline-text-headline-136" class="outline-text-4">
<p>
apply は、Lua の for in との互換用命令です。</p>
<p>
次のように利用します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
apply txt of string.gmatch( &#34;hoge.foo.bar&#34;, &#39;[^%.]+&#39; ) {
   print( txt );
}</code></pre>
</div>
<p>
なお、 <code>apply val of exp {}</code> の exp に与える式は、関数呼び出しでなければなりません。
これは現状の制限です。</p>
</div>
</div>
<div id="outline-container-headline-137" class="outline-4">
<h4 id="headline-137">
foreach
</h4>
<div id="outline-text-headline-137" class="outline-text-4">
<p>
foreach は、リスト、配列、マップの要素を列挙する関数です。</p>
<p>
次のように利用します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
foreach val, index in [ 1, 2, 3 ] {
   print( index, val );
}
foreach val, index in [@ 10, 20, 30 ] {
   print( index, val );
}
foreach val, key in { &#34;a&#34;:100, &#34;b&#34;:200, &#34;c&#34;:300 } {
   print( key, val );
}
foreach val in (@ 1, 2, 3 ) {
   print( val );
}</code></pre>
</div>
<p>
<strong>Set は 値のみ列挙します</strong></p>
<p>
なお リスト、配列の index, マップの key は、次のように省略することができます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
foreach val in [ 1, 2, 3 ] {
   print( val );
}
foreach val in [@ 10, 20, 30 ] {
   print( val );
}
foreach val in { &#34;a&#34;:100, &#34;b&#34;:200, &#34;c&#34;:300 } {
   print( val );
}</code></pre>
</div>
<p>
<strong>foreach, forsort</strong> のループ処理中に、
<strong>列挙しているオブジェクトの変更は禁止</strong> です。変更した場合の挙動は未定義です。</p>
<p>
例えば、次のようなことは禁止です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
let mut list = [ 1, 2, 3 ];
foreach val, index in list {
   list[ index ] = val + 10;
}</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-138" class="outline-4">
<h4 id="headline-138">
forsort
</h4>
<div id="outline-text-headline-138" class="outline-text-4">
<p>
Set, Map を foreach で要素を列挙した場合、 <strong>要素の列挙順は不定</strong> となります。</p>
<p>
forsort は、 Set, Map の要素を列挙する際に、キーでソート(昇順)した順で列挙します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
forsort val, key in { &#34;b&#34;:200, &#34;c&#34;:300, &#34;a&#34;:100 } {
   print( key, val );
}
forsort val in (@ 2, 4, 1, 0 ) {
   print( val );
}</code></pre>
</div>
<p>
Map の forsort は key を省略できます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
forsort val in { &#34;b&#34;:200, &#34;c&#34;:300, &#34;a&#34;:100 } {
   print( val );
}</code></pre>
</div>
<p>
<strong>forsort は内部的に clone と sort を行なうため、 その分のオーバーヘッドがあります。</strong></p>
<p>
また、 Set の型、 Map のキーの型がソート可能な型でない場合、エラーします。</p>
</div>
</div>
<div id="outline-container-headline-139" class="outline-4">
<h4 id="headline-139">
break
</h4>
<div id="outline-text-headline-139" class="outline-text-4">
<p>
break は、一番内側にある繰り返し制御文を抜けます。</p>
<p>
continue はありません。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-140" class="outline-3">
<h3 id="headline-140">
まとめ
</h3>
<div id="outline-text-headline-140" class="outline-text-3">
<p>
LuneScript の一般制御構文は、基本的に Lua と同じです。</p>
<p>
主な違いは、リスト等を処理する foreach, forsort を追加していることです。</p>
<p>
次回は関数を説明します。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-func_ja" class="outline-2">
<h2 id="func_ja">
<strong>関数 編</strong>
</h2>
<div id="outline-text-func_ja" class="outline-text-2">
<p>
今回は、 LuneScript の関数について説明します。</p>
<div id="outline-container-headline-142" class="outline-3">
<h3 id="headline-142">
関数定義
</h3>
<div id="outline-text-headline-142" class="outline-text-3">
<p>LuneScript の関数は次のように定義します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn add_sub( val1:int, val2:int ): int, int {
   return val1 + val2, val1 - val2;
}
print( add_sub( 1, 2 ) ); // 3, -1</code></pre>
</div>
<p>
上記の例は、次の関数を定義しています。</p>
<table>
<thead>
<tr>
<th>定義</th>
<th></th>
<th class="align-right"></th>
</tr>
</thead>
<tbody>
<tr>
<td>関数名</td>
<td>add_sub</td>
<td class="align-right"></td>
</tr>
<tr>
<td>第一引数名</td>
<td>val1</td>
<td class="align-right"></td>
</tr>
<tr>
<td>第一引数型</td>
<td>int</td>
<td class="align-right"></td>
</tr>
<tr>
<td>第二引数名</td>
<td>val2</td>
<td class="align-right"></td>
</tr>
<tr>
<td>第二引数型</td>
<td>int</td>
<td class="align-right"></td>
</tr>
<tr>
<td>第一戻り値型</td>
<td>int</td>
<td class="align-right"></td>
</tr>
<tr>
<td>第二戻り値型</td>
<td>int</td>
<td class="align-right"></td>
</tr>
</tbody>
</table>
<p>
LuneScript は、戻り値を複数返せます。</p>
<div id="outline-container-headline-143" class="outline-5">
<h5 id="headline-143">
戻り値
</h5>
<div id="outline-text-headline-143" class="outline-text-5">
<p>
関数の戻り値は return 文を使用します。</p>
<p>
関数は、複数の値を返せます。</p>
<p>
多値の戻り値については次を参照してください。</p>
<p>
<a href="#multipleretval">#multipleretval</a></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-144" class="outline-3">
<h3 id="headline-144">
処理が戻らない関数
</h3>
<div id="outline-text-headline-144" class="outline-text-3">
<p>
関数によっては、処理を戻さないものがあります。</p>
<p>
次に例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func(): __ {
   while true {
   }
}
func();
print( 1 ); // error</code></pre>
</div>
<p>
この例では、 <code class="verbatim">func()</code> は無限ループです。
よって、 <code class="verbatim">func()</code> は処理を返さないことになります。</p>
<p>
これを明示するため、 <code class="verbatim">func()</code> の戻り値の型は <code>__</code> となっています。
<code>__</code> は、処理を戻さない関数であることを示します。</p>
<p>
これによって、 <code class="verbatim">func()</code> の次の <code class="verbatim">print()</code> 文が処理されないことが分かり、
エラーとなります。</p>
<p>
なお、 戻り値型を <code>__</code> とした関数は、
処理を戻さないようにしなければなりません。</p>
<p>
例えば次のように break すると、ループを抜けてしまうため、
<code class="verbatim">func()</code> から処理が戻ってきます。
このような場合は、エラーとなります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func(val:int): __ {
   while true {
      if val == 1 {
         break;
      }
   }
}</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-145" class="outline-3">
<h3 id="headline-145">
可変長引数、戻り値
</h3>
<div id="outline-text-headline-145" class="outline-text-3">
<p>
可変長引数、戻り値を利用できます。</p>
<p>
詳細は次の記事を参照してください。</p>
<p>
<a href="#arg">#arg</a></p>
</div>
</div>
<div id="outline-container-headline-146" class="outline-3">
<h3 id="headline-146">
定義場所
</h3>
<div id="outline-text-headline-146" class="outline-text-3">
<p>
関数は、 statement が書ける場所であればどこでも定義可能です。
具体的には次のようにブロック内に定義できます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn sub():int {
   let mut val = 0;
   {
      {
         fn func(): int {
            return 1;
         }
         val = val + func();
      }
      fn func(): int {
         return 2;
      }
      val = val + func();
   }
   fn func(): int {
      return 3;
   }
   return val + func();
}
print( sub() ); // 6</code></pre>
</div>
<p>
スコープが異なれば、同名関数を定義できます。</p>
</div>
</div>
<div id="outline-container-headline-147" class="outline-3">
<h3 id="headline-147">
公開関数
</h3>
<div id="outline-text-headline-147" class="outline-text-3">
<p>
関数も変数と同様、pub を使って外部公開できます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
pub fn func(): int {
   return 1;
}</code></pre>
</div>
<p>
pub を指定することで、外部からアクセス可能な関数となります。</p>
<p>
global も利用できます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
global fn func(): int {
   return 1;
}</code></pre>
</div>
<p>
関数の global 宣言には、 変数の global 宣言と同じ制約があります。</p>
<p>
 <strong>「global 宣言した関数は、 その関数を宣言したモジュールを import した時に有効になる。」</strong></p>
<p>
関数の外部公開には、次の制約があります。</p>
<p>
 <strong>「外部公開する関数は、スクリプトの最上位のスコープに宣言しなければならない」</strong></p>
</div>
</div>
<div id="outline-container-headline-148" class="outline-3">
<h3 id="headline-148">
form 型
</h3>
<div id="outline-text-headline-148" class="outline-text-3">
<p>
LuneScript は、関数オブジェクトを値として扱うことが出来ます。
特殊な関数オブジェクトの型として <strong>form</strong> を利用できます。</p>
<p>
次に form の使用例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn test() {
   print( &#34;hoge&#34; );
}
fn sub( func:form ) {
  func();
}
sub( test ); // hoge</code></pre>
</div>
<p>
この例は、次の構成となります。</p>
<ul>
<li>関数 test を定義</li>
<li>関数 sub は form 型の引数を持つ</li>
<li>引数として test を指定して sub を実行</li>
</ul>
<p>これによって、 sub 内で test が実行され、 hoge が出力されます。</p>
<p>
なお、 form 型は次の関数として扱います。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
fn func(...):... {}</code></pre>
</div>
<div id="outline-container-headline-149" class="outline-4">
<h4 id="headline-149">
form 型に代入可能な関数型
</h4>
<div id="outline-text-headline-149" class="outline-text-4">
<p>
上記の通り、form は <code>fn func(...):... {}</code> と同義です。</p>
<p>
また、 <code class="verbatim">...</code> は 0 個以上の <code class="verbatim">stem!</code> を表わします。</p>
<p>
つまり、 stem! 型の引数を持つ関数が form 型に代入可能になり、
非 stem! 型の引数を持つ関数は代入不可能になります。</p>
<p>
もしも代入できてしまうと、
次の func2( nil ) のコールは func( nil ) をコールすることになり、
不正動作となってしまいます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func( val:int ) {
   print( val + 1 );
}
let func2:form = func;
func2( nil );</code></pre>
</div>
<p>
代入可能なケースと、代入不可能なケースの例を次に示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let form1:form = fn ( val1:stem! ) { };
let form2:form = fn ( val1:stem ) { };  // error
let form3:form = fn ( val1:stem!, val2:stem! ) { };
let form4:form = fn ( val1:stem!, val2:stem ) { }; // error</code></pre>
</div>
<p>
上記の form1, form3 は代入可能で、form2, form4 は代入不可能です。</p>
</div>
</div>
<div id="outline-container-headline-150" class="outline-4">
<h4 id="headline-150">
form 宣言
</h4>
<div id="outline-text-headline-150" class="outline-text-4">
<p>
上記の通り、form で扱える関数の型は一部だけです。</p>
<p>
form で扱えない関数を扱うには、次のように form 宣言をします。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
form funcform( val:int ):int;
fn sub( func:funcform ) {
   print( func( 1 ) + 1 );
}
sub( fn ( val:int ):int { return val + 1; } ); // 3</code></pre>
</div>
<p>
この例では、 funcform を form 宣言しています。</p>
<p>
form 宣言によって funcform は、引数に int 型の val を持ち、
戻り値に int 型を持つ関数型となります。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-151" class="outline-3">
<h3 id="headline-151">
anonymous 関数
</h3>
<div id="outline-text-headline-151" class="outline-text-3">
<p>
anonymous 関数は、名前を持たない関数を定義します。</p>
<p>
次は anonymous 関数の例です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn sub( func:form ) {
  func( 1 );
}
sub( fn ( val:stem! ) { print( val ); } );  // 1</code></pre>
</div>
<p>
この例では、 anonymous 関数 <code>fn ( val:int ) { print( val ); }</code> を定義しています。</p>
<p>
この anonymous 関数を <code class="verbatim">sub()</code> の引数に渡すことで、
<code class="verbatim">sub()</code> 内で anonymous 関数が実行されます。</p>
<p>
anonymous 関数宣言は式です。</p>
</div>
</div>
<div id="outline-container-headline-152" class="outline-3">
<h3 id="headline-152">
関数呼び出し
</h3>
<div id="outline-text-headline-152" class="outline-text-3">
<p>
関数オブジェクトに <code>()</code> を付けることで、その関数が実行されます。</p>
<p>
関数の仮引数と実引数の型は一致しなければなりません。
なお、省略した実引数は nil として扱います。
もし省略した実引数に対応する仮引数が nilable でなかった場合、エラーとなります。</p>
<div id="outline-container-headline-153" class="outline-4">
<h4 id="headline-153">
引数の省略  
</h4>
<div id="outline-text-headline-153" class="outline-text-4">
<p>
引数の省略については次の記事を確認してください。</p>
<p>
<a href="#defaultarg">#defaultarg</a></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-154" class="outline-3">
<h3 id="headline-154">
関数の制限
</h3>
<div id="outline-text-headline-154" class="outline-text-3">
<p>
LuneScript の関数は、引数の違いによるオーバーロードはできません。</p>
</div>
</div>
<div id="outline-container-headline-155" class="outline-3">
<h3 id="headline-155">
まとめ
</h3>
<div id="outline-text-headline-155" class="outline-text-3">
<p>
LuneScript の関数をまとめると、</p>
<ul>
<li>fn で宣言する</li>
<li>複数の戻り値を持てる</li>
<li>可変長の引数、戻り値をもてる</li>
<li>pub, global で外部モジュールに関数を公開する</li>
<li>関数オブジェクトの型は、form 型と form 宣言を使用する</li>
<li>anonymous 関数がある</li>
<li>省略した実引数には nil が入る</li>
<li>関数オーバーロードはない</li>
</ul>
<p>次回は nilable について説明します。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-multipleretval_ja" class="outline-2">
<h2 id="multipleretval_ja">
<strong>多値の戻り値</strong>
</h2>
<div id="outline-text-multipleretval_ja" class="outline-text-2">
<p>
LuneScript は、多値の関数戻り値に対応しています。</p>
<p>
例えば、次のように関数は複数の値を返せます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func(): int,int {
   return 1, 2;
}
print( func() );  // 1 2</code></pre>
</div>
<p>
上記サンプルでは、 <code class="verbatim">func()</code> は 1 と 2 を返します。
この多値の戻り値を、そのまま <code class="verbatim">print()</code> の引数として渡しています。</p>
<p>
多値の戻り値は非常に便利ですが、戻り値が多値である言語はまだまだ少ないです。
また、戻り値の 2 番目以降の値は、オプション的な意味合いのケースが多いです。</p>
<p>
そのため、2 番目以降の戻り値の存在を忘れがちです。</p>
<p>
これによって、不具合が発生することがあります。</p>
<div id="outline-container-headline-157" class="outline-3">
<h3 id="headline-157">
多値の戻り値による不具合
</h3>
<div id="outline-text-headline-157" class="outline-text-3">
<p>
次のコードは LuneScript ではなく、 <strong>Lua</strong> のコードです。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="kr">function</span> <span class="nf">func1</span><span class="p">(</span> <span class="n">txt</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">   <span class="n">print</span><span class="p">(</span> <span class="n">string.byte</span><span class="p">(</span> <span class="n">txt</span><span class="p">:</span><span class="n">gsub</span><span class="p">(</span> <span class="s2">&#34;b&#34;</span><span class="p">,</span> <span class="s2">&#34;B&#34;</span> <span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="kr">function</span> <span class="nf">func2</span><span class="p">(</span> <span class="n">txt</span> <span class="p">)</span> 
</span></span><span class="line"><span class="cl">   <span class="n">print</span><span class="p">(</span> <span class="n">string.byte</span><span class="p">(</span> <span class="p">(</span><span class="n">txt</span><span class="p">:</span><span class="n">gsub</span><span class="p">(</span> <span class="s2">&#34;b&#34;</span><span class="p">,</span> <span class="s2">&#34;B&#34;</span> <span class="p">))</span> <span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="n">func1</span><span class="p">(</span> <span class="s2">&#34;abcb&#34;</span> <span class="p">)</span> <span class="c1">-- 66</span>
</span></span><span class="line"><span class="cl"><span class="n">func2</span><span class="p">(</span> <span class="s2">&#34;abcb&#34;</span> <span class="p">)</span> <span class="c1">-- 97</span></span></span></code></pre></div>
</div>
<p>
この func1() と func2() は、同じ引数 &#34;abcb&#34; を与えているのに異なる結果を出力します。
何故そうなるか分かるでしょうか？</p>
<p>
ちなみに <code>txt:gsub( &#34;b&#34;, &#34;B&#34; )</code> は、
文字列 txt 内の &#34;b&#34; を &#34;B&#34; に変換した文字列を返す Lua の標準ライブラリで、
<code>string.byte()</code> は、 指定の文字列に含まれる値を返す標準ライブラリです。</p>
<p>
それでは問の答です。</p>
<p>
func1() は string.byte に <code>txt:gsub( &#34;b&#34;, &#34;B&#34; )</code> の
戻り値そのままを渡しているのに対し、
func2() は <code>()</code> で括った <code>(txt:gsub( &#34;b&#34;, &#34;B&#34; ))</code> を渡しています。</p>
<p>
これにより、
func1() は <code class="verbatim">string.byte()</code> に <code>txt:gsub( &#34;b&#34;, &#34;B&#34; )</code> の多値の値をそのまま渡しているのに対し、
func2() は <code class="verbatim">string.byte()</code> に <code>txt:gsub( &#34;b&#34;, &#34;B&#34; )</code> の多値の先頭の値である文字列だけを渡しています。</p>
<p>
<code>string.byte()</code> は、 第2引数が渡された場合、
第2引数が指定するインデックスの文字の値を返します。
一方、第2引数が省略された場合、先頭の文字の値を返します。</p>
<p>
そして、 <code>txt:gsub( &#34;b&#34;, &#34;B&#34; )</code> は多値を返す関数です。
具体的には、変換後の文字列 str と何箇所変換したか int を返します。</p>
<p>
<code>txt:gsub( &#34;b&#34;, &#34;B&#34; )</code> が変換した文字列を返す関数であることは、
Lua を利用している人であれば認識していることだと思います。
一方で、この関数が多値を返す関数だと認識している人はどの程度いるでしょうか？</p>
<p>
また、認識していたとして、それが不具合につながるということに即座に気付く人は
どれほどいるでしょうか？</p>
<p>
本来 <code>txt:gsub( &#34;b&#34;, &#34;B&#34; )</code> の変換後の文字列だけを引数として使用したいのに、
意図せずに渡された多値の戻り値によって、関数動作が変ってしまうことがあります。</p>
<p>
つまり、本来は func2() のように <code>()</code> を使って多値の先頭だけ使わなければならない時に、
func1() のようにそのまま多値を使ってしまうことがあるのです。</p>
<p>
ここで冒頭で書いたことを思い出してください。</p>
<ul>
<li><code>多値の戻り値は非常に便利ですが、戻り値が多値である言語はまだまだ少ないです。</code></li>
<li><code>また、戻り値の 2 番目以降の値は、オプション的な意味合いのケースが多いです。</code></li>
<li><code>そのため、2 番目以降の戻り値の存在を忘れがちです。</code></li>
</ul>
<p>多値の戻り値は便利ですが、このようなリスクもあるんです。</p>
</div>
</div>
<div id="outline-container-headline-158" class="outline-3">
<h3 id="headline-158">
LuneScript の場合
</h3>
<div id="outline-text-headline-158" class="outline-text-3">
<p>
LuneScript では、このように問題を避けるため多値の戻り値を扱う際、
明示することにしました。
なお、明示しない場合は warning となります。</p>
<p>
ただ、多値を利用する際に明示するのは、それはそれで面倒です。</p>
<p>
そこで、明示が必要なケースとして、次のケースに限定します。</p>
<p>
多値の戻り値の利用先が</p>
<ul>
<li>関数の引数で、なおかつその引数が省略可能な場合</li>
<li>return に指定する値で、なおかつその値が省略可能な場合</li>
</ul>
<p>つまり、 let など直接変数に値を代入するような場合は、明示は不要です。
わざわざ値を代入する変数を用意しているということ自体が、
多値の第二引数以降を使用すると明示しているのと同様だと考えたためです。</p>
</div>
</div>
<div id="outline-container-headline-159" class="outline-3">
<h3 id="headline-159">
明示方法
</h3>
<div id="outline-text-headline-159" class="outline-text-3">
<p>
具体的な明示方法は次になります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func1(): int,int {
   return 1, 2;
}
fn func2( val1:int, val2:int!) {
   print( val1, val2 );
}

func2( func1()** );</code></pre>
</div>
<p>
上記 <code>func1()**</code> のように、関数コールの後に <code>**</code> を付加することで、
その関数コールの多値を使用していることを明示します。</p>
</div>
</div>
<div id="outline-container-headline-160" class="outline-3">
<h3 id="headline-160">
多値戻り値を使用する際の仕様
</h3>
<div id="outline-text-headline-160" class="outline-text-3">
<p>
上記で示す通り、多値を返す関数の実行結果をそのまま別の関数の引数に渡すことができます。</p>
<p>
但し、多値を返す関数の戻り値をそのまま多値として扱うには、
関数の後に何も指定していない場合に限ります。</p>
<p>
これはどういうことかというと、
以下のように多値の戻り値を返す関数 func1 の実行結果を print で出力する際、
func1 の後に指定していると、 func1 の実行結果は先頭の値だけが処理されます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func1(): int,int {
   return 1, 2;
}
print( func1() );      // 1 2
print( func1(), 10 );  // 1 10
print( 0, func1() );  // 0 1 2</code></pre>
</div>
<p>
上の例の場合、</p>
<ul>
<li><code class="verbatim">print( func1() )</code> は、多値の戻り値 <code class="verbatim">1 2</code> がそのまま処理される。</li>
<li><code class="verbatim">print( func1(), 10 )</code> は、多値の戻り値の先頭の <code class="verbatim">10</code> が処理される。</li>
<li><code class="verbatim">print( 0, func1() )</code> は、多値の戻り値 <code class="verbatim">1 2</code> がそのまま処理される。</li>
</ul>
<p>これは、 List のコンストラクタなどの場合も同様です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func1(): int,int {
   return 1, 2;
}
let list1 = [ func1() ]; // [1 2]
let list2 = [ func1(), 10 ];  // [ 1 10]
let list3 = [ 0, func1() ];  // [0 1 2]</code></pre>
</div>
<p>
なお、次のように多値の関数呼び出しに <code class="verbatim">()</code> を付けた場合も、多値の戻り値の先頭だけを処理します。</p>
<pre class="example">
print( (func1()) );
</pre>
<p>
これは、 LuneScript の仕様というよりは、 Lua の仕様にもとづく動作です。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-defaultarg_ja" class="outline-2">
<h2 id="defaultarg_ja">
<strong>引数の省略 編</strong>
</h2>
<div id="outline-text-defaultarg_ja" class="outline-text-2">
<p>
LuneScript は、nilable 型の引数は関数コール時に省略することが出来ます。</p>
<p>
例えば次の関数 <code class="verbatim">func()</code> は、引数を省略してコールできます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( val1:int!, val2:int! ):int {
   when! val1, val2 {
      return val1 + val2;
   }
   when! val1 {
      return val1;
   }
   when! val2 {
      return val2;
   }
   return 0;
}
print( func(1,2) );  // 3
print( func(1) );    // 1
print( func() );     // 0</code></pre>
</div>
<p>
ここで問題となるのが、 <code>func(1)</code> ならびに <code>func()</code> は意図して引数を省略したのか、
それとも指定し忘れたのかが判断できない、ということです。</p>
<p>
引数を省略できること自体は、コーディングの手間を省ける有用な機能ですが、
本来指定すべき引数を指定し忘れたときに、それを検知できなくなってしまう可能性があります。</p>
<p>
これを避けるため次のように引数を定義し、
引数の省略を禁止することで指定し忘れを防止することが出来ます。</p>
<ul>
<li>nilable 型の引数を使わない</li>
<li>nilable 型の引数の後に、非 nilable 型の引数を定義する</li>
</ul>
<p>しかし、引数の省略自体を禁止してしまった場合、次の問題があります。</p>
<ul>
<li>コーディングの手間が増えてしまう。</li>
<li>無駄な引数指定が増え、コードの可読性が悪くなる。</li>
</ul>
<p>引数を省略しつつ、引数の指定し忘れの問題を回避するため、
LuneScript は引数省略の明示を導入します。</p>
<div id="outline-container-headline-162" class="outline-3">
<h3 id="headline-162">
引数省略の明示
</h3>
<div id="outline-text-headline-162" class="outline-text-3">
<p>
LuneScript では、引数を省略する場合 <code>##</code> を使用します。</p>
<p>
上の <code class="verbatim">func()</code> をコールする場合、次のようになります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
print( func(1,2) );  // 3
print( func(1##) );  // 1
print( func(##) );   // 0</code></pre>
</div>
<p>
引数を省略している箇所に <code>##</code> を付加することで、
そこは引数を省略していることを明示します。</p>
<p>
なお <code>##</code> を指定せずに省略している場合、 warning となります。</p>
<p>
これにより、引数の省略と、引数の指定し忘れを防止しています。</p>
<p>
トランスコンパイル時に -Werror オプションを追加することで、
warning を error として扱います。</p>
<p>
また、逆に ## の指定が面倒な場合、
–disable-checking-define-abbr オプションを追加することで
<code>##</code> を指定せずに省略している場合の warning を抑制できます。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-arg_ja" class="outline-2">
<h2 id="arg_ja">
<strong>可変長引数、戻り値 編</strong>
</h2>
<div id="outline-text-arg_ja" class="outline-text-2">
<div id="outline-container-headline-164" class="outline-3">
<h3 id="headline-164">
可変長引数、戻り値
</h3>
<div id="outline-text-headline-164" class="outline-text-3">
<p>
引数、 戻り値に … を利用することで、
可変長引数、可変長戻り値の関数を定義できます。</p>
<p>
… を利用したサンプルを次に示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( ... ) : int, ... {
   let argList = [ ... ];
   let mut total = 0;
   foreach arg in argList {
      when! arg {
         total = total + arg@@int;
      }
   }
   return total, ...;
}

print( func( 1, 2, 3, 4 ) ); // 10 1 2 3 4</code></pre>
</div>
<p>
上記の例では、与えられた可変長引数の値を合計し、
合計値と与えられた可変長引数を返す関数 func() を定義、実行しています。</p>
<p>
関数本体で … を使用することで、可変長引数そのものを示します。
ここで … は、 0 個以上の stem! の値となります。
stem! については後述します。</p>
<p>
可変長引数をもつ関数をコールする側は、 0 個以上のあらゆる型の引数を指定できます。</p>
</div>
</div>
<div id="outline-container-headline-165" class="outline-3">
<h3 id="headline-165">
Generics
</h3>
<div id="outline-text-headline-165" class="outline-text-3">
<p>
上記の通り … を利用することで、可変長引数、戻り値を宣言できます。</p>
<p>
しかし、 … の値は全て stem! として扱うため型情報が失なわれてしまいます。</p>
<p>
上のサンプルでも、 func() には int のデータを渡しているのに、
型情報が失なわれるため
func() 内で値にアクセスするには unwrap やキャストが必要になっています。</p>
<p>
型情報を保つには、次のように <code>...&lt;type&gt;</code> を使用します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( ...&lt;int&gt; ) : int, ...&lt;int&gt; {
   let argList = [ ... ];
   let mut total = 0;
   foreach arg in argList {
      total = total + arg;
   }
   return total, ...;
}
print( func( 1, 2, 3, 4 ) ); // 10 1 2 3 4</code></pre>
</div>
<p>
<code>...&lt;int&gt;</code> を使用することで、
int の型情報を保持したまま可変長引数、戻り値を扱うことが出来ます。</p>
<p>
なお、次のサンプルの func1() と func2() は同義です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func1( ...&lt;stem!&gt; ) {
   print( ... );
}
fn func2( ... ) {
   print( ... );
}
func1( 1, &#34;abc&#34; );
func2( 1, &#34;abc&#34; );</code></pre>
</div>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-nilable_ja" class="outline-2">
<h2 id="nilable_ja">
<strong>nilable 編</strong>
</h2>
<div id="outline-text-nilable_ja" class="outline-text-2">
<p>
今回は LuneScript の nilable について説明します。</p>
<div id="outline-container-headline-167" class="outline-3">
<h3 id="headline-167">
nilable とは
</h3>
<div id="outline-text-headline-167" class="outline-text-3">
<p>
LuneScript は、値に nil を持ちます。</p>
<p>
以前説明しましたが、 stem 型の変数は nil 以外の全ての型を保持できます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let mut val:stem = 1;
val = 1.0;
val = &#34;abc&#34;;
val = {};
val = [];
val = [@];
val = nil; // error</code></pre>
</div>
<p>
では、どうすれば nil を保持できるのかというと、
stem ではなく stem! を使用します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut val:stem! = 1;
val = 1.0;
val = &#34;abc&#34;;
val = {};
val = [];
val = [@];
val = nil; // ok</code></pre>
</div>
<p>
このように、 nil を保持可能な型を nilable と言います。</p>
<p>
nilable は stem! だけでなく、
一部を除く全ての型に nilable 型が存在します。</p>
<p>
例えば int! や str! は、 int の nilable 型、 str の nilable 型となります。</p>
<p>
型名の末尾に ! を付加することで、
本来の型と nil を保持可能な nilable 型となります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let mut val1:int = 1;
val1 = nil;  // error

let mut val2:int! = 1;
val2 = nil;  // ok</code></pre>
</div>
<p>
nil は、他のどの値とも異なる値で、異常値として利用するのに便利な値です。
しかし、 意図しないタイミングで変数の値が nil になることで、
不具合の原因となることが多くあります。</p>
<p>
LuneScript は、 nil を保持出来る nilable 型と、
nil を保持できない非 nilable 型に分けることで、
nil 安全(NULL 安全)を実現しています。</p>
</div>
</div>
<div id="outline-container-headline-168" class="outline-3">
<h3 id="headline-168">
nilable 型の制限
</h3>
<div id="outline-text-headline-168" class="outline-text-3">
<p>
nilable 型は、そのままでは元の型として使用できないという制限があります。</p>
<p>
この説明だと何のことだか伝わり難いと思いますので、次の例を見てください。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let val:int! = 1;
print( val + 1 );  // error</code></pre>
</div>
<p>
上記の val は int の nilable 型です。
そして val + 1 を実行していますが、これはエラーとなります。</p>
<p>
なぜならば、 val は int ではなく int! なので、そのままでは int としては扱えないためです。</p>
<p>
では、なぜ nilable にこのような制限があるかというと、次の通りです。</p>
<ul>
<li>nilable は nil を保持できる型</li>
<li>つまり、nilable 型は nil である可能性がある</li>
<li>元の型として利用するには、 nil でないことを確認しなければならない</li>
</ul>
<p>
非 nilable の型には nil を代入出来ません。
そして、 nilable 型はそのままで元の型として利用が出来ません。</p>
<p>
この制限によって、 ある変数が意図しないタイミングで nil になり、
不具合となることを論理的に防止することが出来ます。</p>
<p>
これが多くの言語で取り入れられている nil 安全(NULL安全)の原理です。</p>
</div>
</div>
<div id="outline-container-headline-169" class="outline-3">
<h3 id="headline-169">
nilable 型との比較
</h3>
<div id="outline-text-headline-169" class="outline-text-3">
<p>
前述している通り、nilable 型は、そのままでは非 nilable として利用できません。</p>
<p>
しかし、次のように比較すること出来ます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn check( val:int! ) {
   if val == 1 {
      print( &#34;ok&#34; );
   }
   else {
      print( &#34;ng&#34; );
   }
}
check( 1 ); // ok
check( 2 ); // ng</code></pre>
</div>
<p>
上記サンプルでは val は int! で、 val == 1 で int と比較しています。
このように nilable と 非 nilable を比較することは可能です。</p>
</div>
</div>
<div id="outline-container-headline-170" class="outline-3">
<h3 id="headline-170">
nilable 型から非 nilable 型への変換
</h3>
<div id="outline-text-headline-170" class="outline-text-3">
<p>
次のように、非 nilable 型から nilable 型への変換は、暗黙的に行なわれます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val:int! = 1;   // int! &lt;-- int</code></pre>
</div>
<p>
一方で nilable 型から非 nilable 型への変換は、明示的に行なう必要があります。</p>
<p>
LuneScript では、nilable 型から非 nilable 型への変換に、次のものを用意しています。</p>
<ul>
<li>unwrap </li>
<li>when!</li>
<li>if!</li>
<li>if! let</li>
<li>let!</li>
<li>unwrap!</li>
</ul>
<div id="outline-container-headline-171" class="outline-4">
<h4 id="headline-171">
unwrap
</h4>
<div id="outline-text-headline-171" class="outline-text-4">
<p>
unwrap は、 nilable 型の式を、非 nilable 型へ変換します。</p>
<p>
例えば次のように使用します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val1:int! = 1;
let val2:int = unwrap val1;</code></pre>
</div>
<p>
このサンプルで val1 は int! です。その val1 を unwrap することで、
int! から int に変換しています。</p>
<p>
なお、次のように unwrap する値が nil だった場合、
そのプログラムは実行時エラーします。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val1:int! = nil;
let val2:int = unwrap val1;   // runtime error</code></pre>
</div>
<p>
この実行時エラーを防ぐのが unwrap default です。
unwrap default は、変換対象の値が nil だった場合の値を指定します。</p>
<p>
次は default を使用した例です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val1:int! = nil;
let val2:int = unwrap val1 default 0;</code></pre>
</div>
<p>
この例では val1 は nil となるため、 default の 0 が unwrap の評価結果となります。</p>
<p>
default のない unwrap の使用は、
確実に nil ではないと判っている時のみに限定してください。</p>
</div>
</div>
<div id="outline-container-headline-172" class="outline-4">
<h4 id="headline-172">
when!
</h4>
<div id="outline-text-headline-172" class="outline-text-4">
<p>
when! は、指定の nilable 型の <strong>変数</strong> が nil かどうかを判定し、分岐します。</p>
<p>
次に when! の例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( val:int!, val2:int! ): int {
   when! val, val2 {
      return val + val2;
   }
   else {
      return 0;
   }
}
print( func( 1, 2 ) );      // 3
print( func( nil, 2 ) );    // 0
print( func( 1, nil ) );    // 0
print( func( nil, nil ) );  // 0</code></pre>
</div>
<p>
この例では int! 型の val, val2 に対して when! で分岐しています。</p>
<ul>
<li>val と val2 が 非 nil の場合、 <code>return val + val2</code> を実行</li>
<li>val あるいは val2 が nil の場合、 return 0 を実行</li>
</ul>
<p>when! は、指定の変数全てが非 nil の時に、最初のブロックを実行します。</p>
<p>
<strong>このブロック内では、次の動作になります。</strong></p>
<ul>
<li>指定変数は unwrap された非 nilable の型となる。</li>
<li>指定変数は immutable となる。</li>
</ul>
<p>when! に指定した変数のいずれかが nil だった場合、
else ブロックを実行します。
else は省略可能です。</p>
<p>
なお、 when! に指定できるのは <strong>変数だけ</strong> です。 <strong>メンバや式は書けません。</strong></p>
</div>
</div>
<div id="outline-container-headline-173" class="outline-4">
<h4 id="headline-173">
if!
</h4>
<div id="outline-text-headline-173" class="outline-text-4">
<p>
if! は、指定の <strong>式</strong> が nil かどうかを判定し、分岐します。</p>
<p>
次に if! の例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( val:int! ): int! {
   return val;
}
fn sub( val:int! ): int {
   if! func( val ) {
      return _exp + 10;
   }  
   else {
      return 0;
   }
}
print( sub( 1 ) ); // 11
print( sub( nil ) ); // 0</code></pre>
</div>
<p>
この例では <code class="verbatim">func()</code> に対して if! で分岐しています。</p>
<ul>
<li><code class="verbatim">func()</code> が 非 nil の場合、 <code>return _exp + 10;</code> を実行</li>
<li><code class="verbatim">func()</code> が nil の場合、 return 0 を実行</li>
</ul>
<p>if! は、指定の式が非 nil だった時に、最初のブロックを実行します。
このブロック内では、式の結果を <strong>_exp</strong> としてアクセスできます。
このとき、 _exp は <strong>非 nilable 型</strong> です。</p>
<p>
if! に指定した式が nil だった場合、
else ブロックを実行します。
else は省略可能です。</p>
<p>
ちなみに、 if! で指定した式が複数の値を返す場合、
最初の戻り値だけが対象です。
2 つ目以降の戻り値は無視します。</p>
<p>
なお、 if! は次のようなネストは出来ません。</p>
<p>
なぜならば、 内側の if! の _exp が、外側の if! の _exp によって、
shadowing されるためです。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
   if! func( val ) {
      if! func( val ) {
         return _exp + 10;
      }  
      else {
         return 0;
      }  
   }</code></pre>
</div>
<p>
これを防ぐためには、次の if! let を使用してください。</p>
</div>
</div>
<div id="outline-container-headline-174" class="outline-4">
<h4 id="headline-174">
if! let
</h4>
<div id="outline-text-headline-174" class="outline-text-4">
<p>
if! let は、 if! で判定する式の結果を格納する変数名を指定可能なバージョンです。</p>
<p>
次は if! let のサンプルです。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( val1:int!, val2:int! ): int!, int! {
   return val1, val2;
}
fn sub( val1:int!, val2:int! ): int {
   if! let work1, work2 = func( val1, val2 ) {
      return work1 + work2;
   }  
   else {
      return 0;
   }
}
print( sub( 1, 2 ) ); // 3
print( sub( nil, 2 ) ); // 0
print( sub( 1, nil ) ); // 0
print( sub( nil, nil ) ); // 0</code></pre>
</div>
<p>
この例では <code>if! let work1, work2 = func( val1, val2 )</code> を実行しています。</p>
<p>
これは、 <code class="verbatim">func()</code> の結果を work1, work2 に代入し、
全てが非 nil だった場合に最初のブロックを実行します。
このブロック内では work1, work2 にアクセスできます。
work1, work2 は、 非 nilable 型となります。
if! let で宣言した変数のスコープは、最初のブロックです。</p>
<p>
何れかが nilable の場合、else ブロックを実行します。
else は省略可能です。</p>
</div>
</div>
<div id="outline-container-headline-175" class="outline-4">
<h4 id="headline-175">
let!
</h4>
<div id="outline-text-headline-175" class="outline-text-4">
<p>
let! は、nil 以外の初期値を持つ変数宣言を行ないます。</p>
<p>
次に let! のサンプルを示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( val1:int!, val2:int! ): int!, int! {
   return val1, val2;
}
fn sub( val1:int!, val2:int! ): int {
   let mut work0 = 0;
   let! work1, work2 = func( val1, val2 ) {
      work1 = 0;
      work2 = 0;
   }
   then {
      work0 = 10;
   };     
   return work0 + work1 + work2;
}
print( sub( 1, 2 ) ); // 3
print( sub( nil, 2 ) ); // 0
print( sub( 1, nil ) ); // 0
print( sub( nil, nil ) ); // 0</code></pre>
</div>
<p>
この例では、 <code>let! work1, work2 = func( val1, val2 )</code> を実行しています。</p>
<ul>
<li>これは、 <code class="verbatim">func()</code> の結果を初期値とする work1, work2 を宣言しています。</li>
<li>work1, work2 <strong>いずれかが nil</strong> だった場合、最初のブロックを実行します。</li>
<li>全てが非 nil だった場合、then ブロックを実行します。 then は省略可能です。</li>
</ul>
<p>let の文には ; が必要です。
上記のサンプルでは、 then ブロック終端に <code>};</code> として ; を付加されています。</p>
<p>
最初のブロックには、次のいずれかを処理しなければならない制限があります。</p>
<ul>
<li>let で宣言している変数全てに値を設定する。</li>
<li>let を宣言しているスコープから抜ける。</li>
</ul>
<p>上記の例では、 work1, work2 に値を設定していますが、
return でこの関数を抜けるようにしても OK です。</p>
<p>
なお、上記制限が守られていない場合の動作は <strong>未定義</strong> です。</p>
</div>
</div>
<div id="outline-container-headline-176" class="outline-4">
<h4 id="headline-176">
unwrap!
</h4>
<div id="outline-text-headline-176" class="outline-text-4">
<p>
unwrap! は、 let! に似た制御です。異なるのは変数を宣言するのではなく、
既にある変数に対して代入する点です。</p>
<p>
次は、 unwrap! の例です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn test( arg:int! ) {
  let mut val = 0;

  unwrap! val = arg { print( 0 ); return; } then { val = val + 1; };
  print( val );
}
test( 1 );  // print( 2 );
test( 2 );  // print( 3 );
test( nil );  // print( 0 );</code></pre>
</div>
<p>
上記例の val は、 int 型変数です。
この変数に、unwrap! を使って int! 型の arg を代入しています。</p>
<p>
上記 <code>unwrap! val = arg { print( 0 ); return; } then { val = val + 1; };</code> は、
次の処理を行ないます。</p>
<ul>
<li>arg が nil の場合、 <code>{ print( 0 ); return; }</code> を実行する。</li>
<li>arg が非 nil の場合、 arg を val に代入する。さらに then ブロックを実行する。</li>
<li>then は省略可能です。</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-177" class="outline-3">
<h3 id="headline-177">
マップ型のアクセス
</h3>
<div id="outline-text-headline-177" class="outline-text-3">
<p>
Map 型データの要素にアクセスした場合、
その結果は nilable となります。</p>
<p>
たとえば次の場合、</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val = { &#34;abc&#34;: 1 };
let val2 = val.abc;</code></pre>
</div>
<p>
val2 は int ではなく、 int! となります。</p>
<p>
なぜならば、 Map 型の要素が存在しない場合、
その評価結果は nil になるためです。</p>
<p>
ちなみに、リスト、配列の要素アクセスは nilable にはなりません。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val = [ 1, 2, 3 ];
let val2 = val[ 1 ];</code></pre>
</div>
<p>
上の例では、 val2 は int! ではなく int になります。</p>
<p>
なお、 val[ 4 ] にアクセスした場合の動作は <strong>未定義</strong> です。</p>
<p>
リスト、配列にインデックスでアクセスする場合は、十分注意してください。</p>
<p>
リスト、配列のインデックスアクセス結果が nilable になるようにも考えましたが、
やり過ぎな気がしたので実施していません。</p>
</div>
</div>
<div id="outline-container-headline-178" class="outline-3">
<h3 id="headline-178">
まとめ
</h3>
<div id="outline-text-headline-178" class="outline-text-3">
<p>
LuneScript は、次の仕様によって nil 安全を実現しています。</p>
<ul>
<li>nilable と非 nilable</li>
<li>unwrap </li>
</ul>
<p>
次回はクラスについて説明します。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-closure_ja" class="outline-2">
<h2 id="closure_ja">
<strong>クロージャ</strong>
</h2>
<div id="outline-text-closure_ja" class="outline-text-2">
<p>
LuneScript はクロージャに対応している。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( mut val:int ): form {
   return fn () {
      val = val + 1;
      print( val );
   };
}

let sub1 = func( 10 );
sub1(##); // 11
sub1(##); // 12
sub1(##); // 13
sub1(##); // 14
let sub2 = func( 100 );
sub2(##); // 101
sub2(##); // 102
sub2(##); // 103
sub2(##); // 104</code></pre>
</div>
<p>
上記の関数 <code class="verbatim">func()</code> は、クロージャを生成して返す関数である。
このクロージャは、 func の引数 val をインクリメントして出力する関数である。</p>
<p>
このサンプルでは、func(10), func(100) をコールし、
それぞれで生成されたクロージャを sub1, sub2 セットし、4 回ずつコールしている。
これによって、 11 〜 14, 101 〜 104 が出力される。</p>
<hr>
</div>
</div>
<div id="outline-container-class1_ja" class="outline-2">
<h2 id="class1_ja">
<strong>クラス 基本 編</strong>
</h2>
<div id="outline-text-class1_ja" class="outline-text-2">
<p>
LuneScript は、クラスによるオブジェクト指向プログラミングをサポートします。</p>
<div id="outline-container-headline-181" class="outline-3">
<h3 id="headline-181">
クラスの仕様
</h3>
<div id="outline-text-headline-181" class="outline-text-3">
<p>
LuneScript のクラスは、次をサポートします。</p>
<ul>
<li>アクセス制御  </li>
<li>accessor</li>
<li>継承</li>
<li>abstract</li>
<li>override</li>
<li>advertise</li>
<li>Mapping</li>
<li>interface  </li>
</ul>
<p>今回は基本的なクラス定義を説明します。</p>
</div>
</div>
<div id="outline-container-headline-182" class="outline-3">
<h3 id="headline-182">
最小のクラス定義
</h3>
<div id="outline-text-headline-182" class="outline-text-3">
<p>
最小のクラス定義は次のように行ないます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
}</code></pre>
</div>
<p>
これは Test というクラスを定義しています。</p>
<p>
<del>なお、クラス定義は最上位のスコープで行なう必要があります。</del></p>
<p>
<strong>(2019/6/24) 関数内でもクラス定義できるように対応しました。
ただし、外部公開可能なクラスは最上位のスコープで宣言する必要があります。</strong></p>
<div id="outline-container-headline-183" class="outline-4">
<h4 id="headline-183">
外部公開
</h4>
<div id="outline-text-headline-183" class="outline-text-4">
<p>
クラスを外部モジュールに公開するには、
次のように pub を付加します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
pub class Test {
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-184" class="outline-3">
<h3 id="headline-184">
インスタンス生成
</h3>
<div id="outline-text-headline-184" class="outline-text-3">
<p>
クラスのインスタンス生成は、次のように new 演算子を使用します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
}
let test = new Test();</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-185" class="outline-3">
<h3 id="headline-185">
メソッド定義
</h3>
<div id="outline-text-headline-185" class="outline-text-3">
<p>
メソッド定義は、ほぼ関数定義と同じです。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pub fn func() {
      print( __func__ );
   }
}
let test = new Test();
test.func();  // Test.func</code></pre>
</div>
<p>
なお、メソッドは form 型にはセットできません。</p>
<p>
例えば、次の <code>sub( test.func )</code> はエラーします。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
class Test {
   pub fn func() {
      print( __func__ );
   }
}
fn sub( foo:form ) {
   foo();
}

let test = new Test();
sub( test.func );  // error</code></pre>
</div>
<p>
これをエラーしないようにするには、
次のように anonymous 関数を作成して <code class="verbatim">sub()</code> に渡します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pub fn func() {
      print( __func__ );
   }
}
fn sub( foo:form ) {
   foo();
}

let test = new Test();
sub( fn() { test.func(); } );</code></pre>
</div>
<div id="outline-container-headline-186" class="outline-4">
<h4 id="headline-186">
アクセス制御
</h4>
<div id="outline-text-headline-186" class="outline-text-4">
<p>
アクセス制御は次の 3 つです。</p>
<table>
<thead>
<tr>
<th>種別</th>
<th>意味</th>
</tr>
</thead>
<tbody>
<tr>
<td>pub</td>
<td>外部公開</td>
</tr>
<tr>
<td>local</td>
<td>同一モジュール内に公開</td>
</tr>
<tr>
<td>pro</td>
<td>サブクラスに公開</td>
</tr>
<tr>
<td>pri</td>
<td>非公開</td>
</tr>
</tbody>
</table>
<p>
指定しない場合、デフォルトは pri です。</p>
</div>
</div>
<div id="outline-container-headline-187" class="outline-4">
<h4 id="headline-187">
self シンボル
</h4>
<div id="outline-text-headline-187" class="outline-text-4">
<p>
メソッド内では、 self シンボルを利用できます。</p>
<p>
self シンボルは、自分自身のインスタンスを表します。</p>
<p>
次の例では、公開メソッドの sub から、
非公開メソッドの <code class="verbatim">func()</code> を self 使用してコールしています。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   fn func() {
      print( __func__ );
   }
   pub fn sub() {
      self.func();
   }
}
let test = new Test();
test.sub();  // Test.func</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-188" class="outline-4">
<h4 id="headline-188">
分離定義
</h4>
<div id="outline-text-headline-188" class="outline-text-4">
<p>
メソッドは、クラス定義と分離して定義することが出来ます。</p>
<p>
先ほどのメソッド定義は、次のようにも書けます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
}
pub fn Test.func() {
   print( __func__ );
}
let test = new Test();
test.func();  // Test.func</code></pre>
</div>
<p>
ただし、別モジュールで定義しているクラスのメソッドを、
import しているモジュール内で定義することは出来ません。</p>
</div>
</div>
<div id="outline-container-headline-189" class="outline-4">
<h4 id="headline-189">
プロトタイプ宣言
</h4>
<div id="outline-text-headline-189" class="outline-text-4">
<p>
メソッド定義は、クラス定義内に型だけを宣言し、実定義を分離することもできます。</p>
<p>
次の例では、 <code class="verbatim">func()</code> をプロトタイプ宣言し、実定義を分離しています。</p>
<p>
<code class="verbatim">func()</code> をプロトタイプ宣言することで、=sub()= 内で <code class="verbatim">func()</code> のコールが可能になります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   fn func();
   pub fn sub() {
      self.func();
   }
}
pub fn Test.func() {
   print( __func__ );
}
let test = new Test();
test.sub();  // Test.func</code></pre>
</div>
<p>
当然、プロトタイプ宣言と実定義のメソッドの型は、一致させる必要があります。</p>
</div>
</div>
<div id="outline-container-headline-190" class="outline-4">
<h4 id="headline-190">
クラスメソッド定義
</h4>
<div id="outline-text-headline-190" class="outline-text-4">
<p>
通常のメソッドはインスタンスに紐付いているためインスタンスがないと実行できませんが、
クラスに紐付いたクラスメソッドはインスタンスがなくても実行できます。</p>
<p>
クラスメソッドの定義は、メソッド定義に static を付加するだけです。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pub static fn sfunc() {
      print( __func__ );
   }
}
Test.sfunc(); // Test.sfunc</code></pre>
</div>
<p>
<strong>クラスメソッドは、最上位のスコープで定義したクラスでのみ利用可能です。</strong></p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-191" class="outline-3">
<h3 id="headline-191">
メンバ定義
</h3>
<div id="outline-text-headline-191" class="outline-text-3">
<p>
メンバ定義は、ほぼ変数定義と同じですが、次の違いがあります。</p>
<ul>
<li>宣言時に初期値の設定が出来ない</li>
<li>アクセス制御が追加</li>
<li>accessor 指定が可能</li>
</ul>
<p>
次にメンバ定義の例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pri let val1:int;
   pri let val2:int;
   pri let val3:int;
   pub fn func() {
      print( self.val1, self.val2, self.val3 );
   }

}
let test = new Test( 1, 2, 3 );
test.func(); // 1 2 3</code></pre>
</div>
<p>
クラス Test は、 val1, val2, val3 をメンバに持ちます。</p>
<p>
val1 の定義は <code>pri let val1:int;</code> となっています。</p>
<p>
これは、 これは通常の変数宣言に pri が付いただけなので問題ないと思います。</p>
<p>
pri はアクセス制御で、意味はメソッド定義と同じです。</p>
</div>
</div>
<div id="outline-container-headline-192" class="outline-3">
<h3 id="headline-192">
mutable
</h3>
<div id="outline-text-headline-192" class="outline-text-3">
<p>
メンバ、メソッドにも mutable と immutable があります。</p>
<p>
メソッドの mutable と immutable の違いは次の通りです。</p>
<ul>
<li>mutable なメソッドは、メンバを変更可能なメソッド</li>
<li>immutable なメソッドは、メンバを変更不可能なメソッド</li>
</ul>
<p>
次に mutable なメンバ、メソッドの例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pri let mut val1:int;
   pri let val2:int;
   pub fn func() {
      print( self.val1, self.val2 );
   }
   pub fn add( val:int ) mut {
      self.val1 = self.val1 + val;
   }
}
let mut test = new Test( 1, 2 );
test.func(); // 1 2
test.add( 10 );
test.func(); // 11 2</code></pre>
</div>
<p>
この例では、val1 が mutable で val2 が immutable です。
また <code class="verbatim">func()</code> が immutable で、 <code class="verbatim">add()</code> が mutable です。</p>
<p>
mutable なメソッドは、引数宣言後に <strong>mut</strong> を宣言します。</p>
<p>
mutable のメソッド <code class="verbatim">add()</code> は、 メンバ val1 に値をセットしています。
これはエラーせずにビルド可能です。</p>
<p>
では、次のように メソッド <code class="verbatim">add()</code> の mut 宣言を外した場合はどうなるかというと。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
class Test {
   pri let mut val1:int;
   pri let val2:int;
   pub fn func() {
      print( self.val1, self.val2 );
   }
   pub fn add( val:int ) {
      self.val1 = self.val1 + val;  // error
   }
}</code></pre>
</div>
<p>
上記の例は、エラーとなります。</p>
<p>
mutable でないメソッド内からメンバを変更しようとした場合、エラーします。</p>
<p>
次の場合もエラーします。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
class Test {
   pri let mut val:int;
   pub fn increment() mut {
      self.val = self.val + 1;
   }
   pub fn func() {
      self.increment(); // error
   }
}</code></pre>
</div>
<p>
上記の例では、 <code class="verbatim">func()</code> から <code class="verbatim">increment()</code> をコールしていますが、
immutable なメソッドから mutable なメソッドのコールは出来ません。</p>
</div>
</div>
<div id="outline-container-headline-193" class="outline-3">
<h3 id="headline-193">
allmut メンバ
</h3>
<div id="outline-text-headline-193" class="outline-text-3">
<p>
前述の通り、 あるクラスのメンバが mutable であっても、
そのクラスのインスタンスが immutable である場合、
そのメンバは immutable となります。</p>
<p>
次の例では、 <code class="verbatim">func()</code> メソッド内から mutable なメンバ val にアクセスしていますが、
<code class="verbatim">func()</code> メソッドは immutable であるため val もまた immutable となり、エラーします。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
class Test {
   pri let mut val:int;
   pub fn func() {
      self.val = self.val + 1;  // error
   }
}</code></pre>
</div>
<p>
mutablity は、意図しないタイミングでの値の変化を防止するために必要な概念です。
一方で、 immutable なメソッドからはいかなるメンバも変更できない、
というのは非常に厳しいルールです。</p>
<p>
このルールが適応されてしまうと、
例えば次のような場合、設計が難しくなってしまいます。</p>
<ul>
<li>キーに紐付けて、読み取り専用データを管理するクラス Data を考える</li>
<li>Data クラスには、引数にキーを与えると、紐付けられたデータを返すメソッド <code class="verbatim">get()</code> を定義する</li>
<li>管理する全てのデータを登録した Data インスタンスは、不要な変更を防ぐため immutable とする</li>
</ul>
<p>これは一般的な考え型だと思います。</p>
<p>
そして、開発が進んでから次の仕様を追加するとします。</p>
<ul>
<li>上記 <code class="verbatim">get()</code> メソッドの処理を高速化するため、
直前の引数キーと、そのキーに紐付けされたデータをキャッシュする</li>
</ul>
<p>この「直前の引数キーと、そのキーに紐付けされたデータをキャッシュする」という処理は、
データを書き換えることになります。
つまり、 immutable ではなく mutable である必要があります。</p>
<p>
一方で、既に Data インスタンスは多くの箇所で immutable として宣言されています。
つまり、キャッシュすることが出来ません。</p>
<p>
このような場合に利用するのが allmut です。
allmut は、メンバの mutablity を宣言し、
インスタンスの mutablity とは独立して常に mutable となります。</p>
<p>
次に allmut のサンプルを示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pri let allmut val:int;
   pub fn func() {
      self.val = self.val + 1;  // ok
   }
}</code></pre>
</div>
<p>
このように <code>pri let allmut val:int;</code>  と宣言することで、
val は常に mutable となります。
これにより、 immutable なメソッド <code class="verbatim">func()</code> から、
val を書き換えることが可能となります。</p>
<p>
<strong>ただし、allmutはあくまでも救済手段であり多用すべきではありません。</strong></p>
<p>
特に、後述する go での非同期プログラミングを行なう際に、
<strong>allmut があると安全性が担保されなくなります。</strong></p>
</div>
</div>
<div id="outline-container-headline-194" class="outline-3">
<h3 id="headline-194">
コンストラクタ定義
</h3>
<div id="outline-text-headline-194" class="outline-text-3">
<p>
コンストラクタは __init で定義できます。</p>
<p>
コンストラクタは、メソッド定義と次の点で異なります。</p>
<ul>
<li>コンストラクタ名は __init でなければならない。</li>
<li>戻り値の型を指定できない。</li>
<li>コンストラクタの定義は、全メンバ定義の後にしなければならない。</li>
<li>
<p>クラスを継承している場合、そのクラスのコンストラクタを先頭で実行しなければならない。</p>
<ul>
<li>super クラスのコンストラクタの実行は <code class="verbatim">super()</code> を使用する。</li>
</ul>
</li>
<li>
<p>コンストラクタは、全メンバを初期化しなければならない。</p>
<ul>
<li>nilable 型のメンバを明示的に初期化しない場合、 初期値 nil となります。</li>
</ul>
</li>
<li>
<p>コンストラクタ内の処理で全メンバを初期化してからでなければ、
そのクラスで定義するメソッドにアクセスできない。</p>
<ul>
<li>ただし static メソッド、 super クラスのメソッドにはアクセス可能。</li>
<li>また、コンストラクタ内ので定義した関数オブジェクトからはメソッドにアクセス可能。</li>
</ul>
</li>
<li>コンストラクタ内からは、プロトタイプ宣言しただけのメソッドはコールできない。</li>
<li>コンストラクタ内で return できない。</li>
</ul>
<p>次にコンストラクタの例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pri let val1:int;
   pri let val2:int;
   pub fn __init() {
      self.val1 = 0;
      self.val2 = 0;
   }
}
let test = new Test();</code></pre>
</div>
<p>
なお、コンストラクタでは immutable なメンバにも初期値を設定可能です。</p>
<div id="outline-container-headline-195" class="outline-4">
<h4 id="headline-195">
コンストラクタの引数
</h4>
<div id="outline-text-headline-195" class="outline-text-4">
<p>
コンストラクタは引数を持てます。
この引数は、new 演算子によって与えられます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pri let val1:int;
   pri let val2:int;
   pub fn __init( val1:int, val2:int ) {
      self.val1 = val1 + 10;
      self.val2 = val2 + 10;
   }
   pub fn func() {
      print( self.val1, self.val2 );
   }
}
let test = new Test( 1, 2 );
test.func(); // 11 12</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-196" class="outline-4">
<h4 id="headline-196">
デフォルトコンストラクタ
</h4>
<div id="outline-text-headline-196" class="outline-text-4">
<p>
コンストラクタを定義しない場合、
自動的に全メンバを設定するコンストラクタが生成されます。
このコンストラクタをデフォルトコンストラクタと言います。</p>
<p>
デフォルトコンストラクタは、全メンバを設定するための引数を持ちます。
引数の順番は、クラスのメンバの宣言順です。</p>
<p>
次のクラス宣言には、コンストラクタが宣言されていないため、
デフォルトコンストラクタが内部的に生成されます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pri let val1:int;
   pri let val2:int;
}</code></pre>
</div>
<p>
そのデフォルトコンストラクタは、次のように定義されます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
   pub fn __init( val1:int, val2:int ) {
      self.val1 = val1;
      self.val2 = val2;
   }</code></pre>
</div>
<p>
デフォルトコンストラクタのアクセス制御は pub です。</p>
<div id="outline-container-headline-197" class="outline-5">
<h5 id="headline-197">
派生クラスのデフォルトコンストラクタ
</h5>
<div id="outline-text-headline-197" class="outline-text-5">
<p>
派生クラスのデフォルトコンストラクタは、旧形式と現形式の 2 種類あります。</p>
<div id="outline-container-headline-198" class="outline-6">
<h6 id="headline-198">
現形式
</h6>
<div id="outline-text-headline-198" class="outline-text-6">
<p>
次のような派生クラス Sub の現形式デフォルトコンストラクタは、</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pro let val:int;
}
class Sub extend Test {
   let val2:int;
   pub fn func() {
      print( self.val, self.val2 );
   }
}
let sub = new Sub( 1, 2 );
sub.func(); // 1, 2</code></pre>
</div>
<p>
上記の <code>new Sub( 1, 2 )</code> ように、
super クラスのコンストラクタの引数 + 派生クラスの全メンバになります。</p>
</div>
</div>
<div id="outline-container-headline-199" class="outline-6">
<h6 id="headline-199">
旧形式
</h6>
<div id="outline-text-headline-199" class="outline-text-6">
<p>
次のような派生クラス Sub の旧形式デフォルトコンストラクタは、</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pro let val:int!;
}
class Sub extend Test {
   let val2:int;
   _lune_control default__init_old;
   pub fn func() {
      print( self.val, self.val2 );
   }
}
let sub = new Sub( 2 );
sub.func(); // nil, 2</code></pre>
</div>
<p>
上記の <code>new Sub( 2 )</code> ように、
派生クラスの全メンバになります。</p>
<p>
なお旧形式では、 super クラスの全ての引数は nilable でなければならないです。
また、 <code>_lune_control default__init_old;</code> で旧形式のデフォルトコンストラクタを
使用することを宣言する必要があります。
この宣言は、全メンバを宣言した後に宣言する必要があります。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-200" class="outline-5">
<h5 id="headline-200">
デフォルトコンストラクタの明示
</h5>
<div id="outline-text-headline-200" class="outline-text-5">
<p>
デフォルトコンストラクタは、
コンストラクタを定義しないと内部的に生成されます。</p>
<p>
しかしこの振舞いは、次のような処理を書いた時に問題になります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
class Test {
   pri let mut val:int {pub};
   pub static fn create(): Test {
      return new Test( 1 );  // error
   }
}</code></pre>
</div>
<p>
上記は、 <code class="verbatim">create()</code> メソッド内で Test クラスのインスタンスを生成していますが、
コンストラクタの宣言がないとしてエラーします。</p>
<p>
本来ならば、コンストラクタの定義がないのでデフォルトコンストラクタが
生成されるのですが、
デフォルトコンストラクタを定義するタイミングは、クラス定義終了時に行なうため、
クラス定義内の <code class="verbatim">create()</code> メソッドでは、コンストラクタがありません。</p>
<p>
このような場合、明示的にデフォルトコンストラクタを使用することを宣言します。</p>
<p>
次に例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pri let mut val:int {pub};
   _lune_control default__init;
   pub static fn create(): Test {
      return new Test( 1 );
   }
}</code></pre>
</div>
<p>
<code>_lune_control default__init;</code> を宣言すると、
デフォルトコンストラクタの使用を明示でき、
このタイミングでデフォルトコンストラクタが生成されます。</p>
<p>
なお <code>_lune_control default__init;</code> は、通常のコンストラクタと同じように、
全メンバの後に宣言する必要があります。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-201" class="outline-3">
<h3 id="headline-201">
クラスメンバ
</h3>
<div id="outline-text-headline-201" class="outline-text-3">
<p>
メソッドにクラスメソッドがあるように、メンバにもクラスメンバがあります。</p>
<p>
クラスメンバの定義も static を付けるだけです。</p>
<p>
クラスメンバの初期化は __init ブロックで行ないます。</p>
<p>
次はクラスメンバ定義の例です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pri static let val1:int;
   pri static let val2:int;

   __init {
      Test.val1 = 1;
      Test.val2 = 1;
   }
}</code></pre>
</div>
<p>
__init ブロックは、次の制限があります。</p>
<ul>
<li>
<p>__init ブロックの定義は、全クラスメンバ定義の後にしなければならない。</p>
<ul>
<li>nilable 型のメンバを明示的に初期化しない場合、 初期値 nil となります。</li>
</ul>
</li>
<li>__init ブロックは、全メンバを初期化しなければならない。</li>
<li>__init ブロック内で return できない。</li>
<li>__init ブロックからクラスメソッドをコールできるが、コールするクラスメソッドは、 
__init ブロックより前に宣言しなければならない。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-202" class="outline-3">
<h3 id="headline-202">
まとめ
</h3>
<div id="outline-text-headline-202" class="outline-text-3">
<p>
LuneScript のクラス定義は、次をサポートします。</p>
<ul>
<li>キーワード class でクラスを定義する</li>
<li>インスタンス生成は new</li>
<li>アクセス制御可能  </li>
<li>self シンボルで自分自身にアクセス</li>
<li>クラス定義とメソッド定義を分離可能</li>
<li>プロトタイプ宣言</li>
<li>static でクラスメソッド、クラスメンバ</li>
<li>コンストラクタは __init</li>
<li>コンストラクタを作成しない場合はデフォルトコンストラクタが作られる</li>
</ul>
<p>
次回は、 accessor の生成方法について説明します。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-class2accessor_ja" class="outline-2">
<h2 id="class2accessor_ja">
<strong>accessor 編</strong>
</h2>
<div id="outline-text-class2accessor_ja" class="outline-text-2">
<p>
今回はメンバの accessor について説明します。</p>
<div id="outline-container-headline-204" class="outline-3">
<h3 id="headline-204">
accessor
</h3>
<div id="outline-text-headline-204" class="outline-text-3">
<p>
メンバの accessor (get,set) を簡単に作成できます。</p>
<p>
次に例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pri let val1:int;
   pri let mut val2:int {pub,pub};
   pri let val3:int {pub};
}
let mut test = new Test( 1, 2, 3 );
print( test.$val2, test.$val3 );  // 2 3
test.set_val2( 10 );
print( test.$val2, test.$val3 );  // 10 3</code></pre>
</div>
<p>
上記例で val2 の定義は、 <code>pri let val2:int {pub,pub};</code> としています。</p>
<p>
この <code>{pub,pub}</code> は、 val2 の accessor を定義しています。
これは、 getter, setter のアクセス制御を指定します。
この指定によって、次のメソッドが内部的に作成されます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
pub fn Test.get_val2(): int {
   return self.val2;
}
pub fn Test.set_val2( val:int ) {
   self.val2 = val;
}</code></pre>
</div>
<p>
getter にアクセスする場合、 $ を使って次のようにアクセスします。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
let mut test = new Test( 1, 2, 3 );
print( test.$val2, test.$val3 );  // 2 3</code></pre>
</div>
<p>
<code>test.$val2</code> は、 <code>test.get_val2()</code> のシンタックスシュガーです。</p>
<p>
上記の通り、
accessor は「getter のアクセス制御」、「setter のアクセス制御」の順で宣言します。</p>
<p>
setter が不要な場合、「setter のアクセス制御」を省略します。</p>
<p>
なお、getter が不要で setter が必要な場合は、次のように宣言します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pri let mut val1:int {non,pub};
}</code></pre>
</div>
<p>
この機能は、 setter を自動で生成しつつ、 getter をカスタマイズする時などに利用できます。</p>
<p>
LuneScript の accessor は、普通のメソッドです。
C# のプロパティのような別のものではありません。</p>
</div>
</div>
<div id="outline-container-headline-205" class="outline-3">
<h3 id="headline-205">
getter の戻り値型
</h3>
<div id="outline-text-headline-205" class="outline-text-3">
<p>
getter の戻り値型は、通常そのメンバの型と一致します。</p>
<p>
例えば次の Test のメンバ list の getter は、 <code class="verbatim">List&lt;int&gt;</code> 型の戻り値を返します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pri let mut list:List&lt;int&gt; {pub};
}
let test = new Test( [] );
foreach val in test.$list { 
   print( val );
}</code></pre>
</div>
<p>
ここで、 <code class="verbatim">List&lt;int&gt;</code> 型は mutable な型であるので、
外部操作でメンバ list の値を変更できることになります。</p>
<p>
しかし、外部操作での参照は許可しても変更を許可したくない場面が多くあります。</p>
<p>
そのような時、 getter の戻り値型を制御することが出来ます。
制限する方法は次の 2 つあります。</p>
<ul>
<li>immutable な型として返す</li>
<li>super クラスや interface の型として返す</li>
</ul>
<div id="outline-container-headline-206" class="outline-4">
<h4 id="headline-206">
immutable な型として返す
</h4>
<div id="outline-text-headline-206" class="outline-text-4">
<p>
getter を次のように宣言することで、
mutable なメンバを immutable として返す getter を作成できます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pri let mut list:List&lt;int&gt; {pub&amp;};
}</code></pre>
</div>
<p>
この例では <code class="verbatim">pub&amp;</code> としています。
getterの「アクセス制御」に <strong>&amp;</strong> を付加することで、その戻り値型は immutable になります。</p>
</div>
</div>
<div id="outline-container-headline-207" class="outline-4">
<h4 id="headline-207">
super クラスや interface の型として返す
</h4>
<div id="outline-text-headline-207" class="outline-text-4">
<p>
getter を次のように宣言することで、
メンバの型そのものではなく、 super クラスや interface の型として返すことが出来ます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Val {
}
class ValSub extend Val {
}

class Test {
   pri let val1:ValSub {pub};
   pri let val2:ValSub {pub:Val};
}
let test = new Test( new ValSub(), new ValSub() );
let val1 = test.$val1;
let val2 = test.$val2;</code></pre>
</div>
<p>
ここで、 <code class="verbatim">Test.val1</code> の getter は <strong>pub</strong> ですが、
Test.val2 の getter は <strong>pub:Val</strong> としています。</p>
<p>
これにより <code class="verbatim">test.$val1</code> は <code class="verbatim">ValSub</code> 型を返しますが、 <code class="verbatim">test.$val2</code> は Sub 型を返します。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-208" class="outline-3">
<h3 id="headline-208">
accessor のカスタマイズ
</h3>
<div id="outline-text-headline-208" class="outline-text-3">
<p>
LuneScript の accessor は、 C# のプロパティのようなカスタマイズ機能
(単純な setter/getter ではない処理を実装する機能)は用意していません。</p>
<p>
なぜならば、 LuneScript の accessor は、単なるメソッド宣言の簡略化機能であり、
C# のプロパティのような「別物」ではないので、
もしも独自処理を行なう accessor が必要ならばその処理を自分で作成すれば良いためです。</p>
<p>
なお、 独自の getter を定義した場合も $ は利用できます。</p>
<p>
$val は、 <code class="verbatim">get_val()</code> のシンタックスシュガーで、accessor 専用ということではありません。</p>
</div>
</div>
<div id="outline-container-headline-209" class="outline-3">
<h3 id="headline-209">
まとめ
</h3>
<div id="outline-text-headline-209" class="outline-text-3">
<p>
LuneScript の accessor は次の仕様です。</p>
<ul>
<li>メンバ宣言と同時に宣言出来る</li>
<li>getter, setter の順に宣言する</li>
<li>getter にアクセスする場合、 メンバ名の前に $ を付加する。</li>
<li>accessor は簡易メソッド定義であり、メソッドと異なる概念ではない。</li>
</ul>
<p>
次回は継承を説明します。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-classinherit_ja" class="outline-2">
<h2 id="classinherit_ja">
<strong>クラス 継承 編</strong>
</h2>
<div id="outline-text-classinherit_ja" class="outline-text-2">
<p>
LuneScript は、クラスの継承をサポートします。</p>
<div id="outline-container-headline-211" class="outline-3">
<h3 id="headline-211">
クラスの継承
</h3>
<div id="outline-text-headline-211" class="outline-text-3">
<p>
次にクラスの継承例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Super {
   pub fn func() {
      print( __func__ );
   }
}
class Sub extend Super {
}
let sub = new Sub();
sub.func(); // Super.func</code></pre>
</div>
<p>
これは、 Super クラスを Sub クラスが継承する例です。</p>
<p>
継承は、クラス宣言時に extend を使用して継承する親クラスを指定します。</p>
<p>
継承可能なクラスは 1 つだけです。</p>
<p>
なお、コンストラクタのアクセス制御が pri の場合、
そのクラスを継承することは出来ません。</p>
<div id="outline-container-headline-212" class="outline-4">
<h4 id="headline-212">
サブクラスのコンストラクタ
</h4>
<div id="outline-text-headline-212" class="outline-text-4">
<p>
親クラスのコンストラクタが引数を持つ場合、
サブクラスはコンストラクタを宣言する必要があります。</p>
<p>
例えば次の例では、 Super クラスはコンストラクタを明示的に宣言していませんが、
メンバ val を初期化する引数を持つデフォルトコンストラクタが内部的に生成されます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Super {
   pro let val:int;
}
class Sub extend Super {
   pub fn __init( val:int ){
      super( val );
   }
   pub fn func() {
      print( self.val );
   }
}
let sub = new Sub( 1 );
sub.func(); // 1</code></pre>
</div>
<p>
この時 Super を継承する Sub クラスは、親クラスが引数を持つコンストラクタを持つため、
Sub クラスのコンストラクタを宣言する必要があります。
また、Sub クラスのコンストラクタ内で 親クラス Super のコンストタクタを実行するため、
<code class="verbatim">super()</code> を呼びます。この <code class="verbatim">super()</code> は、最初の行に書く必要があります。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-213" class="outline-3">
<h3 id="headline-213">
まとめ
</h3>
<div id="outline-text-headline-213" class="outline-text-3">
<p>
LuneScript は次の仕様のクラス継承をサポートします。</p>
<ul>
<li>継承可能なクラスは 1 つだけ</li>
<li>サブクラスは、親クラスのコンストラクタをコールしなければならない。</li>
<li>親クラスのコンストラクタ呼び出しは <code class="verbatim">super()</code> で行なう。</li>
<li><code class="verbatim">super()</code> は、コンストラクタの最初の行に各必要があ。</li>
</ul>
<p>
次回は、メソッドのオーバーライドについて説明します。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-classadvertise_ja" class="outline-2">
<h2 id="classadvertise_ja">
<strong>クラス advertise 編</strong>
</h2>
<div id="outline-text-classadvertise_ja" class="outline-text-2">
<p>
LuneScript は、クラスが保持するメンバのメソッドに対して、
透過的にアクセスさせることが出来ます。</p>
<div id="outline-container-headline-215" class="outline-3">
<h3 id="headline-215">
advertise
</h3>
<div id="outline-text-headline-215" class="outline-text-3">
<p>
「透過的にアクセス」という表現では伝わり難いと思うので、次の例で説明します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
abstract class Test {
   pub abstract fn foo(): str;
   pub abstract fn bar(): str;
}
class TestSub1 extend Test {
   pub override fn foo(): str {
      return &#34;foo&#34;;
   }
   pub override fn bar(): str {
      return &#34;bar&#34;;
   }
}
class TestSub2 extend Test {
   pri let sub:TestSub1;
   advertise sub;
   pub override fn bar(): str {
      return &#34;hoge&#34; .. self.sub.bar();
   }
}
fn func( test:Test ){
   print( test.foo(), test.bar() );
}
func( new TestSub1() ); // foo, bar
func( new TestSub2( new TestSub1() ) ); // foo, hogebar</code></pre>
</div>
<p>
TestSub2 は、 メンバ sub を advertise しています。</p>
<p>
これにより TestSub2 は、
次のようにメンバ sub のメソッド (foo,bar) をコールする処理を内部的に生成します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
pub override fn TestSub2.foo(): str {
   return self.sub.foo();
}
pub override fn TestSub2.bar(): str {
   return self.sub.bar();
}</code></pre>
</div>
<p>
この例の TestSub2 では、メソッド <code class="verbatim">bar()</code> を宣言しています。</p>
<p>
このように宣言したメソッドと、advertise で生成されるメソッドが同名の場合、
宣言したメソッドが優先されます。</p>
<div id="outline-container-headline-216" class="outline-4">
<h4 id="headline-216">
注意
</h4>
<div id="outline-text-headline-216" class="outline-text-4">
<p>
複数のメンバを advertise した時、
そのメンバ間で同名のメソッドがある場合の動作は <strong>未定義</strong> です。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-217" class="outline-3">
<h3 id="headline-217">
まとめ
</h3>
<div id="outline-text-headline-217" class="outline-text-3">
<ul>
<li>advertise 宣言することで、メンバのメソッドを透過的にアクセスさせることが出来る</li>
<li>複数のメンバを advertise する場合は注意が必要</li>
</ul>
<p>次回は、インタフェースについて説明します。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-classoverride_ja" class="outline-2">
<h2 id="classoverride_ja">
<strong>クラス override 編</strong>
</h2>
<div id="outline-text-classoverride_ja" class="outline-text-2">
<p>
LuneScript は、メソッドの override をサポートします。</p>
<div id="outline-container-headline-219" class="outline-3">
<h3 id="headline-219">
メソッドの override
</h3>
<div id="outline-text-headline-219" class="outline-text-3">
<p>
クラスのメソッドは全て override 可能です。</p>
<p>
むしろ、現在は override を抑制することができません。</p>
<p>
メソッドの override の例を次に示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Super {
   pub fn func() {
      print( __func__ );
   }
}
class Sub extend Super {
   pub override fn func() {
      print( __func__ );
   }
}
fn test( obj:Super ) {
   obj.func();
}
test( new Super() ); // Super.func
test( new Sub() ); // Sub.func</code></pre>
</div>
<p>
ここで、 Sub クラスは Super クラスの func メソッドを override しています。</p>
<p>
override する Sub クラス側のメソッドは、
override キーワードで明示する必要があります。</p>
</div>
</div>
<div id="outline-container-headline-220" class="outline-3">
<h3 id="headline-220">
親クラスのメソッド呼び出し
</h3>
<div id="outline-text-headline-220" class="outline-text-3">
<p>
override しているサブクラスから、親クラスのメソッドをコールするには、
<code class="verbatim">super()</code> を使用します。</p>
<p>
次に <code class="verbatim">super()</code> の例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Super {
   pub fn func(): int {
      return 1;
   }
}
class Sub extend Super {
   pub override fn func(): int {
      return 10 + super();
   }
}
fn test( obj:Super ) {
   print( obj.func() );
}
test( new Sub() ); // 11</code></pre>
</div>
<p>
この例では、 Super クラスの <code class="verbatim">func()</code> メソッドを Sub クラスで override しています。
そして、 Sub クラスの <code class="verbatim">func()</code> から <code class="verbatim">super()</code> を使用して、
Super クラスの <code class="verbatim">func()</code> メソッドを呼び出しています。</p>
</div>
</div>
<div id="outline-container-headline-221" class="outline-3">
<h3 id="headline-221">
abstract
</h3>
<div id="outline-text-headline-221" class="outline-text-3">
<p>
実体を持たない abstract メソッドを定義できます。</p>
<p>
次に abstract の例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
abstract class Super {
   pub abstract fn func(): int;
}
class Sub extend Super {
   pub override fn func(): int {
      return 10;
   }
}
fn test( obj:Super ) {
   print( obj.func() );
}
test( new Sub() );</code></pre>
</div>
<p>
この例で、 <code class="verbatim">func()</code> メソッドは実体を持たない abstract メソッドです。</p>
<p>
なお、 abstract メソッドを持つクラスは abstract クラスとして宣言する必要があります。</p>
<p>
abstract メソッドの実体は、 継承したクラスで定義されます。
もしも、親クラスの全ての abstract メソッドを継承したクラスで override しないと、
その継承したクラスは abstract として宣言する必要があります。</p>
<p>
abstract クラスは、それ単体ではインスタンスを生成できなくなります。</p>
</div>
</div>
<div id="outline-container-headline-222" class="outline-3">
<h3 id="headline-222">
まとめ
</h3>
<div id="outline-text-headline-222" class="outline-text-3">
<p>
LuneScript のメソッド override/abstract の仕様は次の通りです。</p>
<ul>
<li>全てのメソッドは override 出来る</li>
<li>override するクラスは、 override を明示する必要がある</li>
<li>override しているメソッドから、 override 元のメソッドをコールするには <code class="verbatim">super()</code> を利用する。</li>
<li>実体の持たない abstract メソッドを宣言できる</li>
<li>abstract メソッドを持つクラスは abstract クラスとなる</li>
<li>abstract メソッドは、サブクラスで override しなければならない</li>
<li>abstract クラスは、単体ではインスタンスを生成できない</li>
</ul>
<p>次回は、 class の advertise について説明します。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-interface_ja" class="outline-2">
<h2 id="interface_ja">
<strong>インタフェース 編</strong>
</h2>
<div id="outline-text-interface_ja" class="outline-text-2">
<p>
LuneScript は、クラスの多重継承をサポートしない代わりに、
インタフェースをサポートします。</p>
<div id="outline-container-headline-224" class="outline-3">
<h3 id="headline-224">
インタフェース
</h3>
<div id="outline-text-headline-224" class="outline-text-3">
<p>
Java や C# を使用していればお馴染だと思いますが、
インタフェースは機能が制限されたクラスと考えて問題ないです。</p>
<p>
具体的には、インタフェースは、クラスと次の違いがあります。</p>
<ul>
<li>宣言は class ではなく interface。</li>
<li>メンバが持てない。</li>
<li>メソッドは全て abstract。 よってインタフェース単体ではインスタンスを生成できない。</li>
<li>インタフェースを実装するクラスは、extend に () を付ける</li>
<li>クラスは複数のインタフェースを実装できる</li>
<li>イタフェースを実装するクラスのメソッドには override を付けない。</li>
</ul>
<p>次にインタフェースの例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
interface IF {
   pub fn func();
}
class Test extend (IF) {
   pub fn func() {
      print( __func__ );
   }
}
fn sub( obj:IF ) {
   obj.func();
}
sub( new Test() ); // Test.func</code></pre>
</div>
<p>
この例では、インタフェース IF を定義しています。</p>
<p>
次に 2 つのインタフェースを実装するクラスの例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
interface IF1 {
   pub fn func1();
}
interface IF2 {
   pub fn func2();
}
class Test extend (IF1,IF2) {
   pub fn func1() {
      print( __func__ );
   }
   pub fn func2() {
      print( __func__ );
   }
}
fn sub( obj1:IF1, obj2:IF2 ) {
   obj1.func1();
   obj2.func2();
}
let mut test = new Test();
sub( test, test ); // Test.func Test.func2</code></pre>
</div>
<p>
複数のインタフェースを実装する場合、 extend の後に () の中に続けて宣言します。</p>
<p>
ちなみに、複数のインタフェースを実装する場合の制限として、
次のように実装するインタフェース内に、
同名で異なる型のメソッドがある場合、エラーとなります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
interface IF1 {
   pub fn func():int;
}
interface IF2 {
   pub fn func():str;
}
class Test extend (IF1,IF2) { // mismatch IF1.func, IF2.func
}</code></pre>
</div>
<p>
なお、現在のインタフェースの仕様として、メソッドのデフォルト処理はサポートしていません。</p>
</div>
</div>
<div id="outline-container-headline-225" class="outline-3">
<h3 id="headline-225">
まとめ
</h3>
<div id="outline-text-headline-225" class="outline-text-3">
<p>
LuneScript は、クラスの多重継承をサポートしない代わりに、
インタフェースをサポートします。</p>
<p>
次回は、Mapping について説明します。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-classmapping_ja" class="outline-2">
<h2 id="classmapping_ja">
<strong>mapping 編</strong>
</h2>
<div id="outline-text-classmapping_ja" class="outline-text-2">
<p>
LuneScript は、クラスのインスタンスとマップとの相互変換をサポートします。</p>
<div id="outline-container-headline-227" class="outline-3">
<h3 id="headline-227">
mapping
</h3>
<div id="outline-text-headline-227" class="outline-text-3">
<p>
LuneScript は、クラスのインスタンスとマップオブジェクトとの相互変換をサポートします。</p>
<p>
具体的には、次が可能です。</p>
<ul>
<li>クラスのインスタンスからマップオブジェクトの生成</li>
<li>マップオブジェクトからクラスのインスタンスの生成</li>
</ul>
<p>これによって、例えばクラスのインスタンスから JSON データを生成したり、
逆に JSON データからクラスのインスタンスを生成できます。</p>
<p>
この機能を mapping と呼びます。</p>
<p>
mapping を利用するには、
クラス宣言時に実装するインタフェースとして Mapping を宣言する必要があります。</p>
<p>
次に例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test extend (Mapping){
   let val1:int {pub};
   let val2:str {pub};
}
let test = new Test(1, &#34;abc&#34; );
let map = test._toMap();
print( map.val1, map.val2 ); // 1 abc
let test2 = unwrap Test._fromMap( map );
print( test2.$val1, test2.$val2 ); // 1 abc</code></pre>
</div>
<p>
上記の例では、 クラス Test が Mapping 実装を宣言しています。</p>
<p>
これにより、次のメソッドが内部的に生成されます。</p>
<ul>
<li>fn _toMap():&amp;Map&lt;str,&amp;stem&gt;</li>
<li>static fn _fromMap(map:&amp;Map&lt;str,&amp;stem&gt;):Test!,str!</li>
</ul>
<p><code class="verbatim">_toMap()</code> は、インスタンスからマップオブジェクトを生成するメソッドで、
<code class="verbatim">_fromMap()</code> は、マップオブジェクトからインスタンスを生成するクラスメソッドです。</p>
<p>
なお <code class="verbatim">_fromMap()</code> は、マップオブジェクトがインスタンスを生成するための
条件を満さない場合は nil を返します。</p>
<p>
具体的には、上記 Test の <code class="verbatim">_fromMap()</code> に、
次のマップオブジェクトを渡した場合はインスタンスが生成されますが、</p>
<div class="src src-js">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="s2">&#34;val1&#34;</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">   <span class="s2">&#34;val2&#34;</span><span class="o">:</span> <span class="s2">&#34;abc&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>
次のマップオブジェクトを渡した場合は、インスタンスが生成されません。</p>
<div class="src src-js">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="s2">&#34;val1&#34;</span><span class="o">:</span> <span class="mi">1</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">   <span class="s2">&#34;val2&#34;</span><span class="o">:</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>
上記マップオブジェクトの場合、本来 val2 が str であるはずが、
int になっていて不整合となるためです。</p>
<p>
さらに <code class="verbatim">_fromMap()</code> の注意点として、
<code class="verbatim">_fromMap()</code> はメンバの型の不整合は確認しますが、値域は確認しません。</p>
<p>
たとえば、本来取り得ない値からでも、型さえあっていればインスタンスを生成します。
ただし enum に関しては、マップオブジェクトの値が enum で定義していない値であれば、
nil を返します。</p>
<div id="outline-container-headline-228" class="outline-4">
<h4 id="headline-228">
mapping の制限
</h4>
<div id="outline-text-headline-228" class="outline-text-4">
<p>
mapping を実装するクラスには、メンバに次の制限が付きます。</p>
<ul>
<li>クラスインスタンスをメンバに持つ場合、そのクラスは mapping 可能でなければならない。</li>
<li>マップオブジェクトをメンバに持つ場合、キーは int, real, str のいずれかでなければならない。</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-229" class="outline-3">
<h3 id="headline-229">
まとめ
</h3>
<div id="outline-text-headline-229" class="outline-text-3">
<p>
mapping によって、
クラスのインスタンスから JSON データの生成などが簡単に実現できます。</p>
<p>
次回は、nil 条件演算子について説明します。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-generics_ja" class="outline-2">
<h2 id="generics_ja">
<strong>generics 編</strong>
</h2>
<div id="outline-text-generics_ja" class="outline-text-2">
<p>
ここでは、 LuneScript がサポートする Generics について説明します。</p>
<p>
LuneScript では当初、組込み型の List/Array/Map でのみ Generics をサポートしていましたが、
ユーザ定義の関数やクラスでも Generics をサポートしました。</p>
<div id="outline-container-headline-231" class="outline-3">
<h3 id="headline-231">
関数
</h3>
<div id="outline-text-headline-231" class="outline-text-3">
<p>
関数の Generics は次のように宣言します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func&lt;T&gt;( val:T ) : Set&lt;T&gt; {
   return (@ val);
}</code></pre>
</div>
<p>
上記サンプルを見ればだいたい理解できると思いますが、
関数宣言する際に 関数名 + <code>&lt;仮型パラメータ&gt;</code> で宣言します。</p>
<p>
ここで func&lt;T&gt;() は、引数の値を持つ Set&lt;T&gt; を生成する関数です。</p>
<p>
仮型パラメータは、複数指定することができます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func&lt;T1,T2&gt;( val1:T1, val2:T2 ) : Set&lt;T1&gt;, List&lt;T2&gt; {
   return (@ val1), [ val2 ];
}</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-232" class="outline-3">
<h3 id="headline-232">
nilable, mutable
</h3>
<div id="outline-text-headline-232" class="outline-text-3">
<p>
仮型パラメータは、通常の型と同じく nilable や mutable の概念を持ちます。</p>
<p>
これにより、次のような処理を書けます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func1&lt;T&gt;( val:T ) : T {
   return val;
}
fn func2&lt;T&gt;( val:T ) : &amp;T {
   return val;
}
fn func3&lt;T&gt;( val:T ) : T! {
   return val;
}
let mut test1 = func1( [ 1, 2 ] );
test1.insert( 1 );
let mut test2 = func2( [ 1, 2 ] );
test2.insert( 1 ); // error test2 is not mutable
let mut test3 = func3( [ 1, 2 ] );
test3.insert( 1 ); // error test3 is nilable</code></pre>
</div>
<ul>
<li>func1 は、引数をそのままの型 T で返します。</li>
<li>func2 は、引数を immutable 型 &amp;T で返します。</li>
<li>func3 は、引数を nilable 型 T! で返します。</li>
</ul>
<p>これにより、 <code class="verbatim">test1.insert()</code> は可能ですが、
test2, test3 はコンパイルエラーとなります。</p>
<p>
なお、ここで気を付けなければならないことは、
仮型パラメータを使用する時は nilable や mutable を利用できますが、
仮型パラメータ名を宣言するときは使用できません。
つまり、次のような <code>func1&lt;T!&gt;</code> はエラーとなります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func1&lt;T!&gt;( val:T ) : T {
   return val;
}</code></pre>
</div>
<p>
また、仮型パラメータに nilable は利用できません。
つまり、次の場合エラーします。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
fn func1&lt;T&gt;( val:T ) : T {
   return val;
}
let val:int! = 1;
print( func1( val ) ); // error type mismatch</code></pre>
</div>
<p>
この例では、 func1( val ) によって int! が func1() に与えられますが、
<code>func1&lt;T&gt;(val:T)</code> の val は T であり、
仮型パラメータは nilable を利用できないためエラーとなります。</p>
<p>
このような処理を行なわせたい場合は、次のように宣言します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func1&lt;T&gt;( val:T! ) : T {
   return unwrap val;
}
let val:int! = 1;
print( func1( val ) ); // ok</code></pre>
</div>
<p>
つまり、 <code>fn func1&lt;T&gt;( val:T! )</code> とすることで、
func1() の引数が nilable であることを宣言します。</p>
<p>
しかし、nilable の値を扱えないと不便なこともあります。
そのような場合に備えて Nilable&lt;T&gt; を用意しています。</p>
<p>
これについては、後日別途説明します。</p>
<div id="outline-container-headline-233" class="outline-4">
<h4 id="headline-233">
サンプル
</h4>
<div id="outline-text-headline-233" class="outline-text-4">
<p>
Generics を利用すると、次のような処理が書けます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func&lt;T&gt;( val:T ) : Set&lt;T&gt; {
   return (@ val);
}
foreach val in func( &#34;foo&#34; ) {
   print( val .. &#34;bar&#34; );  // foobar
}
foreach val in func( 1 ) {
   print( val + 100 );  // 101
}</code></pre>
</div>
<p>
func( &#34;foo&#34; ) は、 (@ &#34;foo&#34; ) の Set&lt;str&gt; を生成し、
func( 1 ) は、 (@ 1 ) の Set&lt;int&gt; を生成します。</p>
<p>
上記を見ると分かる通り、コールした引数に応じて型パラメータを決定しています。</p>
<div id="outline-container-headline-234" class="outline-5">
<h5 id="headline-234">
効果
</h5>
<div id="outline-text-headline-234" class="outline-text-5">
<p>
Generics ではなく、stem を利用することで次のように似たような処理を記載できます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( val:stem ) : Set&lt;stem&gt; {
   return (@ val);
}
foreach val in func( &#34;foo&#34; ) {
   print( val@@str .. &#34;bar&#34; );
}
foreach val in func( 1 ) {
   print( val@@int + 100 );
}</code></pre>
</div>
<p>
しかしこの場合、 str や int などの型情報が stem に丸められてしまいます。
stem に丸められてしまうので <code>@@str</code> や <code>@@int</code> のキャストが必要になります。</p>
<p>
キャストするのは不便ですし、なによりも非常に危険です。</p>
<p>
Generics を利用することで、キャストを使わずに安全にアクセスできます。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-235" class="outline-3">
<h3 id="headline-235">
クラス
</h3>
<div id="outline-text-headline-235" class="outline-text-3">
<p>
クラスの Generics は次のように宣言します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test&lt;T&gt; {
   let val:T;
   pub fn func() : List&lt;T&gt; {
      return [ self.val ];
   }
}</code></pre>
</div>
<p>
クラスの場合、クラス宣言の名前を指定する際に仮型パラメータを指定します。</p>
<p>
なお、クラス宣言の外にメソッドを宣言する場合、
次のように仮型パラメータの宣言は不要です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
pub fn Test.func2() : Set&lt;T&gt; {
   return (@ self.val );
}</code></pre>
</div>
<p>
Generics クラスのインスタンスは次のように生成します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
let test = new Test&lt;str&gt;( &#34;abc&#34; );</code></pre>
</div>
<p>
なお、コンストラクタの引数に全ての仮パラメータを使用している場合、
次のように実型パラメータを省略することも可能です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
let test = new Test( &#34;abc&#34; );</code></pre>
</div>
<p>
<strong><strong>インタフェースは generics 対応していません。</strong></strong></p>
</div>
</div>
<div id="outline-container-headline-236" class="outline-3">
<h3 id="headline-236">
メソッド
</h3>
<div id="outline-text-headline-236" class="outline-text-3">
<p>
メソッドは、クラスの仮型パラメータと、メソッドの仮型パラメータを両方持てます。</p>
<p>
次のサンプルは <code class="verbatim">Test.func()</code> メソッドは、
クラスの仮型パラメータ T と、メソッドの仮型パラメータ T2 を持っています。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test&lt;T&gt; {
   let val:T;
   pub fn func&lt;T2&gt;(val:T2) : Map&lt;T,T2&gt; {
      return { self.val: val };
   }
}
let test = new Test( &#34;abc&#34;);
foreach val, key in test.func( 1 ) {
   print( key .. &#34;xyz&#34;, val + 10 );
}
foreach val, key in test.func( &#34;ABC&#34; ) {
   print( key .. &#34;xyz&#34;, val .. &#34;XYZ&#34; );
}</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-237" class="outline-3">
<h3 id="headline-237">
型パラメータの制約
</h3>
<div id="outline-text-headline-237" class="outline-text-3">
<p>
実型パラメータには、 nil 以外の全ての型を指定できます。</p>
<p>
このため、 Generics なクラスや関数内で仮型パラメータ型の値に対する処理は
<code>==</code> や <code class="verbatim">~=</code> などの型に依存しない演算に限られます。</p>
<p>
これだと、Generics 内の処理で効果的な処理を書けません。</p>
<p>
そこで、型パラメータの制約を利用します。</p>
<div id="outline-container-headline-238" class="outline-4">
<h4 id="headline-238">
サンプル
</h4>
<div id="outline-text-headline-238" class="outline-text-4">
<p>
次は、型パラメータ制約のサンプルです。</p>
<p>
ここでは、 <code>class Test&lt;T:Val&gt;</code> と宣言することで、
Test クラスの仮型パラメータは Val クラスに限られます。</p>
<p>
これにより、 <code class="verbatim">Test.sub()</code> メソッド内で val の値に対し、
Val クラスのメソッド <code class="verbatim">func()</code> をコールできるようになります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
abstract class Val {
   pub abstract fn func(): str;
}
class Test&lt;T:Val&gt; {
   let val:T;
   pub fn sub() {
      print( &#34;this is &#34; .. self.val.func() );
   }
}</code></pre>
</div>
<p>
次は、この Test クラスを使ったサンプルです。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
abstract class Val {
   pub abstract fn func(): str;
}
class Test&lt;T:Val&gt; {
   let val:T;
   pub fn sub() {
      print( &#34;this is &#34; .. self.val.func() );
   }
}

class Val1 extend Val {
   pub override fn func(): str {
      return &#34;val1&#34;;
   }
}

class Val2 extend Val {
   pub override fn func(): str {
      return  &#34;val2&#34;;
   }
}

fn func1( test:Test&lt;Val1&gt; ) {
   test.sub();
}
fn func2( test:Test&lt;Val2&gt; ) {
   test.sub();
}

func1( new Test( new Val1() ) );  // this is val1
func2( new Test( new Val2() ) );  // this is val2</code></pre>
</div>
<p>
このサンプルの構成は次になります。</p>
<ul>
<li>Val1, Val2 クラスは、Val クラスを継承したクラス</li>
<li><code class="verbatim">func()</code> 関数は Test 型の引数 test を持ち、 <code class="verbatim">test.sub()</code> メソッドをコール。</li>
<li><code>new Test( new Val1() )</code>, <code>new Test( new Val2() )</code> によって、
Val1 と Val2 の実型パラメータの Test 型のインスタンスを生成し <code class="verbatim">func()</code> 関数をコール</li>
</ul>
<p>これにより、 <code class="verbatim">Val1.func()</code> , <code class="verbatim">Val2.func()</code> がコールされ
<code>this is val1</code>, <code>this is val2</code> が 出力される。</p>
<p>
なお、 <code>Test&lt;T:Val&gt;</code> の T は Val である必要があるので、
例えば <code>new Test&lt;&#34;abc&#34;&gt;</code> のような指定はエラーになります。</p>
<p>
なぜならば &#34;abc&#34; は str 型であり、 str 型は Val 型ではないからです。</p>
<p>
ちなみに仮型パラメータの制約の syntax は class の extend と同じです。</p>
<p>
つまり次のようになります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
class Hoge&lt;T:SuperClass(IF,...)&gt; {
}</code></pre>
</div>
<p>
ここで SuperClass はクラスで、IF はインタフェースです。</p>
<p>
SuperClass, IF は、それぞれ省略可能です。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-239" class="outline-3">
<h3 id="headline-239">
generics クラスの Mapping
</h3>
<div id="outline-text-headline-239" class="outline-text-3">
<p>
LuneScript は、
クラスのインスタンスを Map オブジェクトに変換する Mapping 機能を持ちます。</p>
<p>
Mapping に関しては、次の記事を参照してください。</p>
<p>
<a href="#classmapping">#classmapping</a></p>
<p>
あるクラスを Mapping するには、
そのクラスが Mapping インタフェースを extend する必要があります。</p>
<p>
次は簡単な例です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test&lt;T&gt; extend (Mapping) {
   let txt:str;
   pub fn func( val:T ) {
      print( self.txt, val );
   }
}

let test = new Test&lt;int&gt;( &#34;hoge&#34; );
let map = test._toMap();
if! let test2 = Test&lt;int&gt;._fromMap( map ) {
   test2.func( 1 );
}</code></pre>
</div>
<p>
Test&lt;T&gt; クラスは Mapping を extend しています。
これにより、Test&lt;T&gt; クラスは Mapping 可能になります。</p>
<p>
上記の場合は、 Generics でない通常のクラスの場合と何も変りません。
これは、仮型パラメータ型のメンバに持たないためです。</p>
<p>
次のように仮型パラメータ型のメンバを持った場合は、エラーになります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
class Test&lt;T&gt; extend (Mapping) {
   let txt:T;
}</code></pre>
</div>
<p>
なぜならば、あるクラスが Mapping を extend するには、
そのクラスが保持する全てのメンバが Mapping 可能でなければならないのに対し、
メンバ txt の型である仮型パラメータ T は、nilable 以外の全ての型になり得るからです。</p>
<p>
これを回避するには、
メンバの型として使用する仮型パラメータに Mapping の制約を設定します。</p>
<p>
具体的には次の通り <code>Test&lt;T:(Mapping)&gt;</code> とします。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test&lt;T:(Mapping)&gt; extend (Mapping) {
   let val:T {pub};
}

let test = new Test( &#34;abc&#34; );
let map = test._toMap();
if! let test2 = Test&lt;str&gt;._fromMap( map ) {
   print( test2.$val .. &#34;xyz&#34; );
}</code></pre>
</div>
<p>
これにより、 Generics クラスが Mapping 可能になります。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-nilcond_ja" class="outline-2">
<h2 id="nilcond_ja">
<strong>nil 条件演算子 編</strong>
</h2>
<div id="outline-text-nilcond_ja" class="outline-text-2">
<p>
今回は LuneScript の nil 条件演算子について説明します。</p>
<div id="outline-container-headline-241" class="outline-3">
<h3 id="headline-241">
Map アクセス
</h3>
<div id="outline-text-headline-241" class="outline-text-3">
<p>
例えば次のような Map のデータがあった場合、</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let json = {
   &#34;lv1&#34;: {
      &#34;lv2&#34;: {
         &#34;lv3&#34;: {
            &#34;lv4&#34;: { 
               &#34;lv5&#34;: {
                  &#34;val&#34;: 1
               }           
            }        
         }     
      }  
   }
};</code></pre>
</div>
<p>
lv5 の val にアクセスするには、次のように処理する必要があります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
if! let lv1 = json.lv1 {
   if! let lv2 = lv1.lv2 {
      if! let lv3 = lv2.lv3 {
         if! let lv4 = lv3.lv4 {
            if! let lv5 = lv4.lv5 {
               print( lv5.val );
            }        
         }     
      }  
   }  
}</code></pre>
</div>
<p>
あるいは次のように unwrap する必要があります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
print( (unwrap (unwrap (unwrap (unwrap (unwrap json.lv1).lv2).lv3).lv4).lv5).val );</code></pre>
</div>
<p>
どちらにしてもイマイチです。</p>
<p>
このようなネストされた nil チェックを簡単に行なうために利用できるのが
nil 条件演算子です。</p>
</div>
</div>
<div id="outline-container-headline-242" class="outline-3">
<h3 id="headline-242">
nil 条件演算子
</h3>
<div id="outline-text-headline-242" class="outline-text-3">
<p>
nil 条件演算子を使って上記の lv5 の val にアクセスすると、
次のようになります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
print( json.lv1$.lv2$.lv3$.lv4$.lv5$.val );</code></pre>
</div>
<p>
だいぶスッキリします。</p>
<p>
nil 条件演算子は、
nilable の式の直後に指定することで、
nilable の式が nil かどうかで、その後の式を実行するかどうかを制御します。</p>
<p>
nilable の式の評価結果が nil でない場合、その後の式を実行し、
nilable の式の評価結果が nil の場合、その後の式を実行せずにその式の結果を nil とします。</p>
<p>
なおリストにアクセスする場合は <code>$[</code> 、 関数呼び出しする場合は <code>$(</code> となります。</p>
<p>
次に例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pub let val:List&lt;int&gt;;
   pub fn func():int {
      return 100;
   }
}
fn sub( test:Test! ) {
   print( test$.val$[1], test$.func$() );
}
sub( new Test( [ 1, 2 ] ) ); // 1 100
sub( nil ); // nil nil</code></pre>
</div>
<p>
上記の例では、 <code class="verbatim">sub()</code> 関数内で Test クラスの val リストと、func に
nil 条件演算子を利用してアクセスしています。
これにより、 unwrap せずにアクセスすることが出来ます。</p>
</div>
</div>
<div id="outline-container-headline-243" class="outline-3">
<h3 id="headline-243">
注意
</h3>
<div id="outline-text-headline-243" class="outline-text-3">
<p>
nil 条件アクセスを使用すると、必ずその評価結果は nilable になります。</p>
<p>
次に例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   pub let val:int;
}
fn sub( test:Test! ) {
   if! test$.val {
      print( _exp + 1 );
   }
}
sub( new Test( 10 ) ); // 11</code></pre>
</div>
<p>
上記の場合、Test クラスの val は int です。</p>
<p>
上記の例の sub 関数では nilable 型の Test クラスのインスタンスに対し、
<code>test$.val</code> でアクセスしています。
この時 <code>test$.val</code> の評価結果は int ではなく int! となります。</p>
</div>
</div>
<div id="outline-container-headline-244" class="outline-3">
<h3 id="headline-244">
まとめ
</h3>
<div id="outline-text-headline-244" class="outline-text-3">
<p>
nil 条件アクセスにより、 深いネストの unwrap が簡単に出来ます。</p>
<p>
次回は、 モジュール管理について説明します。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-import_ja" class="outline-2">
<h2 id="import_ja">
<strong>import/provide 編</strong>
</h2>
<div id="outline-text-import_ja" class="outline-text-2">
<p>
今回は LuneScript のモジュール管理について説明します。</p>
<div id="outline-container-headline-246" class="outline-3">
<h3 id="headline-246">
モジュール
</h3>
<div id="outline-text-headline-246" class="outline-text-3">
<p>
LuneScript のモジュール管理は、基本的に Lua と同じです。</p>
<p>
Lua との違いを、次に挙げます。</p>
<ul>
<li>特に宣言しない場合、ファイルそれぞれが 1 つのモジュールとなる。</li>
<li>ファイル名の拡張子は .lns で、 .lns を除いた名前がモジュール名となる。</li>
<li>init.lns は非サポート。</li>
<li>LuneScript の組込みキーワード(class 等)のファイル名は非サポート。</li>
</ul>
<p>念のため、LuneScript と Lua のモジュール管理の共通部分を説明します。</p>
<ul>
<li>パッケージの検索パスは package.path に格納されているパス情報によって制御される。</li>
<li>モジュール名は . で区切り、サブディレクトリを表わす。</li>
<li>相互参照モジュールをサポートしない。</li>
</ul>
<p>
例えば、ファイル hoge/test.lns のモジュール名は hoge.test になります。</p>
<p>
上記から分かるように、ディレクトリ名、ファイル名(拡張子以外)に
. を含めることは出来ません。</p>
<p>
LuneScript のソースは、特に何も宣言しなくても 1 つのモジュールとなります。</p>
<p>
例えば、次のような Test.lns は関数 func を持つモジュールとなります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
// Test.lns
fn func(): str, str {
   return __mod__, __func__;
}</code></pre>
</div>
<p>
ただし、モジュール内の情報を外部に公開するには、 pub 宣言が必要です。</p>
<p>
具体的には、次のように pub を宣言する必要があります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
// Test.lns
pub fn func(): str, str {
   return __mod__, __func__;
}</code></pre>
</div>
<p>
これによって、このモジュールの <code class="verbatim">func()</code> 関数が外部から利用できるようになります。</p>
</div>
</div>
<div id="outline-container-headline-247" class="outline-3">
<h3 id="headline-247">
import
</h3>
<div id="outline-text-headline-247" class="outline-text-3">
<p>
import は、外部モジュールの利用を宣言します。</p>
<p>
import は、モジュールの先頭に宣言してください。</p>
<p>
<strong>(2019/6/24) 関数内部でも宣言できるように対応しました。</strong></p>
<p>
上記 Test.lns を利用するには、次の様にします。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
import Test;

print( Test.func() ); // @Test   Test.func</code></pre>
</div>
<p>
上記の例では、 <code class="verbatim">Test.func()</code> で Test モジュール内の <code class="verbatim">func()</code> を呼び出しています。</p>
<p>
このように import することで、
外部モジュールが pub 宣言しているシンボルにアクセス出来ます。</p>
<p>
なお、work/Test.lns を import する場合は、次のようになります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
import work.Test;

print( Test.func() ); // work.Test	Test.func</code></pre>
</div>
<p>
上記例から分かるように、import したモジュールにアクセスするには、
そのモジュール名の最後の . 以降の名前を使用します。
上記例の場合、 work.Test を import しているので、シンボル Test でアクセスします。</p>
<p>
なお、複数モジュールを import する時に、
アクセス名が同じになる場合は(例えば foo.bar と hoge.bar を import する場合)、
次に説明する as を利用してください。</p>
<div id="outline-container-headline-248" class="outline-4">
<h4 id="headline-248">
import as
</h4>
<div id="outline-text-headline-248" class="outline-text-4">
<p>
import as は、 import 後のアクセス名を指定します。</p>
<p>
例えば、上記の work.Test を import as で foo とすると、次のようになります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
import work.Test as foo;

print( foo.func() ); // work.Test	Test.func</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-249" class="outline-3">
<h3 id="headline-249">
LuneScript でトランスコンパイルしたモジュールを Lua から require() する
</h3>
<div id="outline-text-headline-249" class="outline-text-3">
<p>
LuneScript は、Lua のトランスコンパイラです。
つまり、 LuneScript で書いたモジュールは、
Lua から <code class="verbatim">require()</code> して使用することが出来ます。</p>
<p>
この場合、 LuneScript で書いたモジュールは、必ずテーブルとなります。</p>
<p>
例えば、上記 Test.lns のトランスコンパイル後の Lua ソースは、次のようになります。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="c1">--work/Test.lns</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">_moduleObj</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">__mod__</span> <span class="o">=</span> <span class="s1">&#39;work.Test&#39;</span>
</span></span><span class="line"><span class="cl"><span class="kr">if</span> <span class="ow">not</span> <span class="n">_lune</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">   <span class="n">_lune</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="kr">function</span> <span class="nf">func</span><span class="p">(</span>  <span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="kd">local</span> <span class="n">__func__</span> <span class="o">=</span> <span class="s1">&#39;Test.func&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kr">return</span> <span class="n">__mod__</span><span class="p">,</span> <span class="n">__func__</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="n">_moduleObj.func</span> <span class="o">=</span> <span class="n">func</span>
</span></span><span class="line"><span class="cl"><span class="kr">return</span> <span class="n">_moduleObj</span></span></span></code></pre></div>
</div>
<p>
上記のソースを見ると分かりますが、
Lua からこのソースを <code class="verbatim">require()</code> すると、_moduleObj が得られることになります。</p>
<p>
一方で、 Lua の <code class="verbatim">require()</code> は任意の値を返すこと出来ます。
そして、この動作を期待される場合があります。</p>
<p>
つまり、LuneScript でトランスコンパイルした Lua モジュールは、
テーブル以外のオブジェクトが得られることを期待した Lua から、
直接 require して使用することが出来ないことになります。</p>
<p>
このような Lua モジュールとの互換を可能にする仕組みが、 provide です。</p>
</div>
</div>
<div id="outline-container-headline-250" class="outline-3">
<h3 id="headline-250">
provide
</h3>
<div id="outline-text-headline-250" class="outline-text-3">
<p>
provide は、既存の Lua モジュールとの互換性を提供するものです。</p>
<p>
<strong>Lua モジュールとの互換性が不要な場合の使用は避けてください。</strong></p>
<p>
次に provide の例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
// Test.lns
pub fn func(): str, str {
   return __mod__, __func__;
}

provide func;</code></pre>
</div>
<p>
上記例は、 provide に 関数 <code class="verbatim">func()</code> を与えています。</p>
<p>
これによって、この Test.lns モジュールのトランスコンパイル結果は、
次のようになります。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="c1">--work/Test.lns</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">__mod__</span> <span class="o">=</span> <span class="s1">&#39;work.Test&#39;</span>
</span></span><span class="line"><span class="cl"><span class="kr">if</span> <span class="ow">not</span> <span class="n">_lune</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">   <span class="n">_lune</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="kr">function</span> <span class="nf">func</span><span class="p">(</span>  <span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="kd">local</span> <span class="n">__func__</span> <span class="o">=</span> <span class="s1">&#39;Test.func&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">   <span class="kr">return</span> <span class="n">__mod__</span><span class="p">,</span> <span class="n">__func__</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kr">return</span> <span class="n">func</span></span></span></code></pre></div>
</div>
<p>
上記から分かるように、 Lua からこのモジュールを <code class="verbatim">require()</code> すると、
関数 func が得られます。</p>
<p>
このように provide を利用すると、
既存の Lua モジュールとの互換性のあるモジュールを生成することが出来ます。</p>
<p>
なお、 provide に指定できるのは <strong>シンボルだけ</strong> です。
immediate な値を指定することは出来ません。</p>
</div>
</div>
<div id="outline-container-headline-251" class="outline-3">
<h3 id="headline-251">
まとめ
</h3>
<div id="outline-text-headline-251" class="outline-text-3">
<p>
LuneScript は、簡単にモジュールを作成でき、既存の Lua モジュールとの互換性もあります。</p>
<p>
次回は、 LuneScript から既存の Lua  モジュールを利用する方法について説明します。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-require_ja" class="outline-2">
<h2 id="require_ja">
<strong>require/module 編</strong>
</h2>
<div id="outline-text-require_ja" class="outline-text-2">
<p>
今回は LuneScript から Lua モジュールを扱う方法について説明します。</p>
<div id="outline-container-headline-253" class="outline-3">
<h3 id="headline-253">
require
</h3>
<div id="outline-text-headline-253" class="outline-text-3">
<p>
Lua モジュールを扱う場合、 <code class="verbatim">require()</code> を使用します。</p>
<p>
<code class="verbatim">require()</code> の仕様は Lua と同じですが、戻り値は stem になります。
つまり、型情報を持ちません。
適宜キャストが必要になります。</p>
</div>
</div>
<div id="outline-container-headline-254" class="outline-3">
<h3 id="headline-254">
module
</h3>
<div id="outline-text-headline-254" class="outline-text-3">
<p>
上記の通り、=require()= は stem を返します。</p>
<p>
stem には型情報が無いため、使い勝手が悪いです。</p>
<p>
そこで、 module 宣言を使用します。</p>
<p>
例えば、次のような Lua のモジュール Test.lua がある場合、</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">mod</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="n">mod.val</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="kr">function</span> <span class="nc">mod</span><span class="p">.</span><span class="nf">func1</span><span class="p">(</span> <span class="n">val</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="kr">return</span> <span class="n">val</span> <span class="o">+</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kr">function</span> <span class="nc">mod</span><span class="p">:</span><span class="nf">func2</span><span class="p">(</span> <span class="n">val</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="kr">return</span> <span class="n">self.val</span> <span class="o">+</span> <span class="n">val</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kr">return</span> <span class="n">mod</span></span></span></code></pre></div>
</div>
<p>
この Test.lua モジュールは、次の要素を持ちます。</p>
<ul>
<li>int の メンバ val </li>
<li>関数 func1</li>
<li>メソッド func2</li>
</ul>
<p>なお、ここで言う関数とは、呼び出す時に obj.func1() のように <strong>.</strong> で呼び出し、
メソッドとは、呼び出す時に obj:func1() のように <strong>:</strong> で呼び出すものを指します。</p>
<p>
この Test.lua モジュールを利用する module 宣言は、次のように行ないます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
module Test require &#39;Test&#39;
{
   pub static let val:int;
   pub static fn func1( val:int ):int;
   pub fn func2( val:int ):int;
}
print( Test.val, Test.func1( 10 ), Test.func2( 20 ) ); // 1 20 21</code></pre>
</div>
<p>
まず、 module Test require &#39;Test&#39; の module Test は、モジュール名 Test を宣言します。
モジュール名は通常のクラス名と考えてください。
ここでは Lua のモジュール名と同じにしましたが、違う名前でも問題ありません。</p>
<p>
module Test require &#39;Test&#39; の require &#39;Test&#39; は、
どのモジュールをロードするかを指定します。
ここでは Test モジュールをロードしていることを指定しています。</p>
<p>
残りは、通常のクラス宣言と同じです。</p>
<p>
module 宣言したモジュールは、モジュール名でアクセスします。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
print( Test.val, Test.func1( 10 ), Test.func2( 20 ) );</code></pre>
</div>
<div id="outline-container-headline-255" class="outline-4">
<h4 id="headline-255">
LuneScript が builtin していない lua の API
</h4>
<div id="outline-text-headline-255" class="outline-text-4">
<p>
LuneScript では、
セルフホストするために最低限必要な Lua の標準 API を built-in しています。</p>
<p>
built-in していない Lua の標準 API (例えば <code class="verbatim">math.pi</code> に、
直接アクセスできません。</p>
<p>
built-in していない API にアクセスするには、
次のように module 宣言することで利用可能になります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
module Math require &#39;math&#39; {
   pub static let pi:real;
   pub static fn sin(x:real):real;
}

print( Math.pi, Math.sin(Math.pi/2) );  // 3.1415926535898	1.0</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-256" class="outline-4">
<h4 id="headline-256">
module 宣言の制限
</h4>
<div id="outline-text-headline-256" class="outline-text-4">
<p>
module 宣言には、次の制限があります。</p>
<ul>
<li>モジュールを継承して新しくクラスを宣言することはできない</li>
<li>
<p>require した Lua のモジュールと、宣言した module との整合性をチェックしない</p>
<ul>
<li>不整合があった場合の動作は <strong>未定義</strong></li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-257" class="outline-3">
<h3 id="headline-257">
まとめ
</h3>
<div id="outline-text-headline-257" class="outline-text-3">
<ul>
<li>LuneScript は、Lua モジュールを扱えます。</li>
<li>Lua モジュールを扱う方法には <code class="verbatim">require()</code> と module 宣言があります。</li>
<li>module 宣言には制限があります。</li>
</ul>
<p>
次回は、マクロについて説明します。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-glue_ja" class="outline-2">
<h2 id="glue_ja">
<strong>glue コードの半自動生成</strong>
</h2>
<div id="outline-text-glue_ja" class="outline-text-2">
<p>
Lua の外部モジュールには、次の 2 つのケースがある。</p>
<ul>
<li>Lua スクリプトで構成されるケース</li>
<li>C 等の Native Library を利用するケース</li>
</ul>
<p>Lua から Native Library を利用するには、
Lua 用のインタフェースを橋渡しする glue が必要である。</p>
<p>
LuneScript は、この glue を半自動的に生成する機能を持つ。</p>
<p>
LuneScript の glue 自動生成機能は、
swig に代表される C/C++ 等のソースから Lua の glue を自動生成する機能ではなく、
LuneScript で module 宣言したモジュールの glue コードを自動生成する機能である。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">swig:		C/C++ ==&gt; glue
</span></span><span class="line"><span class="cl">LuneScript:	Lns   ==&gt; glue</span></span></code></pre></div>
</div>
<div id="outline-container-headline-259" class="outline-3">
<h3 id="headline-259">
使用方法
</h3>
<div id="outline-text-headline-259" class="outline-text-3">
<p>
glue を生成するには、 module 定義時に glue キーワードを指定する。</p>
<p>
次は、 test.ext モジュールの glue を生成するサンプルである。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
module External require &#34;test.ext&#34; glue &#39;hoge_&#39; {
   pub static fn create( val:int ): External;
   pub fn add( val:int ):int;
}

let obj = External.create( 1 );
print( obj.add( 10 ) ); // 11</code></pre>
</div>
<p>
ここで指定した &#34;test.ext&#34; と &#39;hoge_&#39; は、 glue を生成する際に利用される。</p>
<p>
このソースから glue コードを生成するには、次のコマンドを実行する。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ lua lune/base/base.lua src.lns glue [dir]</span></span></code></pre></div>
</div>
<p>
ここで、 src.lns は入力元のソースで、 dir は出力先のディレクトリのパスを指定する。</p>
<p>
このコマンドによって、次の 2 つの glue コードが生成される。</p>
<ul>
<li>test_ext_glue.c</li>
<li>test_ext_glue.h  </li>
</ul>
<p>test_ext_glue.c は、次の内容を持つ。</p>
<div class="src src-c">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;test_ext_glue.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">lns_glue_create</span><span class="p">(</span> <span class="n">lua_State</span> <span class="o">*</span> <span class="n">pLua</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">lns_glue_add</span><span class="p">(</span> <span class="n">lua_State</span> <span class="o">*</span> <span class="n">pLua</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">s_full_class_name</span> <span class="o">=</span> <span class="s">&#34;test_ext&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="k">const</span> <span class="n">luaL_Reg</span> <span class="n">s_lua_func_info</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="s">&#34;create&#34;</span><span class="p">,</span> <span class="n">lns_glue_create</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="k">const</span> <span class="n">luaL_Reg</span> <span class="n">s_lua_method_info</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="s">&#34;add&#34;</span><span class="p">,</span> <span class="n">lns_glue_add</span> <span class="p">},</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span> <span class="nf">lns_glue_get_test_ext</span><span class="p">(</span> <span class="n">lua_State</span> <span class="o">*</span> <span class="n">pLua</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">luaL_checkudata</span><span class="p">(</span> <span class="n">pLua</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">s_full_class_name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">lns_glue_setupObjMethod</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="n">lua_State</span> <span class="o">*</span> <span class="n">pLua</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="n">pName</span><span class="p">,</span> <span class="k">const</span> <span class="n">luaL_Reg</span> <span class="o">*</span> <span class="n">pReg</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">luaL_newmetatable</span><span class="p">(</span><span class="n">pLua</span><span class="p">,</span> <span class="n">pName</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">lua_pushvalue</span><span class="p">(</span><span class="n">pLua</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">lua_setfield</span><span class="p">(</span><span class="n">pLua</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="s">&#34;__index&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#if LUA_VERSION_NUM &gt;= 502
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">luaL_setfuncs</span><span class="p">(</span><span class="n">pLua</span><span class="p">,</span> <span class="n">pReg</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">lua_pop</span><span class="p">(</span><span class="n">pLua</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">luaL_register</span><span class="p">(</span><span class="n">pLua</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">pReg</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">lua_pop</span><span class="p">(</span><span class="n">pLua</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="o">*</span> <span class="nf">lns_glue_new_test_ext</span><span class="p">(</span> <span class="n">lua_State</span> <span class="o">*</span> <span class="n">pLua</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="o">*</span> <span class="n">pBuf</span> <span class="o">=</span> <span class="n">lua_newuserdata</span><span class="p">(</span> <span class="n">pLua</span><span class="p">,</span> <span class="n">size</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="p">(</span> <span class="n">pBuf</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="cp">#if LUA_VERSION_NUM &gt;= 502
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">luaL_setmetatable</span><span class="p">(</span> <span class="n">pLua</span><span class="p">,</span> <span class="n">s_full_class_name</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">luaL_getmetatable</span><span class="p">(</span> <span class="n">pLua</span><span class="p">,</span> <span class="n">s_full_class_name</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">lua_setmetatable</span><span class="p">(</span> <span class="n">pLua</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">pBuf</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">luaopen_test_ext</span><span class="p">(</span> <span class="n">lua_State</span> <span class="o">*</span> <span class="n">pLua</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">lns_glue_setupObjMethod</span><span class="p">(</span> <span class="n">pLua</span><span class="p">,</span> <span class="n">s_full_class_name</span><span class="p">,</span> <span class="n">s_lua_method_info</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="cp">#if LUA_VERSION_NUM &gt;= 502
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">luaL_newlib</span><span class="p">(</span> <span class="n">pLua</span><span class="p">,</span> <span class="n">s_lua_func_info</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#else
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="n">luaL_register</span><span class="p">(</span> <span class="n">pLua</span><span class="p">,</span> <span class="n">s_full_class_name</span><span class="p">,</span> <span class="n">s_lua_func_info</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="cp">#endif
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">lns_glue_add</span><span class="p">(</span> <span class="n">lua_State</span> <span class="o">*</span> <span class="n">pLua</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">val</span> <span class="o">=</span> <span class="n">luaL_checkinteger</span><span class="p">(</span> <span class="n">pLua</span><span class="p">,</span> <span class="mi">2</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">hoge_add</span><span class="p">(</span> <span class="n">pLua</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">int</span> <span class="nf">lns_glue_create</span><span class="p">(</span> <span class="n">lua_State</span> <span class="o">*</span> <span class="n">pLua</span> <span class="p">){</span>
</span></span><span class="line"><span class="cl">  <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="n">val</span> <span class="o">=</span> <span class="n">luaL_checkinteger</span><span class="p">(</span> <span class="n">pLua</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="n">hoge_create</span><span class="p">(</span> <span class="n">pLua</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>
この test_ext_glue.c は、
LuneScript で定義している <code class="verbatim">create()</code> と <code class="verbatim">add()</code> のメソッドを Lua に登録するコードである。</p>
<p>
LuneScript で定義している <code class="verbatim">create()</code> と <code class="verbatim">add()</code> に対応する関数は、
<code class="verbatim">lns_glue_create()</code> と <code class="verbatim">lns_glue_add()</code> である。</p>
<p>
なお、この関数はそれぞれ <code class="verbatim">hoge_create()</code> と <code class="verbatim">hoge_add()</code> をコールしている。
この <strong>hoge_</strong> は、 LuneScript のコード上で指定した glue の文字列が利用される。</p>
<p>
test_ext_glue.h は次の内容を持つ。</p>
<div class="src src-c">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;lauxlib.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="k">extern</span> <span class="kt">int</span> <span class="nf">hoge_create</span><span class="p">(</span> <span class="n">lua_State</span> <span class="o">*</span> <span class="n">pLua</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="nf">hoge_add</span><span class="p">(</span> <span class="n">lua_State</span> <span class="o">*</span> <span class="n">pLua</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="nf">luaopen_test_ext</span><span class="p">(</span> <span class="n">lua_State</span> <span class="o">*</span> <span class="n">pLua</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span> <span class="nf">lns_glue_get_test_ext</span><span class="p">(</span> <span class="n">lua_State</span> <span class="o">*</span> <span class="n">pLua</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">void</span> <span class="o">*</span> <span class="nf">lns_glue_new_test_ext</span><span class="p">(</span> <span class="n">lua_State</span> <span class="o">*</span> <span class="n">pLua</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">size</span> <span class="p">);</span></span></span></code></pre></div>
</div>
<p>
ここで、=hoge_create()= と <code class="verbatim">hoge_add()</code> は次の型となっている。</p>
<div class="src src-c">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="nf">hoge_create</span><span class="p">(</span> <span class="n">lua_State</span> <span class="o">*</span> <span class="n">pLua</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="k">extern</span> <span class="kt">int</span> <span class="nf">hoge_add</span><span class="p">(</span> <span class="n">lua_State</span> <span class="o">*</span> <span class="n">pLua</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span> <span class="p">);</span></span></span></code></pre></div>
</div>
<p>
第一引数の lua_State * と戻り値の int は、
Lua の glue インタフェースと同じ意味を持つ。</p>
<p>
第二引数の int は、 LuneScript で定義しているメソッドの引数が入る。
これは、 LuneScript で自動生成している test_ext_glue.c が
Lua のスタックから値を取り出して値を設定している。</p>
<p>
Lua の glue では、関数引数を得るため API をコールする必要があるが、
LuneScript で glue を生成した場合は、
glue コード内で関数引数を得る API を実行している。
これにより、 ユーザは関数引数を得る API をコールする必要はない。</p>
<p>
ただし、LuneScript 側で定義しているメソッドの引数の型が
int(int!), real(real!), str(str!) 型以外だった場合、
LuneScript で生成する glue では対応できないため、
別途ユーザ側での対応が必要である。</p>
<p>
また glue の戻り値については、
ユーザ側で Lua の glue インタフェースと同じ制御を行なう必要がある。</p>
<p>
<code class="verbatim">hoge_create()</code> と <code class="verbatim">hoge_add()</code> を別途定義することで、
test.ext モジュールが完成する。</p>
<p>
例えば次のように定義する(glue.c)。</p>
<div class="src src-c">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// glue.c
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#include</span> <span class="cpf">&lt;test_ext_glue.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span> <span class="n">glue_t</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">hoge_create</span><span class="p">(</span> <span class="n">lua_State</span> <span class="o">*</span> <span class="n">pLua</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">glue_t</span> <span class="o">*</span> <span class="n">pGlue</span> <span class="o">=</span> <span class="p">(</span><span class="n">glue_t</span><span class="o">*</span><span class="p">)</span><span class="n">lns_glue_new_test_ext</span><span class="p">(</span> <span class="n">pLua</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span> <span class="n">glue_t</span> <span class="p">)</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">pGlue</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">hoge_add</span><span class="p">(</span> <span class="n">lua_State</span> <span class="o">*</span> <span class="n">pLua</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">glue_t</span> <span class="o">*</span> <span class="n">pGlue</span> <span class="o">=</span> <span class="n">lns_glue_get_test_ext</span><span class="p">(</span> <span class="n">pLua</span><span class="p">,</span> <span class="mi">1</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">lua_pushinteger</span><span class="p">(</span> <span class="n">pLua</span><span class="p">,</span> <span class="n">val</span> <span class="o">+</span> <span class="n">pGlue</span><span class="o">-&gt;</span><span class="n">val</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>
ちなみにビルドは次のように行なう。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ gcc -std=c99 -fPIC -shared -o test/ext.so glue.c test_ext_glue.c</span></span></code></pre></div>
</div>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-lua_ja" class="outline-2">
<h2 id="lua_ja">
<strong>Lua と連携 編</strong>
</h2>
<div id="outline-text-lua_ja" class="outline-text-2">
<p>
LuneScript は Lua のコードを実行できます。</p>
<p>
しかし、Lua コードを実行するには幾つかの点で注意が必要です。</p>
<p>
以降では、 LuneScript 上で Lua コードを実行する際の注意点を説明します。</p>
<div id="outline-container-headline-261" class="outline-3">
<h3 id="headline-261">
Lua コードの実行
</h3>
<div id="outline-text-headline-261" class="outline-text-3">
<p>
LuneScript では、
<code class="verbatim">_load()</code> 関数などを利用することで LuneScript 内から Lua のコードを実行できます。</p>
<p>
<code class="verbatim">_load()</code> 関数は、 lua の <code class="verbatim">load()</code> 関数と基本的に同じ仕様です。</p>
<p>
以下にサンプルを示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let code = ```
return { val1 = 10, val2 = 20 }
```;
let loaded, err = _load( code, nil );
when! loaded {
   if! let obj = loaded( ## ) {
      forsort val, key in obj@@Map&lt;str,int&gt; {
         print( key, val + 100 ); 
      }
   }
} else {
   print( err );
}</code></pre>
</div>
<p>
このサンプルは、次の値を出力します。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">val1	110
</span></span><span class="line"><span class="cl">val2	120</span></span></code></pre></div>
</div>
<p>
これは、Lua のコード <code>return { val1 = 10, val2 = 20 }</code> が返す Lua のテーブルを、
forsort で列挙して <code class="verbatim">print( key, val + 100 );</code> で出力した結果です。</p>
<p>
上記サンプルは、以下の LuneScript のコードとほぼ同じと言えます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func():Map&lt;str,int&gt; {
   return { &#34;val1&#34;:10, &#34;val2&#34;:20 };
}
forsort val, key in func() {
   print( key, val + 100 ); 
}</code></pre>
</div>
<p>
このように、 LuneScript と Lua は連携して動作することが出来ます。</p>
</div>
</div>
<div id="outline-container-headline-262" class="outline-3">
<h3 id="headline-262">
Lua → LuneScript のデータ変換
</h3>
<div id="outline-text-headline-262" class="outline-text-3">
<p>
LuneScript から Lua のコードを実行したとき、
その Lua コードの実行結果は Luaval 型になります。</p>
<p>
Luaval 型は、Lua コード内のデータを保持する型で、
LuneScript の型 T に相当する Lua コード内のデータは <code class="verbatim">Luaval&lt;T&gt;</code> となります。</p>
<p>
例えば上記サンプルの <code>{ val1 = 10, val2 = 20 }</code> は、
LuneScritp の Map&lt;str,int&gt; に相当し、 <code class="verbatim">Luaval&lt;Map&lt;str,int&gt;&gt;</code> となります。</p>
<p>
なお、 LuneScript から Lua にトランスコンパイルする場合、
<strong>Luaval&lt;T&gt; は T と完全に一致した型</strong> になります。
LuneScript から Lua にトランスコンパイルする場合、
例え Luaval&lt;T&gt; と明示的に宣言しても内部的に T として変換されるため、
Luaval&lt;T&gt; を意識する必要はありません。</p>
<p>
LuneScript から Lua 以外の言語(現在は go に変換可能)に変換する場合、
Luaval&lt;T&gt; と T は明確に扱いが異なるため、
Lua 以外に変換する場合は Luaval&lt;T&gt; を意識する必要があります。</p>
<p>
<strong>トランスコンパイルのオプションに &#34;–valid-luaval&#34; を指定</strong> することで、
Lua にトランスコンパイルする際も、Luaval&lt;T&gt; と T を分けて管理します。</p>
<p>
上記サンプルは、次のように <code class="verbatim">Luaval&lt;Map&lt;str,int&gt;&gt;</code> の引数を持つ
<code class="verbatim">func()</code> を使用するように書き換えることが出来ます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func(map:Luaval&lt;&amp;Map&lt;str,int&gt;&gt;) {
   forsort val, key in map {
      print( key, val + 100 ); 
   }
}
let code = ```
return { val1 = 10, val2 = 20 }
```;
let loaded, err = _load( code, nil );
when! loaded {
   if! let obj = loaded( ## ) {
      func( obj@@Map&lt;str,int&gt; );
   }
} else {
   print( err );
}</code></pre>
</div>
<p>
また上記のサンプルの様に Map の Luaval 型のデータに対しても、
LuneScript の Map と同様に
foreach や <code class="verbatim">[]</code> を使用した要素アクセスなどで、Map 内のデータを参照できます。
ただし参照は出来ますが、 <strong>変更は出来ません。</strong></p>
<div id="outline-container-headline-263" class="outline-4">
<h4 id="headline-263">
相互変換可能な型
</h4>
<div id="outline-text-headline-263" class="outline-text-4">
<p>
Lua コード内のデータの型が次の場合、
Luaval 型とはならずにそのままの型になります。</p>
<ul>
<li>int, real, bool, str</li>
<li>上記の nilable</li>
</ul>
<p>str に関しては、 <strong>文字列長に比例したオーバーヘッド</strong> が掛かります。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-264" class="outline-3">
<h3 id="headline-264">
Luaval 型のキャスト
</h3>
<div id="outline-text-headline-264" class="outline-text-3">
<p>
Luaval 型のキャストには制限があります。</p>
<p>
上記サンプルは、次のように func の引数に  <code class="verbatim">obj@@Map&lt;str,int&gt;</code> を渡しています。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip   
   if! let obj = loaded( ## ) {
      func( obj@@Map&lt;str,int&gt; );
   }</code></pre>
</div>
<p>
これは obj を Map&lt;str,int&gt; 型にキャストする演算ですが、
ここで obj の型は Luaval&lt;stem&gt; 型であり、
それを Map&lt;str,int&gt; にキャストすると、
そのキャスト後の型は Luaval&lt;Map&lt;str,int&gt;&gt; になります。</p>
<p>
ある型 T1 から T2 型にキャストが可能だった時、
Luaval&lt;T1&gt; から T2 へのキャストを指示した場合、
そのキャスト結果は Luaval&lt;T2&gt; になります。</p>
<p>
また、次のキャストは出来ません。</p>
<ul>
<li>T1 型から Luaval&lt;T1&gt; 型へのキャスト</li>
<li>Luaval&lt;T1&gt; 型から T1 型へのキャスト</li>
</ul>
<p>具体的には Map&lt;str,int&gt; から Luaval&lt;Map&lt;str,int&gt;&gt; へのキャストは出来ません。</p>
<p>
ただし、 stem 型は例外的に Luaval との相互キャストが可能です。</p>
<p>
なお、次のように stem 型を経由することで、
Luaval 型から非 Luaval 型へのキャストが可能ですが、</p>
<pre class="example">
Luaval =&gt; stem =&gt; Luaval
</pre>
<p>
本来とは異なる型にキャストした時の動作は <strong>未定義</strong> です。</p>
<div id="outline-container-headline-265" class="outline-4">
<h4 id="headline-265">
expandLuavalMap
</h4>
<div id="outline-text-headline-265" class="outline-text-4">
<p>
Lua コード内の collection のデータは、 Luaval として扱います。</p>
<p>
たとえば、 Map 型のデータは Luaval&lt;Map&gt; です。
Map 型と Luaval&lt;Map&gt; 型のデータは互換性がないため、代入などは出来ません。</p>
<p>
この collection の Luaval 型のデータを LuneScript の値として展開する方法として、
次の関数を提供しています。</p>
<pre class="example">
fn expandLuavalMap( Luaval&lt;stem&gt;! ) : stem!;
</pre>
<p>
この関数を使用すると、次のような処理が掛けます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func(map:Luaval&lt;&amp;Map&lt;str,int&gt;&gt;) {
   forsort val, key in map {
      print( key, val + 100 ); 
   }
}
fn func2(map:&amp;Map&lt;str,int&gt;) {
   forsort val, key in map {
      print( key, val + 100 ); 
   }
}
let code = ```
return { val1 = 10, val2 = 20 }
```;
let loaded, err = _load( code, nil );
when! loaded {
   if! let obj = loaded( ## ) {
      func( obj@@Map&lt;str,int&gt; );
      if! let map = expandLuavalMap( obj ) {
         func2( map@@Map&lt;str,int&gt; );
      }
   }
} else {
   print( err );
}</code></pre>
</div>
<p>
このサンプルでは、 Luaval&lt;&amp;Map&lt;str,int&gt;&gt; を列挙する <code class="verbatim">func()</code> 関数と、
&amp;Map&lt;str,int&gt; を列挙する <code class="verbatim">func2()</code> 関数があります。</p>
<p>
func2() をコールする前に <code class="verbatim">expandLuavalMap()</code> で Luaval 型のデータを展開し、
それを Map&lt;str,int&gt; にキャストするこおで Luaval&lt;Map&lt;str,int&gt;&gt; ではなく、
Map&lt;str,int&gt; として処理しています。</p>
<p>
なお <code class="verbatim">expandLuavalMap()</code> は、
引数で与えられた Luaval 型のデータを展開したクローンを作成します。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-266" class="outline-3">
<h3 id="headline-266">
Luaval 型の型変換
</h3>
<div id="outline-text-headline-266" class="outline-text-3">
<p>
ある nilable 型の T! を保持する Luaval 型は、 Luaval&lt;T&gt;! になります。
Luaval&lt;T!&gt; にはなりません。</p>
<p>
また、 Luaval&lt;T&gt; の Immutable は Luaval&lt;&amp;T&gt; になります。</p>
</div>
</div>
<div id="outline-container-headline-267" class="outline-3">
<h3 id="headline-267">
Luaval 型の関数、Luaval 型オブジェクトのメソッド
</h3>
<div id="outline-text-headline-267" class="outline-text-3">
<p>
関数型の Luaval は、その引数、戻り値も Luaval 型になります。</p>
<p>
例えば次のサンプルの func 関数の引数 proc は、
Luaval&lt;Process&gt; 型の From であり、
この Form の引数は Luaval&lt;&amp;List&lt;int&gt;&gt; 、
戻り値は Luaval&lt;&amp;List&lt;int&gt;&gt; になります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
   form Process( val:&amp;List&lt;int&gt; ) : &amp;Map&lt;int&gt;;
   fn func( proc:Luaval&lt;Process&gt; ) {
      let list = proc( [ 1, 2, 3 ] );
   }</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-268" class="outline-3">
<h3 id="headline-268">
LuneScript → Lua のデータ変換
</h3>
<div id="outline-text-headline-268" class="outline-text-3">
<p>
Lua の関数に LuneScript の値を渡す時は、Luaval 型の値を渡す必要があります。</p>
<p>
ただし、 Lua の関数の引数が次の値の場合、
Luava 型ではなくそのままの型になります。</p>
<ul>
<li>int, real, bool, str</li>
<li>上記を要素に持つ List などのコレクション型  </li>
<li>上記の nilable</li>
</ul>
<p>次にサンプルを示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let code = ```
return function( tbl )
   local total = 0
   for key, val in pairs( tbl ) do
      total = total + val
   end
   return total
end
```;
let loaded, err = _load( code, nil );
when! loaded {
   if! let obj = loaded( ## ) {
   let map = { &#34;val1&#34;:1, &#34;val2&#34;:10 };
      print( (obj@@form)( map ) );  // Lua の関数コール
   }
} else {
   print( err );
}</code></pre>
</div>
<p>
このサンプルは、
引数で与えられた Lua のテーブルの要素の値の合計を計算する関数をコールします。</p>
<p>
このサンプルでは、
Map&lt;str,int&gt; 型のデータ map を Lua の関数の引数に指定して実行しています。</p>
<p>
このとき、内部的に Map&lt;str,int&gt; 型のデータが Lua のテーブルに変換されています。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-make_ja" class="outline-2">
<h2 id="make_ja">
<strong>ビルド 編</strong>
</h2>
<div id="outline-text-make_ja" class="outline-text-2">
<p>
今回は LuneScript を使用したプロジェクトを、ビルドする方法について説明します。</p>
<p>
<del>+LuneScript は、コマンドラインから利用するトランスコンパイラを提供しますが、</del>
<del>LuneScript 専用のビルドツールは提供していません。</del>
<del>よって、ここでは一般的なビルド方法について説明します。</del></p>
<p>
LuneScript をトランスコンパイルするには、以下の方法があります。</p>
<ul>
<li>個別ビルド</li>
<li>バッチビルド</li>
</ul>
<p>バッチビルドは、複数の .lns ファイルを一括でトランスコンパイルします。</p>
<div id="outline-container-headline-270" class="outline-3">
<h3 id="headline-270">
個別ビルド
</h3>
<div id="outline-text-headline-270" class="outline-text-3">
<p>
Lua へトランスコンパイルするには、次のコマンドを実行します。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ lnsc hello.lns save</span></span></code></pre></div>
</div>
<p>
これにより hello.lns をトランスコンパイルし、
変換後のコードを hello.lua に出力します。</p>
<p>
この hello.lua は Lua コマンドで実行できます。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ lua hello.lua</span></span></code></pre></div>
</div>
<p>
これを、全ての .lns ファイルに対して行なうことで、
全ての .lns ファイルをトランスコンパイルできます。</p>
<p>
ただし、 .lns ファイルが多い場合、これだと効率が悪いです。</p>
</div>
</div>
<div id="outline-container-headline-271" class="outline-3">
<h3 id="headline-271">
バッチビルド
</h3>
<div id="outline-text-headline-271" class="outline-text-3">
<p>
バッチビルドは、複数の .lns ファイルを一括でトランスコンパイルします。</p>
<p>
複数の .lns ファイルを指定するには、 lnsc のオプションに @- を指定し、
stdin に .lns ファイルパスを渡します。
stdin に渡す .lns ファイルパスは、1 行につき 1 ファイル出力します。</p>
<p>
例えば、 proj ディレクトリ以降の全 .lns ファイルを渡す場合、以下になります。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ find proj -name &#39;*.lns&#39; | lnsc @- save</span></span></code></pre></div>
</div>
<p>
現時点で、これが最も高速に処理できる方法です。</p>
</div>
</div>
<div id="outline-container-headline-272" class="outline-3">
<h3 id="headline-272">
参考情報
</h3>
<div id="outline-text-headline-272" class="outline-text-3">
<p>
<strong>以降は参考情報です。</strong>  </p>
<div id="outline-container-headline-273" class="outline-4">
<h4 id="headline-273">
メタ情報ファイル
</h4>
<div id="outline-text-headline-273" class="outline-text-4">
<p>
メタ情報ファイルとは、モジュールが公開しているクラスや、
そのモジュールが import している他のモジュールの依存関係などの情報を
まとめたファイルです。</p>
<p>
import する際、モジュールを解析する代わりに
このメタ情報ファイルを読み込むことで、解析時間を短縮できます。</p>
<p>
メタ情報ファイルは、次のコマンドで生成できます。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ lnsc hello.lns SAVE</span></span></code></pre></div>
</div>
<p>
先程のコマンドと何が違うかというと、 &#34;<strong>save</strong>&#34; と &#34;<strong>SAVE</strong>&#34; の違いです。</p>
<p>
小文字の save は、トランスコンパイルした Lua コードだけ生成しますが、
大文字の SAVE は、 Lua コードとメタ情報ファイルを生成します。</p>
<p>
具体的には、上記コマンドを実行すると hello.lua と hello.meta が生成されます。</p>
<p>
LuneScript はモジュールを import する際、
次の条件が全て成り立つ時に .meta ファイルをロードします。
このとき、import 対象の .lns ファイルの解析は行ないません。</p>
<ul>
<li>.lns に対応する .lua と .meta が存在する</li>
<li>
<p>それぞれのファイルの更新時間について、次の条件を満す</p>
<ul>
<li><code>.lns &lt; .meta</code></li>
</ul>
</li>
<li>
<p>インポート対象の mod1.lns 内で import しているモジュール mod2 の更新時間に対し、
次の条件を満す。</p>
<ul>
<li><code>mod1 &gt; mod2</code></li>
</ul>
</li>
<li>.meta ファイルのフォーマットバージョンが正しい</li>
</ul>
</div>
</div>
<div id="outline-container-headline-274" class="outline-4">
<h4 id="headline-274">
依存関係
</h4>
<div id="outline-text-headline-274" class="outline-text-4">
<p>
2 つのモジュール mod1, mod2 があった時、
mod1 が mod2 を import していると、「mod1 が mod2 に依存する」ことになります。</p>
<p>
「mod1 が mod2 に依存する」ということは、
mod2 を修正した時は「mod2 だけでなく、mod1 もトランスコンパイルが必要になる」
ということです。</p>
<p>
このような依存関係があるモジュールをビルドするには、
古くから make コマンドが利用されています。
近年は様々なビルドツールがありますが、
make が代表的なビルドツールであることには違いありません。</p>
<p>
make コマンドは、定義された依存関係によって、
あるファイルが修正された際、
そのファイルに依存するファイルを更新する制御を行ないます。</p>
<p>
この依存関係を手動で定義するのは、意外と面倒なものです。</p>
<p>
LuneScript は、 make コマンドの依存関係を自動生成する機能を提供します。</p>
<p>
LuneScript で依存関係を自動生成するには、次のように SAVE 時にオプションを指定します。</p>
<div class="src src-sh">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">$ lnsc mod1.lns --depends depends/mod1.d SAVE</span></span></code></pre></div>
</div>
<p>
これは、 mod1.lns をトランスコンパイルすると同時に、
depends/mod1.d に mod1.lns の依存関係情報を出力します。</p>
<p>
この依存関係情報を Makefile に取り込むことで、
手動で依存関係を定義することなく、簡単に make によるビルド制御が可能になります。</p>
<div id="outline-container-headline-275" class="outline-5">
<h5 id="headline-275">
サンプル
</h5>
<div id="outline-text-headline-275" class="outline-text-5">
<p>
例えば次のようなモジュールをもつプロジェクトを作成したとします。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">test/proj/
</span></span><span class="line"><span class="cl">      |
</span></span><span class="line"><span class="cl">      +--- Mod1.lns
</span></span><span class="line"><span class="cl">      |
</span></span><span class="line"><span class="cl">      +--- Mod2.lns
</span></span><span class="line"><span class="cl">      |
</span></span><span class="line"><span class="cl">      +--- Mod3.lns
</span></span><span class="line"><span class="cl">      |
</span></span><span class="line"><span class="cl">      +--- Mod4.lns</span></span></code></pre></div>
</div>
<p>
ここで、それぞれのファイルの中身は次とします。</p>
<ul>
<li>Mod1.lns</li>
</ul>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
import test.proj.Mod2;

pub fn func(): str {
   return &#34;%s -&gt; %s&#34; (__func__, Mod2.func() );
}
print( func() );</code></pre>
</div>
<ul>
<li>Mod2.lns</li>
</ul>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
import test.proj.Mod3;

pub fn func(): str {
   return &#34;%s -&gt; %s&#34; (__func__, Mod3.func() );
}</code></pre>
</div>
<ul>
<li>Mod3.lns</li>
</ul>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
import test.proj.Mod4;

pub fn func(): str {
   return &#34;%s -&gt; %s&#34; (__func__, Mod4.func() );
}</code></pre>
</div>
<ul>
<li>Mod4.lns</li>
</ul>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
pub fn func(): str {
   return __func__;
}</code></pre>
</div>
<p>
上記のファイルの依存関係は次のようになっています。</p>
<table>
<thead>
<tr>
<th>ファイル</th>
<th>依存ファイル</th>
</tr>
</thead>
<tbody>
<tr>
<td>Mod1.lns</td>
<td>Mod2.lns</td>
</tr>
<tr>
<td>Mod2.lns</td>
<td>Mod3.lns</td>
</tr>
<tr>
<td>Mod3.lns</td>
<td>Mod4.lns</td>
</tr>
<tr>
<td>Mod4.lns</td>
<td>なし</td>
</tr>
</tbody>
</table>
<p>
このプロジェクトをビルドする Makefile は、次のようになります。</p>
<div class="src src-makefile">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-makefile" data-lang="makefile"><span class="line"><span class="cl"><span class="nv">PROJ_DIR</span><span class="o">=</span>test/proj
</span></span><span class="line"><span class="cl"><span class="nv">MKFILE</span><span class="o">=</span><span class="k">$(</span>PROJ_DIR<span class="k">)</span>/Makefile
</span></span><span class="line"><span class="cl"><span class="nv">SRC_DIR</span><span class="o">=</span><span class="k">$(</span>PROJ_DIR<span class="k">)</span>/
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">.PHONY</span><span class="o">:</span> <span class="n">test</span> <span class="n">all</span> <span class="n">build</span> <span class="n">setup</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">define</span> <span class="err">comp</span>
</span></span><span class="line"><span class="cl">	<span class="err">@echo</span> <span class="s2">&#34;$1 -&gt; $2&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="err">lnsc</span> <span class="err">$1</span> <span class="err">--depends</span> <span class="err">depends/</span><span class="k">$(</span><span class="nv">shell</span> <span class="nv">echo</span> <span class="k">$</span>1 | <span class="nv">sed</span> &#39;<span class="nv">s</span>@/@.@<span class="nv">g</span>&#39;<span class="k">)</span><span class="err">.d</span> <span class="err">SAVE</span>
</span></span><span class="line"><span class="cl"><span class="err">endef</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">%.meta</span><span class="o">:</span> %.<span class="n">lns</span>
</span></span><span class="line"><span class="cl">	<span class="k">$(</span>call comp,$&lt;,<span class="nv">$@</span><span class="k">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">SRCS</span> <span class="o">=</span>
</span></span><span class="line"><span class="cl"><span class="nv">SRCS</span> <span class="o">+=</span> Mod1.lns
</span></span><span class="line"><span class="cl"><span class="nv">SRCS</span> <span class="o">+=</span> Mod2.lns
</span></span><span class="line"><span class="cl"><span class="nv">SRCS</span> <span class="o">+=</span> Mod3.lns
</span></span><span class="line"><span class="cl"><span class="nv">SRCS</span> <span class="o">+=</span> Mod4.lns
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">SRCS</span> <span class="o">:=</span> <span class="k">$(</span>addprefix <span class="k">$(</span>SRC_DIR<span class="k">)</span>,<span class="k">$(</span>SRCS<span class="k">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">META_LIST</span><span class="o">=</span><span class="k">$(</span>SRCS:.lns<span class="o">=</span>.meta<span class="k">)</span>
</span></span><span class="line"><span class="cl"><span class="nv">LUA_LIST</span><span class="o">=</span><span class="k">$(</span>SRCS:.lns<span class="o">=</span>.lua<span class="k">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">-include</span> <span class="err">depends/*.d</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">all</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	@echo make setup
</span></span><span class="line"><span class="cl">	@echo make build
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">setup</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">	mkdir -p depends
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nf">build</span><span class="o">:</span> <span class="k">$(</span><span class="nv">META_LIST</span><span class="k">)</span></span></span></code></pre></div>
</div>
<p>
ここで重要なのが、 <code>define comp</code> と <code>-include depends/*.d</code> の部分です。</p>
<ul>
<li><code>define comp</code> は、トランスコンパイルと依存情報ファイルの生成処理を登録しています。</li>
<li><code>-include depends/*.d</code> は、生成した依存情報ファイルを読み込んでいます。</li>
</ul>
<p>このような makefile を作成することで、
import の依存関係に応じたビルドが可能になります。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-276" class="outline-3">
<h3 id="headline-276">
まとめ
</h3>
<div id="outline-text-headline-276" class="outline-text-3">
<p>
make コマンドを使うことで、
LuneScript プロジェクトのビルド制御を簡単に実現できます。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-macro_ja" class="outline-2">
<h2 id="macro_ja">
<strong>マクロ 編</strong>
</h2>
<div id="outline-text-macro_ja" class="outline-text-2">
<p>
今回は LuneScript のマクロについて説明します。</p>
<div id="outline-container-headline-278" class="outline-3">
<h3 id="headline-278">
マクロ
</h3>
<div id="outline-text-headline-278" class="outline-text-3">
<p>
LuneScript は、マクロを対応します。</p>
<p>
もしかしたら、
最近は <strong>マクロ</strong> というよりも <strong>メタプログラミング</strong> と言った方が
意味が通り易いのかもしれません。</p>
<p>
「マクロとは何か」を説明するには、
関数との違いを説明すると分かりやすいと思います。</p>
<p>
<strong>関数</strong> は、ある処理をまとめたものです。
一方、 <strong>マクロ</strong> は、複数の関数定義自体をまとめて定義することが出来ます。
もちろん <strong>マクロ</strong> として定義できるのは、
関数定義だけでなく、ほとんど全ての処理を定義できます。</p>
<p>
マクロで一番メジャーなプログラミング言語と言えば Lisp だと思いますが、
LuneScript のマクロは Lisp ほど高機能ではありません。
しかし、 C 言語のマクロほど限定的でもありません。</p>
<div id="outline-container-headline-279" class="outline-4">
<h4 id="headline-279">
マクロの基本
</h4>
<div id="outline-text-headline-279" class="outline-text-4">
<p>
マクロは実行時ではなく <strong>コンパイル時に展開</strong> されるものです。</p>
<p>
これを意識しておかないとマクロを書くことが難しいので、
マクロを書く時は必ず意識しておいてください。</p>
</div>
</div>
<div id="outline-container-headline-280" class="outline-4">
<h4 id="headline-280">
簡単なマクロの例
</h4>
<div id="outline-text-headline-280" class="outline-text-4">
<p>
次に簡単なマクロの例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
macro _Hello() {
   print( &#34;hello world&#34; );
}
_Hello(); // hello world</code></pre>
</div>
<p>
これは hello world を表示するマクロ _Hello です。</p>
<p>
マクロ定義は macro キーワードを使用します。</p>
<p>
この例は、関数定義を使用した場合と全く変わらないマクロであり、
マクロとして定義する意味はありません。</p>
<p>
しかし、「関数定義と同じ感覚でマクロを定義できる」、
ということを伝えるには良い例だと言えます。</p>
<p>
マクロを搭載するプログラム言語では、
マクロ定義には、一般の関数定義などとは違い、
特殊な処理が必要なことが多いです。</p>
<p>
それによって、「マクロは何か難しそう」と心のハードルが上ってしまいます。</p>
<p>
しかし LuneScript では、
上記の hello world のサンプルのように、
ほとんど一般の関数定義と変わらない感覚でマクロ定義を行なえます。</p>
<p>
ただ、上記の例のようなマクロの書き方では、
意味のあるマクロは定義できません。</p>
<p>
以降では、意味のあるマクロを定義する方法を説明します。</p>
</div>
</div>
<div id="outline-container-headline-281" class="outline-4">
<h4 id="headline-281">
マクロの例
</h4>
<div id="outline-text-headline-281" class="outline-text-4">
<p>
少し実用的なマクロの例を次に示します。</p>
<p>
このマクロは、次の仕様となります。</p>
<ul>
<li>int の値を返す関数を定義するマクロ _Test</li>
<li>関数で返す int 値は、マクロの引数で与える</li>
<li>定義する関数の名前は、 int の値によって決定する</li>
<li>具体的には 1 を返す関数名は func1 とする</li>
</ul>
<p>次が具体的なマクロのコードです。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
macro _Test( val:int ) {
   {
      let name = &#34;func%d&#34;(val);
   }
   fn ,,,name(): int {
      return ,,val;
   }
}

_Test( 1 );
_Test( 10 );

print( func1(), func10() ); // 1  10</code></pre>
</div>
<p>
マクロを展開する場合、関数コールとほとんど同じです。</p>
<p>
この場合 _Test( 1 ), _Test( 10 ) がマクロ展開です。
_Test( 1 ), _Test( 10 ) によって、次が展開されます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
// Test( 1 )
fn func1():int {
   return 1;
}
// Test( 10 )
fn func10():int {
   return 10;
}</code></pre>
</div>
<p>
これにより関数 func1(), func10() が定義されるので、
<code>print( func1(), func10() )</code> は 1 10 が出力されます。</p>
<p>
このマクロについて、以降で説明します。</p>
</div>
</div>
<div id="outline-container-headline-282" class="outline-4">
<h4 id="headline-282">
マクロの書き方
</h4>
<div id="outline-text-headline-282" class="outline-text-4">
<p>
マクロの定義の syntax は次になります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
macro name( arg ) {
   {
      macro-statement
   }
   expand-statement
}</code></pre>
</div>
<p>
キーワード macro で開始し、 次にマクロ名 name 、引数 arg と続きます。
マクロ名 name は、 _ で始まる必要があります。
逆にマクロ以外のシンボル名は、 _ 以外で始まる必要があります。</p>
<p>
マクロの引数は、以下の型をサポートします。</p>
<ul>
<li>int</li>
<li>real</li>
<li>str</li>
<li>bool  </li>
<li>stat</li>
<li>上記の List, Map, Set</li>
<li>sym</li>
<li>__exp</li>
<li>__block</li>
</ul>
<p>sym, stat, __exp, __block については後述します。  </p>
<p>
次に macro-statement ブロックと、 expand-statement が続きます。</p>
<p>
マクロの定義方法を理解するには、
expand-statement を先に理解した方が分かり易いので、
macro-statement ブロックの説明の前に、expand-statement を説明します。</p>
<div id="outline-container-headline-283" class="outline-5">
<h5 id="headline-283">
引数
</h5>
<div id="outline-text-headline-283" class="outline-text-5">
<p>
マクロ専用の引数の型として、以下を利用できます。</p>
<ul>
<li>sym</li>
<li>stat  </li>
<li>__exp</li>
<li>__block</li>
</ul>
<div id="outline-container-headline-284" class="outline-6">
<h6 id="headline-284">
sym
</h6>
<div id="outline-text-headline-284" class="outline-text-6">
<p>
sym は、シンボルを格納できる型です。</p>
<p>
シンボルは、関数、変数、メンバ、クラス、全てのシンボルとして利用できます。</p>
</div>
</div>
<div id="outline-container-headline-285" class="outline-6">
<h6 id="headline-285">
stat
</h6>
<div id="outline-text-headline-285" class="outline-text-6">
<p>
stat は、文を格納できる型です。</p>
</div>
</div>
<div id="outline-container-headline-286" class="outline-6">
<h6 id="headline-286">
__exp
</h6>
<div id="outline-text-headline-286" class="outline-text-6">
<p>
__exp は、全ての式を格納できる型です。</p>
<p>
例えば <code class="verbatim">1 + 1</code> や、 <code class="verbatim">func()</code> など、どのような式でも指定できます。
ただし、マクロをコールする時点でエラーなく評価可能な式である必要があります。</p>
</div>
</div>
<div id="outline-container-headline-287" class="outline-6">
<h6 id="headline-287">
__block
</h6>
<div id="outline-text-headline-287" class="outline-text-6">
<p>
__block は、ブロック文 <code class="verbatim">{}</code> を格納できる型です。</p>
<p>
__exp 同様、マクロをコールする時点でエラーなく評価可能なブロックである必要があります。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-288" class="outline-5">
<h5 id="headline-288">
expand-statement
</h5>
<div id="outline-text-headline-288" class="outline-text-5">
<p>
expand-statement は、マクロを展開した後のコードを書きます。</p>
<p>
_Test マクロの例では、 次の部分が expand-statement です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
   fn ,,,name(): int {
      return ,,val;
   }</code></pre>
</div>
<p>
これによって、関数定義が展開されます。</p>
<p>
この expand-statement では、マクロ専用の演算子が利用できます。
,, がその演算子です。</p>
<p>
利用可能な演算子には、次があります。</p>
<ul>
<li>,,,,</li>
<li>,,,</li>
<li>,,</li>
</ul>
<p>,,,, は、直後に続く <strong>変数</strong> を評価して得られた <strong>シンボル</strong> を <strong>文字列に変換</strong> する演算子です。</p>
<p>
,,, は、直後に続く <strong>変数</strong> を評価して得られた <strong>文字列</strong> を <strong>シンボルに変換</strong> する演算子です。</p>
<p>
,, は、直後に続く <strong>変数</strong> を展開する演算子です。</p>
<p>
つまり、上記例では ,,,name は name 変数内の文字列をシンボルに変換し、
,,val は val 変数を展開することで、
<code>_Test( 1 )</code> マクロは、次が展開されます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func1():int {
   return 1;
}</code></pre>
</div>
<p>
expand-statement には、次の制限を満せば、いかなるコードも書くことが出来ます。</p>
<p>
  <strong>expand-statement は、文でなければならない。</strong></p>
<p>
つまり expand-statement は、式や、不完全なトークンの一部などの、
文として成立しないものでなければ、どのようなコードも書けます。</p>
<p>
また、expand-statement には複数の文を書くことも出来ます。</p>
</div>
</div>
<div id="outline-container-headline-289" class="outline-5">
<h5 id="headline-289">
macro-statement
</h5>
<div id="outline-text-headline-289" class="outline-text-5">
<p>
macro-statement ブロックには、 expand-statement で利用する変数を定義します。
expand-statement で利用する変数は、
macro-statement ブロックの最上位のスコープで宣言する必要があります。</p>
<p>
_Test マクロの例では、次が macro-statement です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
   {
      let name = &#34;func%d&#34;(val);
   }</code></pre>
</div>
<p>
ここでは、変数 name を定義しています。
name の初期値として、 &#34;func%d&#34; (val) をセットしています。</p>
<p>
macro-statement 内では、LuneScript の全ての機能を利用できます。
具体的には、macro-statement 内で関数定義なども行なえます。</p>
<p>
例えば、 _Test マクロは次のようにも書けます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
macro _Test( val:int ) {
   {
      fn funcname(): str {
         return &#34;func%d&#34;(val);
      }
      let name = funcname();
   }
   fn ,,,name(): int {
      return ,,val;
   }
}</code></pre>
</div>
<p>
この例では、 macro-statement で <code class="verbatim">funcname()</code> 関数を宣言し、
その結果を name 変数に代入しています。</p>
<p>
なお macro-statement で利用可能な関数は、LuneScript の標準関数のみです。
同じソース内で定義している関数でも、その関数がマクロ外で定義している場合、
macro-statement から使用することは出来ません。</p>
<p>
macro-statement は、expand-statement と同じようにマクロ専用演算子を利用できます。</p>
<p>
具体的には、次の演算子を利用できます。</p>
<ul>
<li>,,,,</li>
<li>,,,</li>
<li>,,</li>
<li><code>`{}</code></li>
<li>~~  </li>
</ul>
<p>「,,,,」 「,,,」 「,,」 は、 expand-statement とほぼ同じです。
expand-statement との違いは、
expand-statement では直後に続く <strong>変数</strong> を処理対象にしていたのに対し、
macro-statement では直後に続く <strong>式</strong> を処理対象にします。</p>
<p>
<code>`{}</code> は、 <code>`{}</code> 内で書いたステートメントを、そのまま値とすることが出来ます。</p>
<p>
例えば、 上記 _Test マクロは <code>`{}</code> を使って次のようにも書けます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
macro _Test( val:int ) {
   {
      let defstat = `{
         fn ,,,&#34;func%d&#34;(val)~~():int {
            return ,,val;
         }
      };
   }
   ,,defstat;
}

_Test( 1 );
_Test( 10 );

print( func1(), func10() ); // 1  10</code></pre>
</div>
<p>
ここでは、 <code>`{}</code> を使って関数定義そのものを変数 defstat に格納し、
defstat を expand-statement で展開しています。</p>
<p>
この defstat の初期化部分を抜き出すと、次のようになります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
      let defstat = `{
         fn ,,,&#34;func%d&#34;(val)~~():int {
            return ,,val;
         }
      };</code></pre>
</div>
<p>
ここで、 <strong>~~</strong> を使用しているのが分かります。</p>
<p>
<strong>~~</strong> は、 ,,, などの演算子の式の区切りを指定するものです。
上記では、&#34;func%d&#34;(val) の後に ~~ を利用しています。
これは、,,, 演算子を適応する式が &#34;func%d&#34;(val) までで、
その後の () はマクロ展開するステートメントの一部であることを示しています。</p>
<p>
~~ を指定しないと、
&#34;func%d&#34;(val) で生成した文字列に () を付けていることになり、
構文エラーとなります。</p>
<p>
次に <code>`{}</code> のリストの例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
macro _Test( val:int ) {
   {
      let mut statList:List&lt;stat&gt; = [];
      for count = 1, val {
         statList.insert(
            `{          
               fn ,,,&#34;func%d&#34;(count)~~():int {
                  return ,,count;
               }
            } );
      }
   }
   ,,statList;
}

_Test( 5 );

print( func1(), func2(), func3(), func4(), func5() ); // 1 2 3 4 5</code></pre>
</div>
<p>
この例では、 <code>`{}</code> のリスト statList に関数定義を複数格納し、
それを展開することで、複数の関数定義(func1 〜 func5)を行なっています。</p>
<p>
なお macro-statement ブロックは、必須ではありません。
macro-statement ブロックを省略する場合、次のように {} ごと省略します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
macro name( arg ) {
   expand-statement
}</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-290" class="outline-5">
<h5 id="headline-290">
macro-statement で利用できる関数
</h5>
<div id="outline-text-headline-290" class="outline-text-5">
<p>
macro-statement では、次の関数が利用できます。</p>
<ul>
<li>fn _lnsLoad( name:str, code:str ): stem;</li>
</ul>
<p>この関数は、code で指定した LuneScript のコードをロードし、
そのモジュールを返します。</p>
</div>
</div>
<div id="outline-container-headline-291" class="outline-5">
<h5 id="headline-291">
マクロ展開
</h5>
<div id="outline-text-headline-291" class="outline-text-5">
<p>
マクロを展開する方法は、関数コールと同じです。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-292" class="outline-4">
<h4 id="headline-292">
公開マクロ
</h4>
<div id="outline-text-headline-292" class="outline-text-4">
<p>
マクロは外部モジュールに公開できます。</p>
<p>
次のように pub を宣言することで、そのマクロを import 先で利用できます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
pub macro _Hello() {
   print( &#34;hello world&#34; );
}</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-293" class="outline-4">
<h4 id="headline-293">
少し実用的なマクロの例
</h4>
<div id="outline-text-headline-293" class="outline-text-4">
<p>
次は少し実用的なマクロの例です。</p>
<p>
Google などが提供する REST API のパラメータやレスポンスなどで利用する JSON を、
LuneScript で扱うには、
REST API の JSON フォーマット毎にクラス化しておくと便利です。
そのような時、何種類もある JSON 形式のデータを扱うクラスを
手動で定義するのは非効率ですし、バグの元でもあります。</p>
<p>
そこで、 サンプルの JSON フォーマットを読み込んで、
その JSON フォーマットを格納可能なクラスを定義するマクロを作成します。</p>
<p>
この例では、次の JSON ファイルを読み込み、</p>
<div class="src src-js">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;val1&#34;</span><span class="o">:</span> <span class="s2">&#34;abc&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="s2">&#34;val2&#34;</span><span class="o">:</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>
上記 JSON を扱うための次のクラスを定義するマクロです。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Hoge {
  pri let val1:str {pub};
  pri let val2:int {pub};
}</code></pre>
</div>
<p>
次がマクロの具体例です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
macro _MkClass( name:str, path:str ) {
   {
      let mut memStatList:List&lt;stat&gt; = [];
      if! let mut fileObj = io.open( path ) {
         if! let txt = fileObj.read( &#34;*a&#34; ) {
            let defMap = &#34;pub let val = %s;&#34; (txt);
            let mod = _lnsLoad( &#34;json&#34;, defMap );
            if! let jsonval = mod.val {
               fn getType( val:stem ): str {
                  switch type( val ) {
                     case &#34;number&#34; {
                        return &#34;int&#34;;
                     }
                     case &#34;string&#34; {
                        return &#34;str&#34;;
                     }
                  }
                  return &#34;stem&#34;;
               }
               forsort val, key in jsonval@@Map&lt;str,stem&gt; {
                  memStatList.insert( `{
                     pri let ,,,key : ,,,getType( val )~~ {pub};
                  } );
               }
            }
         }
      }
   }
   class ,,,name {
      ,,memStatList;
   }
}
_MkClass( &#34;Hoge&#34;, &#34;hoge.js&#34; );

let hoge = new Hoge( &#34;ABC&#34;, 100 );
print( hoge.$val1, hoge.$val2 );</code></pre>
</div>
<p>
このマクロは、ファイルから JSON を読み込み、
その JSON 構造を格納するためのクラスを宣言します。</p>
<p>
クラス名はマクロの第一引数で指定します。</p>
<p>
このマクロは、次の処理を行ないます。</p>
<ul>
<li>指定のファイルを開き、そのファイル内に定義されている JSON 文字列を読み込む。</li>
<li>JSON 文字列 txt から、 &#34;pub let val = %s;&#34; (txt); で、 
LuneScript のコードを生成する。</li>
<li><code class="verbatim">_lnsLoad()</code> を使って、生成した LuneScript のコードをロードする</li>
<li>ロードしたモジュールから json の val を取り出し、 
forsort で JSON の要素を列挙する</li>
<li>列挙した要素を保持するメンバを宣言する <code>`{}</code> を生成し、memStatList に追加する</li>
<li>name と memStatList を使ってクラスを宣言する。  </li>
</ul>
<p>このサンプルでは処理を簡単にするために、
メンバは int と str 型のデータとして扱います。
リストなどはサポートしていません。</p>
</div>
</div>
<div id="outline-container-headline-294" class="outline-4">
<h4 id="headline-294">
マクロ間共通 Map
</h4>
<div id="outline-text-headline-294" class="outline-text-4">
<p>
マクロは、コンパイル時に実行される処理です。
また、マクロの実行はそれぞれ独立しています。
2 つのマクロ A, B を実行する時、
マクロ A の実行結果によってマクロ B の制御を変更する、
ということは出来ません。</p>
<p>
しかし、これだと不便なこともあります。
そこで、マクロ内でデータを共有するのが マクロ間共通 Map です。</p>
<p>
<strong>※これは実験的な機能です。</strong></p>
<p>
マクロの macro-statement 内からは、特殊変数 <code class="verbatim">__var</code> を利用できます。</p>
<p>
特殊変数 __var に以下の制約があります。</p>
<ul>
<li><strong>公開マクロは __var を利用できない</strong></li>
<li>__var にアクセスするマクロは、
そのマクロを定義した名前空間と同じ名前空間から使用しなければならない。</li>
<li>異なる名前空間から __var にアクセスした場合、その __var の内容は不定。</li>
</ul>
<p>
この変数の型は、次の通りです。</p>
<pre class="example">
let mut __var:Map&lt;str,stem&gt;
</pre>
<p>
この変数は、各モジュールのコンパイル開始時に生成され、
全てのマクロから同じ変数にアクセスします。</p>
<p>
次に例を示します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
   macro _test0( name:str, val:int ) {
      {
         __var[ name ] = val;
      }
   }
   macro _test1() {
      {
         let val;
         if! let work = __var[ &#34;hoge&#34; ] {
            val = work@@int;
         }
         else {
            val = 10;
         }
      }
      print( &#34;%s&#34; (,,val) );
   }
   _test0( &#34;hogea&#34;, 1 );
   _test1(); // 10
   _test0( &#34;hoge&#34;, 1 );
   _test1(); // 1</code></pre>
</div>
<p>
この例では、_test0() マクロで <code class="verbatim">__var[ &#34;hoge&#34; ]</code> に int データを保持し、
_test1() マクロで <code class="verbatim">__var[ &#34;hoge&#34; ]</code> の格納されている値によって処理を変更しています。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-295" class="outline-3">
<h3 id="headline-295">
まとめ
</h3>
<div id="outline-text-headline-295" class="outline-text-3">
<p>
LuneScript は、関数と同じ感覚でマクロを定義することが出来ます。</p>
<p>
また、マクロを利用することで、
さまざまな処理を定義できるようになります。</p>
<p>
次回は、 LuneScript を使って開発するプロジェクトの
ビルド方法について説明します。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-cast_ja" class="outline-2">
<h2 id="cast_ja">
<strong>キャスト 編</strong>
</h2>
<div id="outline-text-cast_ja" class="outline-text-2">
<p>
LuneScript は、 3 つのタイプのキャストを提供します。</p>
<ul>
<li><code>@@</code></li>
<li><code>@@@</code></li>
<li><code>@@=</code></li>
</ul>
<div id="outline-container-headline-297" class="outline-3">
<h3 id="headline-297">
<code>@@</code>  
</h3>
<div id="outline-text-headline-297" class="outline-text-3">
<p>
<code>@@</code> は、変換元の値の型を実行時にチェックせずに強制的に型変換します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val1:stem = 1;
let val2:int = val1@@int;</code></pre>
</div>
<p>
次のような本来変換できない値も強制的なキャストを行なえてしまいます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let val1:stem = 1;
let val2:str[] = val1@@str[];
print( #val2 ); // runtime error</code></pre>
</div>
<p>
上記は、 int 型の値 1 を stem 型の val1 に代入し、
それを str リスト型の val2 にキャストしています。
つまり、int 型を str リストにキャストしてしまっています。
この val2 に対してアクセスすると、 <strong>実行時エラー</strong> となります。</p>
<p>
なお、 暗黙的に型変換が行なえるものを @@ で明示的にキャストすると、 
warning となります。</p>
<p>
例えば次のサンプルの <code>func( &#34;abc&#34;@@stem )</code>  は、
文字列 &#34;abc&#34; から stem への変換は明示キャスト不要で変換可能なため
warning が出力されます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( val:stem ) {
}
func( &#34;abc&#34;@@stem );</code></pre>
</div>
<p>
また、明らかに不正な型変換はコンパイルエラーとなります。</p>
<p>
例えば次の場合、 <code>1@@str</code> は int から str に変換していますが、
この型変換は出来ないためコンパイルエラーとなります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let val = &#34;abc&#34;@@int;  // error
let val2 = 1@@str;  // error</code></pre>
</div>
<p>
クラス型への <code class="verbatim">@@</code> キャストは warning 出力します。</p>
<p>
<code class="verbatim">@@</code> は、 nilable から非 nilable へのキャストは出来ません。</p>
<p>
クラス型へのキャストは <code>@@@</code> か <code>@@=</code> を使用してください。</p>
</div>
</div>
<div id="outline-container-headline-298" class="outline-3">
<h3 id="headline-298">
<code>@@@</code>
</h3>
<div id="outline-text-headline-298" class="outline-text-3">
<p>
<code>@@@</code> は、動的に変換元の型をチェックして型変換します。</p>
<p>
次は <code>@@@</code> の例です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( val:stem ) {
   if! val@@@int {
      print( &#34;int:%d&#34; ( _exp ) );
   }
   if! val@@@str {
      print( &#34;str:%s&#34; ( _exp ) );
   }
}
func( 1 ); // int:1
func( &#34;abc&#34; ); // str:abc</code></pre>
</div>
<p>
<code>val@@@int</code> は、 val の型をチェックし int 型ならば変換し、
int 型でなければ nil を返します。
また、 <code>val@@@str</code> は val の型をチェックし str 型ならば変換し、
str 型でなければ nil を返します。</p>
<p>
これにより、
<code>func( 1 )</code> は int:1 を出力し、
<code>func( &#34;abc&#34; )</code> は str:abc を出力します。</p>
<p>
<code class="verbatim">@@@</code> は、 キャスト元が nilable でもキャスト可能です。</p>
<div id="outline-container-headline-299" class="outline-4">
<h4 id="headline-299">
<code>@@@</code> の制限 1
</h4>
<div id="outline-text-headline-299" class="outline-text-4">
<p>
real 型の値から int への @@@ キャストは nil を返すべきですが、
成功するケースがあります。</p>
<p>
そのケースとは、小数点以下を持たない real 型の値を int にキャストした場合です。</p>
<p>
本来の仕様では、
real 型の値から int への @@@ キャストは nil を返すべきですが、これは現状の制限です。</p>
<p>
なお、Go 言語へトランスコンパイルした場合、
本来の仕様通り real 型の値から int への @@@ キャストは nil を返します。</p>
<p>
この動作は、将来の変更になる可能性があります。</p>
<p>
例えば次の <code>func( 1 )</code> は <code>int:1</code> , <code>real:1</code> を出力し、
<code>func( 2.5 )</code> は <code>real:2.5</code> を出力します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( val:stem ) {
   if! val@@@int {
      print( &#34;int:%d&#34; ( _exp ) );
   }
   if! val@@@real {
      print( &#34;real:%g&#34; ( _exp ) );
   }
}
func( 1.0 );
func( 2.5 );</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-300" class="outline-4">
<h4 id="headline-300">
<code>@@@</code> の制限 2
</h4>
<div id="outline-text-headline-300" class="outline-text-4">
<p>
@@@ が利用できるのは、 int/real/str/class/interface だけです。</p>
<p>
enum などは利用できません。</p>
<p>
また、 class でも generics は利用できません。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-301" class="outline-3">
<h3 id="headline-301">
<code>@@=</code>
</h3>
<div id="outline-text-headline-301" class="outline-text-3">
<p>
<code>@@=</code> は、メソッドを持たないクラスを変換する際に利用します。
メソッドを持つクラスや、クラス以外を指定した場合はコンパイルエラーします。</p>
<p>
なお、 <code>@@=</code> も変換元の値をチェックせずに強制的に型変換を行ないます。</p>
<p>
<code>@@=</code> は、型チェックに時間がかかるような場合に限り使用するべきです。</p>
</div>
</div>
<div id="outline-container-headline-302" class="outline-3">
<h3 id="headline-302">
まとめ
</h3>
<div id="outline-text-headline-302" class="outline-text-3">
<p>
int、 real 間の変換以外は、 <strong>出来るだけキャストは避けるべきです。</strong>
generics や、 alge などを利用することで
型を保ったまま汎用処理を作成できます。</p>
<p>
キャストを利用するにしても、 <code>@@@</code> を利用し、
<code>@@</code> や <code>@@=</code> の利用は必要最低限になるように設計してください。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-subfile_ja" class="outline-2">
<h2 id="subfile_ja">
<strong>subfile 編</strong>
</h2>
<div id="outline-text-subfile_ja" class="outline-text-2">
<p>
モジュールの処理が大きくなると、それに伴ないファイルが肥大化する。</p>
<p>
ファイルの肥大化に良いことはないため、
このような場合はモジュールの責務を細分化し、
それぞれのモジュール毎にファイルを分けるのが一般的なリファクタリングである。</p>
<p>
しかし、綺麗に責務を分割できない場合や、
分割すると他のモジュールに与える影響が大きくなってしまう事もよくある。
このようにモジュール分割による対応が出来ない場合の代替手段として、
サブファイル化を行なう。</p>
<p>
サブファイル化とは、
本来 1 つのファイルで構成するモジュールを複数のファイルに分割することである。</p>
<p>
LuneScript は、原則 1 モジュール = 1 ファイルであるが、
サブファイル化した場合は、1 モジュール = 複数ファイルとなる。</p>
<div id="outline-container-headline-304" class="outline-3">
<h3 id="headline-304">
サブファイル構成
</h3>
<div id="outline-text-headline-304" class="outline-text-3">
<p>
サブファイルは 1 つの main と、複数の sub で構成される。</p>
<div class="src src-text">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">- main
</span></span><span class="line"><span class="cl">  +- sub1
</span></span><span class="line"><span class="cl">  +- sub2
</span></span><span class="line"><span class="cl">  +- ...
</span></span><span class="line"><span class="cl">  +- ...
</span></span><span class="line"><span class="cl">  +- subN</span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-305" class="outline-3">
<h3 id="headline-305">
使用方法
</h3>
<div id="outline-text-headline-305" class="outline-text-3">
<p>
次のように foo/bar ディレクトリ以下に、
main.lns, sub.lns が存在し sub.lns が main.lns のサブファイルの場合、</p>
<div class="src src-text">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">foo/bar
</span></span><span class="line"><span class="cl">     + main.lns
</span></span><span class="line"><span class="cl">     + sub.lns</span></span></code></pre></div>
</div>
<p>
サブファイルを利用するには、 main 側で次のように宣言する。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
subfile use foo.bar.sub;</code></pre>
</div>
<p>
また、サブファイル側では次のように宣言する。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
subfile owner foo.bar.main;</code></pre>
</div>
<p>
これにより、
指定したモジュール(上記の例では foo.bar.sub)を分割されたサブファイルとして扱い、
sub.lns は main.lns のモジュールの一部として処理する。</p>
<div id="outline-container-headline-306" class="outline-4">
<h4 id="headline-306">
制限
</h4>
<div id="outline-text-headline-306" class="outline-text-4">
<p>
モジュールの宣言は、スクリプトの先頭で行なう必要がある。
ただし、コメントは除く。</p>
<p>
subfile use は、1 つのファイル内で複数宣言できる。
subfile owner は、一つだけ宣言できる。
つまり、1 つのファイルは複数のサブファイルを持てるが、
1つのサブファイルは1つのオーナからしか利用できない。</p>
<p>
subfile use を複数宣言した場合、宣言した順でサブファイルを処理する。</p>
<p>
サブファイルは C の #include と基本的には同じと考えて良いが、
次の点で #include と異なる。</p>
<ul>
<li>C の <code class="verbatim">#include</code> は宣言した箇所にファイルを展開するが、 
LuneScript ではファイルの最終位置にサブファイルを展開する。</li>
<li>
<p>サブファイルは、 statement として完結している必要がある。</p>
<ul>
<li><code class="verbatim">#include</code> のような、式の一部をサブファイル内には書けない。</li>
</ul>
</li>
<li>サブファイルに対するメインファイルは 1 つでなければならない。</li>
<li>サブファイルから、さらにサブファイルを利用することはできない。</li>
</ul>
<p>例えば、次の main.lns, sub1.lns, sub2.lns があった場合、</p>
<ul>
<li>main.lns</li>
</ul>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
//------ main.lns -------
subfile use sub1;
subfile use sub2;

pub let val = 1;</code></pre>
</div>
<ul>
<li>sub1.lns</li>
</ul>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
//------ sub1.lns -------
subfile owner main;

pub let val1 = 1;</code></pre>
</div>
<ul>
<li>sub2.lns</li>
</ul>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
//------ sub2.lns -------
subfile owner main;

pub let val2 = 1;</code></pre>
</div>
<p>
main.lns は次のスクリプトと等価である。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
//------ main.lns -------
pub let val = 1;
pub let val1 = 1;
pub let val2 = 1;</code></pre>
</div>
<hr>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-lazyloading_ja" class="outline-2">
<h2 id="lazyloading_ja">
<strong>遅延ロード 編</strong>
</h2>
<div id="outline-text-lazyloading_ja" class="outline-text-2">
<p>
ある程度の規模のプロジェクトでは、複数のモジュールを import することになります。
そして import したモジュール内でまた別のモジュールを import しています。</p>
<p>
スクリプト言語における import は、動的なロード処理を意味します。
あるスクリプトを起動すると、
そのスクリプトが利用している全てのモジュールのロード処理が行なわれた後に、
ようやくスクリプトのメイン処理が動き出します。</p>
<p>
例えば、次の図に示すような import の関係があった場合、
メインの mod モジュールの処理が行なわれるのは、
関連する全てのモジュールのロードが終ってから
mod モジュールの処理が行なわれます。</p>
<div class="src src-dot">
<pre tabindex="0"><code class="language-dot" data-lang="dot">digraph G {
rankdir = TB;
mod -&gt; funcA
mod -&gt; funcB
mod -&gt; funcC

funcA -&gt; subA_1
funcA -&gt; subA_2
funcA -&gt; subA_3

funcB -&gt; subB_1
funcB -&gt; subB_2
funcB -&gt; subB_3

funcC -&gt; subC_1
funcC -&gt; subC_2
funcC -&gt; subC_3
}</code></pre>
</div>
<p>
<img src="../lazy.svg" alt="../lazy.svg" title="../lazy.svg" /></p>
<p>
しかし、 import したモジュールを全て常に使うとは限りません。</p>
<p>
例えば、上記の図が 3 つの機能(funcA,funcB,funcC)を提供するプログラムとして考えます。</p>
<p>
このプログラムの 3 つの内の一つを選択して実行するような場合、
選択されなかった残りの 2 つの機能は使われません。</p>
<p>
import は、モジュールが使われるかどうかに関係なく、
モジュールをロードします。
つまり、実際には使わないモジュールのロード処理に掛る時間や、
ロードしたデータを格納しておくメモリ領域は無駄になることになります。</p>
<p>
上記の図で説明すると、
funcA が選択された場合 funcB, subB_1 〜 subB_3、
func_C, subC_1 〜 subC_3 が無駄になります。</p>
<p>
プロジェクトの規模が小さい場合、
この無駄を気にする必要はほとんどありません。
しかし、プロジェクトの規模が大きくなった場合、
この無駄を無視できなくなってきます。</p>
<p>
例えば一つのモジュールのロード処理に必要な時間が 0.01 秒だったとしても、
100 個のモジュールがあれば 1 秒かかります。</p>
<p>
プログラムが常駐するのであれば、ロード処理は一度きりなので、
多少起動時間がかかっても我慢できますが、
常駐せずにリクエスト毎に起動しなければならない場合、
この無駄なロード処理は無視できなくなります。</p>
<p>
このロード処理の無駄を無くすのが遅延ロードです。</p>
<div id="outline-container-headline-308" class="outline-3">
<h3 id="headline-308">
遅延ロード
</h3>
<div id="outline-text-headline-308" class="outline-text-3">
<p>
遅延ロードは、起動時に関連する全てのモジュールをロードするのではなく、
モジュールが必要になったタイミングでロードする処理方式です。</p>
<p>
上記の図で説明すると、
funcA が選択された場合、
アクセスされない funcB, subB_1 〜 subB_3、
func_C, subC_1 〜 subC_3 はロードされません。</p>
<p>
これにより、ロード処理の時間、
ロードしたデータを格納しておくメモリ領域を無駄にしません。</p>
<div id="outline-container-headline-309" class="outline-4">
<h4 id="headline-309">
遅延ロードの実現方法
</h4>
<div id="outline-text-headline-309" class="outline-text-4">
<p>
遅延ロードは、モジュールにアクセスしたタイミングでロード済みかどうかを判断し、
ロードしていなければロードし、
ロードしていればロード済みのデータを利用します。</p>
<p>
一方通常のロードは、
起動時(import したタイミング)に数珠繋ぎで全てのモジュールをロードします。</p>
<p>
つまり、遅延ロードでは、通常のロードと比べて判定処理が入るので
その分のオーバーヘッドがあります。
もちろんオーバーヘッドは非常に少ないです。
しかし、オーバーヘッドが掛るのは事実であるので、
非常にクリティカルなケースでは性能劣化が発生することも考えられます。</p>
<p>
遅延ロードを利用する場合、このようなケースの考慮が必要です。</p>
</div>
</div>
<div id="outline-container-headline-310" class="outline-4">
<h4 id="headline-310">
遅延ロードの影響
</h4>
<div id="outline-text-headline-310" class="outline-text-4">
<p>
前述している通り、遅延ロードには僅かなオーバーヘッドがあります。</p>
<p>
しかし、それが影響することはほとんどないでしょう。</p>
<p>
それよりも影響する可能性が高いと考えられるのが、実行順序の違いです。</p>
<div id="outline-container-headline-311" class="outline-5">
<h5 id="headline-311">
ロード方式の違いによる実行順序の影響
</h5>
<div id="outline-text-headline-311" class="outline-text-5">
<p>
モジュールのトップスコープに書いた処理は、
そのモジュールがロードされた時に実行されます。</p>
<p>
例えば次のようなモジュールがあった場合、</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
print( &#34;hoge&#34; );
fn func() {
    print( &#34;foo&#34; );
}</code></pre>
</div>
<p>
このモジュールがロードされたタイミングで hoge が出力されます。
一方で、 <code class="verbatim">func()</code> はロードされただけでは実行されないので foo は出力されません。</p>
<p>
そして、このモジュールを import する次のモジュールがある場合、</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
import Hoge;

print( &#34;bar&#34; );
Hoge.func();</code></pre>
</div>
<p>
通常ロードの場合、次の出力が行なわれます。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">hoge
</span></span><span class="line"><span class="cl">bar
</span></span><span class="line"><span class="cl">foo</span></span></code></pre></div>
</div>
<p>
一方で遅延ロードの場合、次の出力が行なわれます。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">bar
</span></span><span class="line"><span class="cl">hoge
</span></span><span class="line"><span class="cl">foo</span></span></code></pre></div>
</div>
<p>
出力結果を比較すると、
<strong>bar と hoge の出力順番</strong> が入れ替わっています。</p>
<p>
なぜこのようなことが起るかというと、
通常ロードでは</p>
<ul>
<li>import したタイミングでサブモジュール Hoge がロードされ、</li>
<li>そのタイミングで <code class="verbatim">print( &#34;hoge&#34; )</code> が実行され、</li>
<li>サブモジュール Hoge のロード終了後に <code class="verbatim">print( &#34;bar&#34; )</code> が実行される。</li>
</ul>
<p>一方で遅延ロードでは、
通常ロードでは import したタイミングでサブモジュール Hoge がロードされず、</p>
<ul>
<li>最初に <code class="verbatim">print( &#34;hoge&#34; )</code> が実行され、</li>
<li>次の <code class="verbatim">Hoge.func()</code> を実行する直前に、
サブモジュール Hoge がロードされ、</li>
<li><code class="verbatim">print( &#34;hoge&#34; )</code> が処理される。</li>
</ul>
<p>通常ロードと遅延ロードには、このような違いが起る。</p>
</div>
</div>
<div id="outline-container-headline-312" class="outline-5">
<h5 id="headline-312">
ロード方式の違いによる global の影響
</h5>
<div id="outline-text-headline-312" class="outline-text-5">
<p>
LuneScript のアクセス制御には pub/pro/pri/local の他に、global があります。</p>
<p>
global の詳細については他の記事を参照していただくとして、
global はモジュールをロードしたタイミングで登録されます。</p>
<p>
つまり、遅延ロードの影響で <strong>global のデータが登録されるタイミングがズレます。</strong></p>
<p>
global を使うケースは少ないと思いますが、注意してください。</p>
<p>
<strong>global は、既存の Lua コードとの互換を必要するケースにのみの利用を推奨。</strong></p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-313" class="outline-3">
<h3 id="headline-313">
使用方法
</h3>
<div id="outline-text-headline-313" class="outline-text-3">
<p>
遅延ロードは次の命令で利用できます。</p>
<ul>
<li>import</li>
<li>module</li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>ロード処理</th>
</tr>
</thead>
<tbody>
<tr>
<td>import</td>
<td>コンパイルオプション依存</td>
</tr>
<tr>
<td>import.l</td>
<td>遅延ロード</td>
</tr>
<tr>
<td>import.d</td>
<td>通常ロード</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>命令</th>
<th>ロード処理</th>
</tr>
</thead>
<tbody>
<tr>
<td>module</td>
<td>コンパイルオプション依存</td>
</tr>
<tr>
<td>module.l</td>
<td>遅延ロード</td>
</tr>
<tr>
<td>module.d</td>
<td>通常ロード</td>
</tr>
</tbody>
</table>
<p>
例えば以下のようにすることで、 Sub モジュールは遅延ロードされます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
import.l Sub;</code></pre>
</div>
<p>
import, module はコンパイルオプション依存です。</p>
<p>
コンパイルオプションに次を指定した場合、</p>
<pre class="example">
--default-lazy
</pre>
<p>
import, module は遅延ロードになります。</p>
<p>
なお、import.d, module.d を指定した場合は、
<code class="verbatim">--default-lazy</code> を指定している時も通常ロードになります。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-shebang_main_ja" class="outline-2">
<h2 id="shebang_main_ja">
<strong>shebang とコマンドライン引数</strong>
</h2>
<div id="outline-text-shebang_main_ja" class="outline-text-2">
<p>
LuneScript は shebang に対応しています。</p>
<div id="outline-container-headline-315" class="outline-3">
<h3 id="headline-315">
shebang 対応
</h3>
<div id="outline-text-headline-315" class="outline-text-3">
<p>
shebang とは、シェルスクリプト等で良く見られるスクリプトファイルの最初の行に、
使用するインタプリタをコメントに指定することで、
そのスクリプトファイルを実行すると指定しているインタプリタが実行される機能です。
例えば bash では次のように指定します。</p>
<div class="src src-sh">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1">#! /bin/bash</span></span></span></code></pre></div>
</div>
<p>
LuneScript では、次のように指定します。</p>
<div class="src src-sh">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="c1">#! /usr/bin/lnsc -shebang</span></span></span></code></pre></div>
</div>
<p>
ここで、 <code class="verbatim">/usr/bin/lnsc</code> は環境に合せた指定が必要です。</p>
<p>
これによって、 <code class="verbatim">#!</code> が記載された LuneScript ファイルをそのまま実行できます。</p>
<p>
例えば次のようなファイル hello.lns があった場合、</p>
<div class="src src-sh">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl"><span class="cp">#! /usr/bin/lnsc -shebang
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>print<span class="o">(</span> <span class="s2">&#34;hello world&#34;</span> <span class="o">)</span><span class="p">;</span></span></span></code></pre></div>
</div>
<p>
この hello.lns を直接実行できます。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ hello.lns
</span></span><span class="line"><span class="cl">hello world</span></span></code></pre></div>
</div>
<p>
<del>この時、次の制限があります。</del></p>
<ul>
<li><del>go 版 lnsc では、 import している .lns ファイルに対応する .lua を</del>
<del>事前に生成しておく必要がある。</del></li>
</ul>
</div>
</div>
<div id="outline-container-headline-316" class="outline-3">
<h3 id="headline-316">
コマンドライン引数
</h3>
<div id="outline-text-headline-316" class="outline-text-3">
<p>
shebang で起動された場合や、 go へトランスコンパイルした場合など、
コマンドライン引数を処理したいケースがあります。</p>
<p>
このコマンドライン引数を処理するためには、
次の __main 関数を定義し、
この関数の引数に渡されるコマンドライン引数を処理します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip   
pub fn __main( argList:&amp;List&lt;str&gt; ):int</code></pre>
</div>
<p>
__main 関数の型は、
引数名 argList 以外、必ず上記の型での宣言が必要です。</p>
<div id="outline-container-headline-317" class="outline-4">
<h4 id="headline-317">
__main の実行順
</h4>
<div id="outline-text-headline-317" class="outline-text-4">
<p>
この __main 関数の実行順序は、トップスコープの処理終了後に行なわれます。
つまり、次のスクリプトの場合、</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">#! /usr/bin/lnsc -shebang
// @lnsFront: skip   
print( &#34;hello world&#34; );

pub fn __main( argList:&amp;List&lt;str&gt; ):int {
   print( &#34;hoge&#34; );
   return 0;
}</code></pre>
</div>
<p>
出力結果は以下になります。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ ./mini.lns 
</span></span><span class="line"><span class="cl">hello world
</span></span><span class="line"><span class="cl">hoge</span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-318" class="outline-4">
<h4 id="headline-318">
__main の引数
</h4>
<div id="outline-text-headline-318" class="outline-text-4">
<p>
<code class="verbatim">__main</code> の引数は <code class="verbatim">&amp;List&lt;str&gt;</code> です。</p>
<p>
このリストには、先頭にスクリプトのパス、以降にコマンドライン引数が格納されます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">#! /usr/bin/lnsc -shebang
// @lnsFront: skip   
pub fn __main( argList:&amp;List&lt;str&gt; ):int {
   foreach arg in argList {
      print( arg );
   }
   return 0;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-319" class="outline-3">
<h3 id="headline-319">
lua へトランスコンパイルした時の __main() 関数の動作
</h3>
<div id="outline-text-headline-319" class="outline-text-3">
<p>
次の LuneScript のコードはコマンドラインオプションを出力します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">pub fn __main( argList:&amp;List&lt;str&gt; ) : int {
   foreach arg, index in argList {
      print( index, arg );
   }
   return 0;
}</code></pre>
</div>
<p>
以下は実行結果のサンプルです。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ lnsc -shebang mini.lns a b c 
</span></span><span class="line"><span class="cl">1	mini.lns
</span></span><span class="line"><span class="cl">2	a
</span></span><span class="line"><span class="cl">3	b
</span></span><span class="line"><span class="cl">4	c</span></span></code></pre></div>
</div>
<p>
このコードをトランスコンパイラするには、次のコマンドを実行します。</p>
<pre class="example">
lnsc mini.lns save
</pre>
<p>
これによって、 mini.lua が出力されます。</p>
<p>
この mini.lua を実行すると、以下のようになります。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ lua5.3 mini.lua a b c</span></span></code></pre></div>
</div>
<p>
これが何を意味するかというと、「 <strong>__main() 関数が呼ばれていない</strong> 」ということです。</p>
<p>
lnsc に -shebang オプションを指定して実行した場合、
.lns ファイルに定義されている __main() 関数を実行します。
一方で、トランスコンパイルした lua コードには __main() を実行するコードが
出力されないため、このような動作になります。</p>
<p>
トランスコンパイルした lua コードの __main() を実行するには、次のいずれかが必要です。</p>
<ul>
<li>__main() を実行するコードを別途自前で作成する</li>
<li>トランスコンパイルする際に <code class="verbatim">--main</code> オプションを指定する</li>
</ul>
<div id="outline-container-headline-320" class="outline-4">
<h4 id="headline-320">
<code class="verbatim">--main</code> オプション
</h4>
<div id="outline-text-headline-320" class="outline-text-4">
<p>
トランスコンパイルする際に <code class="verbatim">--main</code> オプションを指定することで、
指定のモジュールに <code class="verbatim">__main()</code> 関数を実行する処理を出力します。</p>
<p>
以下は、 <code class="verbatim">--main</code> オプションのサンプルです。</p>
<pre class="example">
$ lnsc mini.lns save --main mini
</pre>
<p>
ここで、 <code class="verbatim">--main mini</code> の mini は、実行する __main() を含むモジュール名です。</p>
<p>
これにより、 mini.lua には __main() を実行するコードが出力されます。</p>
<p>
以下は、 <code class="verbatim">--main mini</code> を指定して生成した mini.lua の実行結果です。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ lua5.3 mini.lua a b c
</span></span><span class="line"><span class="cl">1	mini.lua
</span></span><span class="line"><span class="cl">2	a
</span></span><span class="line"><span class="cl">3	b
</span></span><span class="line"><span class="cl">4	c</span></span></code></pre></div>
</div>
<p>
ここで注意が必要なのは、
lnsc の shebang で実行した場合の argList の第一引数には <strong>.lns</strong> のパスが入るのに対し、
lua へトランスコンパイルした後の argList の第一引数には
<strong>.lua</strong> のパスが入る違いがあります。</p>
<hr>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-dir_ja" class="outline-2">
<h2 id="dir_ja">
<strong>LuneScript を利用するプロジェクトの推奨ディレクトリ構成</strong>
</h2>
<div id="outline-text-dir_ja" class="outline-text-2">
<p>
LuneScript は lua と go へのトランスコンパイルをサポートします。</p>
<p>
一方で、 lua , go は、ディレクトリ管理方法が異なります。</p>
<p>
ここでは、どちらの言語のディレクトリ管理においても問題なく使えるようにするための
推奨ディレクトリ構成について説明します。</p>
<div id="outline-container-headline-322" class="outline-3">
<h3 id="headline-322">
前提
</h3>
<div id="outline-text-headline-322" class="outline-text-3">
<p>
ここでは以下の github リポジトリで開発することを前提として説明します。</p>
<pre class="example">
github.com/HOGE/PROJ
</pre>
<ul>
<li>HOGE は、任意の github アカウント名。</li>
<li>PROJ は、任意のリポジトリ名。</li>
</ul>
<p>また、以下のモジュールを定義することを前提に説明します。</p>
<pre class="example">
foo.bar.lib
</pre>
</div>
</div>
<div id="outline-container-headline-323" class="outline-3">
<h3 id="headline-323">
基本構成
</h3>
<div id="outline-text-headline-323" class="outline-text-3">
<p>
ディレクトリの基本構成を示します。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">PROJ/
</span></span><span class="line"><span class="cl"> +-- go.mod
</span></span><span class="line"><span class="cl"> +-- lune.js
</span></span><span class="line"><span class="cl"> +-- foo/
</span></span><span class="line"><span class="cl">   +-- bar/
</span></span><span class="line"><span class="cl">      +-- lib.lns</span></span></code></pre></div>
</div>
<p>
go.mod, lune.js, foo/ を、 PROJ ディレクトリ直下に配置します。</p>
<div id="outline-container-headline-324" class="outline-4">
<h4 id="headline-324">
lune.js
</h4>
<div id="outline-text-headline-324" class="outline-text-4">
<p>
lune.js は、以下の内容で作成します。</p>
<pre class="example">
{}
</pre>
</div>
</div>
<div id="outline-container-headline-325" class="outline-4">
<h4 id="headline-325">
go.mod
</h4>
<div id="outline-text-headline-325" class="outline-text-4">
<p>
この時の go.mod の構成を示します。
なお、 go.mod は go へのトランスコンパイルを行なわない場合は不要です。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">module github.com/HOGE/PROJ
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">go 1.16</span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-326" class="outline-4">
<h4 id="headline-326">
メインとサブモジュール
</h4>
<div id="outline-text-headline-326" class="outline-text-4">
<p>
リポジトリは、   
<strong>メイン</strong> のプログラムを管理するケースと、
メインのプログラムから利用される <strong>サブモジュール</strong> を管理するケースがあります。</p>
<p>
<strong>サブモジュール</strong> として管理する場合、
上記の基本構造の制限が若干緩和されます。</p>
<p>
具体的には、以下が緩和されます。</p>
<ul>
<li>go.mod, lune.js, foo を <strong>PROJ 直下に無くても良くなります。</strong></li>
<li>go.sum の github への <strong>登録が不要</strong> になります。</li>
</ul>
<p>例えば以下のように src の下に配置することが出来ます。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">PROJ/
</span></span><span class="line"><span class="cl"> +-- src/  &lt;--- ※任意のディレクトリ以下に配置可能
</span></span><span class="line"><span class="cl">   +-- go.mod
</span></span><span class="line"><span class="cl">   +-- lune.js
</span></span><span class="line"><span class="cl">   +-- foo/
</span></span><span class="line"><span class="cl">     +-- bar/
</span></span><span class="line"><span class="cl">        +-- lib.lns</span></span></code></pre></div>
</div>
<p>
この場合、 go.mod は以下のように module のパスが異なります。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">module github.com/HOGE/PROJ/src
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">go 1.16</span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-327" class="outline-4">
<h4 id="headline-327">
環境変数 GOPATH
</h4>
<div id="outline-text-headline-327" class="outline-text-4">
<p>
go へトランスコンパイルする場合、
上記 PROJ ディレクトリを次の場所に配置する必要があります。</p>
<pre class="example">
${GOPATH}/src/github.com/HOGE/PROJ
</pre>
<p>
GOPATH を設定していない場合は <code class="verbatim">${HOME}/go</code> が利用されます。</p>
<hr>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-go_ja" class="outline-2">
<h2 id="go_ja">
<strong>Go 言語へのトランスコンパイル</strong>
</h2>
<div id="outline-text-go_ja" class="outline-text-2">
<p>
LuneScript はトランスコンパイル先の言語として Lua だけでなく、
Go へのトランスコンパイルが可能です。</p>
<p>
この機能により、
LuneScript のセルフホスティングコードを go 言語のコードにトランスコンパイルし、
それを go でビルドすることで、 LuneScript の高速化(約 16倍)を実現しています。</p>
<p>
高速化については次を参照してください。
<a href="https://ifritjp.github.io/blog2/public/posts/2021/2021-06-28-lunescript-build-time-2000/">https://ifritjp.github.io/blog2/public/posts/2021/2021-06-28-lunescript-build-time-2000/</a></p>
<p>
ただし、
LuneScript のセルフホスティングに必要な機能に限定したサポートになっているため、
一部の機能は対応できていません。</p>
<p>
とはいえ、LuneScript のセルフホスティング自体が、
LuneScript のほとんどの機能を使用しているので、
普通に使う分には問題なく対応出来ています。</p>
<div id="outline-container-headline-329" class="outline-3">
<h3 id="headline-329">
go 言語へのトランスコンパイル方法
</h3>
<div id="outline-text-headline-329" class="outline-text-3">
<p>
go 言語へのトランスコンパイルは、
LuneScript のコマンドラインオプション save あるいは SAVE 時に
 <strong>-langGo</strong> を指定することで、
.go 拡張子のファイルに go へのトランスコンパイル結果を出力します。</p>
</div>
</div>
<div id="outline-container-headline-330" class="outline-3">
<h3 id="headline-330">
Lua との連携動作
</h3>
<div id="outline-text-headline-330" class="outline-text-3">
<p>
go 言語へのトランスコンパイルを行なう場合、
Lua との連携動作を行なう際に特別な型を使用する必要があります。</p>
<p>
詳しくは以下を参照してください。</p>
<p>
<a href="#lua">#lua</a></p>
</div>
</div>
<div id="outline-container-headline-331" class="outline-3">
<h3 id="headline-331">
Go 言語へのトランスコンパイル後の構成
</h3>
<div id="outline-text-headline-331" class="outline-text-3">
<p>
LuneScript は Lua へのトランスコンパイラであり、
LuneScript から Lua のコードを直接利用できるという特徴があります。</p>
<p>
この特徴は、 Go 言語へトランスコンパイルした後でも引き継がれます。</p>
<p>
例えば、次のようなコードを Go 言語へ変換した後でも動かせます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let step = 30;

// Lua のフィボナッチ関数
let code = ```
local function fib ( n )
   if n &lt; 2 then return n end
   return fib(n - 2) + fib(n - 1)
end
return fib
```;

// Lua コードのロード
form fibFunc( num:int ):int;
fn loadLua( txt:str ) : Luaval&lt;fibFunc&gt; {
   let fib;
   __luago {
      let loaded = unwrap _load( txt ## );
      fib = unwrap loaded(##);
   }
   return fib@@fibFunc;
}

// プロファイル用マクロ
macro _profile( exec:__exp ) {
   {}
   {
      let prev = os.clock();
      print( &#34;%s = %d: step = %d: time = %g&#34;
             (,,,,exec, ,,exec, step, os.clock() - prev ) );
   }
}

// Lua のコードをロードして実行
let fib_lua = loadLua( code );
__luago {
   _profile( fib_lua( step ) );
}

// LuneScript のフィボナッチ関数
fn fib_lns( num:int ) : int {
   if num &lt; 2 {
      return num;
   }
   return fib_lns( num - 2 ) + fib_lns( num - 1 );
}
// Go で定義した fib_lns 関数を実行
_profile( fib_lns( step ) );</code></pre>
</div>
<p>
このコードは、 フィボナッチの計算を lua と LuneScript で行なうものです。</p>
<p>
最初の code 変数で定義しているのが lua のコードで、
それをロードするのが <code class="verbatim">loadLua()</code> 関数で、ロードされた Lua の関数が fib_lua です。
そして、後半の <code class="verbatim">fib_lns()</code> 関数は フィボナッチの計算を行なう LuneScript の関数です。</p>
<div id="outline-container-headline-332" class="outline-4">
<h4 id="headline-332">
Lua へトランスコンパイルした場合
</h4>
<div id="outline-text-headline-332" class="outline-text-4">
<p>
上記コードを Lua にトランスコンパイルして動かすと、次が出力されます。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">fib_lua( step ) = 24157817: step = 37: time = 5.69
</span></span><span class="line"><span class="cl">fib_lns( step ) = 24157817: step = 37: time = 5.38</span></span></code></pre></div>
</div>
<p>
これは、=fib_lua()= と <code class="verbatim">fib_lns()</code> それぞれの計算結果と、計算時間を表しています。</p>
<p>
これを見ると、
Lua でロードされた関数 <code class="verbatim">fib_lua()</code> と、
Lns の関数 <code class="verbatim">fib_lns()</code> の実行時間がほとんど同じ時間掛ることが分かります。</p>
<p>
これは当然の結果です。
なぜならば、 LuneScript を Lua に変換した場合は、
LuneScript で書いた <code class="verbatim">fib_lns()</code> と Lua の <code class="verbatim">fib_lua()</code> は、
ほとんど同じ Lua のコードになるからです。</p>
<p>
上記のコードを Lua にトランスコンパイルした際のコードは次のようになります。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="c1">--miniGo.lns</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">_moduleObj</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">__mod__</span> <span class="o">=</span> <span class="s1">&#39;@miniGo&#39;</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">_lune</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span> <span class="s2">&#34;lune.base.runtime2&#34;</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">if</span> <span class="ow">not</span> <span class="n">_lune2</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">   <span class="n">_lune2</span> <span class="o">=</span> <span class="n">_lune</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">step</span> <span class="o">=</span> <span class="mi">37</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">code</span> <span class="o">=</span> <span class="s">[==[
</span></span></span><span class="line"><span class="cl"><span class="s">local function fib ( n )
</span></span></span><span class="line"><span class="cl"><span class="s">   if n &lt; 2 then return n end
</span></span></span><span class="line"><span class="cl"><span class="s">   return fib(n - 2) + fib(n - 1)
</span></span></span><span class="line"><span class="cl"><span class="s">end
</span></span></span><span class="line"><span class="cl"><span class="s">return fib
</span></span></span><span class="line"><span class="cl"><span class="s">]==]</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="kr">function</span> <span class="nf">loadLua</span><span class="p">(</span> <span class="n">txt</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="kd">local</span> <span class="n">loaded</span> <span class="o">=</span> <span class="n">_lune.unwrap</span><span class="p">(</span> <span class="n">_lune.loadstring52</span><span class="p">(</span> <span class="n">txt</span> <span class="p">))</span>
</span></span><span class="line"><span class="cl">   <span class="kd">local</span> <span class="n">fib</span> <span class="o">=</span> <span class="n">_lune.unwrap</span><span class="p">(</span> <span class="n">loaded</span><span class="p">(</span>  <span class="p">))</span>
</span></span><span class="line"><span class="cl">   <span class="kr">return</span> <span class="n">fib</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">fib_lua</span> <span class="o">=</span> <span class="n">loadLua</span><span class="p">(</span> <span class="n">code</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">do</span>
</span></span><span class="line"><span class="cl">   <span class="kd">local</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">os.clock</span><span class="p">(</span>  <span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="n">print</span><span class="p">(</span> <span class="n">string.format</span><span class="p">(</span> <span class="s2">&#34;%s = %d: step = %d: time = %g&#34;</span><span class="p">,</span> <span class="s2">&#34;fib_lua( step )&#34;</span><span class="p">,</span> <span class="n">fib_lua</span><span class="p">(</span> <span class="n">step</span> <span class="p">),</span> <span class="n">step</span><span class="p">,</span> <span class="n">os.clock</span><span class="p">(</span>  <span class="p">)</span> <span class="o">-</span> <span class="n">prev</span><span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="kr">function</span> <span class="nf">fib_lns</span><span class="p">(</span> <span class="n">num</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="kr">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">      <span class="kr">return</span> <span class="n">num</span>
</span></span><span class="line"><span class="cl">   <span class="kr">end</span>
</span></span><span class="line"><span class="cl">   <span class="kr">return</span> <span class="n">fib_lns</span><span class="p">(</span> <span class="n">num</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">)</span> <span class="o">+</span> <span class="n">fib_lns</span><span class="p">(</span> <span class="n">num</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kr">do</span>
</span></span><span class="line"><span class="cl">   <span class="kd">local</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">os.clock</span><span class="p">(</span>  <span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="n">print</span><span class="p">(</span> <span class="n">string.format</span><span class="p">(</span> <span class="s2">&#34;%s = %d: step = %d: time = %g&#34;</span><span class="p">,</span> <span class="s2">&#34;fib_lns( step )&#34;</span><span class="p">,</span> <span class="n">fib_lns</span><span class="p">(</span> <span class="n">step</span> <span class="p">),</span> <span class="n">step</span><span class="p">,</span> <span class="n">os.clock</span><span class="p">(</span>  <span class="p">)</span> <span class="o">-</span> <span class="n">prev</span><span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kr">return</span> <span class="n">_moduleObj</span></span></span></code></pre></div>
</div>
<p>
注目すべき <code class="verbatim">fib_lns()</code> 関数の定義を抜き出したものが以下です。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="kr">function</span> <span class="nf">fib_lns</span><span class="p">(</span> <span class="n">num</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="kr">if</span> <span class="n">num</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">      <span class="kr">return</span> <span class="n">num</span>
</span></span><span class="line"><span class="cl">   <span class="kr">end</span>
</span></span><span class="line"><span class="cl">   <span class="kr">return</span> <span class="n">fib_lns</span><span class="p">(</span> <span class="n">num</span> <span class="o">-</span> <span class="mi">2</span> <span class="p">)</span> <span class="o">+</span> <span class="n">fib_lns</span><span class="p">(</span> <span class="n">num</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span></span></span></code></pre></div>
</div>
<p>
これを見ると分かる通り、
<code class="verbatim">fib_lns()</code> と <code class="verbatim">fib_lub()</code> は等価のコードになっています。</p>
<p>
よって、=fib_lns()= と <code class="verbatim">fib_lua()</code> が同程度時間がかかるのは当然と言えます。</p>
</div>
</div>
<div id="outline-container-headline-333" class="outline-4">
<h4 id="headline-333">
go へトランスコンパイルした場合
</h4>
<div id="outline-text-headline-333" class="outline-text-4">
<p>
一方、 go へトランスコンパイルした場合、実行結果は次の通りです。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">fib_lua( step ) = 24157817: step = 37: time = 6.07
</span></span><span class="line"><span class="cl">fib_lns( step ) = 24157817: step = 37: time = 0.34</span></span></code></pre></div>
</div>
<p>
<code class="verbatim">fib_lns()</code> の方が、=fib_lua()= よりも
計算時間が約 <strong>1/18</strong> 程度に短かくなっていることが分かります。</p>
<p>
go へトランスコンパイルした結果は次の通りです。</p>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// This code is transcompiled by LuneScript.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">package</span> <span class="nx">lnsc</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">.</span> <span class="s">&#34;lnsc/lune/base/runtime_go&#34;</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">init_miniGo</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">miniGo__mod__</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">miniGo_step</span> <span class="nx">LnsInt</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">miniGo_code</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">miniGo_fib_lua</span> <span class="o">*</span><span class="nx">Lns_luaValue</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">miniGo_fibFunc_1003_</span> <span class="kd">func</span> <span class="p">(</span><span class="nx">arg1</span> <span class="nx">LnsInt</span><span class="p">)</span> <span class="nx">LnsInt</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 14: decl @miniGo.loadLua
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">miniGo_loadLua_1009_</span><span class="p">(</span><span class="nx">txt</span> <span class="kt">string</span><span class="p">)</span> <span class="o">*</span><span class="nx">Lns_luaValue</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">loaded</span> <span class="o">*</span><span class="nx">Lns_luaValue</span>
</span></span><span class="line"><span class="cl">    <span class="nx">loaded</span> <span class="p">=</span> <span class="nf">Lns_unwrap</span><span class="p">(</span> <span class="nf">Lns_car</span><span class="p">(</span><span class="nf">Lns_getVM</span><span class="p">().</span><span class="nf">Load</span><span class="p">(</span><span class="nx">txt</span><span class="p">,</span> <span class="kc">nil</span><span class="p">))).(</span><span class="o">*</span><span class="nx">Lns_luaValue</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">fib</span> <span class="nx">LnsAny</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fib</span> <span class="p">=</span> <span class="nf">Lns_unwrap</span><span class="p">(</span> <span class="nf">Lns_car</span><span class="p">(</span><span class="nf">Lns_getVM</span><span class="p">().</span><span class="nf">RunLoadedfunc</span><span class="p">(</span><span class="nx">loaded</span><span class="p">,</span><span class="nf">Lns_2DDD</span><span class="p">([]</span><span class="nx">LnsAny</span><span class="p">{}))[</span><span class="mi">0</span><span class="p">]))</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">fib</span><span class="p">.(</span><span class="o">*</span><span class="nx">Lns_luaValue</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// 36: decl @miniGo.fib_lns
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">miniGo_fib_lns_1025_</span><span class="p">(</span><span class="nx">num</span> <span class="nx">LnsInt</span><span class="p">)</span> <span class="nx">LnsInt</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">num</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">num</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">miniGo_fib_lns_1025_</span><span class="p">(</span><span class="nx">num</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">miniGo_fib_lns_1025_</span><span class="p">(</span><span class="nx">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Lns_miniGo_init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">init_miniGo</span> <span class="p">{</span> <span class="k">return</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">init_miniGo</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">    <span class="nx">miniGo__mod__</span> <span class="p">=</span> <span class="s">&#34;@miniGo&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Lns_InitMod</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nx">miniGo_step</span> <span class="p">=</span> <span class="mi">37</span>
</span></span><span class="line"><span class="cl">    <span class="nx">miniGo_code</span> <span class="p">=</span> <span class="s">&#34;local function fib ( n )\n   if n &lt; 2 then return n end\n   return fib(n - 2) + fib(n - 1)\nend\nreturn fib\n&#34;</span>
</span></span><span class="line"><span class="cl">    <span class="nx">miniGo_fib_lua</span> <span class="p">=</span> <span class="nf">miniGo_loadLua_1009_</span><span class="p">(</span><span class="nx">miniGo_code</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">var</span> <span class="nx">prev</span> <span class="nx">LnsReal</span>
</span></span><span class="line"><span class="cl">        <span class="nx">prev</span> <span class="p">=</span> <span class="nf">Lns_getVM</span><span class="p">().</span><span class="nf">OS_clock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Lns_print</span><span class="p">([]</span><span class="nx">LnsAny</span><span class="p">{</span><span class="nf">Lns_getVM</span><span class="p">().</span><span class="nf">String_format</span><span class="p">(</span><span class="s">&#34;%s = %d: step = %d: time = %g&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="nx">LnsAny</span><span class="p">{</span><span class="s">&#34;fib_lua( step )&#34;</span><span class="p">,</span> <span class="nf">Lns_getVM</span><span class="p">().</span><span class="nf">RunLoadedfunc</span><span class="p">(</span><span class="nx">miniGo_fib_lua</span><span class="p">,</span><span class="nf">Lns_2DDD</span><span class="p">(</span><span class="nx">miniGo_step</span><span class="p">))[</span><span class="mi">0</span><span class="p">].(</span><span class="nx">LnsInt</span><span class="p">),</span> <span class="nx">miniGo_step</span><span class="p">,</span> <span class="nf">Lns_getVM</span><span class="p">().</span><span class="nf">OS_clock</span><span class="p">()</span> <span class="o">-</span> <span class="nx">prev</span><span class="p">})})</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kd">var</span> <span class="nx">prev</span> <span class="nx">LnsReal</span>
</span></span><span class="line"><span class="cl">        <span class="nx">prev</span> <span class="p">=</span> <span class="nf">Lns_getVM</span><span class="p">().</span><span class="nf">OS_clock</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">        <span class="nf">Lns_print</span><span class="p">([]</span><span class="nx">LnsAny</span><span class="p">{</span><span class="nf">Lns_getVM</span><span class="p">().</span><span class="nf">String_format</span><span class="p">(</span><span class="s">&#34;%s = %d: step = %d: time = %g&#34;</span><span class="p">,</span> <span class="p">[]</span><span class="nx">LnsAny</span><span class="p">{</span><span class="s">&#34;fib_lns( step )&#34;</span><span class="p">,</span> <span class="nf">miniGo_fib_lns_1025_</span><span class="p">(</span><span class="nx">miniGo_step</span><span class="p">),</span> <span class="nx">miniGo_step</span><span class="p">,</span> <span class="nf">Lns_getVM</span><span class="p">().</span><span class="nf">OS_clock</span><span class="p">()</span> <span class="o">-</span> <span class="nx">prev</span><span class="p">})})</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">init_miniGo</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>
非常に読み難いので <code class="verbatim">fib_lns()</code> 関数の定義部分を抜き出すと、次になります。</p>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">miniGo_fib_lns_1025_</span><span class="p">(</span><span class="nx">num</span> <span class="nx">LnsInt</span><span class="p">)</span> <span class="nx">LnsInt</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">num</span> <span class="p">&lt;</span> <span class="mi">2</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">num</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nf">miniGo_fib_lns_1025_</span><span class="p">(</span><span class="nx">num</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="nf">miniGo_fib_lns_1025_</span><span class="p">(</span><span class="nx">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>
関数名が長くなっていますが、
LuneScript のコードがそのまま go に変換されていることがわかります。
関数を実行する際も次のように普通に関数コールしているだけです。</p>
<pre class="example">
 miniGo_fib_lns_1025_(miniGo_step)
</pre>
<p>
一方で Lua の <code class="verbatim">fib_lua()</code> 関数は、
<code class="verbatim">miniGo_fib_lua = miniGo_loadLua_1009_(miniGo_code)</code> によって
Lua のコードを実行するための関数がロードされていて、
実行する際も次のように関数コールしています。</p>
<pre class="example">
Lns_getVM().RunLoadedfunc(miniGo_fib_lua,Lns_2DDD(miniGo_step))
</pre>
<p>
このように、=fib_lns()= と <code class="verbatim">fib_lua()</code> では全く処理が異なることが分かります。</p>
</div>
</div>
<div id="outline-container-headline-334" class="outline-4">
<h4 id="headline-334">
ビルド
</h4>
<div id="outline-text-headline-334" class="outline-text-4">
<p>
go へトランスコンパイルしてビルドするには次の step が必要です。</p>
<ul>
<li>go.mod を生成する</li>
<li>LuneScript ランタイムを go.mod に登録する  </li>
<li>main.go を生成する</li>
<li>.lns から .go を生成する</li>
<li>go.mod を更新する</li>
<li>go build する</li>
</ul>
<p>.lns を更新した場合は、
「 .lns から .go を生成する」以降の処理を繰り返し実行します。</p>
<p>
各 step を説明します。</p>
<div id="outline-container-headline-335" class="outline-5">
<h5 id="headline-335">
go.mod を生成する
</h5>
<div id="outline-text-headline-335" class="outline-text-5">
<p>
lune.js があるディレクトリで、以下のコマンドを実行します。</p>
<pre class="example">
$ go mod init test # &lt;--- test は環境に合せて指定してください
</pre>
</div>
</div>
<div id="outline-container-headline-336" class="outline-5">
<h5 id="headline-336">
LuneScript ランタイムを go.mod に登録する
</h5>
<div id="outline-text-headline-336" class="outline-text-5">
<p>
以下のコマンドで、LuneScript のランタイムを go.mod に登録します。</p>
<pre class="example">
$ go get github.com/ifritJP/LuneScript/src@latest
</pre>
<p>
以降の作業で go mod tidy を実行しますが、必ず go get を先に実行してください。</p>
</div>
</div>
<div id="outline-container-headline-337" class="outline-5">
<h5 id="headline-337">
main.go を生成する
</h5>
<div id="outline-text-headline-337" class="outline-text-5">
<p>
go には、エントリ関数の <code class="verbatim">main()</code> が必要です。</p>
<p>
以下のコマンドで、go の <code class="verbatim">main()</code> 関数を定義する main.go を生成します。</p>
<pre class="example">
$ lnsc hoge.lns mkmain main.go
</pre>
<p>
ここで hoge.lns は、 lns で __main を定義しているメインモジュールを指定します。
main.go は出力先のパスを指定します。</p>
<p>
go にトランスコンパイルする場合、 __main 関数を定義するモジュールが必須です。</p>
<p>
このコマンドで生成した main.go には、
lns のランタイムを初期化するコードが含まれます。</p>
</div>
</div>
<div id="outline-container-headline-338" class="outline-5">
<h5 id="headline-338">
.lns から .go を生成する
</h5>
<div id="outline-text-headline-338" class="outline-text-5">
<p>
以下のコマンドで .go を生成します。</p>
<pre class="example">
$ lnsc hoge.lns save -langGo
</pre>
<p>
__main 関数を含むメインモジュールの場合は、さらに –main オプション付加します。</p>
<pre class="example">
$ lnsc hoge.lns save -langGo --main hoge
</pre>
<p>
ここで –main hoge の hoge は、 メインモジュールの import パスです。</p>
<p>
例えばメインモジュールが foo/bar/hoge.lns の場合、</p>
<pre class="example">
$ lnsc foo/bar/hoge.lns save -langGo --main foo.bar.hoge
</pre>
<p>
となります。</p>
<p>
LuneScript を go にトランスコンパイルする場合、__main 関数が必要です。</p>
</div>
</div>
<div id="outline-container-headline-339" class="outline-5">
<h5 id="headline-339">
go.mod を更新する
</h5>
<div id="outline-text-headline-339" class="outline-text-5">
<p>
以下のコマンドで go.mod を更新します。    </p>
<pre class="example">
$ go mod tidy
</pre>
</div>
</div>
<div id="outline-container-headline-340" class="outline-5">
<h5 id="headline-340">
go build する
</h5>
<div id="outline-text-headline-340" class="outline-text-5">
<p>
全ての lns ファイルの変換と main.go の生成ができたら、go build を実行します。</p>
<pre class="example">
$ go build
</pre>
<p>
<strong>上記がエラーする場合は、以下を試してください。</strong></p>
<pre class="example">
$ go build -tags gopherlua
</pre>
<p>
これにより、トランスコンパイルしたモジュールが go でビルドされます。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-341" class="outline-4">
<h4 id="headline-341">
go へトランスコンパイル後は Lua ライブラリのリンクが必要
</h4>
<div id="outline-text-headline-341" class="outline-text-4">
<blockquote>
<p>追記</p>
<p>
<strong>Lua ライブラリのリンクを回避する方法を用意しました。</strong></p>
<p>
<a href="#lua_runtime">#lua_runtime</a></p>
</blockquote>
<p>
上記の通り、 LuneScript は Lua と密接に連携して動作しています。
そして、go へのトランスコンパイル後もその連携動作をサポートしています。</p>
<p>
この連携動作を実現するために、 go へのトランスコンパイル後のコードでは、
lua の処理を行なうための lua VM を必要とします。</p>
<p>
細かいことを言うと、この Lua との連携動作以外にも、
LuneScript には Lua VM を必要とする処理があります。
具体的にはマクロ展開の処理や、一部の組込み関数の処理に Lua VM を利用しています。</p>
<p>
その lua VM は、公式の <strong>lua-5.3.4</strong> を前提としていて、 <strong>liblua5.3.so</strong> をリンクします。</p>
<p>
go 言語には、
「環境に依存しない 1 つの実行ファイルを生成できる」という利点がありますが、
残念ながら LuneScript を go へトランスコンパイルする場合、
liblua5.3.so へのリンクが必要になります。</p>
<p>
なお、実行時に liblua5.3.so が必要になるだけではなく、
ビルド時には lua-5.3.4 のインクルードファイルも必要になります。</p>
<hr>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-go_package_ja" class="outline-2">
<h2 id="go_package_ja">
<strong>Go 言語へのトランスコンパイル時のパッケージ</strong>
</h2>
<div id="outline-text-go_package_ja" class="outline-text-2">
<p>
go でパッケージ管理されているモジュールを LuneScript から利用できます。</p>
<div id="outline-container-headline-343" class="outline-3">
<h3 id="headline-343">
go のパッケージ管理概要
</h3>
<div id="outline-text-headline-343" class="outline-text-3">
<p>
go は go.mod でパッケージを管理します。</p>
<p>
この go.mod で管理されたパッケージは、
環境変数 GOPATH で指定されたローカルディレクトリにキャッシュされます。</p>
<p>
LuneScript は、このキャッシュされたモジュールを利用できます。</p>
<p>
github 上のパッケージを go で利用するには、次のように書きます。</p>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;github.com/ifritJP/lnshttpd&#34;</span></span></span></code></pre></div>
</div>
<p>
これと同じ感覚で、 LuneScript は go のモジュールにアクセスできます。</p>
</div>
</div>
<div id="outline-container-headline-344" class="outline-3">
<h3 id="headline-344">
import
</h3>
<div id="outline-text-headline-344" class="outline-text-3">
<p>
go のパッケージ内にある .lns ファイルを LuneScript で import するには、
次のように書きます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
import go/github:com.ifritJP.lnshttpd.lnsservlet;</code></pre>
</div>
<p>
これは <a href="https://github.com/ifritJP/lnshttpd">https://github.com/ifritJP/lnshttpd</a> の lnsservlet.lns を
import する時の例です。</p>
<p>
ここで、 <code class="verbatim">go/github:com.ifritJP.lnshttpd.lnsservlet</code> に注目します。</p>
<p>
<code class="verbatim">https://github.com/ifritJP/lnshttpd</code> と
<code class="verbatim">go/github:com.ifritJP.lnshttpd.lnsservlet</code> を見比べればだいたい想像が付くと思いますが、
go のパッケージを使用する場合、次の追加ルールがあります。</p>
<ul>
<li>先頭に <code class="verbatim">go/</code> を付加する</li>
<li>github.com のように . が付く場合、 . の代わりに : を指定する</li>
</ul>
<p>LuneScript は、上記形式のモジュールが指定された場合、
通常の検索パスではなく、 go のパッケージパスからモジュールを検索します。</p>
<p>
具体的には、次の順番にファイルを検索します。</p>
<ul>
<li>vendor/github.com/ifritJP/lnshttpd/lnsservlet.lns </li>
<li>${GOPATH}/pkg/mod/github.com/ifrit!j!p/lnshttpd@XXXXXXXXXXXXXXXXX/lnsservlet.lns</li>
</ul>
<p>ここで、 <code class="verbatim">@XXXXXXXXXXXXXXXXX/lnsservlet.lns</code> の <code class="verbatim">XXXXXXXXXXXXXXXXX</code> の部分は、
go.mod に記載されているモジュールの TAG 情報から取得します。
つまり、事前に go mod tidy を実施しておく必要があります。</p>
</div>
</div>
<div id="outline-container-headline-345" class="outline-3">
<h3 id="headline-345">
module
</h3>
<div id="outline-text-headline-345" class="outline-text-3">
<p>
go のモジュールを LuneScript から利用するには、 module 宣言が必要です。</p>
<p>
module 宣言は LuneScript から Lua モジュールを利用する際にも使用していますが、
go モジュールを利用する場合、次の追加ルールがあります。</p>
<ul>
<li>go のモジュールを利用していることを module 宣言に追加する</li>
</ul>
<p>以下は github.com.ifritJP.lnshttpd の servlet.go を利用する際の宣言例です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
module servlet require &#34;go/github:com.ifritJP.lnshttpd.servlet&#34; of &#34;&#34; {
   pub static fn Start( listenPort:int,
                        handlerList: &amp;List&lt;&amp;lnsservlet.HandlerInfo&gt;,
                        hostingList:&amp;List&lt;&amp;lnsservlet.HostingInfo&gt; );
}</code></pre>
</div>
<p>
ここで <code class="verbatim">module servlet require &#34;go/github:com.ifritJP.lnshttpd.servlet&#34; of &#34;&#34;</code> の
<code class="verbatim">of &#34;&#34;</code> は、利用するモジュールの種別を宣言しています。</p>
<p>
指定可能な文字列は次の通りです。</p>
<table>
<thead>
<tr>
<th>文字列</th>
<th>モジュールの言語</th>
</tr>
</thead>
<tbody>
<tr>
<td>&#34;&#34;</td>
<td>トランスコンパイル先言語と同じ</td>
</tr>
<tr>
<td>&#34;Lua&#34;</td>
<td>lua</td>
</tr>
<tr>
<td>&#34;Go&#34;</td>
<td>go</td>
</tr>
</tbody>
</table>
<div id="outline-container-headline-346" class="outline-4">
<h4 id="headline-346">
利用可能な言語
</h4>
<div id="outline-text-headline-346" class="outline-text-4">
<p>
トランスコンパイル先の言語と、
module で利用可能な言語の組み合わせには制限があります。</p>
<table>
<thead>
<tr>
<th></th>
<th>go module</th>
<th>lua module</th>
</tr>
</thead>
<tbody>
<tr>
<td>go へトランスコンパイル</td>
<td>可能</td>
<td>可能</td>
</tr>
<tr>
<td>lua へトランスコンパイル</td>
<td><strong>不能</strong></td>
<td>可能</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-headline-347" class="outline-4">
<h4 id="headline-347">
型の互換性
</h4>
<div id="outline-text-headline-347" class="outline-text-4">
<p>
module 宣言で go モジュールを LuneScript から利用可能です。</p>
<p>
しかし、型の互換性は制限されます。</p>
<p>
以下の型は LuneScript と go とで対になっています。</p>
<table>
<thead>
<tr>
<th>LuneScript の型</th>
<th>go の型</th>
</tr>
</thead>
<tbody>
<tr>
<td>int</td>
<td>int</td>
</tr>
<tr>
<td>real</td>
<td>float64</td>
</tr>
<tr>
<td>bool</td>
<td>bool</td>
</tr>
<tr>
<td>str</td>
<td>string</td>
</tr>
<tr>
<td>nilable</td>
<td>interface{}</td>
</tr>
</tbody>
</table>
<hr>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-lua_runtime_ja" class="outline-2">
<h2 id="lua_runtime_ja">
*Go へトランスコンパイルした際の Lua ランタイム*
</h2>
<div id="outline-text-lua_runtime_ja" class="outline-text-2">
<p>
LuneScript は、 Lua のトランスコンパイラとして開発を始めたプロジェクトだ。
そして Lua の資産を活かすために、
LuneScript は Lua と連携させた動作もサポートしている。</p>
<p>
この LuneScript と Lua を連携させた動作は、
go へトランスコンパイルした際も利用可能である。
つまり、Go と Lua とで連携動作している。</p>
<p>
これを実現するため、 Go と Native lua のランタイムのリンクが必要になる。
なお、LuneScript のコード上で Lua との連携動作を利用していなくても、
内部的に Lua のランタイム機能を利用しているため、
Lua ランタイムのリンクは切り離せない。</p>
<p>
LuneScript と Lua の連携動作は、
Lua のトランスコンパイラという性質上重要な機能である。
一方で LuneScript を Go のトランスコンパイラと考えた場合、
Lua との連携動作はさほど重要とは言えない。</p>
<p>
また、go の長所として以下がある。</p>
<ul>
<li>実行環境のライブラリに依存せず、単一で動作するシングルファイルが作成可能</li>
<li>さまざまな環境へのクロスコンパイルをサポート</li>
</ul>
<p>Lua ランタイムのリンクが必要になると、上記の長所が失われてしまう。</p>
<p>
Lua ランタイムは環境依存の少ない構成であるが、
上記の長所を維持するには大きな足枷になってしまう。</p>
<p>
そこで、 Native Lua ランタイムをリンクしなくても
トランスコンパイル後のコードを実行できるよう対応している。</p>
<div id="outline-container-headline-349" class="outline-3">
<h3 id="headline-349">
gopher-lua の利用
</h3>
<div id="outline-text-headline-349" class="outline-text-3">
<p>
gopher-lua は、 go で実装された Lua ランタイムである。
gopher-lua を利用することで、 Native Lua ランタイムとのリンクを回避する。</p>
<p>
gopher-lua を利用するには、 go build 時のオプションとして -tags を指定する。</p>
<pre class="example">
go build -tags gopherlua
</pre>
<p>
このオプションを指定することで、
Lua ランタイムが Native Lua から gopher-lua に切り替わる。</p>
<div id="outline-container-headline-350" class="outline-4">
<h4 id="headline-350">
gopher-lua の注意点
</h4>
<div id="outline-text-headline-350" class="outline-text-4">
<p>
gopher-lua を利用する場合、
Lua ランタイムの仕様が gopher-lua の仕様によって制限される。</p>
<p>
以下に具体的な例を挙げる。</p>
<ul>
<li>lua のバージョンが 5.1</li>
<li>string.dump など一部の API が利用できない</li>
<li>luasocket など pure Lua ではない Lua ライブラリを利用できない</li>
<li>Native Lua に比べて遅い  </li>
</ul>
<p>LuneScript と Lua の連携を使用していない場合は
気にしなくても問題ない範囲ではあるが、
Native Lua と gopher-lua とでは違いがあることは認識しておく必要がある。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-351" class="outline-3">
<h3 id="headline-351">
他の Lua ランタイム
</h3>
<div id="outline-text-headline-351" class="outline-text-3">
<p>
go で実装された Lua ランタイムには幾つか種類がある。</p>
<p>
その代表的なものとして次がある。</p>
<ul>
<li><a href="https://github.com/yuin/gopher-lua">https://github.com/yuin/gopher-lua</a></li>
<li><a href="https://github.com/Azure/golua">https://github.com/Azure/golua</a></li>
<li><a href="https://github.com/Shopify/go-lua">https://github.com/Shopify/go-lua</a>  </li>
</ul>
<p>yuin/gopher-lua は、今回利用している実装である。
代表例として挙げた中で、
LuneScript のセルフホストの Lua コードを実行できた唯一の実装。</p>
<p>
Azure/golua は、 Microsoft が立ち上げたプロジェクトのようだ。
lua5.3 ベースということで期待していたが、
実際に実行すると期待した動きを全くしていない(Lua を parse できない)状態だった。
なお、 github の repository は Archived になっているため、
今後の展開は期待できない。</p>
<p>
Shopify/go-lua は、 lua5.2 ベースで開発されている。
シンプルな Lua スクリプトは動くが、
LuneScript をセルフホストする lua をロードできなかった。
このため、互換性に問題がありそうなことが予想されたので、
今回は LuneScript での採用を見送った。</p>
<p>
今回 go による Lua 実装をいくつか試してみたが、
LuneScript を実行できるレベルの互換性をサポートする
Lua 実装が少なかったのは残念だった。</p>
<p>
もしも今後、 Lua を実装するような場合、
LuneScript が動くかどうかを確認することで、
Lua の互換性を確認するテストケースとして使えるのではないかと思ったりもした。</p>
<p>
ただし、動かなかった場合、
何が原因で動かないのかが簡単には分からないので、
テストケースとして使い勝手が良いとは言えないことを考えると、
イマイチ現実的ではないか。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-async_ja" class="outline-2">
<h2 id="async_ja">
<strong>安全な非同期処理</strong>
</h2>
<div id="outline-text-async_ja" class="outline-text-2">
<p>
LuneScript から go 言語へのトランスコンパイル対応したのを機に、
LuneScript による非同期処理を対応しました。</p>
<p>
静的にデータ競合を排除する簡易機能を持ちます。</p>
<div id="outline-container-headline-353" class="outline-3">
<h3 id="headline-353">
__Runner インタフェース
</h3>
<div id="outline-text-headline-353" class="outline-text-3">
<p>
LuneScript で非同期処理を行なうには、 __Runner インタフェースを実装します。</p>
<p>
__Runner インタフェースは、以下の型です。 <strong>__async については後述します。</strong></p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
pub interface __Runner {
   pub fn run() __async mut;
}</code></pre>
</div>
<p>
このインタフェースを実装すると、
新しい組込み関数の <code class="verbatim">__run()</code>, <code class="verbatim">__join()</code> を利用できます。</p>
<p>
例えば、以下のような処理を実行すると、
<code class="verbatim">print(&#34;hoge:&#34;, self.val );</code> が非同期で処理されます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Hoge extend (__Runner) {
   let val:int;
   pub fn run() __async mut {
      print(&#34;hoge:&#34;, self.val );
   }
}

let list:List&lt;Hoge&gt; = [];
for index = 0, 10 {
   let mut hoge = new Hoge(index);
   __run( hoge, __lns.runMode.Sync, &#34;&#34; );
   list.insert( hoge );
}
foreach hoge in list {
   __join( hoge );
}</code></pre>
</div>
<div id="outline-container-headline-354" class="outline-4">
<h4 id="headline-354">
__run() 関数
</h4>
<div id="outline-text-headline-354" class="outline-text-4">
<p>
<code class="verbatim">__run()</code> 関数は、 __Runner クラスの非同期実行を開始するための関数です。</p>
<p>
非同期実行が開始されると、
__Runner クラスの <code class="verbatim">run()</code> メソッドが別スレッドで実行されます。</p>
<p>
<code class="verbatim">__run()</code> 関数の型は以下の通りです。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
pub fn __run( runner:__Runner, mode: RunMode, name:str ) : bool</code></pre>
</div>
<ul>
<li>第 1 引数の runner には、 実行する __Runner オブジェクトを指定します。</li>
<li>
<p>第 2 引数の mode には、 以下を指定します。</p>
<ul>
<li>
<p>__lns.runMode.Sync</p>
<ul>
<li>実行中の __Runner 数が一定数越えた場合、
新しくスレッドは起動せずにここで実行する。</li>
</ul>
</li>
<li>
<p>__lns.runMode.Queue</p>
<ul>
<li>実行中の __Runner 数が一定数越えた場合、 Runner queue に入れ、
実行中の __Runner が停止した時に実行する。</li>
</ul>
</li>
<li>
<p>__lns.runMode.Skip</p>
<ul>
<li>実行中の __Runner 数が一定数越えた場合、 Runner を実行しない。</li>
<li>実行しなかった場合、 false を返す。</li>
</ul>
</li>
</ul>
</li>
<li>第 3 引数の name には、この非同期処理の名前を指定する。</li>
</ul>
<p>lua にトランスコンパイルした場合、以下の動作になります。</p>
<ul>
<li>mode が __lns.runMode.Sync あるいは __lns.runMode.Queue の場合、
新しくスレッドは起動せずに、ここで実行する。</li>
<li>mode が __lns.runMode.Skip の場合、実行せずに false を返す。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-355" class="outline-4">
<h4 id="headline-355">
__join() 関数
</h4>
<div id="outline-text-headline-355" class="outline-text-4">
<p>
<code class="verbatim">__join()</code> 関数は、 __Runner の非同期処理の終了を待つ関数です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
pub fn __join( runner:__Runner )</code></pre>
</div>
<p>
lua にトランスコンパイルした場合、非同期処理はないため何もしません。</p>
</div>
</div>
<div id="outline-container-headline-356" class="outline-4">
<h4 id="headline-356">
コンストラクタの引数の制限
</h4>
<div id="outline-text-headline-356" class="outline-text-4">
<p>
__Runner を extend するクラスのコンストラクタの引数は、
以下の型に制限されます。</p>
<ul>
<li>int, real, str, bool, enum </li>
<li>immutable な型</li>
</ul>
<p>つまり、以下のケースはエラーになります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
class Test {
}
class Hoge extend (__Runner) {
   pub fn __init( test:Test, list:List&lt;int&gt; ) __async { // error
   }
   pub fn run() __async mut {
   }
}</code></pre>
</div>
<p>
このエラーは、 引数の test と list が mutable な型であるためです。</p>
<p>
以下のように immutable としての宣言が必要です。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
}
class Hoge extend (__Runner) {
   pub fn __init( test:&amp;Test, list:&amp;List&lt;int&gt; ) __async { // ok
   }
   pub fn run() __async mut {
   }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-357" class="outline-3">
<h3 id="headline-357">
__async, __noasyc 属性
</h3>
<div id="outline-text-headline-357" class="outline-text-3">
<p>
__Runner インタフェースの <code class="verbatim">run()</code> メソッドの定義を見ると、
__async が追加されているのが分かります。</p>
<p>
これは、その関数を非同期に実行可能であることを宣言しています。</p>
<p>
LuneScript は、スレッドが一つだけで動作する従来の同期処理と、
新しくスレッドを起動して実行する非同期処理に分けて管理します。</p>
<p>
ある関数を非同期で実行するには、
その関数が非同期で実行可能であることを宣言する必要があります。</p>
<p>
それが <strong>__async</strong> です。</p>
<p>
一方で、従来の同期処理は <strong>__noasyc</strong> です。</p>
<p>
<em>普通は async の対になるのは sync だと思いますが、</em>
<em>以下の理由からあえて noasync にしています。</em></p>
<ul>
<li>async と sync だと区別しづらい</li>
<li>主体が非同期処理(async)であり、 同期処理は例外だから noasync</li>
</ul>
<p>__async, __noasync どちらも宣言していない場合はデフォルトで __noasyc ですが、
デフォルトを __async として扱える方法を用意しています。</p>
</div>
</div>
<div id="outline-container-headline-358" class="outline-3">
<h3 id="headline-358">
__async 宣言された関数の制限
</h3>
<div id="outline-text-headline-358" class="outline-text-3">
<p>
<strong>__async 宣言された関数には、以下の制限があります。</strong></p>
<ul>
<li>__async 宣言された関数内から __noasync 宣言された関数にアクセスできない。</li>
<li>__async 宣言された関数内から、スコープ外の mutable な変数にアクセスできない。</li>
</ul>
<p><strong>一方で __noasync 宣言された関数には、このような制限はありません。</strong></p>
<p>
これは、安全に非同期処理を実行するためのガードです。</p>
<p>
非同期処理は、 <strong>排他制御</strong> を考慮する必要があります。
必要な箇所で <strong>排他制御</strong> を行なわないと、バグになります。</p>
<p>
<a href="https://ja.wikipedia.org/wiki/%E7%AB%B6%E5%90%88%E7%8A%B6%E6%85%8B#%E6%83%85%E5%A0%B1%E5%87%A6%E7%90%86">排他制御の必要性については、ここを参考に。</a></p>
<p>
しかし、どこに <strong>排他制御</strong> が必要か、
を全てのケースにおいて人手で網羅することは非常に困難です。</p>
<p>
そこで、 LuneScript では文法上にメタ情報を宣言し、
その不整合をコンパイラがチェックすることによって、
ヒューマンエラーによる <strong>排他制御</strong> の抜け漏れを軽減する方法を採用しています。</p>
<p>
このアプローチを採用する代表的な言語に Rust があります。</p>
<p>
Rust は厳格なメタ情報の定義によって、高度な <strong>排他制御</strong> を実現しています。</p>
<p>
LuneScript では、 Rust ほど高度な <strong>排他制御</strong> を実現していない変わりに、
比較的に手軽で扱い易いメタ情報定義を採用しています。</p>
<p>
なお、後述する <strong>__asyncLock</strong> を利用することで、
<strong>__async から __noasync をアクセスすることが可能</strong> になります。</p>
<div id="outline-container-headline-359" class="outline-4">
<h4 id="headline-359">
__async 宣言された関数内から __noasync 宣言された関数は実行できない。
</h4>
<div id="outline-text-headline-359" class="outline-text-4">
<p>
これは、以下のケースがエラーになることを指します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
class Test {
   fn func1() __noasync {
   }
   fn func2() __async {
      self.func1(); // error
   }
}</code></pre>
</div>
<p>
上記 func1 は __noasync で、 func2 は __async です。
このとき、 __async の func2 から __noasync の func1 はアクセスできません。</p>
</div>
</div>
<div id="outline-container-headline-360" class="outline-4">
<h4 id="headline-360">
__async 宣言された関数内から、スコープ外の mutable な変数にアクセスできない。
</h4>
<div id="outline-text-headline-360" class="outline-text-4">
<p>
これは、以下のケースがエラーになることを指します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let mut list = [ 1, 2 ];
let list2 = [ 1, 2 ];
class Test {
   fn func() __async {
      foreach val in list { // error
         print( val );
      }
      foreach val in list2 { // ok
         print( val );
      }
   }
}</code></pre>
</div>
<p>
上記 func は __async で、 list は最上位スコープの mutable な変数です。</p>
<p>
このとき、 __async の func から mutable の list にはアクセスできません。</p>
<p>
一方で、 list2 は immutable です。 immutable な変数には func からアクセス可能です。</p>
<p>
また __noasync のメソッドからは、 mutable なメンバにアクセス可能です。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-361" class="outline-3">
<h3 id="headline-361">
__async:__noasyc == N:1
</h3>
<div id="outline-text-headline-361" class="outline-text-3">
<p>
LuneScript では、 非同期(<code class="verbatim">__async</code>)で動作するスレッドが複数(N)あり、
<code class="verbatim">__noasync</code> で動作するスレッドは 1 つになるように設計しています。</p>
<p>
<code class="verbatim">__noasync</code> で動作するスレッドが複数あると、もはやそれは非同期なので、
<code class="verbatim">__noasync</code> のスレッドが一つなのは当然ですね。</p>
</div>
</div>
<div id="outline-container-headline-362" class="outline-3">
<h3 id="headline-362">
__async の制限を一時的に解除する方法。 (__asyncLock)
</h3>
<div id="outline-text-headline-362" class="outline-text-3">
<p>
前述の通り、 __async 宣言された関数には制限があります。</p>
<p>
理想は、全てにおいてこの制限を満すことですが、
現実問題それでは対応できないケースもあります。</p>
<p>
そこで、 __async 宣言された関数の制限を一時的に解除する方法を用意しています。</p>
<p>
それが <strong>__asyncLock</strong> です。</p>
<p>
例えば、以下のように __asyncLock を利用します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   fn func1() __noasync {
   }
   fn func2() __async {
      __asyncLock {
         self.func1(); // ok
      }
   }
}</code></pre>
</div>
<p>
func2 は __async なので、__noasync である func2 に本来はアクセスできませんが、
__asyncLock ブロック内では __async の制限が解除されます。</p>
<div id="outline-container-headline-363" class="outline-4">
<h4 id="headline-363">
__asyncLock と __noasync の関係
</h4>
<div id="outline-text-headline-363" class="outline-text-4">
<p>
__asyncLock は、 __async 宣言された関数を一時的に __noasync として動作させます。</p>
<p>
そして前述している通り、
__noasync として動作するスレッドは 1 つでなければなりません。</p>
<p>
そこで__asyncLock は、
__noasync スレッドが実行中は、実行停止まで待ち、
__noasync スレッドの実行停止後に _asyncLock のブロックを実行します。</p>
<p>
他の __asyncLock のブロック実行中も __noasync スレッド実行中と同様に扱います。</p>
<div id="outline-container-headline-364" class="outline-5">
<h5 id="headline-364">
関数を跨いだ __asyncLock のネスト
</h5>
<div id="outline-text-headline-364" class="outline-text-5">
<p>
次のケースでは、 func3 -&gt; func2 -&gt; func1 とコールしています。</p>
<p>
この時に、 func3, func2 で __asyncLock していますが、
func2 実行時には既の __noasync として実行しているため、
func2 の __asyncLock はブロックせずに実行されます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   fn func1() __noasync {
   }
   fn func2() __async {
      __asyncLock {
         self.func1();
      }
   }
   fn func3() __async {
      __asyncLock {
         self.func2();
      }
   }
}</code></pre>
</div>
<p>
このように、関数を跨いだ __asyncLock はネストできます。</p>
<p>
一方で同一関数内の __asyncLock はネストできません。エラーします。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
class Test {
   fn func1() __noasync {
   }
   fn func2() __async {
      __asyncLock {
         __asyncLock { // error
            self.func1();
         }
      }
   }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-365" class="outline-4">
<h4 id="headline-365">
__asyncLock のオーバーヘッド
</h4>
<div id="outline-text-headline-365" class="outline-text-4">
<p>
前述の通り、 __asyncLock は排他制御を行ないます。</p>
<p>
排他制御はオーバーヘッドがかかるので、__asyncLock の利用は最小限にすべきです。</p>
<p>
例えば次のように for ループ内で __asyncLock を使うと、
ループ分のオーバーヘッドが余計に加算されます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   fn func1() __noasync {
   }
   fn func2() __async {
      for _ = 1, 10000000 {
         __asyncLock {
            self.func1();
         }
      }
   }
}</code></pre>
</div>
<p>
この場合は、 __asyncLock を for ループの外に出すのが良いです。
しかし、for ループの外に出すと、
排他される範囲が広くなりすぎるケースもあります。</p>
<p>
どの範囲を __asyncLock するかは慎重に判断する必要があります。</p>
</div>
</div>
<div id="outline-container-headline-366" class="outline-4">
<h4 id="headline-366">
__asyncLock の制限 
</h4>
<div id="outline-text-headline-366" class="outline-text-4">
<p>
__asyncLock には以下の制限があります。</p>
<ul>
<li>__asyncLock 内から return, break できない。</li>
</ul>
<p>つまり、以下のような処理は出来ません。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
class Test {
   fn func1() __noasync : bool {
      return true;
   }
   fn func2() __async : int {
      __asyncLock {
         if self.func1() {
            return 1; // error
         }
      }
      return 0;
   }
}</code></pre>
</div>
<p>
このような処理を行なう場合は、以下のよう書きます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Test {
   fn func1() __noasync : bool {
      return true;
   }
   fn func2() __async : int {
      let mut val = 0;
      __asyncLock {
         if self.func1() {
            val = 1;
         }
      }
      return val;
   }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-367" class="outline-3">
<h3 id="headline-367">
デフォルトを __async にする
</h3>
<div id="outline-text-headline-367" class="outline-text-3">
<p>
何も宣言していない関数は __noasync です。</p>
<p>
これを、 デフォルト __async にする方法を用意しています。</p>
<pre class="example">
_lune_control default_async_all
</pre>
<p>
上記が .lns ファイルの先頭に宣言されている場合、
その .lns ファイル内では デフォルト __async になります。</p>
</div>
</div>
<div id="outline-container-headline-368" class="outline-3">
<h3 id="headline-368">
ソフトウェアデザイン
</h3>
<div id="outline-text-headline-368" class="outline-text-3">
<p>
これまでの特徴をまとめると以下になります。</p>
<ul>
<li>__async スレッドが複数(N)で __noasync スレッドは 1 つの N:1 になる。</li>
<li>他に __noasync スレッド実行中、 __asyncLock はブロックする。</li>
</ul>
<p>これらから、 LuneScript において非同期処理を行なうには以下が必要になります。</p>
<p>
<strong>「基本は __Runner で __async 処理し、 __noasync の処理は必要最低限に留める」</strong></p>
<p>
例えば、
<code class="verbatim">__main()</code> で起動直後に __Runner を起動し、その __Runner の終了を __join で待つ。
というデザインをするのが基本となります。</p>
</div>
</div>
<div id="outline-container-headline-369" class="outline-3">
<h3 id="headline-369">
安全に非同期制御を行なうためのメカニズム
</h3>
<div id="outline-text-headline-369" class="outline-text-3">
<p>
LuneScript では、以下によって排他制御の抜け漏れを防止しています。</p>
<ul>
<li>__async 宣言された関数の制限</li>
<li>__Runner を extend したクラスのコンストラクタの制限</li>
</ul>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
let mut list = [ 1, 2 ];
class Test {
   fn func() __async {
      foreach val in list { //error
         print( val );
      }
   }
}</code></pre>
</div>
<p>
例えば、上記の <code class="verbatim">func()</code> から list へのアクセスは本来コンパイルエラーになりますが、
これをエラーとしない場合、
<code class="verbatim">func()</code> メソッドを実行している間に、
別のスレッドで list の値を更新した場合、
list に対して参照と変更が同時に発生し、不定な動作になります。</p>
<p>
これをガードするために、 __async 宣言した関数には制限が付きます。</p>
<p>
また、次のようなコードを実行した場合、</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: error
class Hoge extend (__Runner) {
   let list:List&lt;int&gt;;
   pub fn __init( list:List&lt;int&gt; ) __async { // error
      self.list = list;

      __run( self, __lns.runMode.Queue, &#34;test&#34; );
   }
   pub fn run() __async mut {
      self.list.insert(1);
   }
}

let mut workList = [1];
let hoge1 = new Hoge( workList );
let hoge2 = new Hoge( workList );</code></pre>
</div>
<p>
本来 Hoge のコンストラクタの list の型が
mutable であるためコンパイルエラーになりますが、
これをエラーとしない場合、同じ workList に対して、
複数の Hoge の非同期処理によって <code class="verbatim">insert()</code> が同時に発生し、
不定な動作になります。</p>
<p>
これをガードするために、
__Runner を extend したコンストラクタには制限が付きます。</p>
<div id="outline-container-headline-370" class="outline-4">
<h4 id="headline-370">
不完全な制限
</h4>
<div id="outline-text-headline-370" class="outline-text-4">
<p>
前述している通り LuneScript の排他制御は、不完全です。</p>
<p>
既に気付いている方もいると思いますが、
現状の制限を守っていても不定な動作を起すことが簡単に出来ます。</p>
<p>
例えば、以下のコードの
<code class="verbatim">func()</code> からアクセスする list2 は &amp;List&lt;int&gt; なので immutable であり、
__async 関数の制限を満します。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
let mut list = [ 1, 2 ];
let list2 = list;
class Test {
   fn func() __async {
      foreach val in list2 {
         print( val );
      }
   }
}</code></pre>
</div>
<p>
しかし、func を非同期で実行中に別のスレッドから list を更新されると、
funcでアクセスしてる list2 は list と同じインスタンスであるため、
不定な動作になります。</p>
<p>
コンストラクタの制限についても同じようなことを起せます。</p>
<p>
このように、不完全な制限になってしまっていますが、
これは、プログラミング開発の手軽さと、
静的チェックの厳格さとのトレードオフな部分であり、
LuneScript ではバランスを取って現状はこの仕様になっています。</p>
<p>
プログラミング開発の手軽さを保ちつつ、
静的チェックの厳格さを向上できる方法は今後も模索していきます。</p>
<hr>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-async_old_ja" class="outline-2">
<h2 id="async_old_ja">
<strong>非同期処理(過去情報)</strong>
</h2>
<div id="outline-text-async_old_ja" class="outline-text-2">
<p>
LuneScript から go 言語へのトランスコンパイル対応したのを機に、
LuneScript による非同期処理を対応しました。</p>
<p>
ただし、これは非常に実験的な内容なので参考程度にしてください。</p>
<p>
<strong>1.3.0 から廃止。 このドキュメントは過去ログとして保持しておきます。</strong></p>
<div id="outline-container-headline-372" class="outline-3">
<h3 id="headline-372">
LuneScript のランタイム
</h3>
<div id="outline-text-headline-372" class="outline-text-3">
<p>
LuneScript には、LuneScript の言語仕様とトランスコンパイル先の言語仕様との
差を埋めるためのランタイムがあります。</p>
<p>
例えば go にトランスコンパイルする場合、次の処理をライタイムで実現しています。</p>
<ul>
<li>lua との連携動作</li>
<li>and or 演算子の挙動</li>
</ul>
<p>これら処理は、ランタイム内で宣言しているデータにアクセスしています。</p>
<p>
LuneScript を非同期処理に対応する場合、
ランタイム内のデータアクセスを排他対応する必要があります。</p>
<p>
一方で、 mutex などによる排他制御は、
シングルスレッド時にもパフォーマンスに影響してしまいます。</p>
<p>
今回の非同期処理ではシングルスレッドへの影響を最小限にするため、
排他制御は最低限にし、
必要なデータを複製してスレッド毎にアクセスするデータを切り替えることしました。</p>
<p>
具体的には、「lua との連携動作」と「and or 演算子の挙動」に必要なランタイムデータを
スレッド毎に複製し、スレッド毎に切り替えて利用します。</p>
<p>
ここで一つ問題があります。</p>
<p>
それは、 go は現在実行中のスレッド ID を取得することが出来ない、ということです。</p>
<p>
スレッド ID の取得が出来れば、ランタイムのデータにアクセスする際に、
現在のスレッド ID を取得して、そのスレッド ID に対応したランタイムのデータに
アクセス先を切り替える、という処理を行なえます。</p>
<p>
しかし、スレッド ID の取得が出来ないため、それが出来ません。</p>
<p>
これが出来ないと、スレッド ID を全ての関数の引数に渡していく、
という方法が必要になります。</p>
<p>
さすがにこれはやりたくないので、別の方法を考えました。</p>
<p>
以降では、今回導入した非同期処理の方法について説明します。</p>
</div>
</div>
<div id="outline-container-headline-373" class="outline-3">
<h3 id="headline-373">
LnsThread クラスの導入と制限
</h3>
<div id="outline-text-headline-373" class="outline-text-3">
<p>
LuneScript で非同期処理を行なう場合、 LnsThread クラスを継承します。</p>
<p>
LnsThread クラスは、次のようなクラスです。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
abstract class LnsThread {
   pro abstract fn loop() mut;
}</code></pre>
</div>
<p>
LnsThread のサブクラスでは、 <code class="verbatim">loop()</code> メソッドを override し、
その中で非同期処理を行ないます。</p>
<p>
LnsThread のサブクラスのメソッド内で次のコマンドが実行されると、</p>
<pre class="example">
_lune_control run_async_pipe;
</pre>
<p>
go routine <code class="verbatim">loop()</code> メソッドが実行されます。</p>
<p>
なお、 LnsThread を継承するには、事前に次の宣言をしておく必要があります。</p>
<pre class="example">
_lune_control use_async;
</pre>
<p>
これは、 非同期処理を行なうことを宣言するコマンドです。</p>
<p>
このコマンドが実行されているモジュー内では、
次の演算が制限がかかり、
LnsThread のサブクラスのメソッド内からのみしか実行できなくなります。</p>
<ul>
<li>and/or 演算</li>
<li>nil 条件演算</li>
<li>一部のビルトイン関数、メソッドアクセス</li>
</ul>
<p>また、非同期処理とのデータを送受信するための手段として、
__pipe&lt;T&gt; クラスを追加しています。</p>
<p>
__pipe&lt;T&gt; クラスは、 go の chan と等価と思ってください。</p>
<p>
__pipe&lt;T&gt; クラスは、次のようなクラスです。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
class __pipe&lt;T&gt; {
  pub fn get() mut : T!;
  pub fn put( val:T! ) mut;
}</code></pre>
</div>
<p>
ここで、__pipe&lt;T&gt;  の T には __AsyncItem インタフェースを implement したクラスを
指定する必要があります。</p>
<p>
<code class="verbatim">put()</code> した val が、 <code class="verbatim">get()</code> で取得できるようになります。
put(val:T!) に nil を与えると、その __pipe の通信は終了し、
その後 nil 意外を <code class="verbatim">put()</code> しても、 <code class="verbatim">get()</code> は nil を返すようになります。</p>
<p>
__AsyncItem インタフェースを implement クラスは、
同時に Mapping インタフェースも implement が必要です。</p>
<p>
__AsyncItem インタフェースを implement したクラスには、
次のメソッドが追加されます。</p>
<pre class="example">
pub static fn _createPipe( num:int ) : __pipe&lt;T&gt;!;
</pre>
<p>
ここで 引数 num は、 chan の cap と同じです。</p>
<p>
なお、 Lua にトランスコンパイルした場合、
この <code class="verbatim">_createPipe()</code> 関数は必ず nil を返します。</p>
<p>
上記をまとめると、非同期処理は次のように書きます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
_lune_control use_async;

class Test extend (__AsyncItem,Mapping) {
   let val:str {pub};
}

class Async extend LnsThread {
   let mut count:int {pub};
   let mut pipe:__pipe&lt;Test&gt;!;
   
   pub fn __init( pipe:__pipe&lt;Test&gt;! ) {
      super();
      self.pipe = pipe;
      self.count = 0;
   }
   
   pro override fn loop() mut {
      print( &#34;hoge:&#34; );
      while true {
         if! let mut pipe = self.pipe {
            let! val = pipe.get() {  // pipe からデータを取得
               print( &#34;hoge:&#34; );
               break;
            };
            val.$val.find( &#34;%d&#34; (self.count) ## );
            self.count = self.count + 1;
         }
      }
   }
   pub fn start() {
      _lune_control run_async_pipe;  // loop() 起動
   }
   pub fn put( test:Test ) mut {
      if! let mut pipe = self.pipe { // pipe にデータをセット
         pipe.put( test );
      }
   }
}

let mut async = new Async( Test._createPipe( 10 ) );
async.start();
let mut async2 = new Async( Test._createPipe( 10 ) );
async2.start();

for _ = 1, 100000 {
   async.put( new Test( &#34;abcdefg&#34; ) );
   async2.put( new Test( &#34;abcdefg&#34; ) );
}
print( async.$count, async2.$count );</code></pre>
</div>
<div id="outline-container-headline-374" class="outline-4">
<h4 id="headline-374">
非同期処理の制限
</h4>
<div id="outline-text-headline-374" class="outline-text-4">
<p>
次の処理を行なった場合の動作は未定義です。</p>
<ul>
<li><code class="verbatim">Loop()</code> 内から、別モジュールのデータ、メソッドにアクセスする</li>
<li>別モジュールから LnsThread を継承したクラスのデータ、メソッドにアクセスする</li>
<li>LnsThread を継承したクラスのインスタンス間のデータ、メソッドにアクセスする  </li>
</ul>
<p>以上のように、非常に限定的で使い勝手の悪い仕様になっています。
この仕様は間違いなく将来変更になるので、
冒頭で書いたようにあくまで参考程度にしてください。</p>
<p>
ちなみに、これだけ制限の多い非同期処理ですが、
LuneScript の parse 処理に利用していて、
LuneScript の高速化にほんの少し貢献しています。</p>
<hr>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-luago_ja" class="outline-2">
<h2 id="luago_ja">
<strong>Lua と連携 編</strong>
</h2>
<div id="outline-text-luago_ja" class="outline-text-2">
<p>
LuneScript は Lua のコードを実行できます。</p>
<p>
この特徴は、 go 言語にトランスコンパイラした後も維持されますが、
幾つかの点で注意が必要です。</p>
<p>
特に非同期処理と lua コード実行の組み合わせには要注意です。</p>
<div id="outline-container-headline-376" class="outline-3">
<h3 id="headline-376">
Luaval
</h3>
<div id="outline-text-headline-376" class="outline-text-3">
<p>
既にリンク先で説明している通り、 lua で実行した結果は <strong>Luaval 型</strong> で管理します。</p>
<p>
<a href="#lua">#lua</a></p>
<p>
この Luaval 型のデータには、以下の制限がありあます。</p>
<p>
<strong>ある Luaval 型のデータ dataA を取得する際に実行した Lua VM と、</strong>
<strong>その dataA にアクセスする際に実行する Lua VM とは、</strong>
<strong>同じ Lua VM でなければなりません。</strong></p>
<p>
この制限を満さない場合の動作は <strong>不定</strong> です。</p>
<p>
非同期処理で Luaval を扱わない場合は、
利用される Lua VM は一つに限られるので、
どの Lua VM が利用されるを意識する必要はありません。</p>
<p>
なお、 <strong>「Luaval 型のデータへのアクセス」</strong> とは、
変数間の代入は含まれません。
つまり、次の <code>work = val</code> は <strong>「Luaval 型のデータへのアクセス」</strong> にはならないので、
Lua VM を意識する必要はありません。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( val:&amp;Luaval&lt;&amp;List&lt;int&gt;&gt; ) {
   let work = val;
}</code></pre>
</div>
</div>
</div>
<div id="outline-container-headline-377" class="outline-3">
<h3 id="headline-377">
Lua VM の種類
</h3>
<div id="outline-text-headline-377" class="outline-text-3">
<p>
Lua VM には次の 2 つの種類があります。</p>
<ul>
<li>__noasync で実行する Lua VM</li>
<li>
<p>__async で実行する Lua VM</p>
<ul>
<li>__async 用 Lua VM は、非同期スレッドごとに存在します</li>
</ul>
</li>
</ul>
<p>
lua を実行する際、どの Lua VM にアクセスするか制御が必要です。</p>
<p>
この制御を行なうのが <strong>lua アクセスブロック</strong> です。</p>
</div>
</div>
<div id="outline-container-headline-378" class="outline-3">
<h3 id="headline-378">
lua アクセスブロック
</h3>
<div id="outline-text-headline-378" class="outline-text-3">
<p>
<strong>lua アクセスブロック</strong> には、以下の種類があります。
また、アクセスする関数が __async なのか __noasync なのかによって、
利用する <strong>lua アクセスブロック</strong> が異なります。</p>
<ul>
<li>
<p>__luago</p>
<ul>
<li>__noasync の関数から lua にアクセスする際に利用する</li>
<li>これは __noasync 用 Lua VM で lua にアクセスする。</li>
</ul>
</li>
<li>
<p>__luaLock</p>
<ul>
<li>__async の関数から lua にアクセスする際に利用する</li>
<li>これは __asyncLock と __luago の組み合わせと等価です。</li>
</ul>
</li>
<li>
<p>__luaDepend</p>
<ul>
<li>__async の関数から lua にアクセスする際に利用する</li>
<li>これは <strong>現在実行中のスレッドに紐付けられた Lua VM 用 lua でアクセスする。</strong></li>
<li>つまり、現在実行中のスレッドが __noasync であれば、__noasync 用 Lua VM でアクセスし、
現在実行中のスレッドが __async であれば、__async 用 Lua VM でアクセスする。</li>
</ul>
</li>
</ul>
<p>
<strong>__luaDepend は、使用される Lua VM が実行時に決定されるため細心の注意が必要です。</strong></p>
<div id="outline-container-headline-379" class="outline-4">
<h4 id="headline-379">
サンプル
</h4>
<div id="outline-text-headline-379" class="outline-text-4">
<p>
以下は、 lua コードを実行するサンプルです。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
__luago {
   let code = ```
return { val1 = 10, val2 = 20 }
```;
   let loaded, err = _load( code, nil );
   when! loaded {
      if! let obj = loaded( ## ) {
         forsort val, key in obj@@Map&lt;str,int&gt; {
            print( key, val + 100 ); 
         }
      }
   } else {
      print( err );
   }
}</code></pre>
</div>
<p>
変数 code に代入した lua のコード <code class="verbatim">return { val1 = 10, val2 = 20 }</code> を実行し、
その結果得られた Map を foreach で列挙して出力しています。</p>
<p>
この先頭で、 __luago を宣言しています。</p>
</div>
</div>
<div id="outline-container-headline-380" class="outline-4">
<h4 id="headline-380">
lua アクセスブロックの使い分け
</h4>
<div id="outline-text-headline-380" class="outline-text-4">
<p>
前述している通り、非同期処理から Lua にアクセスするには、
lua アクセスブロックの __luaLock と __luaDepend を使い分ける必要があります。</p>
<p>
しかし、よほど Lua の重い処理を非同期で実行しない限り、
__luaDepend を使うべきではありません。</p>
<p>
__luaDepend を使わずに、 __luago と __luaLock に限定することで、
Lua VM 内のロード処理を最低限にし、使用メモリを抑えられ、
結果的に非同期で実行するよりも効率よく処理できることがあります。</p>
<p>
また__luaDepend を使う場合、使用される lua VM に注意する必要があり、
それを間違えると <strong>実行時に不定な結果</strong> になります。</p>
<p>
__luaDepend を利用するには、
非同期に処理を行なうメリットと、デメリットを良く考える必要があります。</p>
<div id="outline-container-headline-381" class="outline-5">
<h5 id="headline-381">
__luaDepend を使った方が良いケース
</h5>
<div id="outline-text-headline-381" class="outline-text-5">
<p>
<code class="verbatim">string.gmatch()</code> は lua にアクセスするため lua アクセスブロックが必要です。</p>
<p>
この時、 <code class="verbatim">string.gmatch()</code> が扱う Luaval データは apply ブロック内に閉じるため、
__luaDepend を使った方が効率良く安全に処理できます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
   let mut list:List&lt;str&gt; = [];
   __luaDepend {
      apply token of string.gmatch( txt, pattern ) {
         list.insert( token );
      }
   }</code></pre>
</div>
<hr>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-go_study_ja" class="outline-2">
<h2 id="go_study_ja">
<strong>Go 言語へのトランスコンパイル (検討段階)</strong>
</h2>
<div id="outline-text-go_study_ja" class="outline-text-2">
<p>
Go 言語へのトランスコンパイル対応については、次の記事を参考に。</p>
<p>
<a href="#go">#go</a></p>
<p>
<strong>ここの情報は古いが、参考程度に残しておく。</strong></p>
<p>
LuneScript から Go 言語へのトランスコンパイルを検討中。</p>
<p>
ここでは、検討中の内容を記録する。</p>
<div id="outline-container-headline-383" class="outline-3">
<h3 id="headline-383">
ねらい
</h3>
<div id="outline-text-headline-383" class="outline-text-3">
<p>
LuneScript から Go 言語へのトランスコンパイルの狙いは次の通り。</p>
<ul>
<li>
<p>LuneScript の動作高速化</p>
<ul>
<li>LuneScript はコード補完機能をサポートしているが、
規模の大きいコードだと重くなって使い勝手が悪い。</li>
<li>高速化することで、LuneScript のコード補完機能の使い勝手を向上させる。</li>
</ul>
</li>
<li>
<p>高速化による、 LuneScript 自体のバージョンアップ作業効率改善</p>
<ul>
<li>LuneScript のセルフホストのビルド・テスト時間が、現状 2 分弱掛っている。</li>
<li>変更する毎に 2 分かかるのは辛いので、Go で高速化を図る。</li>
<li>C 言語へのトランスコンパイルの対応を進めていたが、
C 言語での GC 実装が思うように進まなかったので、
言語レベルで GC 対応している Go を先に対応する。</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-384" class="outline-3">
<h3 id="headline-384">
値
</h3>
<div id="outline-text-headline-384" class="outline-text-3">
<table>
<thead>
<tr>
<th>LuneScriptの型</th>
<th>Go の型</th>
<th>Go 用 Lns ランタム での type</th>
</tr>
</thead>
<tbody>
<tr>
<td>nil, null</td>
<td>interface{}</td>
<td>nil</td>
</tr>
<tr>
<td>int</td>
<td>int</td>
<td>LnsInt (alias)</td>
</tr>
<tr>
<td>real</td>
<td>float64</td>
<td>LnsReal(alias)</td>
</tr>
<tr>
<td>str</td>
<td>string</td>
<td>LnsStr (alias)</td>
</tr>
<tr>
<td>bool</td>
<td>bool</td>
<td>LnsBool(alias)</td>
</tr>
<tr>
<td>List</td>
<td>独自構造体</td>
<td>LnsList</td>
</tr>
<tr>
<td>Array</td>
<td>配列</td>
<td>LnsArray</td>
</tr>
<tr>
<td>Map</td>
<td>map</td>
<td>LnsMap</td>
</tr>
<tr>
<td>Set</td>
<td>map (key に item を入れる)</td>
<td>LnsSet</td>
</tr>
<tr>
<td>class</td>
<td>構造体</td>
<td></td>
</tr>
<tr>
<td>interface</td>
<td>interface</td>
<td></td>
</tr>
<tr>
<td>form</td>
<td>func</td>
<td>LnsForm</td>
</tr>
<tr>
<td>enum</td>
<td>int/float64/string</td>
<td>LnsEnum</td>
</tr>
<tr>
<td>stem</td>
<td>interface{}</td>
<td>LnsStem</td>
</tr>
<tr>
<td>nilable</td>
<td>interface{}</td>
<td></td>
</tr>
</tbody>
</table>
<div id="outline-container-headline-385" class="outline-4">
<h4 id="headline-385">
int/real の扱い
</h4>
<div id="outline-text-headline-385" class="outline-text-4">
<p>
LuneScript int/real は、 go の type alias を使用して次のように定義する。</p>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">LnsInt</span> <span class="p">=</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">LnsReal</span> <span class="p">=</span> <span class="kt">float64</span></span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-386" class="outline-4">
<h4 id="headline-386">
nilable の扱い
</h4>
<div id="outline-text-headline-386" class="outline-text-4">
<p>
LuneScript の nilable は、そのままでは元の値として扱えない。
しかし、等しいかどうかのチェックは行なえる。
これは go と LuneScript と同じ。</p>
</div>
</div>
<div id="outline-container-headline-387" class="outline-4">
<h4 id="headline-387">
真偽値の扱い
</h4>
<div id="outline-text-headline-387" class="outline-text-4">
<p>
LuneScript は nil と false が偽で、それ以外は真となる。
go は true/false で判断が必要なので、 LuneScript 用の条件変換関数を用意する。</p>
</div>
</div>
<div id="outline-container-headline-388" class="outline-4">
<h4 id="headline-388">
and/or の扱い
</h4>
<div id="outline-text-headline-388" class="outline-text-4">
<p>
LuneScript の and/or は論理演算ではなく、式の評価を制御し、評価結果も bool ではない。
go は評価結果が bool になる。</p>
</div>
</div>
<div id="outline-container-headline-389" class="outline-4">
<h4 id="headline-389">
Generics の扱い
</h4>
<div id="outline-text-headline-389" class="outline-text-4">
<p>
go は Generics がないので、 Generics の型は全て interface{} で扱う。</p>
</div>
</div>
<div id="outline-container-headline-390" class="outline-4">
<h4 id="headline-390">
Set の扱い
</h4>
<div id="outline-text-headline-390" class="outline-text-4">
<p>
go は Set がないので、 Map で代用する。   </p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-391" class="outline-3">
<h3 id="headline-391">
多値返却
</h3>
<div id="outline-text-headline-391" class="outline-text-3">
<p>
go と LuneScript の多値返却は動きが異なる。</p>
<p>
<code class="verbatim">hoge()</code> が x, y を返す多値返却の関数としたとき、それぞれ次の動きになる。</p>
<table>
<thead>
<tr>
<th>コード</th>
<th>LuneScript 展開結果</th>
<th>go 展開結果</th>
</tr>
</thead>
<tbody>
<tr>
<td>(hoge())</td>
<td>x</td>
<td>x, y</td>
</tr>
<tr>
<td>hoge(), val</td>
<td>x, val</td>
<td>x, y, val</td>
</tr>
</tbody>
</table>
<p>
上記違いを実現するために、 go では次の変換関数を用意する。</p>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// 多値返却の先頭 int を返す
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">carInt</span><span class="p">(</span> <span class="nx">multi</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{}</span> <span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="nx">multi</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nb">panic</span><span class="p">(</span> <span class="s">&#34;nothing&#34;</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">multi</span><span class="p">[</span><span class="mi">0</span><span class="p">].(</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">// 多値返却の先頭 int! を返す
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">carIntN</span><span class="p">(</span> <span class="nx">multi</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{}</span> <span class="p">)</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span> <span class="nx">multi</span> <span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">multi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">multi</span><span class="p">[</span><span class="mi">0</span><span class="p">].(</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-392" class="outline-3">
<h3 id="headline-392">
クラスと継承
</h3>
<div id="outline-text-headline-392" class="outline-text-3">
<p>
Go は構造体とレシーバはあるが、継承がない。</p>
<p>
LuneScript は継承を持つので、 Go で継承を実現する必要がある。</p>
<p>
次の LuneScript のクラスを Go で対応する方法を示す。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
interface IF {
  pub fn sub1():int;
}
class Parent {
   let val1:int;
   pub fn sub1():int {
      return self.val1;
   }
}
class Sub extend Parent {
   let val2:int;
   pub override fn sub1():int {
      return self.val2;
   }
   pub fn sub2():int {
      return self.val2;
   }
}
class SubSub extend Sub {
   let val3:int;
   pub override fn sub1():int {
      return self.val3;
   }
   pub fn sub3():int {
      return self.val3;
   }
}</code></pre>
</div>
<div id="outline-container-headline-393" class="outline-4">
<h4 id="headline-393">
Go による等価コード
</h4>
<div id="outline-text-headline-393" class="outline-text-4">
<p>
Go による等価コードを示す</p>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ParentMtd</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sub1</span> <span class="p">()</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Parent</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">val1</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">FP</span> <span class="nx">ParentMtd</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ParentDownCast</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ToParent</span><span class="p">()</span> <span class="o">*</span><span class="nx">Parent</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">obj</span> <span class="o">*</span><span class="nx">Parent</span> <span class="p">)</span> <span class="nf">ToParent</span><span class="p">()</span> <span class="o">*</span><span class="nx">Parent</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">obj</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">Parent</span><span class="p">)</span> <span class="nf">sub1</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">val1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">NewParent</span><span class="p">(</span><span class="nx">val1</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Parent</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">parent</span> <span class="o">:=</span> <span class="nx">Parent</span><span class="p">{</span> <span class="nx">val1</span><span class="p">,</span> <span class="kc">nil</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">parent</span><span class="p">.</span><span class="nx">FP</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">parent</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">parent</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SubMtd</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ParentMtd</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sub2</span> <span class="p">()</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Sub</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Parent</span>
</span></span><span class="line"><span class="cl">    <span class="nx">val2</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">FP</span> <span class="nx">SubMtd</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SubDownCast</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ToSub</span><span class="p">()</span> <span class="o">*</span><span class="nx">Sub</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">obj</span> <span class="o">*</span><span class="nx">Sub</span> <span class="p">)</span> <span class="nf">ToSub</span><span class="p">()</span> <span class="o">*</span><span class="nx">Sub</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">obj</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">Sub</span><span class="p">)</span> <span class="nf">sub1</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">val2</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">Sub</span><span class="p">)</span> <span class="nf">sub2</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">val2</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">newSub</span><span class="p">(</span><span class="nx">val1</span><span class="p">,</span><span class="nx">val2</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Sub</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sub</span> <span class="o">:=</span> <span class="nx">Sub</span><span class="p">{</span> <span class="nx">Parent</span><span class="p">{</span> <span class="nx">val1</span><span class="p">,</span> <span class="kc">nil</span> <span class="p">},</span> <span class="nx">val2</span><span class="p">,</span> <span class="kc">nil</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sub</span><span class="p">.</span><span class="nx">Parent</span><span class="p">.</span><span class="nx">FP</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sub</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sub</span><span class="p">.</span><span class="nx">FP</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sub</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">sub</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SubSubMtd</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">SubMtd</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sub3</span> <span class="p">()</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SubSub</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Sub</span>
</span></span><span class="line"><span class="cl">    <span class="nx">val3</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">FP</span> <span class="nx">SubSubMtd</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SubSubDownCast</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ToSubSub</span><span class="p">()</span> <span class="o">*</span><span class="nx">SubSub</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">obj</span> <span class="o">*</span><span class="nx">SubSub</span> <span class="p">)</span> <span class="nf">ToSubSub</span><span class="p">()</span> <span class="o">*</span><span class="nx">SubSub</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">obj</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">obj</span> <span class="o">*</span><span class="nx">SubSub</span> <span class="p">)</span> <span class="nf">ToSub</span><span class="p">()</span> <span class="o">*</span><span class="nx">Sub</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">obj</span><span class="p">.</span><span class="nx">Sub</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">SubSub</span><span class="p">)</span> <span class="nf">sub1</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">val3</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">SubSub</span><span class="p">)</span> <span class="nf">sub2</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Sub</span><span class="p">.</span><span class="nf">sub2</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">SubSub</span><span class="p">)</span> <span class="nf">sub3</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">val3</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">newSubSub</span><span class="p">(</span><span class="nx">val1</span><span class="p">,</span><span class="nx">val2</span><span class="p">,</span><span class="nx">val3</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">SubSub</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">subsub</span> <span class="o">:=</span> <span class="nx">SubSub</span><span class="p">{</span> <span class="nx">Sub</span><span class="p">{</span> <span class="nx">Parent</span><span class="p">{</span> <span class="nx">val1</span><span class="p">,</span> <span class="kc">nil</span> <span class="p">},</span> <span class="nx">val2</span><span class="p">,</span> <span class="kc">nil</span> <span class="p">},</span> <span class="nx">val3</span><span class="p">,</span> <span class="kc">nil</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">subsub</span><span class="p">.</span><span class="nx">Parent</span><span class="p">.</span><span class="nx">FP</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">subsub</span>
</span></span><span class="line"><span class="cl">    <span class="nx">subsub</span><span class="p">.</span><span class="nx">Sub</span><span class="p">.</span><span class="nx">FP</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">subsub</span>
</span></span><span class="line"><span class="cl">    <span class="nx">subsub</span><span class="p">.</span><span class="nx">FP</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">subsub</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">subsub</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">testParent</span><span class="p">(</span> <span class="nx">obj</span> <span class="o">*</span><span class="nx">Parent</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">FP</span><span class="p">.</span><span class="nf">sub1</span><span class="p">()</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">testSub</span><span class="p">(</span> <span class="nx">mess</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">obj</span> <span class="o">*</span><span class="nx">Sub</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span> <span class="nx">mess</span><span class="p">,</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">FP</span><span class="p">.</span><span class="nf">sub1</span><span class="p">(),</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">FP</span><span class="p">.</span><span class="nf">sub2</span><span class="p">()</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">testCast</span><span class="p">(</span> <span class="nx">obj</span> <span class="o">*</span><span class="nx">Parent</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">cast</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">FP</span><span class="p">.(</span><span class="nx">SubDownCast</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">ok</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">testSub</span><span class="p">(</span> <span class="s">&#34;cast&#34;</span><span class="p">,</span> <span class="nx">cast</span><span class="p">.</span><span class="nf">ToSub</span><span class="p">()</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span> <span class="s">&#34;cast NG&#34;</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Lns_init</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">subsub</span> <span class="o">:=</span> <span class="nf">newSubSub</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span> <span class="nx">subsub</span><span class="p">.</span><span class="nx">val1</span><span class="p">,</span> <span class="nx">subsub</span><span class="p">.</span><span class="nx">val2</span><span class="p">,</span> <span class="nx">subsub</span><span class="p">.</span><span class="nx">val3</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span> <span class="nx">subsub</span><span class="p">.</span><span class="nx">FP</span><span class="p">.</span><span class="nf">sub1</span><span class="p">(),</span> <span class="nx">subsub</span><span class="p">.</span><span class="nx">FP</span><span class="p">.</span><span class="nf">sub2</span><span class="p">(),</span> <span class="nx">subsub</span><span class="p">.</span><span class="nx">FP</span><span class="p">.</span><span class="nf">sub3</span><span class="p">()</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">testSub</span><span class="p">(</span> <span class="s">&#34;subsub.Sub&#34;</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">subsub</span><span class="p">.</span><span class="nx">Sub</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">testParent</span><span class="p">(</span> <span class="o">&amp;</span><span class="nx">subsub</span><span class="p">.</span><span class="nx">Parent</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">testCast</span><span class="p">(</span> <span class="o">&amp;</span><span class="nx">subsub</span><span class="p">.</span><span class="nx">Parent</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">sub</span> <span class="o">:=</span> <span class="nf">newSub</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">testSub</span><span class="p">(</span> <span class="s">&#34;sub&#34;</span><span class="p">,</span> <span class="nx">sub</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">testParent</span><span class="p">(</span> <span class="o">&amp;</span><span class="nx">sub</span><span class="p">.</span><span class="nx">Parent</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">testCast</span><span class="p">(</span> <span class="o">&amp;</span><span class="nx">sub</span><span class="p">.</span><span class="nx">Parent</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">testCast</span><span class="p">(</span> <span class="nf">NewParent</span><span class="p">(</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-394" class="outline-4">
<h4 id="headline-394">
継承実現方法
</h4>
<div id="outline-text-headline-394" class="outline-text-4">
<div id="outline-container-headline-395" class="outline-5">
<h5 id="headline-395">
Parent クラス
</h5>
<div id="outline-text-headline-395" class="outline-text-5">
<p>
まず、 Parent クラスについて説明する。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Parent {
   let val1:int;
   pub fn sub1():int {
      return self.val1;
   }
}</code></pre>
</div>
<div id="outline-container-headline-396" class="outline-6">
<h6 id="headline-396">
データ構造
</h6>
<div id="outline-text-headline-396" class="outline-text-6">
<p>
Parent クラスを表現するため、次の構造体と interface を定義する。</p>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ParentMtd</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sub1</span> <span class="p">()</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Parent</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">val1</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">FP</span> <span class="nx">ParentMtd</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">ParentDownCast</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ToParent</span><span class="p">()</span> <span class="o">*</span><span class="nx">Parent</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">obj</span> <span class="o">*</span><span class="nx">Parent</span> <span class="p">)</span> <span class="nf">ToParent</span><span class="p">()</span> <span class="o">*</span><span class="nx">Parent</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">obj</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<ul>
<li>
<p>ParentMtd インタフェースは、次の役割を持つ</p>
<ul>
<li>Parent クラスのメソッドを定義</li>
<li>Parent クラスのモリモーフィズムを表現する</li>
</ul>
</li>
<li>Parent 構造体は、メンバと ParentMtd を持つ</li>
<li>ParentDownCast は、ダウンキャスト用にクラスごとに定義する</li>
</ul>
</div>
</div>
<div id="outline-container-headline-397" class="outline-6">
<h6 id="headline-397">
メソッド
</h6>
<div id="outline-text-headline-397" class="outline-text-6">
<p>
Parent クラスのメソッドを表現するため、次のレシーバ関数を定義する。</p>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">Parent</span><span class="p">)</span> <span class="nf">sub1</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">val1</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-398" class="outline-6">
<h6 id="headline-398">
コンストラクタ
</h6>
<div id="outline-text-headline-398" class="outline-text-6">
<p>
Parent クラスのコンストラクタとして、次を定義する。</p>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">NewParent</span><span class="p">(</span><span class="nx">val1</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Parent</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">super</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Parent</span><span class="p">{</span> <span class="nx">val1</span><span class="p">,</span> <span class="kc">nil</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">super</span><span class="p">.</span><span class="nx">FP</span> <span class="p">=</span> <span class="nx">super</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">super</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>
このコンストラクタは次の処理を行なう。</p>
<ul>
<li>メンバの初期化</li>
<li>FP の設定</li>
</ul>
</div>
</div>
<div id="outline-container-headline-399" class="outline-6">
<h6 id="headline-399">
Parent クラスの使用方法
</h6>
<div id="outline-text-headline-399" class="outline-text-6">
<p>
Parent は次のように使用する。</p>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">parent</span> <span class="o">:=</span> <span class="nf">NewParent</span><span class="p">(</span> <span class="mi">1</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">FP</span><span class="p">.</span><span class="nf">sub1</span><span class="p">()</span> <span class="p">)</span></span></span></code></pre></div>
</div>
<p>
メソッドをコールする場合、必ず FP インタフェースを介してコールする。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-400" class="outline-5">
<h5 id="headline-400">
Sub クラス
</h5>
<div id="outline-text-headline-400" class="outline-text-5">
<p>
Sub クラスについて説明する。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
class Sub extend Parent {
   let val2:int;
   pub override fn sub1():int {
      return self.val2;
   }
   pub fn sub2():int {
      return self.val2;
   }
}</code></pre>
</div>
<div id="outline-container-headline-401" class="outline-6">
<h6 id="headline-401">
データ構造
</h6>
<div id="outline-text-headline-401" class="outline-text-6">
<p>
Sub クラスを表現するため、次の構造体と interface を定義する。</p>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SubMtd</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">ParentMtd</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sub2</span> <span class="p">()</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Sub</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Parent</span>
</span></span><span class="line"><span class="cl">    <span class="nx">val2</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">FP</span> <span class="nx">SubMtd</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SubDownCast</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ToSub</span><span class="p">()</span> <span class="o">*</span><span class="nx">Sub</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">obj</span> <span class="o">*</span><span class="nx">Sub</span> <span class="p">)</span> <span class="nf">ToSub</span><span class="p">()</span> <span class="o">*</span><span class="nx">Sub</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">obj</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">obj</span> <span class="o">*</span><span class="nx">Sub</span> <span class="p">)</span> <span class="nf">ToParent</span><span class="p">()</span> <span class="o">*</span><span class="nx">Parent</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">obj</span><span class="p">.</span><span class="nx">Parent</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<ul>
<li>
<p>SubMtd インタフェースは、 Sub で定義しているメソッドを宣言する。</p>
<ul>
<li>Parent のメソッドは含めない </li>
</ul>
</li>
<li>Sub 構造体は、Parent 構造体のデータと、 Sub で定義しているメンバを宣言する。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-402" class="outline-6">
<h6 id="headline-402">
メソッド
</h6>
<div id="outline-text-headline-402" class="outline-text-6">
<p>
Sub クラスのメソッドを表現するため、次のレシーバ関数を定義する。</p>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">Sub</span><span class="p">)</span> <span class="nf">sub1</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">val2</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">Sub</span><span class="p">)</span> <span class="nf">sub2</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">val2</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-403" class="outline-6">
<h6 id="headline-403">
コンストラクタ
</h6>
<div id="outline-text-headline-403" class="outline-text-6">
<p>
Sub クラスのコンストラクタとして、次を定義する。</p>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">newSub</span><span class="p">(</span><span class="nx">val1</span><span class="p">,</span><span class="nx">val2</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">Sub</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sub</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Sub</span><span class="p">{</span> <span class="nx">Parent</span><span class="p">{</span> <span class="nx">val1</span><span class="p">,</span> <span class="kc">nil</span> <span class="p">},</span> <span class="nx">val2</span><span class="p">,</span> <span class="kc">nil</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sub</span><span class="p">.</span><span class="nx">Parent</span><span class="p">.</span><span class="nx">FP</span> <span class="p">=</span> <span class="nx">sub</span>
</span></span><span class="line"><span class="cl">    <span class="nx">sub</span><span class="p">.</span><span class="nx">FP</span> <span class="p">=</span> <span class="nx">sub</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">sub</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>
このコンストラクタは次の処理を行なう。</p>
<ul>
<li>メンバの初期化</li>
<li>
<p>FP の設定</p>
<ul>
<li><strong>super の FP もここで設定する</strong></li>
<li>この super の FP に &amp;super ではなく &amp;sub を設定することで、ポリモーフィズムを実現する</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-404" class="outline-5">
<h5 id="headline-404">
SubSub クラス
</h5>
<div id="outline-text-headline-404" class="outline-text-5">
<p>
SubSub クラスについて説明する。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
class SubSub extend Sub {
   let val3:int;
   pub override fn sub1():int {
      return self.val3;
   }
   pub fn sub3():int {
      return self.val3;
   }
}</code></pre>
</div>
<div id="outline-container-headline-405" class="outline-6">
<h6 id="headline-405">
データ構造
</h6>
<div id="outline-text-headline-405" class="outline-text-6">
<p>
SubSub クラスを表現するため、次の構造体と interface を定義する。</p>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SubSubMtd</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">SubMtd</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sub3</span> <span class="p">()</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SubSub</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Sub</span>
</span></span><span class="line"><span class="cl">    <span class="nx">val3</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">FP</span> <span class="nx">SubSubMtd</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">SubSubDownCast</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ToSubSub</span><span class="p">()</span> <span class="o">*</span><span class="nx">SubSub</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">obj</span> <span class="o">*</span><span class="nx">SubSub</span> <span class="p">)</span> <span class="nf">ToSubSub</span><span class="p">()</span> <span class="o">*</span><span class="nx">SubSub</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">obj</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">obj</span> <span class="o">*</span><span class="nx">SubSub</span> <span class="p">)</span> <span class="nf">ToSub</span><span class="p">()</span> <span class="o">*</span><span class="nx">Sub</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">obj</span><span class="p">.</span><span class="nx">Sub</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">obj</span> <span class="o">*</span><span class="nx">SubSub</span> <span class="p">)</span> <span class="nf">ToParent</span><span class="p">()</span> <span class="o">*</span><span class="nx">Parent</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">obj</span><span class="p">.</span><span class="nx">Parent</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<ul>
<li>
<p>SubSubMtd インタフェースは、 SubSub で定義しているメソッドを宣言する。</p>
<ul>
<li>Sub のメソッドは含めない </li>
</ul>
</li>
<li>SubSub 構造体は、Sub 構造体のデータと、 SubSub で定義しているメンバを宣言する。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-406" class="outline-6">
<h6 id="headline-406">
メソッド
</h6>
<div id="outline-text-headline-406" class="outline-text-6">
<p>
SubSub クラスのメソッドを表現するため、次のレシーバ関数を定義する。</p>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">SubSub</span><span class="p">)</span> <span class="nf">sub1</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">val3</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">SubSub</span><span class="p">)</span> <span class="nf">sub2</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">Sub</span><span class="p">.</span><span class="nf">sub2</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">SubSub</span><span class="p">)</span> <span class="nf">sub3</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">val3</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<div id="outline-container-headline-407" class="outline-7">
<h7 id="headline-407">
override していないメソッド定義
</h7>
<div id="outline-text-headline-407" class="outline-text-7">
<p>
上記で注目すべきは、 sub2() メソッドで <code class="verbatim">self.Sub.sub2()</code> をコールしている点。</p>
<p>
SubSub クラスは、 sub2 メソッドを override していない。
つまりは、SubSub の sub2 メソッドは Sub クラスのメソッドが使用されることになる。
よって、 Sub.sub2 メソッドをコールしている。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-408" class="outline-6">
<h6 id="headline-408">
コンストラクタ
</h6>
<div id="outline-text-headline-408" class="outline-text-6">
<p>
SubSub クラスのコンストラクタとして、次を定義する。</p>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">newSubSub</span><span class="p">(</span><span class="nx">val1</span><span class="p">,</span><span class="nx">val2</span><span class="p">,</span><span class="nx">val3</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">SubSub</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">subsub</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">SubSub</span><span class="p">{</span> <span class="nx">Sub</span><span class="p">{</span> <span class="nx">Parent</span><span class="p">{</span> <span class="nx">val1</span><span class="p">,</span> <span class="kc">nil</span> <span class="p">},</span> <span class="nx">val2</span><span class="p">,</span> <span class="kc">nil</span> <span class="p">},</span> <span class="nx">val3</span><span class="p">,</span> <span class="kc">nil</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nx">subsub</span><span class="p">.</span><span class="nx">Parent</span><span class="p">.</span><span class="nx">FP</span> <span class="p">=</span> <span class="nx">subsub</span>
</span></span><span class="line"><span class="cl">    <span class="nx">subsub</span><span class="p">.</span><span class="nx">Sub</span><span class="p">.</span><span class="nx">FP</span> <span class="p">=</span> <span class="nx">subsub</span>
</span></span><span class="line"><span class="cl">    <span class="nx">subsub</span><span class="p">.</span><span class="nx">FP</span> <span class="p">=</span> <span class="nx">subsub</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">subsub</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>
このコンストラクタは次の処理を行なう。</p>
<ul>
<li>メンバの初期化</li>
<li>
<p>FP の設定</p>
<ul>
<li><strong>Parent, Sub の FP もここで設定する</strong></li>
<li>Parent, Sub の FP に &amp;subsub を設定することで、ポリモーフィズムを実現する</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-409" class="outline-5">
<h5 id="headline-409">
IF インタフェース
</h5>
<div id="outline-text-headline-409" class="outline-text-5">
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
interface IF {
  pub fn sub1():int;
}</code></pre>
</div>
<div id="outline-container-headline-410" class="outline-6">
<h6 id="headline-410">
データ構造
</h6>
<div id="outline-text-headline-410" class="outline-text-6">
<p>
LuneScript の interface は、 Go のインタフェースをそのまま使用する。</p>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">interface</span> <span class="nx">IF</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nx">pub</span> <span class="nx">fn</span> <span class="nf">sub1</span><span class="p">():</span><span class="kt">int</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-411" class="outline-5">
<h5 id="headline-411">
メソッド呼び出し
</h5>
<div id="outline-text-headline-411" class="outline-text-5">
<p>
Parent クラスのメソッドを呼び出すには、次のように行なう。</p>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">test</span><span class="p">(</span><span class="nx">parent</span> <span class="o">*</span><span class="nx">Parent</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nb">print</span><span class="p">(</span> <span class="nx">parent</span><span class="p">.</span><span class="nx">FP</span><span class="p">.</span><span class="nf">sub1</span><span class="p">()</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="nb">print</span><span class="p">(</span> <span class="nx">parent</span><span class="p">.</span><span class="nf">sub1</span><span class="p">()</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<div id="outline-container-headline-412" class="outline-6">
<h6 id="headline-412">
parent.FP.sub1() と parent.sub1() の違い
</h6>
<div id="outline-text-headline-412" class="outline-text-6">
<p>
メソッド呼び出しには、次の 2 つのパターンがある。</p>
<ul>
<li>
<p>parent.FP.sub1()</p>
<ul>
<li>ポリモーフィズムに対応したメソッド呼び出し</li>
</ul>
</li>
<li>
<p>parent.sub1()</p>
<ul>
<li>
<p>Parent クラスに定義しているメソッド呼び出し</p>
<ul>
<li>ポリモーフィズムに非対応</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-413" class="outline-6">
<h6 id="headline-413">
オーバーヘッド
</h6>
<div id="outline-text-headline-413" class="outline-text-6">
<ul>
<li>ポリモーフィズムに対応したメソッド呼び出しは、オーバーヘッドが大きい。</li>
<li>ポリモーフィズムに対応したメソッド呼び出しは、
<strong>ポリモーフィズムが必要な場合に限定すべき。</strong></li>
<li>
<p>ポリモーフィズムが必要かどうかは、 <strong>LuneScript では現状定義がない。</strong></p>
<ul>
<li><strong>クラスとメソッドに final 宣言を導入</strong> し、
ポリモーフィズムが不要であることを明示できるようにする対応が必要</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-414" class="outline-5">
<h5 id="headline-414">
up-cast / down-cast
</h5>
<div id="outline-text-headline-414" class="outline-text-5">
<ul>
<li>
<p>up-cast は、埋め込みのポインタにアクセスすることで実現する</p>
<ul>
<li>インタフェースへの up-cast は、オブジェクトが保持する interface 型を使用する</li>
</ul>
</li>
<li>
<p>down-cast は、 interface を型アサーションで実現する。</p>
<ul>
<li>各クラスごとに DownCast インタフェースを定義して、
そのインタフェースにキャストしてから、
さらに目的のクラスへのキャスト関数を実行する</li>
</ul>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">ifObj</span> <span class="nx">IF</span> <span class="p">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">FP</span> <span class="c1">// インタフェースをセットする
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">parent</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">obj</span><span class="p">.</span><span class="nx">Parent</span> <span class="c1">// アップキャスト
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">(</span><span class="nx">parent</span><span class="p">.</span><span class="nx">FP</span><span class="p">.(</span><span class="nx">SubDownCast</span><span class="p">)).</span><span class="nf">ToSub</span><span class="p">()</span> <span class="c1">// obj を Sub にダウンキャストする
</span></span></span></code></pre></div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-415" class="outline-4">
<h4 id="headline-415">
Class のまとめ
</h4>
<div id="outline-text-headline-415" class="outline-text-4">
<ul>
<li>
<p>クラスのメソッドを定義する interface を宣言する</p>
<ul>
<li>Super クラスで定義しているメソッドの interface を埋め込む</li>
</ul>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">TestMtd</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">SuperMtd</span>
</span></span><span class="line"><span class="cl">    <span class="nf">method</span><span class="p">()</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<ul>
<li>
<p>クラスのメンバと前記の interface を保持する構造体を宣言する</p>
<ul>
<li>継承は、 継承する型を埋め込む</li>
</ul>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Test</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">Super</span>
</span></span><span class="line"><span class="cl">    <span class="nx">val</span> <span class="kt">int</span>
</span></span><span class="line"><span class="cl">    <span class="nx">FP</span> <span class="nx">TestMtd</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<ul>
<li>ダウンキャスト用の interface を定義する</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">TestDownCast</span> <span class="kd">interface</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">ToTest</span><span class="p">()</span> <span class="o">*</span><span class="nx">Test</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<ul>
<li>
<p>ダウンキャスト用のメソッドを定義する</p>
<ul>
<li>このメソッドは、 Super クラスの分を全て宣言する</li>
</ul>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">obj</span> <span class="o">*</span><span class="nx">SubSub</span><span class="p">)</span> <span class="nf">ToSub</span><span class="p">()</span> <span class="o">*</span><span class="nx">Sub</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="o">&amp;</span><span class="nx">obj</span><span class="p">.</span><span class="nx">Sub</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<ul>
<li>
<p>クラスのメソッドの動作を定義するレシーバを宣言する</p>
<ul>
<li>レシーバは Super クラスのメソッドを含めて宣言する</li>
<li>override していない関数は、そのメソッドを定義している構造体のメソッドをコールする</li>
</ul>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">self</span> <span class="o">*</span><span class="nx">Test</span><span class="p">)</span> <span class="nf">method</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">self</span><span class="p">.</span><span class="nx">super</span><span class="p">.</span><span class="nf">method</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<ul>
<li>
<p>コンストラクタで、メンバの初期化と interface FP を初期化する</p>
<ul>
<li>interface は、 Super クラスの interface FP を含めて初期化する</li>
</ul>
</li>
<li>
<p>メソッド呼び出しは、 interface FP 経由でコールする</p>
<ul>
<li>ポリモーフィズム無効なメソッド呼び出しは、構造体のメソッドを直接コールする</li>
</ul>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">obj</span><span class="p">.</span><span class="nx">FP</span><span class="p">.</span><span class="nf">method</span><span class="p">()</span> <span class="c1">// ポリモーフィズム有効
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">obj</span><span class="p">.</span><span class="nf">method</span><span class="p">()</span>    <span class="c1">// ポリモーフィズム無効
</span></span></span></code></pre></div>
</div>
<ul>
<li>
<p>up-cast は、メンバの Super クラスのポインタにアクセスすることで実現する</p>
<ul>
<li>インタフェースへの up-cast は、オブジェクトが保持する interface 型を使用する</li>
</ul>
</li>
<li>down-cast は、 interface を型アサーションと、ダウンキャスト用 interface で実現する。</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">ifObj</span> <span class="nx">IF</span> <span class="p">=</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">FP</span> <span class="c1">// インタフェースをセットする
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">super</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">obj</span><span class="p">.</span><span class="nx">super</span> <span class="c1">// アップキャスト
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">(</span><span class="nx">parent</span><span class="p">.</span><span class="nx">FP</span><span class="p">.(</span><span class="nx">SubDownCast</span><span class="p">)).</span><span class="nf">ToSub</span><span class="p">()</span> <span class="c1">// obj を Sub にダウンキャストする
</span></span></span></code></pre></div>
</div>
<ul>
<li>
<p>インタフェースは、 Go の interface をそのまま利用する</p>
<ul>
<li>クラスオブジェクトからインタフェースに up-cast する場合、 interface FP を使用する</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-416" class="outline-3">
<h3 id="headline-416">
シンボル名
</h3>
<div id="outline-text-headline-416" class="outline-text-3">
<p>
LuneScript と go のシンボル名は、次の点で大きく異なる。</p>
<ul>
<li>
<p>名前空間</p>
<ul>
<li>LuneScript は、同一ファイル(モジュール)内</li>
<li>go は、同一ディレクトリ(パッケージ)内</li>
</ul>
</li>
<li>
<p>公開・非公開の制御方法</p>
<ul>
<li>LuneScript は、 pub/pro などで制御する</li>
<li>go は、 シンボルの先頭文字の大文字/小文字で制御する</li>
</ul>
</li>
</ul>
<p>この違いによって次の問題が発生する。</p>
<ul>
<li>LuneScript で異なるファイル FileA.lns, FileB.lns それぞれに
同名のシンボル sym を定義している時、
これを go に変換する際に同じ構成で
FileA.go, FileB.go に同名のシンボル sym を定義すると、
シンボル sym が重複定義エラーとなる。</li>
<li>
<p>LuneScript で小文字で公開定義したシンボルが、 go では非公開になる。</p>
<ul>
<li>LuneScript で大文字で非公開定義したシンボルが、 go では公開になる。</li>
</ul>
</li>
</ul>
<p>この問題に対応するため、次の通りシンボル名を処理する。</p>
<p>
公開・非公開制御対象の関数あるいはクラスのシンボルの先頭にファイル名を付加する。
さらに公開なら G ( GLOBAL の G)、非公開なら l (local の l) を付加する。</p>
<p>
つまり次の LuneScript のソースを go に変換する場合、</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func() {
}
pub class Class {
   let val1:int;
   pub let val2:int;
}</code></pre>
</div>
<p>
LuneScript と go のシンボルの関係は次のようになる。</p>
<table>
<thead>
<tr>
<th>公開/非公開</th>
<th>lns</th>
<th>go</th>
</tr>
</thead>
<tbody>
<tr>
<td>非公開</td>
<td>func</td>
<td>lfile_func</td>
</tr>
<tr>
<td>公開</td>
<td>Class</td>
<td>Gfile_Class</td>
</tr>
<tr>
<td>非公開</td>
<td>val1</td>
<td>lval1</td>
</tr>
<tr>
<td>公開</td>
<td>val2</td>
<td>Gval2</td>
</tr>
</tbody>
</table>
<p>
なお、引数やローカル変数は LuneScript と go とでスコープに違いはないため、
基本的にそのまま変換する。</p>
</div>
</div>
<div id="outline-container-headline-417" class="outline-3">
<h3 id="headline-417">
Lua VM
</h3>
<div id="outline-text-headline-417" class="outline-text-3">
<p>
現状の LuneScript では、 Macro 展開時に Lua VM を使用する。
Go で Lua VM を使用する方法として、次の 2 つがある。</p>
<ul>
<li>Lua を Go に移植した gopher-lua を使用する</li>
<li>liblua を使用する</li>
</ul>
<p>gopher-lua を使用すると Lua VM の扱いが楽になるが、次の制限がある。</p>
<ul>
<li>Lua VM のバージョンが Lua5.1 になる</li>
<li>
<p>liblua と比べると遅い</p>
<ul>
<li>
<p>公式 Wiki(&lt;<a href="https://github.com/yuin/gopher-lua/wiki/Benchmarks">https://github.com/yuin/gopher-lua/wiki/Benchmarks</a>&gt;) の情報によると、
fib(35) の実行時間が次になる。</p>
<dl>
<dt>
lua5.1.4
</dt>
<dd>1.71sec</dd>
<dt>
Gopherlua
</dt>
<dd>5.40sec</dd>
</dl>
</li>
</ul>
</li>
</ul>
<p>上記から、 LuneScript のトランスコンパイラでは liblua を利用する。</p>
<div id="outline-container-headline-418" class="outline-4">
<h4 id="headline-418">
cgo
</h4>
<div id="outline-text-headline-418" class="outline-text-4">
<p>
Go から liblua を利用するため cgo を使う。</p>
<p>
cgo は Go から C 言語のライブラリをコールするためのパッケージ。</p>
<p>
以下のように import &#34;C&#34; の前のコメントに書いた C コードが解析され、
Go からアクセスできるように C パッケージ内に展開される。</p>
<div class="src src-go">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// #include &lt;stdlib.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1">// #cgo CFLAGS: -I/usr/include/lua
</span></span></span><span class="line"><span class="cl"><span class="c1">// #cgo LDFLAGS: -ldl -lm -llua
</span></span></span><span class="line"><span class="cl"><span class="c1">// #include &lt;lauxlib.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1">// #include &lt;lualib.h&gt;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">import</span> <span class="s">&#34;C&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="s">&#34;unsafe&#34;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// lua のコードを実行する
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">lua_runScript</span><span class="p">(</span> <span class="nx">script</span> <span class="kt">string</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kd">var</span> <span class="nx">vm</span> <span class="o">*</span> <span class="nx">C</span><span class="p">.</span><span class="nx">lua_State</span> <span class="p">=</span> <span class="nx">C</span><span class="p">.</span><span class="nf">luaL_newstate</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">vm</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="nx">C</span><span class="p">.</span><span class="nf">lua_close</span><span class="p">(</span> <span class="nx">vm</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">C</span><span class="p">.</span><span class="nf">luaL_openlibs</span><span class="p">(</span> <span class="nx">vm</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">block</span> <span class="o">:=</span> <span class="nx">C</span><span class="p">.</span><span class="nf">CString</span><span class="p">(</span> <span class="nx">script</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="nx">C</span><span class="p">.</span><span class="nf">free</span><span class="p">(</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span> <span class="nx">block</span> <span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="nx">C</span><span class="p">.</span><span class="nf">luaL_loadstring</span><span class="p">(</span> <span class="nx">vm</span><span class="p">,</span> <span class="nx">block</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nx">C</span><span class="p">.</span><span class="nf">lua_pcallk</span><span class="p">(</span> <span class="nx">vm</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">C</span><span class="p">.</span><span class="nx">LUA_MULTRET</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">nil</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="nf">lua_runScript</span><span class="p">(</span> <span class="s">&#34;print( &#39;hello world&#39; )&#34;</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>
<strong>cgo</strong> は #define マクロ関数には対応していないので、
次のようなマクロ定義された関数は、自前で展開して処理を書かなければならない。</p>
<div class="src src-c">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define luaL_dostring(L, s) \
</span></span></span><span class="line"><span class="cl"><span class="cp">	(luaL_loadstring(L, s) || lua_pcall(L, 0, LUA_MULTRET, 0))</span></span></span></code></pre></div>
</div>
<hr>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-go_wasm_ja" class="outline-2">
<h2 id="go_wasm_ja">
<strong>LuneScript の WebAssembly 対応</strong>
</h2>
<div id="outline-text-go_wasm_ja" class="outline-text-2">
<p>
LuneScript で作成したコードを Web ブラウザ上で動作させる方法には、
次の 2 つあります。</p>
<ul>
<li>LuneScript から Lua にトランスコンパイルし、その Lua コードを fengari 等で動かす</li>
<li>LuneScript から go にトランスコンパイルし、その go コードを WebAssemly に変換する</li>
</ul>
<p>ここでは、 go から WebAssemly に変換する方法について説明します。</p>
<div id="outline-container-headline-420" class="outline-3">
<h3 id="headline-420">
go から Web Assemly への変換
</h3>
<div id="outline-text-headline-420" class="outline-text-3">
<p>
go から WebAssemly への変換は、 go の機能を利用します。</p>
<p>
go で WebAssembly を利用する方法の基本的な流れは、
次のオフィシャルドキュメントを参照してください。</p>
<p>
&lt;<a href="https://github.com/golang/go/wiki/WebAssembly">https://github.com/golang/go/wiki/WebAssembly</a>&gt;</p>
<p>
ここでは、 LuneScript 特有の話をします。</p>
<div id="outline-container-headline-421" class="outline-4">
<h4 id="headline-421">
Lua のランタイムは gopherlua を利用する
</h4>
<div id="outline-text-headline-421" class="outline-text-4">
<p>
LuneScript のコードを go のアプリに変換するには、 Lua のランタイムが必要になります。</p>
<p>
LuneScript は、Lua のランタイムとして次の 2 つをサポートしています。</p>
<ul>
<li>オフィシャルな Lua ランタイム</li>
<li>gopherlua</li>
</ul>
<p>ここで、「オフィシャルな Lua ランタイム」は WebAssembly では利用できないため、
gopherlua を利用することになります。</p>
<p>
よって、 go から WebAssembly に変換する場合のコマンドは以下のように
<code class="verbatim">-tags gopherlua</code> を指定することになります。</p>
<pre class="example">
$ GOOS=js GOARCH=wasm go build -tags gopherlua -o main.wasm
</pre>
</div>
</div>
<div id="outline-container-headline-422" class="outline-4">
<h4 id="headline-422">
JavaScript と LuneScript 間の連携動作
</h4>
<div id="outline-text-headline-422" class="outline-text-4">
<p>
JavaScript と LuneScript 間の連携動作は、main() が実行されている間可能です。</p>
<p>
逆に言えば、 JavaScript から非同期に LuneScript と連携動作させるには、
LuneScript の処理を終わらさずに待たせる必要があります。</p>
<p>
この待ち処理を実現するには、次の 2 つの方法があります。</p>
<ul>
<li>go 外部モジュールで処理する</li>
<li>__AsyncItem を利用する  </li>
</ul>
<p>以下で説明します。</p>
<div id="outline-container-headline-423" class="outline-5">
<h5 id="headline-423">
go 外部モジュールで処理する
</h5>
<div id="outline-text-headline-423" class="outline-text-5">
<ul>
<li>go の channel を生成して、その channel からデータの読み出しを行なう。</li>
<li>この処理を go の外部モジュールとして定義し、 LuneScript の module 宣言等で、
そのモジュールを実行する。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-424" class="outline-5">
<h5 id="headline-424">
__AsyncItem を利用する    
</h5>
<div id="outline-text-headline-424" class="outline-text-5">
<ul>
<li>LuneScript の __AsyncItem インタフェースを利用し、 pipe を作成し、その pipe からデータ読み出しを行なう。</li>
<li>__AsyncItem のインタフェースを extend した独自のクラスを定義し、
そのクラスから pipe を作成する。</li>
<li>この pipe の put, get メソッドを利用する。</li>
<li>次のサンプルの loop() が待ち処理で、 notify() が pipe へのデータ書き込み処理です。</li>
<li>この notify() を利用することで、JavaScript から非同期のメッセージを受信できます。</li>
</ul>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">pub class AsyncItem extend (__AsyncItem,Mapping) {
   let val:str {pub};
}

let queue:__pipe&lt;AsyncItem&gt;! = AsyncItem._createPipe( 0 );

fn loop() {
  while! queue {
    while true {
       let! item = queue.get() {
          break;
       };
       print( item.$val );
    }
  }
}
pub fn notify( val:str ) {
   when! queue {
      queue.put( new AsyncItem( val ) );
   }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-425" class="outline-4">
<h4 id="headline-425">
LuneScript 内の非同期処理
</h4>
<div id="outline-text-headline-425" class="outline-text-4">
<p>
現状の WebAssembly では、
LuneScript 内の非同期処理は次が指定された時と同じ動きになります。</p>
<pre class="example">
GOMAXPROCS=1
</pre>
<p>
つまり、いずれかの処理が動作している間は、他の処理は動きません。</p>
<p>
__asyncLock や pipe の待ちなどのタイミングで処理が切り替わります。</p>
<p>
__asyncLock や pipe 以外で、いずれかの処理がブロックすると、
そのブロックを抜けるまでは全体の処理が止まります。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-426" class="outline-3">
<h3 id="headline-426">
tinygo
</h3>
<div id="outline-text-headline-426" class="outline-text-3">
<p>
go から WebAssembly に変換する方法には、
オフィシャルな go を使う方法と、tinygo を使う方法があります。</p>
<p>
tinygo を利用した方が、
WebAssembly のサイズや JavaScript との連携が簡単になるようです。</p>
<p>
しかし、現時点で最新の tinygo v0.22.0 では
LuneScript で利用するパッケージの対応がされていないため、
tinygo を利用できません。</p>
<p>
以上。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-lnstags_ja" class="outline-2">
<h2 id="lnstags_ja">
*lnstags によるタグジャンプ (ソースコードタグシステム) *
</h2>
<div id="outline-text-lnstags_ja" class="outline-text-2">
<p>
LuneScript は、タグジャンプ (ソースコードタグシステム)に対応している。</p>
<div id="outline-container-headline-428" class="outline-3">
<h3 id="headline-428">
タグジャンプ (ソースコードタグシステム) とは
</h3>
<div id="outline-text-headline-428" class="outline-text-3">
<p>
タグジャンプは、ソースコードの以下の情報へのアクセスを提供する。</p>
<ul>
<li>シンボル(クラス、関数、変数 etc..)の <strong>定義位置</strong></li>
<li>シンボル(クラス、関数、変数 etc..)の <strong>参照位置</strong></li>
</ul>
<div id="outline-container-headline-429" class="outline-4">
<h4 id="headline-429">
例
</h4>
<div id="outline-text-headline-429" class="outline-text-4">
<p>
以下に例を示す。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Foo {
   pub fn func() {
   }
}
class Bar {
   pub fn func() {
   }
}
let foo = new Foo();
foo.func();
let bar = new Bar();
bar.func();</code></pre>
</div>
<p>
たとえば、上記のような mini.lns ファイルがあった場合、
Foo クラスの func メソッドの定義位置をリストするには、
次のコマンドを実行する。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ lnstags inq def @mini.Foo.func
</span></span><span class="line"><span class="cl">@mini.Foo.func      2 mini.lns            pub fn func() {</span></span></code></pre></div>
</div>
<p>
Bar クラスの func メソッドの参照位置をリストするには、
次のコマンドを実行する。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ lnstags inq ref @mini.Bar.func
</span></span><span class="line"><span class="cl">@mini.Bar.func     12 mini.lns         bar.func();</span></span></code></pre></div>
</div>
<p>
lnstags コマンドの使用方法についての詳細は後述する。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-430" class="outline-3">
<h3 id="headline-430">
lnstags の特徴
</h3>
<div id="outline-text-headline-430" class="outline-text-3">
<p>
lnstags は一般的なタグジャンプの機能に加え、次の機能を提供する。</p>
<ul>
<li>
<p>変数の値を設定している箇所のリスト</p>
<ul>
<li>値をセットしているのか、参照しているのかを区別していて、
<strong>値をセットしている箇所だけ</strong> をリストできる。</li>
</ul>
</li>
<li>
<p>継承関係の考慮</p>
<ul>
<li>オーバーライドされているメソッドをコールする場合、
ポリモーフィズムによって実際にコールされるメソッドが異なる。</li>
<li>lnstags では、コールされる可能性のあるメソッドを全てリストする。</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-431" class="outline-3">
<h3 id="headline-431">
使い方
</h3>
<div id="outline-text-headline-431" class="outline-text-3">
<p>
lnstags は、次の URL で公開している。</p>
<p>
&lt;<a href="https://github.com/ifritJP/lnstags">https://github.com/ifritJP/lnstags</a>&gt;</p>
<div id="outline-container-headline-432" class="outline-4">
<h4 id="headline-432">
ビルド方法
</h4>
<div id="outline-text-headline-432" class="outline-text-4">
<p>
次の 2 つのビルド方法があります。</p>
<ul>
<li>go install を利用する</li>
<li>リポジトリを close して make する</li>
</ul>
<p>通常は go install で問題ありません。  </p>
<div id="outline-container-headline-433" class="outline-5">
<h5 id="headline-433">
go install 
</h5>
<div id="outline-text-headline-433" class="outline-text-5">
<p>
以下を実行すると、 $GOPATH/bin に lnstags がインストールされます。</p>
<pre class="example">
go install -tags gopherlua github.com/ifritJP/lnstags@latest
</pre>
</div>
</div>
<div id="outline-container-headline-434" class="outline-5">
<h5 id="headline-434">
go でビルドする。
</h5>
<div id="outline-text-headline-434" class="outline-text-5">
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ git clone --depth 1 https://github.com/ifritJP/lnstags
</span></span><span class="line"><span class="cl">$ cd lnstags
</span></span><span class="line"><span class="cl">$ make build ONLY_GO=y</span></span></code></pre></div>
</div>
<p>
上記で lnstags/lnstags が生成されます。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-435" class="outline-4">
<h4 id="headline-435">
ソースコードの解析
</h4>
<div id="outline-text-headline-435" class="outline-text-4">
<p>
ソースコードの解析は、
解析対象のソースコードのプロジェクトディレクトリ上で実行する。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ cd proj  // lune.js を置いてあるディレクトリに移動する
</span></span><span class="line"><span class="cl">$ lnstags init
</span></span><span class="line"><span class="cl">$ lnstags build test/main.lns</span></span></code></pre></div>
</div>
<p>
<strong>lnstags build は、次のどちらかで実行する必要がある。</strong></p>
<ul>
<li>プロジェクトの main となる .lns ファイルを指定する</li>
</ul>
<pre class="example">
$ lnstags build main.lns
</pre>
<ul>
<li><code class="verbatim">lnstags build @-</code> として指定し、stdin に .lns ファイルのパスを 1 行づつ指定する。</li>
</ul>
<pre class="example">
$ find . -iname &#39;*.lns&#39; | lnstags build @-
</pre>
<p>
lnstags は、指定された lns ファイルから import されているモジュールを
辿って全て解析する。</p>
<p>
これにより、多くの場合は main となる .lns ファイルを指定するだけで問題ない。</p>
<p>
後者を使うケースは、
1 つの lns ファイルから全てのモジュールを辿れないケースで利用する。</p>
<p>
<strong>なお現在の lnstags は、差分更新はサポートしていない。</strong></p>
<p>
このため、 build に <strong>@-</strong> を使用する場合、全ての .lns ファイルを指定する必要がある。</p>
<p>
ソースコードの解析結果は、 <strong>lnstags.sqlite3 ファイル</strong> に登録する。</p>
</div>
</div>
<div id="outline-container-headline-436" class="outline-4">
<h4 id="headline-436">
DB の更新
</h4>
<div id="outline-text-headline-436" class="outline-text-4">
<p>
<code class="verbatim">lctags build</code> による解析後にソースコードを変更すると、
DB に登録している情報と実際のソースコードの情報に不整合が生じる。</p>
<p>
DB を更新するには、 <strong>次のいずれか</strong> を実行する。</p>
<ul>
<li><code class="verbatim">lctags build</code> を再度実行する。</li>
<li><code class="verbatim">lctags update</code> を実行する。</li>
</ul>
<pre class="example">
$ lctags update
</pre>
<div id="outline-container-headline-437" class="outline-5">
<h5 id="headline-437">
lctags update
</h5>
<div id="outline-text-headline-437" class="outline-text-5">
<p>
<code class="verbatim">lctags update</code> は、
DB に登録されている lns のソースファルイリストを元に、
情報を更新する。</p>
<p>
<code class="verbatim">lctags build</code> と異なり、解析するソースファイルを指定する必要がない。</p>
<p>
<strong>解析対象の lns ファイルが増減した場合</strong> は、
<code class="verbatim">lctags update</code> ではなく、
<code class="verbatim">lctags build</code> を使用しなければならない。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-438" class="outline-4">
<h4 id="headline-438">
問い合わせ
</h4>
<div id="outline-text-headline-438" class="outline-text-4">
<p>
<code class="verbatim">lnstags build</code> でソースコードを解析した後は、シンボルの情報を問い合わせる。</p>
<p>
問い合わせには、次のパターンがある。</p>
<ul>
<li>inq</li>
<li>inq-at</li>
<li>suffix</li>
</ul>
<div id="outline-container-headline-439" class="outline-5">
<h5 id="headline-439">
inq
</h5>
<div id="outline-text-headline-439" class="outline-text-5">
<p>
inq は、シンボル名を指定して問い合わせを行なう。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Foo {
   pub fn func() {
   }
}
class Bar {
   pub fn func() {
   }
}
let foo = new Foo();
foo.func();
let bar = new Bar();
bar.func();</code></pre>
</div>
<p>
たとえば、上記のような mini.lns ファイルがあった場合、
Foo クラスの func メソッドのシンボル名は次になる。</p>
<pre class="example">
@mini.Foo.func
</pre>
<p>
ここで、 @mini はモジュール名を示し、 mini は mini.lns を指す。
例えば abc/def/ghi.lns の場合、モジュール名は <strong>@abc.@def.@ghi</strong> となる。
<code class="verbatim">Foo.func</code> は、 Foo クラスの func メソッドを指す。</p>
<p>
そして、次のコマンドを実行することで、
@mini.Foo.func の定義位置がリストされる。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ lnstags inq def @mini.Foo.func
</span></span><span class="line"><span class="cl">@mini.Foo.func      2 mini.lns            pub fn func() {</span></span></code></pre></div>
</div>
<p>
このコマンド <code class="verbatim">lnstags inq def</code> の <strong>def</strong> は、 <strong>定義場所</strong> の問い合わせを指定する。</p>
</div>
</div>
<div id="outline-container-headline-440" class="outline-5">
<h5 id="headline-440">
問い合わせモード
</h5>
<div id="outline-text-headline-440" class="outline-text-5">
<p>
問い合わせの種類は次がある。</p>
<table>
<thead>
<tr>
<th>オプション</th>
<th>動作</th>
</tr>
</thead>
<tbody>
<tr>
<td>def</td>
<td>定義位置</td>
</tr>
<tr>
<td>ref</td>
<td>参照位置</td>
</tr>
<tr>
<td>set</td>
<td>設定位置</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="outline-container-headline-441" class="outline-5">
<h5 id="headline-441">
inq-at
</h5>
<div id="outline-text-headline-441" class="outline-text-5">
<p>
問い合わせしたいシンボルの完全限定名が判っている場合は inq コマンドが利用できるが、
完全限定名を調べるのが困難だったり面倒だったりする。</p>
<p>
そこで、ソースの所定位置のシンボルについて問い合わせを行なうのが <strong>inq-at</strong> である。</p>
<p>
以下のソースがある時に、
10 行目の 5 列目にある <code class="verbatim">foo.func()</code> の定義場所を問合せる場合、</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Foo {
   pub fn func() {
   }
}
class Bar {
   pub fn func() {
   }
}
let foo = new Foo();
foo.func();
let bar = new Bar();
bar.func();</code></pre>
</div>
<p>
次のコマンドを実行する。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ lnstags inq-at def mini.lns 10 5
</span></span><span class="line"><span class="cl">@mini.Foo.func      2 mini.lns            pub fn func() {</span></span></code></pre></div>
</div>
<p>
これにより、指定した場所にあるシンボルについての問い合わせが行なわれる。</p>
<p>
上記の場合、 mini.lns 10 5 にある <code class="verbatim">foo.func</code> の完全限定名が、
@mini.Foo.func であることを認識し、
それについての <strong>def</strong> 問い合わせを行なっている。</p>
<p>
なお、inq-at を利用する場合、
<strong>指定の lns ファイルがエラー無くビルドできなければならない。</strong></p>
<p>
また、指定の lns ファイルの AST を解析するため、時間がかかる。</p>
</div>
</div>
<div id="outline-container-headline-442" class="outline-5">
<h5 id="headline-442">
suffix
</h5>
<div id="outline-text-headline-442" class="outline-text-5">
<p>
inq-at は lns ファイルの位置を指定して完全限定名を取得するが、
suffix はシンボル名の後方一致で完全限定名のリストを取得する。</p>
<p>
例えば func に後方一致する完全限定名のリストを表示するには以下を実行する。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">$ lnstags suffix func
</span></span><span class="line"><span class="cl">@mini.Foo.func
</span></span><span class="line"><span class="cl">@mini.Bar.func</span></span></code></pre></div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-443" class="outline-3">
<h3 id="headline-443">
emacs から利用する場合
</h3>
<div id="outline-text-headline-443" class="outline-text-3">
<p>
lisp/lnstags-conf.el をロードする。</p>
<p>
キーバインドは次の通り。</p>
<table>
<thead>
<tr>
<th>キー</th>
<th>操作</th>
</tr>
</thead>
<tbody>
<tr>
<td>M-t</td>
<td>カーソル位置のシンボルの <strong>定義位置</strong> にジャンプ</td>
</tr>
<tr>
<td>M-r</td>
<td>カーソル位置のシンボルの <strong>参照位置</strong> にジャンプ</td>
</tr>
<tr>
<td>M-s</td>
<td>カーソル位置のシンボルの <strong>設定位置</strong> にジャンプ</td>
</tr>
<tr>
<td>M-m</td>
<td>タグジャンプの履歴</td>
</tr>
<tr>
<td>C-t</td>
<td>ジャンプ元に戻る</td>
</tr>
</tbody>
</table>
<p>
M-t, M-r, M-s については、完全限定名を得るために suffix 問い合わせを実行し、
シンボルに一致する完全限定名をリストし、
選択された完全限定名についての inq 問い合わせを行なう。</p>
<p>
なお、M-t, M-r, M-s にプレフィックス C-u を付けることで、
カーソル位置の inq-at 問い合わせを行なう。</p>
</div>
</div>
<div id="outline-container-headline-444" class="outline-3">
<h3 id="headline-444">
解析時間
</h3>
<div id="outline-text-headline-444" class="outline-text-3">
<p>
lnstags は、 LuneScript トランスコンパイラの AST 解析部を利用して、
解析対象ソースコード内のシンボル情報を DB に登録している。</p>
<p>
このため DB 登録に掛る時間は、
Lns ファイルの <strong>トランスコンパイル時間とほぼ等価</strong> である。</p>
<p>
LuneScript のセルフホストコードを解析しても、 10 秒弱で終了する。</p>
<p>
ソースコードタグシステムの一番重い AST 解析を、
LuneScript のモジュールで行うことで、
lnstags 自体のコードは 2000 行強のシンプルな構成になっている。 (2021現在)</p>
<p>
なお、lnstags 自体も LuneScript で開発している。    </p>
<p>
前述している通り、
lnstags は DB の差分をサポートしていない。
これは、 LuneScript のプロジェクトでそこまで時間のかかる大規模のものは現状ないと
判断しているためである。</p>
<p>
もしも、大規模プロジェクトで LuneScript を利用しているのであれば、
参考までに連絡して欲しい。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-reason_ja" class="outline-2">
<h2 id="reason_ja">
<strong>Lua のトランスコンパイラ LuneScript を開発した理由</strong>
</h2>
<div id="outline-text-reason_ja" class="outline-text-2">
<p>
Lua は軽量で、かつ実行パフォーマンスの高い言語である。
Lua の 知名度は、同じスクリプト系言語の Ruby や Python, JavaScript 等とは
比べるまでもなく低いが、
システムの拡張に利用できる言語としては、
最もメジャーで組み込み易い言語の一つと言えるだろう。
実際、 Lua を組み込んでいるシステムは多く存在している。</p>
<p>
また実行性能においても、スクリプト言語としては高速な部類に入る。
DSP のような処理をさせなければ、
システムパフォーマンスのボトルネックになるようなことは少ないだろう。</p>
<p>
私自身、 いくつかのソフト（趣味、業務ともに）を Lua を利用して開発した経験があり、
よく使う言語の１つである。</p>
<div id="outline-container-headline-446" class="outline-3">
<h3 id="headline-446">
Lua のトランスコンパイラ LuneScript を開発した理由
</h3>
<div id="outline-text-headline-446" class="outline-text-3">
<p>
Lua は私の良く使う言語の 1 つである。
しかし、次の理由から Lua のコードを直接書くのは止めて、
トランスコンパイラ LuneScript を使って開発する事を考えるようになった。</p>
<ul>
<li>楽して安全に書きたい</li>
<li>
<p>Lua には動的型付け言語特有の問題がある</p>
<ul>
<li>静的なエラーチェックが出来ない</li>
<li>他人のコードの内容を把握し難い</li>
<li>メンテナンスや機能追加、リファクタリングのリスクが大きい</li>
<li>コーディング時の補完がイケてない</li>
<li>テーブル内のフィールドアクセス制御が出来ない</li>
</ul>
</li>
<li>
<p>Lua の機能に不満がある  </p>
<ul>
<li>nil安全でない </li>
<li>マクロがない</li>
</ul>
</li>
<li>Lua の特徴である組込みやさと実行性能の高さには代替手段が少ない</li>
<li>既に数多くのシステムで Lua を利用している</li>
</ul>
<p>以降で、それぞれについて説明する。</p>
<div id="outline-container-headline-447" class="outline-4">
<h4 id="headline-447">
楽して安全に書きたい
</h4>
<div id="outline-text-headline-447" class="outline-text-4">
<p>
Ruby のまつもとゆきひろ氏は、Ruby に楽しさを求めている。</p>
<p>
私は　LuneScriptに楽しさは求めていない。
いや、「楽しさ」を求める以上に「楽」をしたいと考えている。</p>
<p>
もちろん、なにをするにも楽しい方がいい。
私自身、ソフトウェア開発に楽しさを感じているからこそ、
プライベートな時間に趣味（無償）のソフトウェア開発をやっている。</p>
<p>
今は営業の出来ない純粋なソフト屋だって、
クラウドワークスの様なサービスを使ってギャランティーを受けられる仕事を
取ってくることができる時代だ。
そんな時代に、プライベートな時間を潰して無償のソフトウェア開発をする動機なんて、
「楽しい」以外の何ものでもない。</p>
<p>
ただ、ソフトウェア開発自体は楽しいが、変なバグ取りやテストコード作成は楽しくない。
では何故このような楽しくない作業が必要なのかと言えば、
ソフトウェア開発にはバグが入り込み易く、
そのバグを取り除いてやらないとまともにソフトが動かないからだ。</p>
<p>
繰り返すが、この作業は楽しくない。
人によっては楽しめるかもしれないが、少なくとも私にとっては苦行だ。
まぁ、「やりとげた」という達成感は無くはないが、
仕事ならともかく、わざわざプライベートな時間を潰してまでやりたくない。</p>
<p>
そういった楽しくない作業を出来るだけやらずに、
楽して安全なソフトウェア開発をしたいのだ。</p>
<p>
Perl の作者 Larry Wall 氏は
プログラマーの三大美徳として「怠惰 、短気、傲慢」をあげている。
「楽して安全なソフトウェア開発」は、これとかなり似ていると思う。</p>
<p>
Lua には、楽して安全なソフトウェア開発を行なう仕組みが提供されていない。
提供されていないなら、自分で作れば良いだけだ。</p>
<p>
私は、楽をするための労力は惜しまない。</p>
<p>
これが、私が LuneScript を開発する一番の理由だ。</p>
</div>
</div>
<div id="outline-container-headline-448" class="outline-4">
<h4 id="headline-448">
動的型付け言語特有の問題
</h4>
<div id="outline-text-headline-448" class="outline-text-4">
<p>
私は動的型付け言語を否定している訳ではない。</p>
<p>
私自身、動的型付け言語で処理を書く事は良くあるし、
100 行にも満たない様な簡単な処理を書く時に
静的型付け言語なんて使いたいとは思わない。</p>
<p>
ここで動的型付け言語を問題としているのは、
個人が一人で作成して、一人でメンテナンスするスクリプトではなく、
不特定多数が開発する可能性のあるスクリプトに
動的型付け言語を利用した場合に、
問題となり易いことを挙げている。</p>
<div id="outline-container-headline-449" class="outline-5">
<h5 id="headline-449">
静的なエラーチェックが出来ない
</h5>
<div id="outline-text-headline-449" class="outline-text-5">
<p>
人間は間違える。</p>
<p>
フルタイムでコーディングしているソフトウェアエンジニアなら、
引数に間違った型のデータを渡した経験は両手・両足では数え切れない程度は有るだろう。
よくある間違いとしては、
数字文字列の入力を parse した結果をある関数に渡す時、
その関数は数値型の値を求めているのに、
parse したそのままの文字列データを渡してしまう等、
例を考えれば他にも色々と思い浮かぶ。</p>
<p>
複数メンバーで開発する際は、コミュニケーションミス等で、間違いが発生する確率が更に高まる。</p>
<p>
静的型付け言語であれば、
コンパイル時、あるいはイマドキはコーディング時に
型不一致エラーとなって間違いに気が付く。</p>
<p>
しかし動的型付け言語では、
実際に動かさないと分からない。
また、場合によっては単純に動かしただけでは発生せず、
特定のパスや特定のタイミングでしか発生しない、と言う事すらある。</p>
<p>
単純なミスが後々になって重大な問題の原因となる、
そしてその原因にたどり着く為に多大なコストが必要になることはよくある。</p>
<p>
「テストでカバー出来る」という考えもあると思うが、テストを書くのもタダではない。
最初に書いたが、私はテスト作成を楽しめない。
テストを書かずにコンパイラが保証してくれるなら、私はそちらの方を取る。</p>
<p>
動的型付け言語で書いたコードに対しても、ある程度は静的チェックを行なうことは可能だ。
しかし、それは静的型付け言語のものに比べれば、
とてもコストの掛かる事であり、精度も不十分である。</p>
<p>
静的型付け言語であれば、少なくとも型に関連するミスは、
確実に静的に解析することが出来る。</p>
<p>
もちろん、c の void * や java の Object の様な何でもありな型にしてしまった場合や、
強制的な型変換を使用した場合などは解析不能だが。</p>
<p>
私は、将来的に、ディープラーニング等の技術によって静的解析技術が進化し、
もっと楽してソフトウェア開発が出来るようになると考えている。
そして、そのような開発をサポートするのは、動的型付け言語ではなく、
静的型付け言語であると思う。</p>
<p>
まぁ、もっと違うパラダイムなのかもしれないが。</p>
</div>
</div>
<div id="outline-container-headline-450" class="outline-5">
<h5 id="headline-450">
他人のコードの内容を把握し難い
</h5>
<div id="outline-text-headline-450" class="outline-text-5">
<p>
他人のコードは、自分が書いたコードに比べれば、内容を把握し難い。
コレは当然のことだ。</p>
<p>
ここで言いたいのは、そういう事ではない。</p>
<p>
また、インデントが揃ってないとか、
コーディング規約が守られていないとか、
そういうレベルの低い事でもない。</p>
<p>
どんなに著名なエンジニアが書こうとも、
ソレが動的型付け言語で書かれていれば、
静的型付け言語で書かれたコードに比べれば把握し難い。</p>
<p>
何故ならば、プログラムの重要なファクターであるデータの型情報が、
ほとんど書かれていないのだから。
もしも型情報などは大して重要ではないと言うエンジニアがいるならば、
「アルゴリズムとデータ構造」の単位を取り直した方が良い。</p>
<p>
なお、シンボル名から型を予想することは出来る。
また、そのようにシンボル名は付けるべきだ。</p>
<p>
しかし、ソレはあくまでも予想であり、事実ではない。
私はソフトウェア開発をする時に、推理ゲームに頼って開発したいとは思わない。</p>
<p>
また、コメントあるいはドキュメントに型情報を記載しているからそれを確認すれば良い、
と言う意見もあるだろう。
しかし、コメントやドキュメントと実装が乖離している事は良くあるし、
コードをひと目見れば理解出来るのと、コード+αを見ないと分からないのであれば、
私はコードをひと目見れば理解出来る方が良い。</p>
<p>
なんども言うが私は楽をしたいのだ。</p>
</div>
</div>
<div id="outline-container-headline-451" class="outline-5">
<h5 id="headline-451">
メンテナンスや機能追加、リファクタリングのリスクが大きい
</h5>
<div id="outline-text-headline-451" class="outline-text-5">
<p>
どんなコードでも、一度作ったらそれっきり手を加えない、なんて事は滅多にない。</p>
<p>
動かしている OS が変わったとか、機能追加が必要になったとか、
潜在バグが見つかったとか理由は様々だが、
既存のコードに手を加える機会は少なくない。</p>
<p>
そうした既存のコードに手を加える時に、
動的型付け言語は静的型付け言語に比べるとリスクが大きい。</p>
<p>
ここでも、「テストをしっかり書いておけば問題無い」と言う意見もあるだろう。
しかし、ソレは半分正解だが半分ハズレだ。</p>
<p>
「手を加える」と言うことは、「振る舞いが変わる」と同義だ。
変化の度合いの違いはあっても、変わる事には違いはない。
そして振る舞い変わってしまうと、テストがあっても安心とは言えなくなる。</p>
<p>
何故ならば、テストは振る舞いが正しい事を確認するためのもので、
その振る舞いが変わるのだから、テストもそのままでは使えなくなるからだ。
もちろん、すべてが使えなくなる訳ではなく、振る舞いが変わるところだけに限定は出来る。</p>
<p>
さて、本題の動的型付け言語と静的型付け言語の話に戻そう。</p>
<p>
どうして動的型付け言語だと、静的型付け言語に比べて、
既存のコードに手を加える時のリスクが大きいのか。
それは、手を加えることによって影響する箇所を
抜け漏れなく修正する事が難しいからだ。</p>
<p>
静的型付け言語であれば、コンパイルさえ通せば、
ほぼ修正完了と言って良い。
一方、動的型付け言語では、全てを修正した後、
いざテストを動かそうとしても、修正漏れによるエラーでまともに動かない、と言うことが多い。
エラーを一つ一つ潰してていき、ようやく完了となる。</p>
<p>
コンパイルエラーの対応と、テストのエラーを対応するのにどちらが時間がかかるか、
と考えれば、それは圧倒的にテストのエラーだ。
コンパイルエラーであれば、コンパイルエラーの行を修正すれば済むが、
テストのエラーは、エラーの原因を特定する作業が余計に追加となる。
更に、既存のテスト自体に漏れがあれば、修正漏れ自体を発見できない可能性もある。</p>
<p>
また、手を加える作業者が、そのモジュール作成者本人であればまだ良いが、
全くの別人が対応することも珍しくない。
その場合は、先程挙げた「他人のコードの内容を把握し難い」との相乗効果で
更にリスクが高まる。</p>
<p>
LuneScript 開発中、何度も設計変更を行ったが、
もしこれを動的型付け言語で行っていたかと想像すると寒気がするレベルだ。</p>
</div>
</div>
<div id="outline-container-headline-452" class="outline-5">
<h5 id="headline-452">
コーディング時の補完がイケてない
</h5>
<div id="outline-text-headline-452" class="outline-text-5">
<p>
コーディングで楽をするには、まともな補完機能が必須である。</p>
<p>
最近は動的型付け言語でも、かなり頑張ってコーディングの補完機能が動作している。
しかし、その補完機能がリストする候補にガッカリした経験を持っていないだろうか。
あるいは、そもそもリストされるべきものが、全くリストされない事は無いだろうか。</p>
<p>
動的型付け言語の補完はかなり難しい。
何故ならば補完機能は型情報をもとに補完候補を認識するが、
動的型付け言語では、それを静的に認識するのが困難だからだ。</p>
<p>
静的型付け言語であれば、型情報が静的に決定できるので、
型関連の補完は正確に実現可能た。</p>
<p>
もちろん、 LuneScript も補完機能を提供している。</p>
<p>
詳しくは次の記事を参照のこと。</p>
<p>
<a href="#completion">#completion</a></p>
</div>
</div>
<div id="outline-container-headline-453" class="outline-5">
<h5 id="headline-453">
テーブル内のフィールドアクセス制御が出来ない
</h5>
<div id="outline-text-headline-453" class="outline-text-5">
<p>
アクセス制御は重要である。</p>
<p>
どのデータ・関数をアクセスしても大丈夫かを明示できるからだ。</p>
<p>
設計時の大前提として、外部から使用可能な関数、データを公開し、
外部から使用されると動作を保証できない関数、データを非公開とするのが常識だ。</p>
<p>
しかし、 Lua ではテーブルのフィールドに対してはこれが出来ない。</p>
<p>
もしかしたら、 metatable を駆使すれば動的な制御は可能かもしれないが、
少なくとも静的な制御は出来ない。</p>
<p>
何度も言うが、動的にエラーが検知できるのは
エラーが検知できるだけマシというだけで、
静的にエラーが検出できることに比べれば、圧倒的に不便である。</p>
<p>
アクセス制限を持つ言語でも、
リフレクションの機能を使うと非公開としていた関数・データにアクセスできる場合もあるが、
これは特に問題はないと考える。</p>
<p>
何故ならアクセス制御は、そのモジュール設計者の意図を明示することで、
別の人間がそのモジュールを利用する時にその意図を理解せずにアクセスした場合、
そのアクセスは設計者の意図からはずれていることを報せることが目的だと、
私は考えているからである。</p>
<p>
特にテストコードを書く場合は、非公開関数・データにアクセスできることが
求められることがあるため、非公開関数・データにアクセスする手段があること自体は、
問題ではない。</p>
<p>
問題なのはそういった制御がなく、全てアクセス可能になってしまっていることである。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-454" class="outline-4">
<h4 id="headline-454">
Luaの機能に不満がある
</h4>
<div id="outline-text-headline-454" class="outline-text-4">
<p>
Lua はコンパクトでパワフルな言語であるが、
素の Lua ではサポートされていない機能も多くある。</p>
<p>
トランスコンパイラは、Lua に手を加えずに、
素の Lua ではサポートされていない機能をサポートすることも
目的の一つに開発している。</p>
<div id="outline-container-headline-455" class="outline-5">
<h5 id="headline-455">
nil安全でない
</h5>
<div id="outline-text-headline-455" class="outline-text-5">
<p>
Lua の nil は便利な値ではあるが、動的エラーの原因にもなる。
多くのエンジニアは、この nil 関連のエラーに悩まされている。</p>
<p>
その問題を解決するのが nil 安全だ。</p>
<p>
現在のプログラミングで無くてはならない多くの機能は、
Lisp の時代からすでに実現されている。
例えば、GC やラムダ式や、クロージャ等は、数十年前からあるものだ。</p>
<p>
つまり、その時代からほとんど進化していないと言える。</p>
<p>
「ほとんど進化していない」というのは、「多少進化している」ということでもあり、
その進化の一つに nil 安全は含めて良いだろう。それ程重要なものだ。</p>
<p>
しかし、 Lua には nil 安全がサポートされておらず、
これはイマドキの言語としては、かなりの減点対象と言って良い。</p>
<p>
なお、話は逸れるが、
Rust はライフタイムと所有権という概念で nil(null) の危険性に対応している。
初めてこのアプローチを見た時「こんなやり型があったのか」と、とても関心した。</p>
<p>
さらに Rust はライフタイムと所有権によって、 nil 安全だけでなく、
メモリ管理やデータアクセス競合など様々な問題を解決している。</p>
<p>
Rust を触れたことがないのであれば、
是非ライフタイムと所有権について確認してもらいたい。</p>
<p>
閑話休題。</p>
<p>
LuneScript では、
nil を取り得る型 nilable と、
nil を取り得ない 非 nilable を別の型として管理することで、
意図しないタイミングで nil エラーが発生することを防止している。</p>
<p>
また、 nilable から 非 nilable 型への変換の unwrap 処理、
多階層の nilable データに楽にアクセスするための nil 条件演算子をサポートすることで、
nil エラーの対応を楽にかつ安全に対応できるようにしている。</p>
</div>
</div>
<div id="outline-container-headline-456" class="outline-5">
<h5 id="headline-456">
マクロがない
</h5>
<div id="outline-text-headline-456" class="outline-text-5">
<p>
マクロといえば、 Lisp が非常に強力なマクロを持っていて、
マクロをもつ言語の代表格と言って良いだろう。
Lisp の魅力の根底を支えているものこそマクロだと言っても過言ではない。</p>
<p>
しかし、比較的新しい言語は、マクロをサポートしていないものが多い気がする。</p>
<p>
C 言語ですら「なんちゃってマクロ」を持っているのに、何故だろうか？</p>
<p>
まぁ、言語自体がマクロを持っていなくても、
なんらかのデータからコードを自動生成するスクリプトを別途エンジニアが作成すれば、
マクロは不要だと言えなくもないかもしれない。</p>
<p>
ただ、そうすると「なんらかのデータ」や、「自動生成するスクリプト」が
氾濫することになってしまう。</p>
<p>
そのようなことにならないようにするためにも、マクロは必要だと考える。</p>
<p>
とはいえ、Lisp ほどの高機能なマクロは実装が難しく、
使用する側もそれなりの学習が必要である。</p>
<p>
LuneScript では、実装が簡単で、かつ使用する側の学習に負担がなく、
誰でも簡単に使えて効果のあるマクロを用意した。</p>
<p>
LuneScript のセルフホスティングでもマクロを使用しているが、
やはりマクロはプログラム言語には無くてはならないものだと改めて感じている。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-457" class="outline-4">
<h4 id="headline-457">
Lua の特徴である組込みやさと実行性能の高さには代替手段が少ない
</h4>
<div id="outline-text-headline-457" class="outline-text-4">
<p>
前述している通り、Lua はシステムに組込むには最も扱い易い言語の一つである。</p>
<p>
特にそのコンパクトさや、C の標準関数のみでコンパイル可能という特徴は、
組込みには非常に有用である。</p>
<p>
他にも組込みを意識した言語はいくつかあるが、
組込みという条件で見た場合、Lua を越える言語を私は知らない。</p>
</div>
</div>
<div id="outline-container-headline-458" class="outline-4">
<h4 id="headline-458">
既に数多くのシステムで Lua を利用している
</h4>
<div id="outline-text-headline-458" class="outline-text-4">
<p>
Lua を組み込んでいるシステムは多く存在する。</p>
<p>
一度システムに組込まれれば、
そのシステムが生きている限り余程の事がなければ、その Lua は生き続ける。</p>
<p>
ちょっと気にいらないからといって、変えられるものではない。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-459" class="outline-3">
<h3 id="headline-459">
最後に
</h3>
<div id="outline-text-headline-459" class="outline-text-3">
<p>
LuneScript は、Lua の欠点を補うべく開発している。</p>
<p>
これは、Lua が使えない言語だからではなく、
Lua の欠点を放置して他の言語に浮気するには惜しい言語だからだ。</p>
<p>
もし今後、組込み言語を検討する機会があれば、
Lua には LuneScript があることも検討材料にして欲しい。</p>
<p>
何度も言うが、Lua は軽量で、かつ実行パフォーマンスの高い言語である。
そして、Lua には LuneScript という選択肢もあることを覚えておいて欲しい。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-recommend_ja" class="outline-2">
<h2 id="recommend_ja">
<strong>トランスコンパイラ開発のすゝめ</strong>
</h2>
<div id="outline-text-recommend_ja" class="outline-text-2">
<p>
LuneScript 入門のアドベントカレンダー最後の記事は、
これまでとは趣向を変えてトランスコンパイラ開発そのものについて扱っていきます。</p>
<div id="outline-container-headline-461" class="outline-3">
<h3 id="headline-461">
トランスコンパイラ開発をすゝめる理由
</h3>
<div id="outline-text-headline-461" class="outline-text-3">
<p>
私は LuneScript というトランスコンパイラを開発しています。</p>
<p>
この開発を通して、エンジニアとして良い経験が出来たと感じています。</p>
<p>
なお、LuneScript を開発した理由については次の記事に書いています。</p>
<p>
<a href="#reason">#reason</a></p>
<p>
私は次の理由からトランスコンパイラ開発を
多くの方に経験して欲しいと思い、この記事を書くことにしました。</p>
<ul>
<li>現状に対する不満を建設的に解決できる</li>
<li>トレンドの技術を確認できる</li>
<li>コーディングルールを矯正できる  </li>
</ul>
<p>以降では、上記の各項目を説明していきます。</p>
<div id="outline-container-headline-462" class="outline-4">
<h4 id="headline-462">
現状に対する不満を建設的に解決できる
</h4>
<div id="outline-text-headline-462" class="outline-text-4">
<p>
皆さんは、今のソフトウェア開発に対して不満を持っていませんか？</p>
<ul>
<li>上司が気にいらないとか、</li>
<li>開発 PC の性能がショボいとか、</li>
<li>給料が安いとか、</li>
<li>残業が多いとか、</li>
</ul>
<p>私が言っている「不満」は、
上記のソフトウェア開発を取り巻く「現実社会への不満」では <strong>なく</strong> 、</p>
<p>
ソフトウェア開発を行う上で、
頭の中にあるアイデアを実現するのに</p>
<ul>
<li>言語仕様上バグり易いとか、</li>
<li>もの凄く手間のかかる面倒な書き方しか出来ないとか、</li>
<li>実現するために必要なユーティリティ的なものを一から作らなければならず、
本来作りたいものに辿り着く前に時間が掛り過ぎるとか、</li>
<li>そもそも言語仕様的に実現できないとか、</li>
</ul>
<p>そういった、プログラム言語に対する不満です。</p>
<p>
そのような不満がある人で、
その不満を解決するための具体的なアイデアがある人には、
トランスコンパイラを開発することを薦めます。</p>
<p>
私自身、トランスコンパイラを開発しようと思った一番の理由はこのためです。</p>
<p>
「無いなら自分で作れば良い」</p>
<p>
アイデアをソフトウェアで実現出来る能力を持っているからこそ
「ソフトウェアエンジニア」ではないでしょうか？</p>
<div id="outline-container-headline-463" class="outline-5">
<h5 id="headline-463">
「コンパイラ」ではなく「トランスコンパイラ」である理由
</h5>
<div id="outline-text-headline-463" class="outline-text-5">
<p>
『なんで「コンパイラ」じゃなくて「トランスコンパイラ」なの？』
と疑問に思う方もいるかもしれません。</p>
<p>
それは、「トランスコンパイラ」の方が「コンパイラ」を作りよりも
技術的なハードルが低いためです。
LLVM の登場で、以前と比べればコンパイラ開発のハードルは下っているとは思いますが、
それでもトランスコンパイラの方がまだまだハードルは低いです。</p>
<p>
特に、コンパイルした後のコードにバグがあった時の「原因追求コスト」は、
トランスコンパイラの方が圧倒的に低いです。</p>
<p>
コンパイラを作ること自体が目的であればそれでも良いとは思いますが、
コンパイラを作ること自体は手段であり、
あくまでも目的は「プログラム言語に対する不満」を解決することです。</p>
<p>
出来るだけコストを掛けずに実現できる方が良いでしょう。</p>
<p>
それに、「プログラム言語に対する不満」の多くは、
トランスコンパイラで解決できることがほとんどです。</p>
<p>
もちろん「コンパイル時間をもっと短くしたい」というような不満には、
コンパイラを自前で開発しなければならないと思いますが、
それ以外のほとんど不満はトランスコンパイラで解決できるでしょう。</p>
<p>
最終的なゴールが、コンパイラを作ることであったとしても、</p>
<ul>
<li>まずはトランスコンパイラを作成し、</li>
<li>不満を解決できていることや、言語としての使い易さを実証し、</li>
<li>そのトランスコンパイラを使うことが有益であることが確認でき、</li>
<li>その後、直接ネイティブへのコンパイルが必要になってから</li>
</ul>
<p>最終的にコンパイラを開発するのが、効率の良い方法と言えるでしょう。</p>
</div>
</div>
<div id="outline-container-headline-464" class="outline-5">
<h5 id="headline-464">
「インタプリタ」ではなく「トランスコンパイラ」である理由
</h5>
<div id="outline-text-headline-464" class="outline-text-5">
<p>
「コンパイラ」ではない理由は上述しました。</p>
<p>
ここでは、「インタプリタ」ではない理由を説明します。</p>
<p>
と、言っても理由は「コンパイラ」の時と変らずに、
「インタプリタ」よりも「ハードルが低い」からです。</p>
<p>
インタプリタを作るのは、コンパイラよりはハードルが低いです。
私自身、簡易的なインタプリタは何度か作った経験があります。</p>
<p>
しかし、実用的なインタプリタとなると話は別です。
実用的なインタプリタとなると、
開発工数的な問題と、実行性能的な問題があります。
コンパイラの時にも書きましたが、
「プログラム言語に対する不満」を解決するのが目的なので、
それ以外のことは一旦考えないでおきましょう。</p>
<p>
今は実用的なインタプリタ型の言語(スクリプト言語)が世の中にいくつもあります。
わざわざ自前で作る必要はないでしょう。</p>
</div>
</div>
<div id="outline-container-headline-465" class="outline-5">
<h5 id="headline-465">
出力結果が分かり易い
</h5>
<div id="outline-text-headline-465" class="outline-text-5">
<p>
コンパイラと比べてトランスコンパイラの方が良いこととして、
「トランスコンパイラの出力コードは多くの人にとって分かり易い」ことが
挙げられます。</p>
<p>
コンパイラが出力した「ネイティブコード」と、
トランスコンパイラが出力した「とある言語のコード」、
どちらが分かり易いかと言えば、「とある言語のコード」の方が分かり易いのは
誰もが認めるところでしょう。</p>
<p>
「じゃぁなんで分かり易い方が良いんだ？」というと、
導入リスクがそれだけ低いということです。</p>
<p>
新しい技術をプロジェクトに導入する際、
それが「安全」かどうかを判断する必要があります。</p>
<p>
単に「安全」と言っても、色々な観点があります。</p>
<ul>
<li>ウイルス的なものが入り込んでいないことを保証する「情報セキュリティ」</li>
<li>海外に輸出可能か、「外為法」の対象かどうか</li>
<li>ライセンス的に問題ないか。 
そのコンパイラの作者が作成した部分のライセンスは問題なくても、
作者が意図せずに使用しているコードにライセンス上の問題がないか</li>
</ul>
<p>他にも新しいものを導入するには、幾つかの安全性をクリアする必要があります。</p>
<p>
これらの安全性をクリアする際、その対象技術の分かり易さは非常に重要です。</p>
<p>
コンパイラの場合、
生成されたネイティブコードを調べるのは現実的ではないため、
コンパイラのコードを調査して安全性を確認することになります。</p>
<p>
一方トランスコンパイラは、
ライセンスと変換後のコードを調べれば良いだけです。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-466" class="outline-4">
<h4 id="headline-466">
トレンドの技術を確認できる
</h4>
<div id="outline-text-headline-466" class="outline-text-4">
<p>
せっかく新しいトランスコンパイラを開発するのであれば、
できるだけ使い勝手の良いものを作ろうと思うのがエンジニアの性分でしょう。</p>
<p>
であれば、さまざまな言語の特徴を調査して、
良いものを取り込むのが常套手段です。</p>
<p>
私も LuneScript を開発するにあたり、なるべく多くの言語を調査し、
さまざまな機能を取り込んだつもりです。</p>
<p>
さまざまな言語の特徴を知ることに何の意味があるのか？
例えば普段 C 言語のプロジェクトしか関わりのないエンジニアが
Go や swift の特徴を知ることに意味があるのか？
そのようなことを疑問に思う人もいると思います。</p>
<p>
普段から Qiita 等のサイトで自ら新しい情報を収集しているような人ならば、
そのようなことを疑問に持つことはないと思いますが、
そうでない場合は疑問に思う人は少なくないでしょう。</p>
<p>
私は、例え普段 C 言語のプロジェクトしか関わりのないエンジニアであっても、
イマドキの言語の特徴は把握しておくべきだと思います。</p>
<p>
それは、イマドキの言語の特徴そのものは C 言語では使えないとしても、
考え方や、エッセンスなどは C 言語でも導入可能だからです。</p>
<p>
例えば、関数型言語の考え方自体は、
Haskell を使わなくても C 言語でも実現できます。</p>
<p>
もちろん、C 言語の syntax だと書き難いモノや、
C 言語の仕様上実現できないモノなども存在します。</p>
<p>
しかし、関数型言語の考え方自体を知った上で、敢えて C 言語らしく書くことと、
C 言語しか知らないからいつも通りに C 言語で書くことは、違います。</p>
<p>
また、イマドキの言語の特徴をトランスコンパイラの機能として取り込むには、
単にイマドキの言語を使うよりも、より深い理解が可能になります。
というか深い理解がなければ取り込むことは出来ません。</p>
<p>
このように、イマドキの言語の特徴の理解を深めるためにも
トランスコンパイラの開発は経験として良いものだと言えます。</p>
</div>
</div>
<div id="outline-container-headline-467" class="outline-4">
<h4 id="headline-467">
コーディングルールを矯正できる  
</h4>
<div id="outline-text-headline-467" class="outline-text-4">
<p>
これは、いままで挙げた内容と少し方向性が違いますが、
自分としては結構重要だと思った点です。</p>
<p>
皆さん、コーディングする際、
「こう書きたい」「こう書くべき」というような理想の書き方を持っていると思います。</p>
<p>
トランスコンパイラを開発するということは、
コーディングルールを言語レベルで矯正(強制)できる、ということでもあります。</p>
<p>
この説明だと「どういうこと？」と疑問に持つ方も多いと思いますが、
python の「インデントによるブロック」と言えば通じると思います。</p>
<p>
python は、
ブロックをキーワードや区切り記号ではなく、インデントによって表現します。</p>
<p>
つまり、「ブロックはインデントすべき」ということを
コーディングルールで縛るのではなく、
Python では「インデントが揃っていないとブロックとして扱わねぇよ」と
言語レベルで矯正(強制)している訳です。</p>
<p>
コーディングルールで論争が起ることは少なくありません。
独自にトランスコンパイラを開発すれば、
言語レベルでそのような無駄な論争を防げます。</p>
<p>
自分でトランスコンパイラを開発するまではあまり意識していませんでしたが、
普段意識しているコーディングルールの中でも、
別の言語では言語レベルで実施できないから不要になっているルールというものが
いくつかあることが分かりました。</p>
<p>
新しい言語を開発する際は、新しい機能を取り入れるだけでなく、
普段のコーディングルールを見直し、言語レベルで対応できないか検討するべきだと思います。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-468" class="outline-3">
<h3 id="headline-468">
最後に
</h3>
<div id="outline-text-headline-468" class="outline-text-3">
<p>
これまでに、
簡易的なインタプリタや、<a href="#__/lctags/">ソースコードタグシステム</a> 等を趣味で作ってきました。</p>
<p>
今回 LuneScript 開発を通して、
また一つソフトウェア開発の面白さを実感できました。</p>
<p>
「いまさら新しい言語なんて作っても意味はない」、
そう思っている方も多いと思います。少なくとも私はそう思っていました。</p>
<p>
しかし、今回 LuneScript を開発することで、
また一つソフトウェアエンジニアとして成長出来たと思います。</p>
<p>
人がどう思おうが自分で成長を感じることが出来れば、それが一番です。</p>
<p>
ソフトウェア開発に対して不満を持っている方は、
是非新しいプログラミング言語の開発にチャレンジしてみてください。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-completion_ja" class="outline-2">
<h2 id="completion_ja">
<strong>A.イマドキな開発環境でもっと楽しよう</strong>
</h2>
<div id="outline-text-completion_ja" class="outline-text-2">
<p>
皆さんは Lua の開発に、エディタは何を使用しているでしょうか？</p>
<p>
Lua Development Tools や Atom, VSCode のようなイマドキな機能満載な環境ですか？
それとも、emacs や vim などの古典的な環境ですか？</p>
<p>
どちらの環境にしろ、 Lua コーディング中の補完機能に不満を持っていないですか？</p>
<p>
Lua の補完機能は、多くの場合かなり賢く補完してくれるんですが、
補完が効かないことって結構ありますよね？</p>
<p>
ちょっと確認しただけでも、次の場面では補完が効いてくれないようです。</p>
<ul>
<li>関数の引数に渡したオブジェクトが持つメソッドのフィールド補完</li>
<li>metatable を利用したオブジェクト指向プログラミングの補完</li>
</ul>
<p>軽い処理では、上記問題はあまり気にならないのかもしれないですが、
ある程度の規模の処理を書く時は結構気になります。</p>
<p>
Lua のトランスコンパイラ LuneScript では、
どんな場面でも補完が効くように、コンパイラレベルで補完機能を提供します。</p>
<p>
ここでは、LuneScript のコーディング時に利用出来る、
イマドキの開発支援を紹介します。</p>
<p>
具体的には次の 3 つの機能です。</p>
<ul>
<li>コード補完機能</li>
<li>カーソル位置の型情報確認  </li>
<li>Syntax エラーチェック機能</li>
<li>subfile を認識した検索</li>
</ul>
<div id="outline-container-headline-470" class="outline-3">
<h3 id="headline-470">
コード補完機能
</h3>
<div id="outline-text-headline-470" class="outline-text-3">
<p>
LuneScript は、クラスフィールドの補完機能を提供しています。</p>
<p>
例えば次のようなコードのとき、</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
class Super {
   pub let val:int;
   pri let val2:int { pub };
   pub fn funcsuper():int! {
      return 0;
   }
}
class Test extend Super {
   pub fn __init( val: int ) {
      super( val, val + 1 );
   }
   pub fn func( val: int ):int {
      return 1;
   }
}
let test = new Test( 1 );</code></pre>
</div>
<p>
test のフィールドの補完が次のように行なえます。</p>
<p>
<img src="https://ifritjp.github.io/doc/LuneScript/comp1.gif" alt="https://ifritjp.github.io/doc/LuneScript/comp1.gif" title="https://ifritjp.github.io/doc/LuneScript/comp1.gif" /></p>
<p>
ここで注目してもらいたいのは次の点です。</p>
<ul>
<li>継承関係を認識して Super と Test のフィールドが候補にリストされている</li>
<li>アクセス制御を認識して Super の private な val2 メンバがリストから除外されている</li>
<li>インスタンスからアクセス出来ないコンストラクタ(__init)がリストから除外されている</li>
<li>定義していない get_val2() がリストされている</li>
</ul>
<p>当たり前の機能ですが、
この当たり前の機能をしっかりとコンパイラ自体が提供しているというのは、
意外に少なかったりします。</p>
</div>
</div>
<div id="outline-container-headline-471" class="outline-3">
<h3 id="headline-471">
カーソル位置の型情報確認
</h3>
<div id="outline-text-headline-471" class="outline-text-3">
<p>
LuneScript は、型推論を対応しています。</p>
<p>
これにより、型情報を明示しなくてもコーディングを進められます。</p>
<p>
例えば、次のコードには型の明示が一切ありません。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
foreach val, key in { &#34;abc&#34;: 1, &#34;xyz&#34;: 10 } {
  print( key, val );
}</code></pre>
</div>
<p>
これはこれで便利ですが、
逆に型を確認できないというのは欠点とも言えます。</p>
<p>
そこで、カーソル位置のシンボルが、どのような型なのかを確認できる機能を提供しています。</p>
<p>
確認したいシンボルにカーソルを移動し、 C-c I を実行することで、
そのシンボルの型情報を確認できます。</p>
</div>
</div>
<div id="outline-container-headline-472" class="outline-3">
<h3 id="headline-472">
Syntax エラーチェック機能
</h3>
<div id="outline-text-headline-472" class="outline-text-3">
<p>
LuneScript は、コンパイラなので当然 Syntax エラーチェック機能を持ちます。</p>
<p>
このエラーチェック情報の基、エディタ上にエラー箇所を表示可能です。</p>
<p>
例えば、次のようなソースで、</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: ok
fn func( val: int ) {
   print( val );
}
let map = { &#34;a&#34;: 1, &#34;b&#34;:2 };</code></pre>
</div>
<p>
次の処理を追加するとエラーとなります。</p>
<p>
<img src="https://ifritjp.github.io/doc/LuneScript/error.gif" alt="https://ifritjp.github.io/doc/LuneScript/error.gif" title="https://ifritjp.github.io/doc/LuneScript/error.gif" /></p>
<p>
<a href="https://ifritjp.github.io/doc/LuneScript/error2.PNG">https://ifritjp.github.io/doc/LuneScript/error2.PNG</a></p>
<p>
これは、 map 型の item へのアクセス結果は nilable 型になり、
それを <code class="verbatim">func()</code> に与えた場合、 int! と int の型不一致エラーとなります。</p>
<p>
このような、ちょっと見過しがちなエラーもエディタ上で簡単に確認できます。</p>
</div>
</div>
<div id="outline-container-headline-473" class="outline-3">
<h3 id="headline-473">
subfile を認識した検索
</h3>
<div id="outline-text-headline-473" class="outline-text-3">
<p>
LuneScript は、大きいモジュールを定義するファイルを
複数のファイルに分割して定義する機能 subfile を持ちます。</p>
<p>
この機能を利用することで、ファイルが大きくなってエディタが重くなる、
なんてストレスから開放されます。</p>
<p>
しかし、ファイルが分割されてしまうので、
モジュール内の検索性が悪くなる欠点があります。</p>
<p>
例えば、あるモジュールが owner.lns, sub1.lns, sub2.lns, sub3.lns で構成されている場合、
あるモジュール内データがどこでアクセスされているかを検索するには、
owner.lns, sub1.lns, sub2.lns, sub3.lns の 4 つのファイルを
切り替えて検索する必要があります。</p>
<p>
これは面倒な操作です。</p>
<p>
この面倒な操作を、検索時に自動で行ないます。</p>
<p>
具体的には owner.lns で検索して見つかない場合は、次は sub1.lns に切り替えて検索。
sub1.lns で見つからない場合は、次は sub2.lns に切り替えて検索。
… この処理を自動で行ないます。</p>
</div>
</div>
<div id="outline-container-headline-474" class="outline-3">
<h3 id="headline-474">
設定
</h3>
<div id="outline-text-headline-474" class="outline-text-3">
<p>
emacs の設定です。  </p>
<div class="src src-lisp">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lisp" data-lang="lisp"><span class="line"><span class="cl"><span class="p">(</span><span class="nf">require</span> <span class="ss">&#39;lns-conf</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">;;(require &#39;lns-flymake)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nf">require</span> <span class="ss">&#39;lns-flycheck</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nf">require</span> <span class="ss">&#39;lns-company-mode</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">;;(require &#39;lns-auto-complete)</span>
</span></span><span class="line"><span class="cl"><span class="p">(</span><span class="nf">require</span> <span class="ss">&#39;lns-helm</span><span class="p">)</span></span></span></code></pre></div>
</div>
<p>
コード補完、Syntax チェックは、環境に合わせてどちらかを選択してください。</p>
<ul>
<li>
<p>コード補完</p>
<ul>
<li>flycheck </li>
<li>flymake</li>
</ul>
</li>
<li>
<p>Syntax チェック</p>
<ul>
<li>company-mode</li>
<li>auto-complete</li>
</ul>
</li>
</ul>
<p>LuneScript の flymake, auto-complete 対応は、メンテナンスしていません。
flycheck, company-mode の使用を推奨します。</p>
</div>
</div>
<div id="outline-container-headline-475" class="outline-3">
<h3 id="headline-475">
プロジェクト
</h3>
<div id="outline-text-headline-475" class="outline-text-3">
<p>
LuneScript は、モジュールパスをプロジェクトからの相対パスで管理します。
このため、emacs にプロジェクトのルートディレクトリを認識させる必要があります。</p>
<p>
プロジェクトのルートディレクトリを emacs に認識させるには、
プロジェクトのルートディレクトリに次の <strong>lune.js</strong> ファイルを作成してください。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">lune.js</span></span></code></pre></div>
</div>
<p>
この <strong>lune.js</strong> ファイルには、次を書いておきます。</p>
<div class="src src-js">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="p">{}</span></span></span></code></pre></div>
</div>
<div id="outline-container-headline-476" class="outline-4">
<h4 id="headline-476">
モジュールのパス
</h4>
<div id="outline-text-headline-476" class="outline-text-4">
<p>
次の位置に lune.js を作成した場合、
proj/foo/bar/module1.lsn のモジュールのパスは foo.bar.module1 になります。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">proj/lune.js
</span></span><span class="line"><span class="cl">proj/foo/bar/module1.lsn</span></span></code></pre></div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-477" class="outline-3">
<h3 id="headline-477">
最後に
</h3>
<div id="outline-text-headline-477" class="outline-text-3">
<p>
今回の機能は emacs 上で動作確認しています。
ちなみに、コード補完は company-mode, auto-complete,
syntax エラーチェックは flymake, flycheck に対応しています。</p>
<p>
LuneScript でデフォルトで提供しているのは emacs 向けの設定ですが、
emacs が行なっているのはフロントエンド制御だけで、
バックエンドは全て LuneScript が行なっています。</p>
<p>
つまり、 emacs 以外の環境に移植することは十分可能です。
ただ、私自身は emacs ユーザなので、 emacs を最優先で開発しています。</p>
<p>
もしも LuneScript に興味をもったなら、
emacs 以外の環境に対応していただけると嬉しいです。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-onweb_ja" class="outline-2">
<h2 id="onweb_ja">
<strong>Web ブラウザ上で動作する LuneScript</strong>
</h2>
<div id="outline-text-onweb_ja" class="outline-text-2">
<p>
LuneScript の動作確認用に、Web ブラウザ上で動作する LuneScript 環境を用意しています。</p>
<p>
&lt;<a href="https://ifritjp.github.io/LuneScript-webFront/contents/">https://ifritjp.github.io/LuneScript-webFront/contents/</a>&gt;</p>
<p>
上記リンク先には、次の 3 つの textarea があります。</p>
<ul>
<li>LuneScript のコード入力用</li>
<li>実行結果出力用</li>
<li>Lua への変換結果出力用</li>
</ul>
<p>LuneScript のコード入力用の textarea に LuneScript のコードを入力し、
execute ボタンを押下すると、Lua に変換・実行します。</p>
<p>
LuneScript の全ての処理が、ブラウザ上で動作しています。</p>
<p>
ただし、次の制限があります。</p>
<ul>
<li><code class="verbatim">io.open()</code> などのファイル操作が出来ない</li>
<li><code class="verbatim">import()</code> などのモジュールロードが出来ない</li>
</ul>
<p>LuneScript の全ての処理をブラウザ上で動作させているため、
スマホなどでは初回実行に時間が掛ります。</p>
<div id="outline-container-headline-479" class="outline-3">
<h3 id="headline-479">
技術解説
</h3>
<div id="outline-text-headline-479" class="outline-text-3">
<p>
fengari を利用してブラウザ上で Lua VM を動かし、
その Lua VM 上で LuneScript コンパイラを実行しています。</p>
<p>
fengari については次の記事を参照してください。</p>
<p>
<a href="#__/lua/fengari/">#__/lua/fengari/</a></p>
<p>
fengari の Lua VM は、
Lua 上で require すると XMLHttpRequest でそのモジュールをロードします。
LuneScript は 30 個の Lua ファイルで構成しているため、
30 個の Lua ファイルをシーケンシャルにロードすることになります。
30 ファイルのシーケンシャルなロードは流石に効率が悪いため、
事前に XMLHttpRequest で非同期でロードしておき、
require 処理の時は事前にロードしたファイルを load するように処理を切り替えています。</p>
<p>
そして LuneScript コンパイラのロード後に、
入力されたユーザの LuneScript コードを LuneScript で変換し、
それを実行します。</p>
<p>
LuneScript コンパイラのロードは、そこそこの時間がかかります。
私が使用しているスマホで 10 秒弱、 PC だと 1 秒弱。
一度ロードした後は、ブラウザをリロードするまでは LuneScript のロードは不要で、
ユーザの LuneScript コードの変換、実行が出来ます。</p>
<p>
なお、ユーザの LuneScript コードがバグって暴走した時の対処として、
実行後 2 秒経過したら強制停止するようにしています。</p>
<p>
この LuneScript コンパイラは、
一度ロードした後は完全にブラウザ内に閉じで動作するため、
サーバ側に負荷は掛りません。
サーバに必要な機能は、静的コンテンツのホスティングだけです。</p>
<div id="outline-container-headline-480" class="outline-4">
<h4 id="headline-480">
LuneScript の fengari 対応
</h4>
<div id="outline-text-headline-480" class="outline-text-4">
<p>
fengari Lua VM 上で LuneScript を動かすにあたって、
LuneScript の次の処理を修正しました。</p>
<p>
<strong>「List&lt;X&gt; 型の foreach 処理を pairs() から ipairs() に切り替え」</strong></p>
<p>
オリジナルの Lua VM では、シーケンスのテーブルにおいては、
<code class="verbatim">pairs()</code> でも <code class="verbatim">ipairs()</code> でも列挙する順番が同じであるのに対し、
fengari Lua VM では <code class="verbatim">pairs()</code> では順不同になるようです。
LuneScript では、処理の簡単化と確実性を取って <code class="verbatim">ipairs()</code> ではなく
<code class="verbatim">pairs()</code> を利用していましたが、 fengari Lua VM では <code class="verbatim">ipairs()</code> に切り替えました。</p>
<p>
なお、この切り替えの制御を <strong>–use-ipairs コンパイルオプション</strong> で行なうようにしています。
–use-ipairs を指定した場合 <code class="verbatim">ipairs()</code> になります。
現状、オプションを指定していない場合は <code class="verbatim">pairs()</code> を利用していますが、
将来はデフォルト状態を逆にすることも検討しています。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-481" class="outline-3">
<h3 id="headline-481">
リファレンスのサンプルコード実行
</h3>
<div id="outline-text-headline-481" class="outline-text-3">
<p>
この技術を使用して、 LuneScript リファレンスのサンプルコードを実行するようにしています。</p>
<p>
組込み方法は簡単で、次の JavaScript をロードし、</p>
<pre class="example">
ifritJP.github.io/LuneScript-webFront/contents/lunescript-front.js
</pre>
<p>
<code class="verbatim">lnsFront.setup()</code>, <code class="verbatim">lnsFront.compile()</code> 関数を実行するだけです。</p>
<div id="outline-container-headline-482" class="outline-4">
<h4 id="headline-482">
lnsFront.setup()
</h4>
<div id="outline-text-headline-482" class="outline-text-4">
<p>
<code class="verbatim">lnsFront.setup()</code> は、 fengari と LuneScript をロードし、
各 HTML element の紐付けを行ない、
textarea に格納されている LuneScript コードをコンパイルし、実行します。</p>
<p>
<code class="verbatim">setup()</code> は、次の型の関数です。</p>
<div class="src src-js">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">lnsFront</span><span class="p">.</span><span class="nx">setup</span><span class="p">(</span> <span class="nx">consoleId</span><span class="p">,</span> <span class="nx">luaCodeId</span><span class="p">,</span> <span class="nx">lnsCodeId</span><span class="p">,</span> <span class="nx">executeId</span> <span class="p">)</span></span></span></code></pre></div>
</div>
<table>
<thead>
<tr>
<th>引数</th>
<th>意味</th>
<th>必須/Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>consoleId</td>
<td>コンソール出力結果を格納する textarea の id</td>
<td>必須</td>
</tr>
<tr>
<td>luaCodeId</td>
<td>変換後の Lua コードを格納する textarea の id</td>
<td>Option</td>
</tr>
<tr>
<td>lnsCodeId</td>
<td>Lns コードを格納する textarea の id</td>
<td>必須</td>
</tr>
<tr>
<td>executeId</td>
<td>変換を開始するトリガボタンの id</td>
<td>Option</td>
</tr>
</tbody>
</table>
<p>
上記の Option の element を使用しない場合、
element ID は空文字列を指定してください。</p>
<p>
例えば 変換後の Lua コードが不要な場合は、次のように実行します。</p>
<div class="src src-js">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="kd">var</span> <span class="nx">frontId</span> <span class="o">=</span> <span class="nx">lnsFront</span><span class="p">.</span><span class="nx">setup</span><span class="p">(</span> <span class="nx">consoleId</span><span class="p">,</span> <span class="s2">&#34;&#34;</span><span class="p">,</span> <span class="nx">lnsCodeId</span><span class="p">,</span> <span class="nx">executeId</span> <span class="p">)</span></span></span></code></pre></div>
</div>
<p>
なお、この関数は引数に与えられた consoleId 等をまとめて管理し、
ID を発行して紐付けます。そして、その ID が戻り値となります。</p>
<p>
<code class="verbatim">lnsFront.setup()</code> 実行後は、 executeId で指定したボタンをクリックするか、
<code class="verbatim">lnsFront.compile()</code> を実行すると、
登録した lnsCodeId の textarea 内の LuneScript コードを変換して実行し、
実行結果を各 textarea に格納します。</p>
<p>
LuneScript のコードを入力する textarea が複数ある場合、
<code class="verbatim">lnsFront.setup()</code> をそれぞれで実行します。</p>
<div id="outline-container-headline-483" class="outline-5">
<h5 id="headline-483">
lnsFront.setup() の注意
</h5>
<div id="outline-text-headline-483" class="outline-text-5">
<p>
<strong>一つの textarea に対して、lnsFront.setup() を複数回実行しないでください。</strong></p>
<p>
一度 <code class="verbatim">lnsFront.setup()</code> を実行した後は、
executeId で登録したボタンをクリックするか、
<code class="verbatim">lnsFront.compile()</code> を実行することで、
登録されている textarea 内の LuneScript のコードを実行します。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-484" class="outline-4">
<h4 id="headline-484">
<code class="verbatim">lnsFront.compile()</code>
</h4>
<div id="outline-text-headline-484" class="outline-text-4">
<p>
<code class="verbatim">lnsFront.compile()</code> は、
<code class="verbatim">lnsFront.setup()</code> で登録した textarea 内の LuneScript コードを
コンパイル・実行します。</p>
<div class="src src-js">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-js" data-lang="js"><span class="line"><span class="cl"><span class="nx">lnsFront</span><span class="p">.</span><span class="nx">compile</span><span class="p">(</span> <span class="nx">frontId</span><span class="p">,</span> <span class="nx">maxTime</span> <span class="p">)</span></span></span></code></pre></div>
</div>
<table>
<thead>
<tr>
<th>引数</th>
<th>意味</th>
<th>必須/Option</th>
</tr>
</thead>
<tbody>
<tr>
<td>frontId</td>
<td><code class="verbatim">lnsFront.setup()</code> の戻り値</td>
<td>必須</td>
</tr>
<tr>
<td>maxTime</td>
<td>ユーザの LuneScript 実行のタイムリミット(秒)</td>
<td>Option</td>
</tr>
</tbody>
</table>
<p>
maxTime を省略した場合、デフォルトの 2 秒がリミットになります。
なお 10 秒以上を指定した場合、無効値として扱い、デフォルト値がセットされます。</p>
<hr>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-test_ja" class="outline-2">
<h2 id="test_ja">
<strong>言語開発の品質コントロールにおけるセルフホスティングの重要性とテスト設計</strong>
</h2>
<div id="outline-text-test_ja" class="outline-text-2">
<p>
このドキュメントを見ているような人であれば、
日々「プログラミング言語」でコーディングしている方がほとんどだと思います。
そして、誰かが仕込んだバグ潰し作業に追われている方も多いでしょう。</p>
<p>
そんな日々お世話になっている「プログラミング言語」も
誰かが作ったソフトウェアであるので、いかにバグを出さないか、
という品質コントロールが重要になります。</p>
<p>
私は運が良いいのか(？)、プログラミング言語を仕事で利用してきた中で
言語のバグに遭遇したことはありません。</p>
<p>
<em>バグの様に思える言語の規格とかはありますが。。。</em></p>
<p>
プログラミング言語のバグに遭遇してしまった場合、
その対処は数あるソフトウェアバグの中でもかなり厄介な部類になると思います。</p>
<p>
<em>そもそもプログラミング言語のバグだということに辿り着くのが困難です。</em></p>
<p>
ここでは、
私が開発している独自言語のテスト方法について紹介したいと思います。</p>
<p>
なお、プログラミング言語は次の 2 つに分類できます。</p>
<ul>
<li>コンパイラ型</li>
<li>インタプリタ型</li>
</ul>
<p>私が開発している言語はコンパイラ型であるため、
以降はコンパイラ型のテストについて話をします。</p>
<p>
ちなみに私が開発している独自言語の LuneScript については、次の記事で紹介しています。</p>
<p>
https://qiita.com/dwarfJP/items/21d4d4099ab0feb68eaf</p>
<p>
今後、独自言語を開発しようと考えている方のテスト設計検討に、
少しでも役にたてれば幸いです。</p>
<div id="outline-container-headline-486" class="outline-4">
<h4 id="headline-486">
コンパイラは関数
</h4>
<div id="outline-text-headline-486" class="outline-text-4">
<p>
コンパイラ型プログラミング言語は、
そのプログラミング言語で書かれたコードをマシン語などに変換するのが仕事です。</p>
<p>
例えば、</p>
<ul>
<li>C 言語のコンパイラは Native コードに変換</li>
<li>Java のコンパイラは JVM コードに変換</li>
<li>C# は CIL に変換</li>
<li>Clang は LLVM-IR に変換し、 LLVM が各種コードに変換</li>
</ul>
<p>つまりコンパイラとは、
「入力を与えると、その入力に応じた出力を返す 1 つの大きな関数」と考えられます。</p>
<p>
コンパイラを 1 つの関数と考えれば、そのテストは非常に単純です。
様々な入力を与えて、その出力と期待値とを比較すればテストが出来ます。</p>
<p>
日頃作成している関数の UNIT TEST と考え方は全く同じです。</p>
</div>
</div>
<div id="outline-container-headline-487" class="outline-4">
<h4 id="headline-487">
コンパイラのテスト
</h4>
<div id="outline-text-headline-487" class="outline-text-4">
<p>
独自言語である LuneScript では、次のテストを実施しています。</p>
<ul>
<li>セルフホスティングしている LuneScript 自身のビルド</li>
<li>言語が対応する全構文の正常系</li>
<li>言語が対応する全構文の異常系</li>
</ul>
<p>ここで特に重要なのがセルフホスティングしていることです。</p>
<p>
セルフホスティングしていることで、あえてテストコードを書かなくても、
自分自身のコードがそのままテストコードになります。</p>
<p>
ある程度の規模で、意味のあるテストコードを作成する、
というのは中々骨の折れる作業です。</p>
<p>
特に自分以外誰も使っていないような独自言語の場合、
テストのためのコードではなく、
ちゃんとした実用的なコードというものが github を探せば簡単に出てくる、
<strong>なんてことはない</strong> ので、
ある程度の規模のテストコードというのは貴重になります。</p>
<p>
セルフホスティングしていると、
自分自身のコードがその貴重なテストコードになるのです。</p>
<p>
ただ、「自分自身のコードがそのままテストコードになる」と言っても、
それだけでは十分なテストにはなりません。
使用する構文やデザインパターン等に偏りが出てしまい、
網羅性という意味ではイマイチなテストになってしまいます。
また、コンパイルエラーになるような異常系コードは、
セルフホスティングしている自分自身のコードに仕込んでおけません。
よって、セルフホスティングしている自分自身のコードだけでは
テストケースとして不十分であり、
網羅的に正常系を確認するテストと、
コンパイルエラーを検出する異常系のテストが別途必要になります。</p>
<p>
この正常系と、異常系のテストは、
予め期待値を用意しておくことで、テストの成否を確認出来ます。</p>
<p>
一方で「自分自身のコードをコンパイルした結果が正しいかどうか」、
をどのように判定すれば良いか？が問題です。</p>
<p>
テストケースのコードは一般的に不変なので、そのコンパイル結果も不変です。
つまり、テストケースと期待値のペアを一度作成すれば、
テストケースを変更しないかぎりは同じ期待値を使い続けられます。</p>
<p>
一方で、セルフホスティングしている自分自身のコードは当然変っていきます。
つまり、期待値も常に変わるため、期待値を事前に用意しておくことは不可能です。</p>
<p>
では、セルフホスティングしている自分自身のコードのコンパイル結果が正しいかどうかを、
どのように判断するのかというと、 次が成り立つかどうかで判断します。</p>
<pre class="example">
「使用中のコンパイラでのテストケースの結果」 == 「新しくコンパイルしたコンパイラでのテストケースの結果」
</pre>
<p>
これは、使用中のコンパイラが正しい動作をしていることを前提に、
その正しい動作をしている使用中のコンパイラで実行したテストケースの結果と、
新しくコンパイルしたコンパイラで実行したテストケースの結果が同一であるならば、
新しくコンパイルしたコンパイラも正しい、という論理です。</p>
<p>
さらに、新しくコンパイルしたコンパイラで、もう一度自分自身をコンパイルしています。
これは、同じコードをコンパイルしたときに、
その出力結果が全く同じ結果になることを確認するために実行しています。</p>
<p>
まとめると、 LuneScript のテストは次を実行します。</p>
<dl>
<dt>
step1
</dt>
<dd>現在使用中のコンパイラ A を使って、セルフホスティングしている自身のコードをコンパイルしコンパイラ B を生成</dd>
<dt>
step2
</dt>
<dd>コンパイラ B を使って、再度自身のコードをコンパイルしコンパイラ C を生成</dd>
<dt>
step3
</dt>
<dd>コンパイラ C を使って、再度自身のコードをコンパイルしコンパイラ D を生成</dd>
<dt>
step4
</dt>
<dd>コンパイラ C とコンパイラ D が同一であることを確認</dd>
<dt>
step5
</dt>
<dd>コンパイラ A の正常系、異常系のテストを実行し、テスト結果を result A に保存</dd>
<dt>
step6
</dt>
<dd>コンパイラ D の正常系、異常系のテストを実行し、テスト結果を result D に保存</dd>
<dt>
step7
</dt>
<dd>result A と result D が同一であることを確認</dd>
</dl>
<p>上記テストをパスしたら、コンパイラ D を最新のコンパイラ A として次回から利用します。
また、拡張した言語仕様の正常系、異常系のテストを随時追加します。</p>
<p>
セルフホスティングの場合、
不具合があると自分自身のコンパイル自体が出来なくなって、
開発を進められなくなってしまう可能性があります。
このテストを行なうことで、
新しくビルドしたコンパイラが正常に動作することを確実に保証でき、
安全に言語の機能拡張を進められます。</p>
<p>
独自言語の場合、
セルフホスティングへの移行タイミングというのは非常に重要になると思います。</p>
<p>
コンパイラのコード規模が大きくなると移植作業に掛かる時間も大きくなってくるので、
独自言語をフルスクラッチで開発する場合、
セルフホスティングに必要な機能を優先的に実現し、
出来るだけ早い段階でセルフホスティングに移行することをオススメします。</p>
</div>
</div>
<div id="outline-container-headline-488" class="outline-3">
<h3 id="headline-488">
それでもバグは残る
</h3>
<div id="outline-text-headline-488" class="outline-text-3">
<p>
独自言語開発で実施しているテストについて紹介しましたが、
テストをしても残念ながらバグは残ります。</p>
<p>
そのバグの原因を分類すると次の 2 つになります。</p>
<ul>
<li>異常系が検出できないケース</li>
<li>本来正常に動作しなければならないのに動作しないケース</li>
</ul>
<p>上記の 2 つの内、異常系が検出できないケースが圧倒的に多いです。</p>
<p>
というのも、
正常系のパスは言語仕様通りのコードを書いて動くことを確認すれば良いのに対し、
異常系のパスは言語仕様から外れたコードを書いてエラーを検出する必要があります。</p>
<p>
この「言語仕様から外れる」というのが結構難しく、穴が空いてしまうことが多いです。</p>
<p>
最初から完璧なテストを求めるのではなく、
こういう「穴」を見つけ、
それを塞ぐテストケースを追加していき、
再度同じ「穴」が開いた時に検出できるように対応することが
テストでは重要だと考えます。</p>
</div>
</div>
<div id="outline-container-headline-489" class="outline-3">
<h3 id="headline-489">
最後に
</h3>
<div id="outline-text-headline-489" class="outline-text-3">
<p>
独自言語の開発を続けてこられたのも、
次のテスト方針で進めて来たことが大きいと考えています。</p>
<ul>
<li>
<p>早期にセルフホスティングに移行したこと</p>
<ul>
<li>
<p>セルフホスティングに移行すると、否応なく一定以上の品質保証が必要になる</p>
<ul>
<li>品質が悪ければセルフホスティングに支障が出るため、自ずと品質が保たれる</li>
</ul>
</li>
</ul>
</li>
<li>
<p>始めから 100% のテストを目指さないこと</p>
<ul>
<li>目的は独自言語の開発であって、テストの開発ではない。</li>
<li>独自言語に集中できる。</li>
</ul>
</li>
<li>
<p>言語の仕様拡充とテストコード拡充を同期して行なって来たこと</p>
<ul>
<li>テストの抜け漏れ、デグレードを防止できる</li>
</ul>
</li>
<li>
<p>関数レベルのテストではなく、コンパイラ入出力レベルでのテストを行なったこと</p>
<ul>
<li>関数レベルのテストだと、設計変更の度にテストケース変更が必要だが、
コンパイラ入出力レベルでのテストならば、
コンパイラの仕様変更がない限りはテストケースの変更が不要</li>
</ul>
</li>
</ul>
<p>独自言語の開発を行なう場合は、品質を確保するという意味でも、
まずはセルフホスティングを目指すのが効率的だと思います。</p>
<p>
以上。</p>
<hr>
</div>
</div>
</div>
</div>
<div id="outline-container-box_ja" class="outline-2">
<h2 id="box_ja">
<strong>Box 編</strong>
</h2>
<div id="outline-text-box_ja" class="outline-text-2">
<p>
<strong>これは、検討中の情報です。 現在は利用できません。</strong></p>
<div id="outline-container-headline-491" class="outline-3">
<h3 id="headline-491">
Nilable 型
</h3>
<div id="outline-text-headline-491" class="outline-text-3">
<p>
前述している通り、 Generics の実型パラメータに nilable は指定できません。</p>
<p>
この制限により、次の <code>new Test( val )</code> はエラーになります。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
class Test&lt;T&gt; {
   let val:T;
}
let val:int! = 1;
let test = new Test( val ); // error</code></pre>
</div>
<p>
このエラーを回避するには、 2 つのパターンがあります。</p>
<ul>
<li>T! を利用する</li>
<li>Nilable 型を利用する</li>
</ul>
<p>「T! を利用する」のケースでは、上記処理は次のように書けます。</p>
<div class="src src-lns">
<pre tabindex="0"><code class="language-lns" data-lang="lns">// @lnsFront: skip
class Test&lt;T&gt; {
   let val:T!; // &lt;--- T! とする
}
let val:int! = 1;
let test = new Test( val );</code></pre>
</div>
<p>
ただこうすると、多くの場合は 非 nilable で良いケースでも nilable として宣言しなければならないため、
unwrap 処理が必須となってしまい面倒です。</p>
<p>
そこで、 Nilable 型を利用します。</p>
<div id="outline-container-headline-492" class="outline-4">
<h4 id="headline-492">
Nilable 型とは
</h4>
<div id="outline-text-headline-492" class="outline-text-4">
<p>
Nilable 型は、 nilable の値をラッピングする型です。
Java で言うところの int に対する Integer クラスと思ってください。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="edit-meta">

<br></div><nav class="pagination"><a class="nav nav-prev-2" href="https://ifritjp.github.io/documents/lunescript/go_study/" title="Z. Go 言語へのトランスコンパイル (検討段階)"><i class="fas fa-arrow-left" aria-hidden="true"></i> Prev - Z. Go 言語へのトランスコンパイル (検討段階)</a>
<a class="nav nav-next-2" href="https://ifritjp.github.io/documents/lunescript/tutorial1/" title="00. はじめに">Next - 00. はじめに <i class="fas fa-arrow-right" aria-hidden="true"></i></a>
</nav><footer><p class="powered">Powered by <a href="https://gohugo.io">Hugo</a>. Theme by <a href="https://themes.gohugo.io/hugo-theme-techdoc/">TechDoc</a>. Designed by <a href="https://github.com/thingsym/hugo-theme-techdoc">Thingsym</a>.</p>
</footer>
</main><div class="sidebar">

<nav class="slide-menu">
<ul>
<li class=""><a href="https://ifritjp.github.io/documents">Home</a></li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/lctags/">C/C&#43;&#43; ソースコードタグシステム lctags の紹介<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/lctags/introduce/">C/C&#43;&#43; ソースコードタグシステム lctags の紹介</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/rename/">C/C&#43;&#43; ソースコードをリファクタリング by lctags on emacs (リネーム編)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/enum/">C/C&#43;&#43; の enum 補完 by lctags on emacs</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/highlight/">C/C&#43;&#43; の特定シンボルをハイライト by lctags on emacs</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/varsize/">C/C&#43;&#43; の変数サイズ確認 by lctags on emacs</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/callgraph/">C言語/C&#43;&#43; コードを解析してインタラクティブなコールグラフ表示 by lctags</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/modulegraph/">C言語/C&#43;&#43; コードを解析してインタラクティブなモジュール構成図っぽいグラフ表示 by lctags</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/callfunc/">lctags で C 言語の関数コールを簡単に</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/register/">lctags のプロジェクト簡易登録</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/c-language/">lctags を開発している時に改めて感じた C 言語規格のイケてないところ</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/subroutine/">lctags を使って C/C&#43;&#43; ソースコードをリファクタリング(サブルーチン化編)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/windows/">Windows で lctags (C言語/C&#43;&#43; のタグジャンプ、コールグラフ、etc..)</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/lua/">C/C&#43;&#43; 言語プログラマのための Lua 入門リファレンス<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/lua/detail/">C インタフェース詳細編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lua/interface/">C インタフェース編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lua/fengari/">fengari の使い方 (Lua を Web ブラウザで動かす方法)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lua/lua5.4/">Lua 5.4 の主な変更点</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lua/anti-pattern/">Lua でやりがちなミス</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lua/pointer/">ポインタ編</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/emacs/">Emacs<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/emacs/simple-httpd/">emacs 簡易 HTTPD 化パケージ simple-httpd.el</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/emacs/company-mode/">自作言語 (LuneScript) の emacs company-mode backend 設定</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/go/">Goes<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/go/package/">Go のパッケージ</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/go/guide/">Go 入門</a></li>
</ul>
  
</li>

<li class=""><a href="https://ifritjp.github.io/documents/gcp/">Google Cloud Platform を使ってみる</a>
  
</li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/javascript/">Javascripts<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/javascript/d3force/">D3.js V4 forceSimulation のノード動的更新(追加・削除)</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/libclang/">Lua で C/C&#43;&#43; の構文解析 (libclang の Lua binding)<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/libclang/operator/">libclang で演算子を特定する方法</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/libclang/ast/">libclang の AST(Abstract Syntax Tree)</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/rust/">Rusts<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/rust/lifetime/">C/C&#43;&#43;エンジニアのための Rust のデータ所有権とライフタイム入門</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/singleboard/">Singleboards<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/singleboard/raspios64-point/">64bit 版 Raspberry Pi OS でカーネルモジュールを使った際に遭遇したエラーと対応方法</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/singleboard/build-kernel-module-64/">64bit 版 Raspberry Pi OS のカーネルモジュールのビルド環境設定</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/singleboard/bluetooth-a2dp-receiver/">Raspberry Pi で Bluetooth レシーバー (オーディオ:A2DP) を作成するための設定方法解説</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/singleboard/usb-gadget/">USB Gadget 機能を利用して Raspberry Pi を HID Keyboard と RNDIS の複合デバイスにする</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/singleboard/recover-image/">誤ってパーティションテーブル (LBA 0) を消して(0クリアして)しまった場合の対処</a></li>
</ul>
  
</li>

<li class="parent has-sub-menu"><a href="https://ifritjp.github.io/documents/lunescript/">トランスコンパイラ LuneScript で Lua の開発をもっと楽に!!<span class="mark opened">-</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/tutorial1/">00. はじめに</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/tutorial2.setup/">01. 導入編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/tutorial3.hello/">02. Hello world</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/crosscompile/">03. Lua バージョン間のクロスコンパイル</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/value/">04. 値編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/set/">04.2. Set 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/enum/">05. enum 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/match/">06. match 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/variable/">07. 変数 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/branch/">08. 一般分岐構文 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/loop/">09. 繰り返し構文 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/func/">10. 関数 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/multipleretval/">10.2. 多値の戻り値</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/defaultarg/">10.3. 引数の省略 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/arg/">10.4. 可変長引数、戻り値 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/closure/">10.5. クロージャ</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/nilable/">11. nilable 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/class1/">12. クラス 基本 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/class2accessor/">13. accessor 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/classinherit/">14. クラス 継承 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/classadvertise/">15. クラス advertise 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/classoverride/">16. クラス override 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/interface/">17. インタフェース 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/classmapping/">18. mapping 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/generics/">19. generics 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/nilcond/">20. nil 条件演算子 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/import/">21. import/provide 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/require/">22. require/module 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/glue/">22.1. glue コードの半自動生成</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/lua/">22.2. Lua と連携 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/make/">23. ビルド 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/macro/">24. マクロ 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/cast/">25. キャスト 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/subfile/">26. subfile 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/lazyloading/">27. 遅延ロード 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/shebang_main/">28. shebang とコマンドライン引数</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/dir/">29. LuneScript を利用するプロジェクトの推奨ディレクトリ構成</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/go/">80. Go 言語へのトランスコンパイル</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/go_package/">80.2 Go 言語へのトランスコンパイル時のパッケージ</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/lua_runtime/">80.3 Go へトランスコンパイルした際の Lua ランタイム</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/go_wasm/">80.4 LuneScript の WebAssembly 対応</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/async/">81. 安全な非同期処理</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/async_old/">81.1 非同期処理(過去情報)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/luago/">82. Lua と連携 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/lnstags/">A. lnstags によるタグジャンプ (ソースコードタグシステム)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/reason/">A. Lua のトランスコンパイラ LuneScript を開発した理由</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/regret/">A. LuneScript の言語仕様でミスだったと思っているところ</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/onweb/">A. Web ブラウザ上で動作する LuneScript</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/recommend/">A. トランスコンパイラ開発のすゝめ</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/completion/">A.イマドキな開発環境でもっと楽しよう</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/box/">Box 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/test/">X. 言語開発の品質コントロールにおけるセルフホスティングの重要性とテスト設計</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/go_study/">Z. Go 言語へのトランスコンパイル (検討段階)</a></li>
<li class="active"><a href="https://ifritjp.github.io/documents/lunescript/all/">全文検索用結合ファイル</a></li>
</ul>
  
</li>
</ul>
</nav>



<div class="sidebar-footer"></div>
</div>
</div><a href="#" id="backtothetop-fixed" class="backtothetop"
 data-backtothetop-duration="600"
 data-backtothetop-easing="easeOutQuart"
 data-backtothetop-fixed-fadeIn="1000"
 data-backtothetop-fixed-fadeOut="1000"
 data-backtothetop-fixed-bottom="10"
 data-backtothetop-fixed-right="20">
<span class="fa-layers fa-fw">
<i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i>
</span></a>
</div>
</body>
</html>
