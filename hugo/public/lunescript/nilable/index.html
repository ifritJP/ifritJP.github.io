<!DOCTYPE html>
<html lang="en-us">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>nilable 編 - 公開技術情報</title>
<meta name="generator" content="Hugo 0.68.3" />
<link href="https://ifritjp.github.io/hugo/publicindex.xml" rel="alternate" type="application/rss+xml">
<link rel="canonical" href="https://ifritjp.github.io/hugo/public/lunescript/nilable/">
<link rel="stylesheet" href="https://ifritjp.github.io/hugo/public/css/theme.min.css">
<script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
<link rel="stylesheet" href="https://ifritjp.github.io/hugo/public/css/chroma.min.css">
<script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js"></script>
<script src="https://ifritjp.github.io/hugo/public/js/bundle.js"></script><style>
:root {}
</style>
<meta property="og:title" content="nilable 編" />
<meta property="og:description" content="今回は LuneScript の nilable について説明します。 nilable とは LuneScript は、値に nil を持ちます。 以前説明しましたが、 stem 型の変数は nil 以外の全ての型を保持できます。 let mut val:stem = 1; val =" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ifritjp.github.io/hugo/public/lunescript/nilable/" />
<meta property="og:image" content="https://ifritjp.github.io/hugo/public/images/og-image.png"/>
<meta property="og:site_name" content="公開技術情報" />
<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://ifritjp.github.io/hugo/public/images/og-image.png"/>

<meta name="twitter:title" content="nilable 編"/>
<meta name="twitter:description" content="今回は LuneScript の nilable について説明します。 nilable とは LuneScript は、値に nil を持ちます。 以前説明しましたが、 stem 型の変数は nil 以外の全ての型を保持できます。 let mut val:stem = 1; val ="/>
<meta itemprop="name" content="nilable 編">
<meta itemprop="description" content="今回は LuneScript の nilable について説明します。 nilable とは LuneScript は、値に nil を持ちます。 以前説明しましたが、 stem 型の変数は nil 以外の全ての型を保持できます。 let mut val:stem = 1; val =">

<meta itemprop="wordCount" content="3304">
<meta itemprop="image" content="https://ifritjp.github.io/hugo/public/images/og-image.png"/>



<meta itemprop="keywords" content="" /></head>
<body><div class="container"><header>
<h1>公開技術情報</h1>

</header>
<div class="global-menu">
<nav>
<ul>
<li><a href="/hugo/public/">Home</a></li></ul>
</nav>
</div>
<div class="content-container">
<main><h1>nilable 編</h1>

<p>
今回は LuneScript の nilable について説明します。
</p>
<h2 id="headline-1">
nilable とは
</h2>
<p>
LuneScript は、値に nil を持ちます。
</p>
<p>
以前説明しましたが、 stem 型の変数は nil 以外の全ての型を保持できます。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">let mut val:stem = 1;
val = 1.0;
val = &#34;abc&#34;;
val = {};
val = [];
val = [@];
val = nil; // error</code></pre>
</div>
<p>
では、どうすれば nil を保持できるのかというと、
stem ではなく stem! を使用します。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">let mut val:stem! = 1;
val = 1.0;
val = &#34;abc&#34;;
val = {};
val = [];
val = [@];
val = nil; // ok</code></pre>
</div>
<p>
このように、 nil を保持可能な型を nilable と言います。
</p>
<p>
nilable は stem! だけでなく、
一部を除く全ての型に nilable 型が存在します。
</p>
<p>
例えば int! や str! は、 int の nilable 型、 str の nilable 型となります。
</p>
<p>
型名の末尾に ! を付加することで、
本来の型と nil を保持可能な nilable 型となります。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">let mut val1:int = 1;
val1 = nil;  // error

let mut val2:int! = 1;
val2 = nil;  // ok</code></pre>
</div>
<p>
nil は、他のどの値とも異なる値で、異常値として利用するのに便利な値です。
しかし、 意図しないタイミングで変数の値が nil になることで、不具合の原因となる多くあります。
</p>
<p>
LuneScript は、 nil を保持出来る nilable 型と、
nil を保持できない非 nilable 型に分けることで、
nil 安全(NULL 安全)を実現しています。
</p>
<h2 id="headline-2">
nilable 型の制限
</h2>
<p>
nilable 型は、そのままでは元の型として使用できないという制限があります。
</p>
<p>
この説明だと何のことだか伝わり難いと思いますので、次の例を見てください。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">let val:int! = 1;
print( val + 1 );  // error</code></pre>
</div>
<p>
上記の val は int の nilable 型です。
そして val + 1 を実行していますが、これはエラーとなります。
</p>
<p>
なぜならば、 val は int ではなく int! なので、そのままでは int としては扱えないためです。
</p>
<p>
では、なぜ nilable にこのような制限があるかというと、次の通りです。
</p>
<ul>
<li>
<p>
nilable は nil を保持できる型
</p>
</li>
<li>
<p>
つまり、nilable 型は nil である可能性がある
</p>
</li>
<li>
<p>
元の型として利用するには、 nil でないことを確認しなければならない
</p>
</li>
</ul>
<p>
非 nilable の型には nil を代入出来ません。
そして、 nilable 型はそのままで元の型として利用が出来ません。
</p>
<p>
この制限によって、 ある変数が意図しないタイミングで nil になり、
不具合となることを論理的に防止することが出来ます。
</p>
<p>
これが多くの言語で取り入れられている nil 安全(NULL安全)の原理です。
</p>
<h2 id="headline-3">
nilable 型との比較
</h2>
<p>
前述している通り、nilable 型は、そのままでは非 nilable として利用できません。
</p>
<p>
しかし、次のように比較すること出来ます。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">fn check( val:int! ) {
   if val == 1 {
      print( &#34;ok&#34; );
   }
   else {
      print( &#34;ng&#34; );
   }
}
check( 1 ); // ok
check( 2 ); // ng</code></pre>
</div>
<p>
上記サンプルでは val は int! で、 val == 1 で int と比較しています。
このように nilable と 非 nilable を比較することは可能です。
</p>
<h2 id="headline-4">
nilable 型から非 nilable 型への変換
</h2>
<p>
次のように、非 nilable 型から nilable 型への変換は、暗黙的に行なわれます。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">let val:int! = 1;   // int! &lt;-- int</code></pre>
</div>
<p>
一方で nilable 型から非 nilable 型への変換は、明示的に行なう必要があります。
</p>
<p>
LuneScript では、nilable 型から非 nilable 型への変換に、次のものを用意しています。
</p>
<ul>
<li>
<p>
unwrap 
</p>
</li>
<li>
<p>
when!
</p>
</li>
<li>
<p>
if!
</p>
</li>
<li>
<p>
if! let
</p>
</li>
<li>
<p>
let!
</p>
</li>
<li>
<p>
unwrap!
</p>
<h3 id="headline-5">
unwrap
</h3>
</li>
</ul>
<p>
unwrap は、 nilable 型の式を、非 nilable 型へ変換します。
</p>
<p>
例えば次のように使用します。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">let val1:int! = 1;
let val2:int = unwrap val1;</code></pre>
</div>
<p>
このサンプルで val1 は int! です。その val1 を unwrap することで、
int! から int! に変換しています。
</p>
<p>
なお、次のように unwrap する値が nil だった場合、
そのプログラムは実行時エラーします。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">let val1:int! = nil;
let val2:int = unwrap val1;   // runtime error</code></pre>
</div>
<p>
unwrap は、変換対象の値が nil だった場合、実行時エラーします。
</p>
<p>
この実行時エラーを防ぐのが unwrap default です。
unwrap default は、変換対象の値が nil だった場合の値を指定します。
</p>
<p>
次は default を使用した例です。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">let val1:int! = nil;
let val2:int = unwrap val1 default 0;</code></pre>
</div>
<p>
この例では val1 は nil となるため、 default の 0 が unwrap の評価結果となります。
</p>
<p>
default のない unwrap の使用は、確実に nil ではないと判っている時のみにしてください。
</p>
<h3 id="headline-6">
when!
</h3>
<p>
when! は、指定の nilable 型の <strong>変数</strong> が nil かどうかを判定し、分岐します。
</p>
<p>
次に when! の例を示します。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">fn func( val:int!, val2:int! ): int {
   when! val, val2 {
      return val + val2;
   }
   else {
      return 0;
   }
}
print( func( 1, 2 ) );      // 3
print( func( nil, 2 ) );    // 0
print( func( 1, nil ) );    // 0
print( func( nil, nil ) );  // 0</code></pre>
</div>
<p>
この例では int! 型の val, val2 に対して when! で分岐しています。
</p>
<ul>
<li>
<p>
val と val2 が 非 nil の場合、 <code>return val + val2</code> を実行
</p>
</li>
<li>
<p>
val あるいは val2 が nil の場合、 return 0 を実行
</p>
</li>
</ul>
<p>
when! は、指定の変数全てが非 nil の時に、最初のブロックを実行します。
<strong>このブロック内では、指定変数は非 nilable の型となります。</strong>
</p>
<p>
when! に指定した変数のいずれかが nil だった場合、
else ブロックを実行します。
else は省略可能です。
</p>
<p>
なお、 when! に指定できるのは <strong>変数だけ</strong> です。 <strong>式は書けません。</strong>
</p>
<h3 id="headline-7">
if!
</h3>
<p>
if! は、指定の <strong>式</strong> が nil かどうかを判定し、分岐します。
</p>
<p>
次に if! の例を示します。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">fn func( val:int! ): int! {
   return val;
}
fn sub( val:int! ): int {
   if! func( val ) {
      return _exp + 10;
   }  
   else {
      return 0;
   }
}
print( sub( 1 ) ); // 11
print( sub( nil ) ); // 0</code></pre>
</div>
<p>
この例では func() に対して if! で分岐しています。
</p>
<ul>
<li>
<p>
func() が 非 nil の場合、 <code>return _exp + 10;</code> を実行
</p>
</li>
<li>
<p>
func() が nil の場合、 return 0 を実行
</p>
</li>
</ul>
<p>
if! は、指定の式が非 nil だった時に、最初のブロックを実行します。
このブロック内では、式の結果を <strong>_exp</strong> としてアクセスできます。
このとき、 _exp は <strong>非 nilable 型</strong> です。
</p>
<p>
if! に指定した式が nil だった場合、
else ブロックを実行します。
else は省略可能です。
</p>
<p>
ちなみに、 if! で指定した式が複数の値を返す場合、
最初の戻り値だけが対象です。
2 つ目以降の戻り値は無視します。
</p>
<p>
なお、 if! は次のようなネストは出来ません。
</p>
<p>
なぜならば、 内側の if! の _exp が、外側の if! の _exp によって、
shadowing されるためです。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">   if! func( val ) {
      if! func( val ) {
         return _exp + 10;
      }  
      else {
         return 0;
      }  
   }</code></pre>
</div>
<p>
これを防ぐためには、次の if! let を使用してください。
</p>
<h3 id="headline-8">
if! let
</h3>
<p>
if! let は、 if! で判定する式の結果を格納する変数名を指定可能なバージョンです。
</p>
<p>
次は if! let のサンプルです。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">fn func( val1:int!, val2:int! ): int!, int! {
   return val1, val2;
}
fn sub( val1:int!, val2:int! ): int {
   if! let work1, work2 = func( val1, val2 ) {
      return work1 + work2;
   }  
   else {
      return 0;
   }
}
print( sub( 1, 2 ) ); // 3
print( sub( nil, 2 ) ); // 0
print( sub( 1, nil ) ); // 0
print( sub( nil, nil ) ); // 0</code></pre>
</div>
<p>
この例では <code>if! let work1, work2 = func( val1, val2 )</code> を実行しています。
</p>
<p>
これは、 func() の結果を work1, work2 に代入し、
全てが非 nil だった場合に最初のブロックを実行します。
このブロック内では work1, work2 にアクセスできます。
work1, work2 は、 非 nilable 型となります。
if! let で宣言した変数のスコープは、最初のブロックです。
</p>
<p>
何れかが nilable の場合、else ブロックを実行します。
else は省略可能です。
</p>
<h3 id="headline-9">
let!
</h3>
<p>
let! は、nil 以外の初期値を持つ変数宣言を行ないます。
</p>
<p>
次に let! のサンプルを示します。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">fn func( val1:int!, val2:int! ): int!, int! {
   return val1, val2;
}
fn sub( val1:int!, val2:int! ): int {
   let mut work0 = 0;
   let! work1, work2 = func( val1, val2 ) {
      work1 = 0;
      work2 = 0;
   }
   then {
      work0 = 10;
   };     
   return work0 + work1 + work2;
}
print( sub( 1, 2 ) ); // 3
print( sub( nil, 2 ) ); // 0
print( sub( 1, nil ) ); // 0
print( sub( nil, nil ) ); // 0</code></pre>
</div>
<p>
この例では、 <code>let! work1, work2 = func( val1, val2 )</code> を実行しています。
</p>
<ul>
<li>
<p>
これは、 func() の結果を初期値とする work1, work2 を宣言しています。
</p>
</li>
<li>
<p>
work1, work2 <strong>いずれかが nil</strong> だった場合、最初のブロックを実行します。
</p>
</li>
<li>
<p>
全てが非 nil だった場合、then ブロックを実行します。 then は省略可能です。
</p>
</li>
</ul>
<p>
let の文には ; が必要です。
上記のサンプルでは、 then ブロック終端に <code>};</code> として ; を付加されています。
</p>
<p>
最初のブロックには、次のいずれかを処理しなければならない制限があります。
</p>
<ul>
<li>
<p>
let で宣言している変数全てに値を設定する。
</p>
</li>
<li>
<p>
let を宣言しているスコープから抜ける。
</p>
</li>
</ul>
<p>
上記の例では、 work1, work2 に値を設定していますが、
return でこの関数を抜けるようにしても OK です。
</p>
<p>
なお、上記制限が守られていない場合の動作は <strong>未定義</strong> です。
</p>
<h3 id="headline-10">
unwrap!
</h3>
<p>
unwrap! は、 let! に似た制御です。異なるのは変数を宣言するのではなく、
既にある変数に対して代入する点です。
</p>
<p>
次は、 unwrap! の例です。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">fn test( arg:int! ) {
  let mut val = 0;

  unwrap! val = arg { print( 0 ); return; } then { val = val + 1; };
  print( val );
}
test( 1 );  // print( 2 );
test( 2 );  // print( 3 );
test( nil );  // print( 0 );</code></pre>
</div>
<p>
上記例の val は、 int 型変数です。
この変数に、unwrap! を使って int! 型の arg を代入しています。
</p>
<p>
上記 <code>unwrap! val = arg { print( 0 ); return; } then { val = val + 1; };</code> は、
次の処理を行ないます。
</p>
<ul>
<li>
<p>
arg が nil の場合、 <code>{ print( 0 ); return; }</code> を実行する。
</p>
</li>
<li>
<p>
arg が非 nil の場合、 arg を val に代入する。さらに then ブロックを実行する。
</p>
</li>
<li>
<p>
then は省略可能です。
</p>
</li>
</ul>
<h2 id="headline-11">
マップ型のアクセス
</h2>
<p>
Map 型データの要素にアクセスした場合、
その結果は nilable となります。
</p>
<p>
たとえば次の場合、
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">let val = { &#34;abc&#34;: 1 };
let val2 = val.abc;</code></pre>
</div>
<p>
val2 は int ではなく、 int! となります。
</p>
<p>
なぜならば、 Map 型の要素が存在しない場合、
その評価結果は nil になるためです。
</p>
<p>
ちなみに、リスト、配列の要素アクセスは nilable にはなりません。
</p>
<div class="src src-lns">
<pre><code class="language-lns" data-lang="lns">let val = [ 1, 2, 3 ];
let val2 = val[ 1 ];</code></pre>
</div>
<p>
上の例では、 val2 は int! ではなく int になります。
</p>
<p>
なお、 val[ 4 ] にアクセスした場合の動作は <strong>未定義</strong> です。
</p>
<p>
リスト、配列にインデックスでアクセスする場合は、十分注意してください。
</p>
<p>
リスト、配列のインデックスアクセス結果が nilable になるようにも考えましたが、
やり過ぎな気がしたので実施していません。
</p>
<h2 id="headline-12">
まとめ
</h2>
<p>
LuneScript は、次の仕様によって nil 安全を実現しています。
</p>
<ul>
<li>
<p>
nilable と非 nilable
</p>
</li>
<li>
<p>
unwrap 
</p>
</li>
</ul>
<p>
次回はクラスについて説明します。
</p>
<div class="edit-meta">

<br></div><nav class="pagination"><a class="nav nav-prev" href="https://ifritjp.github.io/hugo/public/lunescript/nilcond/" title="nil 条件演算子 編"><i class="fas fa-arrow-left" aria-hidden="true"></i> Prev - nil 条件演算子 編</a>
<a class="nav nav-next" href="https://ifritjp.github.io/hugo/public/lunescript/require/" title="require/module 編">Next - require/module 編 <i class="fas fa-arrow-right" aria-hidden="true"></i></a>
</nav><footer><p class="powered">Powered by <a href="https://gohugo.io">Hugo</a>. Theme by <a href="https://themes.gohugo.io/hugo-theme-techdoc/">TechDoc</a>. Designed by <a href="https://github.com/thingsym/hugo-theme-techdoc">Thingsym</a>.</p>
</footer>
</main><div class="sidebar">

<nav class="open-menu">
<ul>
<li class=""><a href="https://ifritjp.github.io/hugo/public">Home</a></li>

<li class=""><a href="https://ifritjp.github.io/hugo/public/lua/">C/C&#43;&#43; 言語プログラマのための Lua 入門リファレンス</a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/hugo/public/lua/interface/">C インタフェース編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lua/detail/">C インタフェース詳細編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lua/anti-pattern/">Lua でやりがちなミス</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lua/pointer/">ポインタ編</a></li>
</ul>
  
</li>

<li class="parent"><a href="https://ifritjp.github.io/hugo/public/lunescript/">トランスコンパイラ LuneScript で Lua の開発をもっと楽に!!</a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/class2accessor/">accessor 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/box/">Box 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/enum/">enum 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/generics/">generics 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/tutorial3.hello/">Hello world</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/import/">import/provide 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/introduce2/">Lua のトランスコンパイラ LuneScript の紹介 2</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/introduce3/">Lua のトランスコンパイラ LuneScript の紹介 3</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/crosscompile/">Lua バージョン間のクロスコンパイル</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/classmapping/">mapping 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/match/">match 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/nilcond/">nil 条件演算子 編</a></li>
<li class="active"><a href="https://ifritjp.github.io/hugo/public/lunescript/nilable/">nilable 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/require/">require/module 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/set/">Set 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/tutorial1/">はじめに</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/completion/">イマドキな開発環境でもっと楽しよう</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/interface/">インタフェース 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/cast/">キャスト 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/classadvertise/">クラス advertise 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/classoverride/">クラス override 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/class1/">クラス 基本 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/classinherit/">クラス 継承 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/recommend/">トランスコンパイラ開発のすゝめ</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/make/">ビルド 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/macro/">マクロ 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/branch/">一般分岐構文 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/value/">値編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/arg/">可変長引数、戻り値 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/variable/">変数 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/multipleretval/">多値の戻り値</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/tutorial2.setup/">導入編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/defaultarg/">引数の省略 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/loop/">繰り返し構文 編</a></li>
<li class=""><a href="https://ifritjp.github.io/hugo/public/lunescript/func/">関数 編</a></li>
</ul>
  
</li>
</ul>
</nav>



<div class="sidebar-footer"></div>
</div>
</div><a href="#" id="backtothetop-fixed" class="backtothetop"
 data-backtothetop-duration="600"
 data-backtothetop-easing="easeOutQuart"
 data-backtothetop-fixed-fadeIn="1000"
 data-backtothetop-fixed-fadeOut="1000"
 data-backtothetop-fixed-bottom="10"
 data-backtothetop-fixed-right="20">
<span class="fa-layers fa-fw">
<i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i>
</span></a>
</div>
</body>
</html>
