<!DOCTYPE html>
<html lang="ja-jp">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>Go 入門 - 公開技術情報</title>
<meta name="generator" content="Hugo 0.71.1" />
<link href="https://ifritjp.github.io/documentsindex.xml" rel="alternate" type="application/rss+xml">
<link rel="canonical" href="https://ifritjp.github.io/documents/go/guide/">
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/theme.min.css">
<script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/custom.css">
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/chroma.min.css">
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js"></script>
<script src="https://ifritjp.github.io/documents/js/bundle.js"></script>
<script src="https://ifritjp.github.io/documents/js/lnsSrcRun.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-120218599-2"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-120218599-2');
</script>
<style>
:root {}
</style>
<meta property="og:title" content="Go 入門" />
<meta property="og:description" content="公式チュートリアルまとめ &lt;https://tour.golang.org/welcome/1&gt; 特徴 文の区切りに ; を使用しない 型の宣言はシンボル名の後 多値返却 型推論に対応(ただし、専用の宣言方法が必要) 変数のデ" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ifritjp.github.io/documents/go/guide/" />
<meta property="og:site_name" content="公開技術情報" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Go 入門"/>
<meta name="twitter:description" content="公式チュートリアルまとめ &lt;https://tour.golang.org/welcome/1&gt; 特徴 文の区切りに ; を使用しない 型の宣言はシンボル名の後 多値返却 型推論に対応(ただし、専用の宣言方法が必要) 変数のデ"/>
<meta itemprop="name" content="Go 入門">
<meta itemprop="description" content="公式チュートリアルまとめ &lt;https://tour.golang.org/welcome/1&gt; 特徴 文の区切りに ; を使用しない 型の宣言はシンボル名の後 多値返却 型推論に対応(ただし、専用の宣言方法が必要) 変数のデ">

<meta itemprop="wordCount" content="6860">



<meta itemprop="keywords" content="" /></head>
<body><div class="container"><header>
<h1>公開技術情報</h1>

</header>
<div class="global-menu">
<nav>
<ul>
<li><a href="/documents/">Home</a></li>
<li><a href="https://ifritjp.github.io/blog2/public/">blog</a></li>
<li><a href="https://ifritjp.github.io/LuneScript-webFront/contents/">LuneScript on Web</a></li></ul>
</nav>
</div>
<div class="content-container">
<main><h1>Go 入門</h1>

<h2 id="headline-1">
公式チュートリアルまとめ
</h2>
<p>
&lt;<a href="https://tour.golang.org/welcome/1">https://tour.golang.org/welcome/1</a>&gt;
</p>
<h3 id="headline-2">
特徴
</h3>
<ul>
<li>
<p>
文の区切りに <code class="verbatim">;</code> を使用しない
</p>
</li>
<li>
<p>
型の宣言はシンボル名の後
</p>
</li>
<li>
<p>
多値返却
</p>
</li>
<li>
<p>
型推論に対応(ただし、専用の宣言方法が必要)
</p>
</li>
<li>
<p>
変数のデフォルトは mutable
</p>
</li>
<li>
<p>
for 文などは、必ずブロックを持つ。
</p>
</li>
</ul>
<h3 id="headline-3">
関数
</h3>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
<span class="p">}</span></code></pre></div>
</div>
<p>
同じ型の引数が複数ある場合、最後以外の型宣言を省略できる。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span>
<span class="p">}</span></code></pre></div>
</div>
<h4 id="headline-4">
可変長引数
</h4>
<p>
可変長引数は次のように <code class="verbatim">...</code> を使って定義する。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">hoge1</span><span class="p">(</span> <span class="nx">vals</span> <span class="o">...</span><span class="kt">int</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span><span class="p">(</span> <span class="nx">vals</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span> <span class="s">&#34;%v &#34;</span><span class="p">,</span> <span class="nx">val</span> <span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">hoge1</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<p>
上記 hoge1 は、 int 型の値を複数指定してコールすることができる。
引数 vals は、 関数内で slice として処理できる。
</p>
<h5 id="headline-5">
可変長引数への slice 展開
</h5>
<p>
可変長引数に値を渡す場合、個別に値を指定する以外に、
slice の値を展開して渡すことも出来る。
</p>
<p>
次の例の <code class="verbatim">hoge1( 1, 2)</code> と <code class="verbatim">hoge( work... )</code> は、同じ結果となる。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">hoge1</span><span class="p">(</span> <span class="nx">vals</span> <span class="o">...</span><span class="kt">int</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span><span class="p">(</span> <span class="nx">vals</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span> <span class="s">&#34;%v &#34;</span><span class="p">,</span> <span class="nx">val</span> <span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">hoge1</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span>
    <span class="nx">work</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">}</span>
    <span class="nf">hoge1</span><span class="p">(</span> <span class="nx">work</span><span class="o">...</span> <span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<h4 id="headline-6">
多値返却
</h4>
<p>
多値返却をサポートする。
多値返却は <code class="verbatim">()</code> で括る。 <strong>これはタプルではない。</strong>
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">swap</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="kt">string</span><span class="p">,</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">x</span>
<span class="p">}</span></code></pre></div>
</div>
<p>
戻り値を関数宣言時に指定できる。
次の場合、宣言時に x, y を戻り値に指定し、関数本体では return だけを書いている。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">split</span><span class="p">(</span><span class="nx">sum</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">x</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">*</span> <span class="mi">4</span> <span class="o">/</span> <span class="mi">9</span>
	<span class="nx">y</span> <span class="p">=</span> <span class="nx">sum</span> <span class="o">-</span> <span class="nx">x</span>
	<span class="k">return</span>
<span class="p">}</span></code></pre></div>
</div>
<h4 id="headline-7">
多値返却による関数コール
</h4>
<p>
次のように、関数コールの引数に多値返却の値を使用できる。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gets</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">add</span><span class="p">(</span> <span class="nx">val1</span><span class="p">,</span> <span class="nx">val2</span> <span class="kt">int</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span> <span class="nx">val1</span> <span class="o">+</span> <span class="nx">val2</span> <span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">add</span><span class="p">(</span> <span class="nf">gets</span><span class="p">()</span> <span class="p">)</span> <span class="c1">// 1 + 2 = 3
</span><span class="c1"></span><span class="p">}</span></code></pre></div>
</div>
<p>
ただし、次の条件を全て満す必要がある。
</p>
<ul>
<li>
<p>
コールする関数の引数に渡す値は、多値返却の関数だけ
</p>
</li>
<li>
<p>
コールする関数の引数が可変長引数を含ない場合
</p>
<ul>
<li>
<p>
多値返却で返す値の数と、コールする関数の引数数が一致する
</p>
</li>
</ul>
</li>
<li>
<p>
コールする関数の引数に可変長引数を含む場合
</p>
<ul>
<li>
<p>
多値返却で返す値の数と、コールする関数の可変長引数以外の引数数が一致する
</p>
</li>
</ul>
</li>
</ul>
<p>
次の例では、 多値返却する gets() の戻り値を使用して
hoge1(), hoge2(), hoge3() をコールしている。
</p>
<ul>
<li>
<p>
hoge1() は、可変長引数のみ持つ。
</p>
</li>
<li>
<p>
hoge2() は、int 型の引数 1 つと可変長引数を持つ。
</p>
</li>
<li>
<p>
hoge2() は、int 型の引数 2 つと可変長引数を持つ。
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">gets</span><span class="p">()</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">hoge1</span><span class="p">(</span> <span class="nx">vals</span> <span class="o">...</span><span class="kt">int</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nf">test</span><span class="p">(</span> <span class="nx">vals</span> <span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">hoge2</span><span class="p">(</span> <span class="nx">val</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">vals</span> <span class="o">...</span><span class="kt">int</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nf">test</span><span class="p">(</span> <span class="nb">append</span><span class="p">(</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span> <span class="nx">val</span> <span class="p">},</span> <span class="nx">vals</span><span class="o">...</span> <span class="p">)</span> <span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">hoge3</span><span class="p">(</span> <span class="nx">val</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">val2</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">vals</span> <span class="o">...</span><span class="kt">int</span> <span class="p">)</span> <span class="p">{</span>
    <span class="nf">test</span><span class="p">(</span> <span class="nb">append</span><span class="p">(</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">val2</span> <span class="p">},</span> <span class="nx">vals</span><span class="o">...</span> <span class="p">)</span> <span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">hoge1</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span>
    <span class="nf">hoge1</span><span class="p">(</span> <span class="nf">gets</span><span class="p">()</span> <span class="p">)</span>

    <span class="nf">hoge2</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span>
    <span class="nf">hoge2</span><span class="p">(</span> <span class="nf">gets</span><span class="p">()</span> <span class="p">)</span>

    <span class="nf">hoge3</span><span class="p">(</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span>
    <span class="nf">hoge3</span><span class="p">(</span> <span class="nf">gets</span><span class="p">()</span> <span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">test</span><span class="p">(</span> <span class="nx">vals</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">val</span> <span class="o">:=</span> <span class="k">range</span><span class="p">(</span> <span class="nx">vals</span> <span class="p">)</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span> <span class="s">&#34;%v &#34;</span><span class="p">,</span> <span class="nx">val</span> <span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span> <span class="s">&#34;&#34;</span> <span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<p>
この例では、全て 1 2 を出力する。
</p>
<h4 id="headline-8">
関数 body 内の関数宣言
</h4>
<p>
次のような関数 body 内の関数宣言は出来ない。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">hoge</span><span class="p">()</span> <span class="p">{</span>
   <span class="kd">func</span> <span class="nf">sub</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="c1">// error
</span><span class="c1"></span>     <span class="k">return</span> <span class="mi">1</span>
   <span class="p">}</span>
   <span class="nb">print</span><span class="p">(</span> <span class="nf">sub</span><span class="p">()</span> <span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<p>
しかし、次のように anonymous 関数オブジェクトを変数に入れてコールすることは出来る。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">hoge</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">sub</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
     <span class="k">return</span> <span class="mi">1</span>
   <span class="p">}</span>
   <span class="nb">print</span><span class="p">(</span> <span class="nf">sub</span><span class="p">()</span> <span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<p>
ただこの場合、
hoge 関数コール毎にオブジェクトが作られて、実行性能が悪くなるようだ。
</p>
<p>
試しに次のようなコードを作成し、 Test() と Test2() の実行性能を比較すると、
Test2() の実行時間は Test() の 3 倍以上かかった。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">hoge</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">Test</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">hoge</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">Test2</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="nx">hoge2</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nf">hoge2</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
</div>
<p>
つまり、クロージャが目的で無いのなら、通常の関数宣言を行なうべき。
関数コール可能なスコープを制限するテクニックとして
関数 body 内部に関数を定義することがあるが、
パフォーマンスを考えるとそれは非推奨となる。
</p>
<p>
もちろん、パフォーマンスと可読性・メンテナンス性は
トレードオフになるケースがあるので、どちらを優先すべきかは状況次第である。
どちらにせよ、「パフォーマンスに影響がある」という知識を持っておくことは重要。
</p>
<h3 id="headline-9">
変数
</h3>
<p>
var で宣言する。
<strong>初期化していない場合の値はゼロ値で初期化される。</strong>
<strong>ゼロ値は型毎に決っている</strong>
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">python</span><span class="p">,</span> <span class="nx">java</span> <span class="kt">bool</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">i</span> <span class="kt">int</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">python</span><span class="p">,</span> <span class="nx">java</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<p>
初期化。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">python</span><span class="p">,</span> <span class="nx">java</span> <span class="p">=</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="s">&#34;no!&#34;</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">python</span><span class="p">,</span> <span class="nx">java</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<p>
<code>:=</code> を使って型推論。
ただし、これは関数内部でのみ有効。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span> <span class="p">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span>
	<span class="nx">k</span> <span class="o">:=</span> <span class="mi">3</span>
	<span class="nx">c</span><span class="p">,</span> <span class="nx">python</span><span class="p">,</span> <span class="nx">java</span> <span class="o">:=</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="s">&#34;no!&#34;</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span><span class="p">,</span> <span class="nx">k</span><span class="p">,</span> <span class="nx">c</span><span class="p">,</span> <span class="nx">python</span><span class="p">,</span> <span class="nx">java</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<h3 id="headline-10">
型
</h3>
<div class="src src-txt">
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">bool

string

int  int8  int16  int32  int64
uint uint8 uint16 uint32 uint64 uintptr

byte // uint8 の別名

rune // int32 の別名
     // Unicode のコードポイントを表す

float32 float64

complex64 complex128</code></pre></div>
</div>
<p>
int/uint のサイズは、処理系によって異なる。
サイズを限定する場合以外は int/uint の使用を推奨。
</p>
<h4 id="headline-11">
ゼロ値
</h4>
<p>
初期値を与えない変数の初期値。
</p>
<div class="src src-txt">
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">    数値型(int,floatなど): 0
    bool型: false
    string型: &#34;&#34; (空文字列( empty string ))</code></pre></div>
</div>
<h4 id="headline-12">
文字列
</h4>
<ul>
<li>
<p>
文字列は byte 列で、終端文字はない。その代わりに、長さ情報を持つ。
</p>
</li>
<li>
<p>
文字列データは immutable。
</p>
</li>
<li>
<p>
文字列 str の byte 長は len(str) で取得する。
</p>
</li>
<li>
<p>
str[ i ] は、 i 番目の byte データを取得する。
</p>
</li>
<li>
<p>
&amp;str[ i ] はアクセスできない。
</p>
</li>
<li>
<p>
文字列リテラルは <code class="verbatim">&#34;&#34;</code> と <code class="verbatim">``</code> を使用する。
</p>
</li>
<li>
<p>
<code class="verbatim">``</code> は、改行や \ のクオートを無視してそのまま文字列にする。
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="s">&#34;abc&#34;</span> <span class="c1">// abc
</span><span class="c1"></span><span class="s">`
</span><span class="s">\n`</span>    <span class="c1">// \n\\n
</span><span class="c1"></span><span class="s">&#34;\&#34;&#34;</span>  <span class="o">//</span> <span class="err">&#34;</span></code></pre></div>
</div>
<h4 id="headline-13">
型変換
</h4>
<p>
ある値 v を、型 T に変換する場合、 T(v) で変換する。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">i</span> <span class="o">:=</span> <span class="mi">42</span>
<span class="nx">f</span> <span class="o">:=</span> <span class="nb">float64</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>  <span class="c1">// &lt;- 42 を float64 に変換
</span><span class="c1"></span><span class="nx">u</span> <span class="o">:=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>     <span class="o">//</span> <span class="o">&lt;-</span> <span class="mi">42</span> <span class="nx">を</span> <span class="kt">uint</span> <span class="nx">に変換</span></code></pre></div>
</div>
<h4 id="headline-14">
Constant
</h4>
<p>
定数は Constant で変数を宣言する。
定数なので、当然初期値を設定する。
この初期値を使って型推論も行なうので、型宣言は不要。
なお、変数の型推論は関数内だけで有効だが、 Constant は関数外でも有効。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="nx">Pi</span> <span class="p">=</span> <span class="mf">3.14</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">const</span> <span class="nx">World</span> <span class="p">=</span> <span class="s">&#34;世界&#34;</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Hello&#34;</span><span class="p">,</span> <span class="nx">World</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Happy&#34;</span><span class="p">,</span> <span class="nx">Pi</span><span class="p">,</span> <span class="s">&#34;Day&#34;</span><span class="p">)</span>

	<span class="kd">const</span> <span class="nx">Truth</span> <span class="p">=</span> <span class="kc">true</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Go rules?&#34;</span><span class="p">,</span> <span class="nx">Truth</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<h5 id="headline-15">
数値の Constant
</h5>
<p>
数値型の範囲(64bit)では表現できない値も、 Constant であれば表現できる。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="c1">// Create a huge number by shifting a 1 bit left 100 places.
</span><span class="c1"></span>	<span class="c1">// In other words, the binary number that is 1 followed by 100 zeroes.
</span><span class="c1"></span>	<span class="nx">Big</span> <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">100</span>
	<span class="c1">// Shift it right again 99 places, so we end up with 1&lt;&lt;1, or 2.
</span><span class="c1"></span>	<span class="nx">Small</span> <span class="p">=</span> <span class="nx">Big</span> <span class="o">&gt;&gt;</span> <span class="mi">99</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">needInt</span><span class="p">(</span><span class="nx">x</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">x</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">}</span>
<span class="kd">func</span> <span class="nf">needFloat</span><span class="p">(</span><span class="nx">x</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">x</span> <span class="o">*</span> <span class="mf">0.1</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">needInt</span><span class="p">(</span><span class="nx">Small</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">needFloat</span><span class="p">(</span><span class="nx">Small</span><span class="p">))</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">needFloat</span><span class="p">(</span><span class="nx">Big</span><span class="p">))</span>
<span class="p">}</span></code></pre></div>
</div>
<h3 id="headline-16">
for
</h3>
<ul>
<li>
<p>
ほぼ C と同じ。
</p>
</li>
<li>
<p>
スコープは for ループで閉じる。
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">0</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">i</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">sum</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<p>
For の 3 つのループ制御ステートメントはそれぞれ省略可能。
これにより、 while/無限ループを表現する。
For で while と等価な表現ができるため、 go は while をサポートしない。
</p>
<p>
while と等価の for。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">sum</span> <span class="o">:=</span> <span class="mi">1</span>
	<span class="k">for</span> <span class="nx">sum</span> <span class="p">&lt;</span> <span class="mi">1000</span> <span class="p">{</span>
		<span class="nx">sum</span> <span class="o">+=</span> <span class="nx">sum</span>
	<span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">sum</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<p>
無限ループの for。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="p">{</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
</div>
<h3 id="headline-17">
if
</h3>
<ul>
<li>
<p>
<code class="verbatim">()</code> が無い
</p>
</li>
<li>
<p>
{} が必須
</p>
</li>
<li>
<p>
条件式の前に文を書ける。
</p>
<ul>
<li>
<p>
ここで宣言した変数は if と else のスコープ。
</p>
</li>
</ul>
</li>
<li>
<p>
else は、 if の <code class="verbatim">}</code> と同じ行に書かなければならない。
</p>
</li>
</ul>
<p>
次の場合はコンパイルエラー。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">val</span> <span class="p">{</span>
<span class="p">}</span>
<span class="k">else</span> <span class="p">{</span>
<span class="p">}</span></code></pre></div>
</div>
<p>
次のように <code class="verbatim">}</code> の行に else を書く。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">if</span> <span class="nx">val</span> <span class="p">{</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="p">}</span></code></pre></div>
</div>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">pow</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">lim</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">v</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Pow</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">n</span><span class="p">);</span> <span class="nx">v</span> <span class="p">&lt;</span> <span class="nx">lim</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">v</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">lim</span>
<span class="p">}</span></code></pre></div>
</div>
<h3 id="headline-18">
switch
</h3>
<ul>
<li>
<p>
switch は if/else のシンタックスシュガー。
</p>
</li>
<li>
<p>
条件文の前の文も書ける。
</p>
</li>
<li>
<p>
シンタックスシュガーなので、 case の各式は上から順に評価される。
</p>
</li>
<li>
<p>
C のような fall-through はない。
</p>
<ul>
<li>
<p>
break はなくても、一致した case/default を実行したら終わる。
</p>
</li>
</ul>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34;Go runs on &#34;</span><span class="p">)</span>
	<span class="k">switch</span> <span class="nx">os</span> <span class="o">:=</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">GOOS</span><span class="p">;</span> <span class="nx">os</span> <span class="p">{</span>
	<span class="k">case</span> <span class="s">&#34;darwin&#34;</span><span class="p">:</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;OS X.&#34;</span><span class="p">)</span>
	<span class="k">case</span> <span class="s">&#34;linux&#34;</span><span class="p">:</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Linux.&#34;</span><span class="p">)</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="c1">// freebsd, openbsd,
</span><span class="c1"></span>		<span class="c1">// plan9, windows...
</span><span class="c1"></span>		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%s.&#34;</span><span class="p">,</span> <span class="nx">os</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
</div>
<h4 id="headline-19">
switch の値を省略
</h4>
<p>
switch の値を省略すると switch true と同義。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
	<span class="k">switch</span> <span class="p">{</span>
	<span class="k">case</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Hour</span><span class="p">()</span> <span class="p">&lt;</span> <span class="mi">12</span><span class="p">:</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Good morning!&#34;</span><span class="p">)</span>
	<span class="k">case</span> <span class="nx">t</span><span class="p">.</span><span class="nf">Hour</span><span class="p">()</span> <span class="p">&lt;</span> <span class="mi">17</span><span class="p">:</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Good afternoon.&#34;</span><span class="p">)</span>
	<span class="k">default</span><span class="p">:</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;Good evening.&#34;</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
</div>
<h3 id="headline-20">
defer
</h3>
<ul>
<li>
<p>
関数コールを呼び出し元関数終了時に実行するように予約する。
</p>
<ul>
<li>
<p>
<strong>defer はブロック終了時ではなく、関数終了時に実行される</strong>
</p>
</li>
</ul>
</li>
<li>
<p>
関数コールの引数に与えている式は、 defer 評価時に実行される。
</p>
</li>
</ul>
<p>
次は hello hoge ではなく、hello world が表示される。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">txt</span> <span class="o">:=</span> <span class="s">&#34;world&#34;</span>
	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span> <span class="nx">txt</span> <span class="p">)</span>
	<span class="nx">txt</span> <span class="p">=</span> <span class="s">&#34;hoge&#34;</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<p>
defer の予約は、スタックに Push される。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;counting&#34;</span><span class="p">)</span>

	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;done&#34;</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<h3 id="headline-21">
ポインタ
</h3>
<ul>
<li>
<p>
値を格納しているポインタを扱える。
</p>
</li>
<li>
<p>
ただし、ポインタの演算はできない。
</p>
</li>
<li>
<p>
C++ の参照と考えれば良い。
</p>
</li>
<li>
<p>
ゼロ値は nil。
</p>
</li>
<li>
<p>
演算子は C と同じ。 &amp;val でポインタ取得。 *val でポインタが格納する値を取得。
</p>
</li>
<li>
<p>
C と同じで、構造体は値渡しとポインタ渡しで意味が異なる。
</p>
<ul>
<li>
<p>
値渡しはコピーされる。
</p>
</li>
</ul>
</li>
<li>
<p>
ポインタ型は 型名の前に * を付ける。 <code class="verbatim">*int</code> 等。
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="o">:=</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">2701</span>

	<span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">i</span>         <span class="c1">// point to i
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="c1">// read i through the pointer -- 42
</span><span class="c1"></span>	<span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="mi">21</span>         <span class="c1">// set i through the pointer
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>  <span class="c1">// see the new value of i   -- 21
</span><span class="c1"></span>
	<span class="nx">p</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">j</span>         <span class="c1">// point to j
</span><span class="c1"></span>	<span class="o">*</span><span class="nx">p</span> <span class="p">=</span> <span class="o">*</span><span class="nx">p</span> <span class="o">/</span> <span class="mi">37</span>   <span class="c1">// divide j through the pointer
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">j</span><span class="p">)</span> <span class="c1">// see the new value of j -- 73
</span><span class="c1"></span><span class="p">}</span></code></pre></div>
</div>
<h3 id="headline-22">
構造体
</h3>
<ul>
<li>
<p>
メンバアクセスは C と同じで <code class="verbatim">.</code> を使用する。
</p>
</li>
<li>
<p>
ただし、ポインタ経由のアクセス方法が異なる
</p>
<ul>
<li>
<p>
時に <code class="verbatim">-&gt;</code> は使用せず、 <code class="verbatim">.</code> を使用する。
</p>
</li>
<li>
<p>
(*p).val のようにも書けるが、 p.val と同義。
</p>
</li>
</ul>
</li>
<li>
<p>
Println は、構造体のデータを出力可能
</p>
</li>
<li>
<p>
構造体のポインタを Println すると、 &amp; を付加した
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Vertex</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">X</span> <span class="kt">int</span>
	<span class="nx">Y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">Vertex</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
	<span class="nx">p</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">v</span>
	<span class="nx">p</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="mf">1e9</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<h4 id="headline-23">
構造体リテラル
</h4>
<ul>
<li>
<p>
構造体の初期化データ。
</p>
</li>
<li>
<p>
メンバの初期化は宣言順に処理される。
</p>
</li>
<li>
<p>
初期値を与えないメンバは、ゼロ値で初期化される。
</p>
</li>
<li>
<p>
構造体リテラルのポインタも取れる。
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Vertex</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="p">(</span>
	<span class="nx">v1</span> <span class="p">=</span> <span class="nx">Vertex</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>  <span class="c1">// has type Vertex
</span><span class="c1"></span>	<span class="nx">v2</span> <span class="p">=</span> <span class="nx">Vertex</span><span class="p">{</span><span class="nx">X</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>  <span class="c1">// Y:0 is implicit
</span><span class="c1"></span>	<span class="nx">v3</span> <span class="p">=</span> <span class="nx">Vertex</span><span class="p">{}</span>      <span class="c1">// X:0 and Y:0
</span><span class="c1"></span>	<span class="nx">p</span>  <span class="p">=</span> <span class="o">&amp;</span><span class="nx">Vertex</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span> <span class="c1">// has type *Vertex
</span><span class="c1"></span><span class="p">)</span></code></pre></div>
</div>
<h3 id="headline-24">
配列
</h3>
<ul>
<li>
<p>
要素数固定のシーケンス。
</p>
</li>
<li>
<p>
要素数は、宣言時に指定する。
</p>
</li>
<li>
<p>
配列は <code class="verbatim">[N]T</code> として宣言する。ここで N は要素数、T は型。 
</p>
</li>
<li>
<p>
要素アクセスは 0 〜 N-1 まで。
</p>
</li>
<li>
<p>
範囲外アクセスはエラー
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="kt">string</span>
	<span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;Hello&#34;</span>
	<span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="s">&#34;World&#34;</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">a</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">)</span>

	<span class="nx">primes</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">primes</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<h4 id="headline-25">
スライス
</h4>
<ul>
<li>
<p>
スライスは、配列の一部を参照する。
</p>
</li>
<li>
<p>
スライスの型は <code class="verbatim">[]T</code> として宣言する。要は配列の N がない形になる。
</p>
</li>
<li>
<p>
スライスの要素アクセスは 0 〜。
</p>
</li>
<li>
<p>
範囲外アクセスはエラー
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">primes</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">}</span>

	<span class="kd">var</span> <span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">=</span> <span class="nx">primes</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<ul>
<li>
<p>
上記の primes[1:4] がスライス
</p>
</li>
<li>
<p>
ここで primes[1:4] は、 {3,5,7} を示す。 つまり 1 から (4-1) 番目まで。
</p>
</li>
<li>
<p>
参照元の配列の範囲内であっても、要素アクセスにマイナスは指定できない。
</p>
<ul>
<li>
<p>
例えば <code>s := primes[1:]</code> の時の <code>s[-1]</code> は NG。
</p>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<p>
スライスは参照なので、スライスの要素を変更すると、参照元の値も変更になる。
</p>
</li>
<li>
<p>
次の場合、スライス <code>s[1] = 0</code> しているが、これによって、 primes[ 2 ] が変わる。
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">primes</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">}</span>

	<span class="kd">var</span> <span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">=</span> <span class="nx">primes</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span> <span class="nx">primes</span> <span class="p">)</span>  <span class="c1">// [2 3 0 7 11 13]
</span><span class="c1"></span><span class="p">}</span></code></pre></div>
</div>
<h5 id="headline-26">
スライスの範囲
</h5>
<ul>
<li>
<p>
スライスの範囲は、省略できる。
</p>
</li>
<li>
<p>
省略した場合、最小、あるいは最大になる。
</p>
</li>
<li>
<p>
次の s1 〜 s4 は同じ範囲を示す。
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">primes</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">}</span>

	<span class="nx">s1</span> <span class="o">:=</span> <span class="nx">primes</span><span class="p">[</span> <span class="mi">0</span><span class="p">:</span> <span class="mi">6</span> <span class="p">]</span>
	<span class="nx">s2</span> <span class="o">:=</span> <span class="nx">primes</span><span class="p">[</span> <span class="p">:</span> <span class="mi">6</span> <span class="p">]</span>
	<span class="nx">s3</span> <span class="o">:=</span> <span class="nx">primes</span><span class="p">[</span> <span class="mi">0</span><span class="p">:</span> <span class="p">]</span>
	<span class="nx">s4</span> <span class="o">:=</span> <span class="nx">primes</span><span class="p">[</span> <span class="p">:</span> <span class="p">]</span>
<span class="p">}</span></code></pre></div>
</div>
<h5 id="headline-27">
スライスのスライス
</h5>
<ul>
<li>
<p>
スライスから更にスライスを作れる。
</p>
</li>
<li>
<p>
この場合、スライスの範囲は生成元スライスのインデックスを指定するが、
範囲の上限値は生成元スライスの上限値を越えて、
元の配列の最終要素に該当するインデックスまで指定できる。
</p>
<ul>
<li>
<p>
ただし下限値は 0 〜。 
</p>
</li>
</ul>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">13</span><span class="p">}</span>
	<span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> 
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span> <span class="nx">s</span> <span class="p">)</span>  <span class="c1">// [7 11]
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="nx">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="c1">// [11 13]
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span> <span class="nx">s</span> <span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<h5 id="headline-28">
スライスの len と cap
</h5>
<ul>
<li>
<p>
len は、スライスの要素数
</p>
</li>
<li>
<p>
cap は、次の式から得られる
</p>
</li>
</ul>
<pre class="example">
スライスが参照する元の配列の要素数 - スライスが先頭が参照する元の配列インデックス
</pre>
<ul>
<li>
<p>
つまり cap は、そのスライスを生成元にした新しいスライスの最大サイズ
</p>
</li>
</ul>
<h5 id="headline-29">
スライスのゼロ値
</h5>
<ul>
<li>
<p>
ゼロ値は nil
</p>
</li>
<li>
<p>
len( nil ) と cap( nil ) は 0
</p>
</li>
</ul>
<h5 id="headline-30">
多次元スライス
</h5>
<ul>
<li>
<p>
多次元のスライスを生成できる
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">board</span> <span class="o">:=</span> <span class="p">[][]</span><span class="kt">string</span><span class="p">{</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;o&#34;</span><span class="p">,</span> <span class="s">&#34;o&#34;</span><span class="p">,</span> <span class="s">&#34;o&#34;</span><span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;o&#34;</span><span class="p">,</span> <span class="s">&#34;o&#34;</span><span class="p">,</span> <span class="s">&#34;o&#34;</span><span class="p">},</span>
	<span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">&#34;o&#34;</span><span class="p">,</span> <span class="s">&#34;o&#34;</span><span class="p">,</span> <span class="s">&#34;o&#34;</span><span class="p">},</span>
<span class="p">}</span>
<span class="nb">print</span><span class="p">(</span> <span class="nx">board</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="p">)</span></code></pre></div>
</div>
<h5 id="headline-31">
スライスへの append
</h5>
<ul>
<li>
<p>
スライスは append によって、末尾に要素を追加できる
</p>
</li>
<li>
<p>
スライスの上限値によって、 append の動作が変わる
</p>
<ul>
<li>
<p>
スライスの上限値が参照元の配列より小さい場合
</p>
<ul>
<li>
<p>
参照元の配列の該当位置に append した値がセットされる
</p>
</li>
</ul>
</li>
<li>
<p>
スライスの上限値が参照元の配列と同じ場合
</p>
<ul>
<li>
<p>
append に必要な要素数分だけ拡張した参照元の配列のコピーが生成され、
それを参照するスライスが生成される
</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">ss</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">}</span>
	<span class="kd">var</span> <span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span> <span class="p">=</span> <span class="nx">ss</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span>
	<span class="nf">printSlice</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>

	<span class="c1">// ここでは、 ss[3] に 0 がセットされる
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> 
	<span class="nf">printSlice</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>

	<span class="c1">// ここで、ss のサイズ + α の配列が生成され、ss の内容がコピーされる
</span><span class="c1"></span>	<span class="c1">// + αが幾つになるかは？？？
</span><span class="c1"></span>	<span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> 
	<span class="nf">printSlice</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>

	<span class="c1">// ここで s[0] に代入しているが、参照元配列がコピーした物に
</span><span class="c1"></span>	<span class="c1">// 置き換わっているため当初の参照先の ss [0] は書き変わらない。
</span><span class="c1"></span>	<span class="nx">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">=</span> <span class="mi">10</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v&#34;</span><span class="p">,</span> <span class="nx">ss</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">printSlice</span><span class="p">(</span><span class="nx">s</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;len=%d cap=%d %v\n&#34;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span> <span class="nx">s</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<p>
上記の結果は次になる。
</p>
<div class="src src-txt">
<div class="highlight"><pre class="chroma"><code class="language-txt" data-lang="txt">len=3 cap=4 [1 2 3]
len=4 cap=4 [1 2 3 0]
len=5 cap=8 [1 2 3 0 1]
[1 2 3 0]</code></pre></div>
</div>
<h3 id="headline-32">
range
</h3>
<ul>
<li>
<p>
range は for ループで制御するイテレータ制御を行なう。
</p>
</li>
<li>
<p>
スライスを range で処理する場合、 要素の index, 要素のコピーを返す
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">pow</span> <span class="p">=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">128</span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">pow</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;2**%d = %d\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></div>
</div>
<ul>
<li>
<p>
range の戻り値は、格納先を <code class="verbatim">_</code> とすることで値を捨てられる。
</p>
</li>
<li>
<p>
<code class="verbatim">_</code> を使用することで、記述の省略が可能。
</p>
</li>
</ul>
<h3 id="headline-33">
map
</h3>
<ul>
<li>
<p>
map のゼロ値は nil
</p>
</li>
<li>
<p>
map 型の表現は次になる
</p>
<ul>
<li>
<p>
これは、キーが int、値が string の map
</p>
</li>
</ul>
</li>
</ul>
<pre class="example">
map[int]string
</pre>
<ul>
<li>
<p>
map リテラルは次になる。
</p>
</li>
</ul>
<pre class="example">
{ key1:val1, key2:val2, }
</pre>
<h4 id="headline-34">
map アクセス
</h4>
<ul>
<li>
<p>
m[key] = val
</p>
<ul>
<li>
<p>
map の key に val を設定
</p>
</li>
</ul>
</li>
<li>
<p>
val = m[key]
</p>
<ul>
<li>
<p>
map の key の要素を取得
</p>
</li>
</ul>
</li>
<li>
<p>
val, ret = m[key]
</p>
<ul>
<li>
<p>
map の key の要素を取得し、 key に対する要素の有無が ret に取得。
</p>
</li>
<li>
<p>
ret は bool
</p>
</li>
</ul>
</li>
<li>
<p>
delete( m, key )
</p>
<ul>
<li>
<p>
map の key の要素を削除
</p>
</li>
</ul>
</li>
</ul>
<h3 id="headline-35">
レシーバー
</h3>
<ul>
<li>
<p>
Rust のトレイトのような仕組み。
</p>
</li>
<li>
<p>
次は関数 Abs の Vertex 型のレシーバーを定義している。
</p>
</li>
<li>
<p>
レシーバーは構造体だけでなく全ての型に対して定義できる。
</p>
</li>
<li>
<p>
ただし、同じパッケージ内で定義している型でなければならない。
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Vertex</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="nx">Vertex</span><span class="p">)</span> <span class="nf">Abs</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Sqrt</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">X</span><span class="o">*</span><span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="o">+</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Y</span><span class="o">*</span><span class="nx">v</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">Vertex</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nf">Abs</span><span class="p">())</span>
<span class="p">}</span></code></pre></div>
</div>
<ul>
<li>
<p>
レシーバーの型は、ポインタで宣言しないとコピーが発生する。
</p>
<ul>
<li>
<p>
つまり、構造体のレシーバは通常ポインタ型で宣言する。
</p>
</li>
</ul>
</li>
<li>
<p>
次の Scale() は *Vertex 型で渡している。
これを Vertex に変更すると、Scale() 内で変更した結果は Scale() 呼び出し元には反映されない。
</p>
</li>
<li>
<p>
このとき Scale() 呼び出し側は、
レシーバの型が *Vertex と Vertex どちらでも呼び出し方は変わらない。
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Vertex</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">float64</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Vertex</span><span class="p">)</span> <span class="nf">Abs</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Sqrt</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">X</span><span class="o">*</span><span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="o">+</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Y</span><span class="o">*</span><span class="nx">v</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Vertex</span><span class="p">)</span> <span class="nf">Scale</span><span class="p">(</span><span class="nx">f</span> <span class="kt">float64</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="o">*</span> <span class="nx">f</span>
	<span class="nx">v</span><span class="p">.</span><span class="nx">Y</span> <span class="p">=</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Y</span> <span class="o">*</span> <span class="nx">f</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">Vertex</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>
	<span class="nx">v</span><span class="p">.</span><span class="nf">Scale</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nf">Abs</span><span class="p">())</span>
<span class="p">}</span></code></pre></div>
</div>
<ul>
<li>
<p>
非ポインタ型の値からポインタ型のレシーバをコールできるように、
ポインタ型の値から非ポインタ型のレシーバをコールできる。
</p>
</li>
</ul>
<h3 id="headline-36">
interface
</h3>
<ul>
<li>
<p>
レシーバの集りを定義したもの
</p>
</li>
<li>
<p>
次は、 Abs() レシーバを持つ Abser インタフェースを定義している
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Abser</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Abs</span><span class="p">()</span> <span class="kt">float64</span>
<span class="p">}</span></code></pre></div>
</div>
<ul>
<li>
<p>
次の <code>a = &amp;v</code> はコンパイルが通るが、 <code>a = v</code> はコンパイルエラーになる。
</p>
</li>
<li>
<p>
これは、 Abs() のレシーバが *Vertex であり、 Vertex ではないため。
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Abser</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">Abs</span><span class="p">()</span> <span class="kt">float64</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">a</span> <span class="nx">Abser</span>
	<span class="nx">v</span> <span class="o">:=</span> <span class="nx">Vertex</span><span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">}</span>

	<span class="nx">a</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">v</span> <span class="c1">// a *Vertex implements Abser
</span><span class="c1"></span>	<span class="nx">a</span> <span class="p">=</span> <span class="nx">v</span>

	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">a</span><span class="p">.</span><span class="nf">Abs</span><span class="p">())</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">Vertex</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">X</span><span class="p">,</span> <span class="nx">Y</span> <span class="kt">float64</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">v</span> <span class="o">*</span><span class="nx">Vertex</span><span class="p">)</span> <span class="nf">Abs</span><span class="p">()</span> <span class="kt">float64</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">math</span><span class="p">.</span><span class="nf">Sqrt</span><span class="p">(</span><span class="nx">v</span><span class="p">.</span><span class="nx">X</span><span class="o">*</span><span class="nx">v</span><span class="p">.</span><span class="nx">X</span> <span class="o">+</span> <span class="nx">v</span><span class="p">.</span><span class="nx">Y</span><span class="o">*</span><span class="nx">v</span><span class="p">.</span><span class="nx">Y</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<ul>
<li>
<p>
どの型が、どの interface を実装しているか宣言はしない
</p>
</li>
<li>
<p>
ある型 T が、ある interface I を実装できているかどうかは、
T 型のデータを I 型の変数に代入する時にコンパイルエラーするかどうかで判断する
</p>
</li>
</ul>
<h3 id="headline-37">
インタフェース型の値
</h3>
<ul>
<li>
<p>
インタフェース型の値は、レシーバの型をもつ。
</p>
</li>
<li>
<p>
次の T は、 *T でレシーバを定義しているため、 I の型は *T となる。
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">I</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">M</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">I2</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">M2</span><span class="p">()</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">S</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">M</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">S</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="nx">T</span><span class="p">)</span> <span class="nf">M2</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">S</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">T</span><span class="p">{</span><span class="s">&#34;Hello&#34;</span><span class="p">}</span>
	<span class="nf">describe</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">t</span><span class="p">)</span>
	<span class="nf">describe2</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">describe</span><span class="p">(</span><span class="nx">i</span> <span class="nx">I</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;(%v, %T)\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>  <span class="c1">// (&amp;{Hello}, *main.T)
</span><span class="c1"></span>	<span class="nx">i</span><span class="p">.</span><span class="nf">M</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">describe2</span><span class="p">(</span><span class="nx">i</span> <span class="nx">I2</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;(%v, %T)\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>  <span class="c1">// ({Hello}, main.T)
</span><span class="c1"></span>	<span class="nx">i</span><span class="p">.</span><span class="nf">M2</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
</div>
<h4 id="headline-38">
レシーバの値が nil だった場合の処理
</h4>
<p>
インタフェース型の変数が nil になるケースは次の 2 つある。
</p>
<ul>
<li>
<p>
変数を未初期化の場合
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">i</span> <span class="nx">IF</span></code></pre></div>
</div>
<ul>
<li>
<p>
変数に nil 値を持つ型をセットした場合
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">t</span> <span class="o">*</span><span class="nx">T</span>
<span class="kd">var</span> <span class="nx">i</span> <span class="nx">IF</span>
<span class="nx">i</span> <span class="p">=</span> <span class="nx">t</span></code></pre></div>
</div>
<p>
ただし、2番目の方は実際には nil ではない。
これは、インタフェースの値の持ち方から来ている。
インタフェースの値は、型情報の *T と nil をセット (*T,nil) を保持している。
よって、次に示すように <code>i == nil</code> は false となる。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">t</span> <span class="o">*</span><span class="nx">T</span>
<span class="kd">var</span> <span class="nx">i</span> <span class="nx">IF</span>
<span class="nx">i</span> <span class="p">=</span> <span class="nx">t</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span> <span class="nx">i</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">t</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">)</span> <span class="o">//</span> <span class="kc">false</span> <span class="kc">true</span></code></pre></div>
</div>
<ul>
<li>
<p>
上記の i のように、インタフェースの型が確定していて、
その型のオブジェクトが nil の場合、そのレシーバの関数はコールできる。
</p>
</li>
<li>
<p>
一般的なオブジェクト指向言語では、
nil オブジェクトのメソッドコールはランタイムエラーするが、
go では関数が実行される。
</p>
</li>
<li>
<p>
この時のレシーバの値は、 nil として関数が実行される。
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">I</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">M</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">type</span> <span class="nx">T</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">S</span> <span class="kt">string</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">)</span> <span class="nf">M</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// この t が nil となる
</span><span class="c1"></span>        <span class="k">if</span> <span class="nx">t</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
   	  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;nil&#34;</span><span class="p">)</span>
	  <span class="k">return</span>
	<span class="p">}</span>
 	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">S</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">t</span> <span class="o">*</span><span class="nx">T</span><span class="p">;</span>
	<span class="nf">describe</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">describe</span><span class="p">(</span><span class="nx">i</span> <span class="nx">I</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;(%v, %T)\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>  <span class="c1">// (&lt;nil&gt;, *main.T)
</span><span class="c1"></span>	<span class="nx">i</span><span class="p">.</span><span class="nf">M</span><span class="p">()</span>
<span class="p">}</span></code></pre></div>
</div>
<p>
上記のように型が確定しているインタフェースは型の値が nil でも関数コールされる。
一方で、型も確定していないゼロ値であるインタフェースを関数コールすると、
ランタイムエラーする。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">I</span> <span class="kd">interface</span> <span class="p">{</span>
	<span class="nf">M</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">i</span> <span class="nx">I</span>
	<span class="nf">describe</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
	<span class="nx">i</span><span class="p">.</span><span class="nf">M</span><span class="p">()</span>
<span class="p">}</span>
<span class="kd">func</span> <span class="nf">describe</span><span class="p">(</span><span class="nx">i</span> <span class="nx">I</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;(%v, %T)\n&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<h4 id="headline-39">
空のインタフェース
</h4>
<p>
関数を持たないインタフェースを空のインタフェースと呼ぶ。
この空のインタフェースは、全ての値を保持できる。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">interface</span> <span class="p">{}</span></code></pre></div>
</div>
<p>
func main() {
 var i interface{}
 i = 1
 i = &#34;abc&#34;
}
</p>
<h3 id="headline-40">
型アサーション
</h3>
<p>
インタフェースの値を、具体的な型に変換する。
</p>
<ul>
<li>
<p>
<code class="verbatim">i.(T)</code> を書き、インタフェースの値 i を T に変換する。
</p>
</li>
<li>
<p>
戻り値は 2 つあり、1つ目は T に変換した値、 2 つ目は変換が成功したかどうかの bool。
</p>
</li>
<li>
<p>
変換が失敗し、2 つ目の戻り値を変数に格納しなかった場合は panic する。
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">i</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">=</span> <span class="s">&#34;hello&#34;</span>

	<span class="nx">s</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>

	<span class="nx">s</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="kt">string</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="nx">ok</span><span class="p">)</span>

	<span class="nx">f</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="kt">float64</span><span class="p">)</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">ok</span><span class="p">)</span>

	<span class="nx">f</span> <span class="p">=</span> <span class="nx">i</span><span class="p">.(</span><span class="kt">float64</span><span class="p">)</span> <span class="c1">// panic
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">f</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<ul>
<li>
<p>
上記コードでは、空のインタフェース i に &#34;hello&#34; をセットしている。
</p>
</li>
<li>
<p>
次に i を string に変換する
</p>
<ul>
<li>
<p>
ここでは成功するので s は &#34;hello&#34; で、 ok は true が入る
</p>
</li>
</ul>
</li>
<li>
<p>
次に i を float64 に変換する
</p>
<ul>
<li>
<p>
ここでは失敗するので s は 0 で、ok は false が入る
</p>
</li>
</ul>
</li>
<li>
<p>
最後に i を float64 に変換し、 2 つ目の戻り値を格納していない
</p>
<ul>
<li>
<p>
ここでは panic する   
</p>
</li>
</ul>
</li>
</ul>
<h3 id="headline-41">
型 switch
</h3>
<p>
型情報で switch する。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">switch</span> <span class="nx">v</span> <span class="o">:=</span> <span class="nx">i</span><span class="p">.(</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
<span class="k">case</span> <span class="nx">T</span><span class="p">:</span>
    <span class="c1">// here v has type T
</span><span class="c1"></span><span class="k">case</span> <span class="nx">S</span><span class="p">:</span>
    <span class="c1">// here v has type S
</span><span class="c1"></span><span class="k">default</span><span class="p">:</span>
    <span class="c1">// no match; here v has the same type as i
</span><span class="c1"></span><span class="p">}</span></code></pre></div>
</div>
<h3 id="headline-42">
stringer インタフェース
</h3>
<p>
値を文字列表現で出力する際に使用する。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Stringer</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">String</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span></code></pre></div>
</div>
<h3 id="headline-43">
error インタフェース
</h3>
<p>
エラーを保持する。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="kt">error</span> <span class="kd">interface</span> <span class="p">{</span>
    <span class="nf">Error</span><span class="p">()</span> <span class="kt">string</span>
<span class="p">}</span></code></pre></div>
</div>
<p>
error が <strong>nil 以外</strong> のときエラーが発生している。
</p>
<h3 id="headline-44">
goroutine
</h3>
<p>
go が管理する軽量スレッド。   
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="k">go</span> <span class="nf">f</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span></code></pre></div>
</div>
<p>
f, x, y, z が、呼び出し元スレッドで評価され、
f の実行は新しいスレッドで実行される。
</p>
<p>
goroutine は、同じメモリ空間内で実行される。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">say</span><span class="p">(</span><span class="nx">s</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Millisecond</span><span class="p">)</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">s</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">go</span> <span class="nf">say</span><span class="p">(</span><span class="s">&#34;world&#34;</span><span class="p">)</span>
	<span class="nf">say</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">)</span>
<span class="p">}</span></code></pre></div>
</div>
<h3 id="headline-45">
channel
</h3>
<ul>
<li>
<p>
値の送受信を行なうための FIFO。
</p>
</li>
<li>
<p>
コピーした値を、送受信する。
</p>
<ul>
<li>
<p>
参照渡しする場合は、ポインタを送信する。
</p>
</li>
</ul>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ch</span> <span class="o">&lt;-</span> <span class="nx">v</span>    <span class="c1">// v をチャネル ch へ送信する
</span><span class="c1"></span><span class="nx">v</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span>  <span class="o">//</span> <span class="nx">ch</span> <span class="nx">から受信した変数を</span> <span class="nx">v</span> <span class="nx">へ割り当てる</span></code></pre></div>
</div>
<p>
int のチャネル型の生成。
デフォルトの場合、 0 個のバッファ。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">ch</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">)</span>
<span class="nx">ch2</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span></code></pre></div>
</div>
<h4 id="headline-46">
ブロック
</h4>
<ul>
<li>
<p>
<strong>送信処理は、バッファに空きがあればブロックしない。</strong>
</p>
</li>
<li>
<p>
<strong>受信処理は、データの送信が行なわれるまでブロックされる。</strong>
</p>
</li>
</ul>
<h4 id="headline-47">
close
</h4>
<ul>
<li>
<p>
チャネルの送信完了を明示するため close を呼ぶ。
</p>
</li>
<li>
<p>
close したチャネルへの送信は panic する。  
</p>
</li>
<li>
<p>
close された空のチャネルからデータを受信すると、そのデータ型のゼロ値が取得される。
</p>
</li>
<li>
<p>
close されていたかどうかは、次のように 2 つ目の戻り値を取得する
</p>
</li>
</ul>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="nx">v</span><span class="p">,</span> <span class="nx">ret</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">ch</span></code></pre></div>
</div>
<h3 id="headline-48">
select
</h3>
<ul>
<li>
<p>
対応する case の式がブロックしていない(ready)場合、その case を実行する。
</p>
</li>
<li>
<p>
全ての case の式がブロックしている場合、いずれかの式がブロック解除されるまで待つ。
</p>
<ul>
<li>
<p>
default がある場合、 default を実行する。
</p>
</li>
</ul>
</li>
<li>
<p>
複数の case の式が ready の場合、ランダムで実行する。
</p>
</li>
</ul>
<h3 id="headline-49">
Mutex
</h3>
<p>
排他制御を行なう。
</p>
<p>
sync.Mutex の Lock()/Unlock() を使用して排他区間を明示する。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">var</span> <span class="nx">lock</span> <span class="nx">sync</span><span class="p">.</span><span class="nx">Mutex</span>
<span class="nx">lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span> <span class="nx">lock</span> <span class="p">)</span>
<span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span></code></pre></div>
</div>
<h3 id="headline-50">
パッケージ
</h3>
<ul>
<li>
<p>
公開シンボルは大文字で始める。
</p>
</li>
</ul>
<h3 id="headline-51">
import
</h3>
<p>
パッケージをインポートする。
</p>
<div class="src src-go">
<div class="highlight"><pre class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="p">(</span>
  <span class="s">&#34;fmt&#34;</span>
  <span class="s">&#34;math&#34;</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="s">&#34;fmt&#34;</span>
<span class="kn">import</span> <span class="s">&#34;math&#34;</span></code></pre></div>
</div>
<div class="edit-meta">

<br></div><nav class="pagination"><a class="nav nav-prev" href="https://ifritjp.github.io/documents/go/package/" title="Go のパッケージ"><i class="fas fa-arrow-left" aria-hidden="true"></i> Prev - Go のパッケージ</a>
<a class="nav nav-next" href="https://ifritjp.github.io/documents/javascript/" title="Javascripts">Next - Javascripts <i class="fas fa-arrow-right" aria-hidden="true"></i></a>
</nav><footer><p class="powered">Powered by <a href="https://gohugo.io">Hugo</a>. Theme by <a href="https://themes.gohugo.io/hugo-theme-techdoc/">TechDoc</a>. Designed by <a href="https://github.com/thingsym/hugo-theme-techdoc">Thingsym</a>.</p>
</footer>
</main><div class="sidebar">

<nav class="slide-menu">
<ul>
<li class=""><a href="https://ifritjp.github.io/documents">Home</a></li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/lctags/">C/C&#43;&#43; ソースコードタグシステム lctags の紹介<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/lctags/enum/">C/C&#43;&#43; の enum 補完 by lctags on emacs</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/varsize/">C/C&#43;&#43; の変数サイズ確認 by lctags on emacs</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/highlight/">C/C&#43;&#43; の特定シンボルをハイライト by lctags on emacs</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/rename/">C/C&#43;&#43; ソースコードをリファクタリング by lctags on emacs (リネーム編)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/introduce/">C/C&#43;&#43; ソースコードタグシステム lctags の紹介</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/callgraph/">C言語/C&#43;&#43; コードを解析してインタラクティブなコールグラフ表示 by lctags</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/modulegraph/">C言語/C&#43;&#43; コードを解析してインタラクティブなモジュール構成図っぽいグラフ表示 by lctags</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/callfunc/">lctags で C 言語の関数コールを簡単に</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/register/">lctags のプロジェクト簡易登録</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/subroutine/">lctags を使って C/C&#43;&#43; ソースコードをリファクタリング(サブルーチン化編)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/c-language/">lctags を開発している時に改めて感じた C 言語規格のイケてないところ</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/windows/">Windows で lctags (C言語/C&#43;&#43; のタグジャンプ、コールグラフ、etc..)</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/lua/">C/C&#43;&#43; 言語プログラマのための Lua 入門リファレンス<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/lua/interface/">C インタフェース編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lua/detail/">C インタフェース詳細編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lua/fengari/">fengari の使い方 (Lua を Web ブラウザで動かす方法)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lua/anti-pattern/">Lua でやりがちなミス</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lua/lua5.4/">Lua5.4 の主な変更点</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lua/pointer/">ポインタ編</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/emacs/">Emacs<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/emacs/simple-httpd/">emacs 簡易 HTTPD 化パケージ simple-httpd.el</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/emacs/company-mode/">自作言語 (LuneScript) の emacs company-mode backend 設定</a></li>
</ul>
  
</li>

<li class=""><a href="https://ifritjp.github.io/documents/gcp/">Google Cloud Platform を使ってみる</a>
  
</li>

<li class="parent has-sub-menu"><a href="https://ifritjp.github.io/documents/go/">Gos<span class="mark opened">-</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/go/package/">Go のパッケージ</a></li>
<li class="active"><a href="https://ifritjp.github.io/documents/go/guide/">Go 入門</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/javascript/">Javascripts<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/javascript/d3force/">D3.js V4 forceSimulation のノード動的更新(追加・削除)</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/libclang/">Lua で C/C&#43;&#43; の構文解析 (libclang の Lua binding)<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/libclang/operator/">libclang で演算子を特定する方法</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/libclang/ast/">libclang の AST(Abstract Syntax Tree)</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/rust/">Rusts<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/rust/lifetime/">C/C&#43;&#43;エンジニアのための Rust のデータ所有権とライフタイム入門</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/singleboard/">Singleboards<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/singleboard/bluetooth-a2dp-receiver/">Raspberry Pi で Bluetooth レシーバー (オーディオ:A2DP) を作成するための設定方法解説</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/lunescript/">トランスコンパイラ LuneScript で Lua の開発をもっと楽に!!<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/tutorial1/">00. はじめに</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/tutorial2.setup/">01. 導入編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/tutorial3.hello/">02. Hello world</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/crosscompile/">03. Lua バージョン間のクロスコンパイル</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/value/">04. 値編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/set/">04.2. Set 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/enum/">05. enum 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/match/">06. match 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/variable/">07. 変数 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/branch/">08. 一般分岐構文 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/loop/">09. 繰り返し構文 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/func/">10. 関数 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/multipleretval/">10.2. 多値の戻り値</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/defaultarg/">10.3. 引数の省略 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/arg/">10.4. 可変長引数、戻り値 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/closure/">10.5. クロージャ</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/nilable/">11. nilable 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/class1/">12. クラス 基本 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/class2accessor/">13. accessor 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/classinherit/">14. クラス 継承 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/classadvertise/">15. クラス advertise 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/classoverride/">16. クラス override 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/interface/">17. インタフェース 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/classmapping/">18. mapping 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/generics/">19. generics 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/nilcond/">20. nil 条件演算子 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/import/">21. import/provide 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/require/">22. require/module 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/glue/">22.1. glue コードの半自動生成</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/lua/">22.2. Lua と連携 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/make/">23. ビルド 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/macro/">24. マクロ 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/cast/">25. キャスト 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/subfile/">26. subfile 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/reason/">A. Lua のトランスコンパイラ LuneScript を開発した理由</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/onweb/">A. Web ブラウザ上で動作する LuneScript</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/recommend/">A. トランスコンパイラ開発のすゝめ</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/completion/">A.イマドキな開発環境でもっと楽しよう</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/box/">Box 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/test/">X. 言語開発の品質コントロールにおけるセルフホスティングの重要性とテスト設計</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/go/">Z. Go 言語へのトランスコンパイル</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/all/">全文検索用結合ファイル</a></li>
</ul>
  
</li>
</ul>
</nav>



<div class="sidebar-footer"></div>
</div>
</div><a href="#" id="backtothetop-fixed" class="backtothetop"
 data-backtothetop-duration="600"
 data-backtothetop-easing="easeOutQuart"
 data-backtothetop-fixed-fadeIn="1000"
 data-backtothetop-fixed-fadeOut="1000"
 data-backtothetop-fixed-bottom="10"
 data-backtothetop-fixed-right="20">
<span class="fa-layers fa-fw">
<i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i>
</span></a>
</div>
</body>
</html>
