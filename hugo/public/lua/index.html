<!DOCTYPE html>
<html lang="ja-jp">
<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<title>C/C&#43;&#43; 言語プログラマのための Lua 入門リファレンス - 公開技術情報</title>
<meta name="generator" content="Hugo 0.100.1" />
<link href="https://ifritjp.github.io/documentsindex.xml" rel="alternate" type="application/rss+xml">
<link rel="canonical" href="https://ifritjp.github.io/documents/lua/">
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/theme.min.css">
<script src="https://use.fontawesome.com/releases/v5.0.6/js/all.js"></script>
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/chroma.min.css">
<script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery.easing@1.4.1/jquery.easing.min.js"></script>
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/custom.css">
<script src="https://ifritjp.github.io/documents/js/bundle.js"></script>
<script src="https://ifritjp.github.io/documents/js/lnsSrcRun.js"></script>
<script src="https://ifritjp.github.io/documents/js/highlight_lns.js"></script>
<link rel="stylesheet" href="https://ifritjp.github.io/documents/css/highlight_lns.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script><style>
:root {}
</style>
<meta property="og:title" content="C/C&#43;&#43; 言語プログラマのための Lua 入門リファレンス" />
<meta property="og:description" content="" />
<meta property="og:type" content="website" />
<meta property="og:url" content="https://ifritjp.github.io/documents/lua/" /><meta property="og:site_name" content="公開技術情報" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C/C&#43;&#43; 言語プログラマのための Lua 入門リファレンス"/>
<meta name="twitter:description" content=""/>
<meta itemprop="name" content="C/C&#43;&#43; 言語プログラマのための Lua 入門リファレンス">
<meta itemprop="description" content="">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4708B8S6ES"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-4708B8S6ES');
</script>
</head>
<body><div class="container"><header>
<h1>公開技術情報</h1>


[<a href="https://ifritjp.github.io/documents/en/">English</a>]

[<a href="https://ifritjp.github.io/documents/">Japanese</a>]

</header>
<div class="global-menu">
<nav>
<ul>
<li><a href="/documents/">Home</a></li>
<li><a href="https://ifritjp.github.io/blog2/public/">blog</a></li>
<li><a href="https://ifritjp.github.io/LuneScript-webFront/lnsc_web_frontend/for_fengari/">LuneScript on Web</a></li></ul>
</nav>
</div>
<div class="content-container">
<main><h1>C/C&#43;&#43; 言語プログラマのための Lua 入門リファレンス</h1>
<p>
これは、C/C++ 言語のプログラマがこれだけ読めば Lua スクリプトを問題なく書けるようになることを目的にしたドキュメントです。</p>
<p>
Lua から C 言語の呼び出し、 C 言語から Lua の呼び出しについては次を参照してください。</p>
<ul>
<li>C/C++ 言語プログラマのための Lua 入門リファレンス ( C インタフェース編 )</li>
</ul>
<p><a href="interface">interface</a></p>
<ul>
<li>C/C++ 言語プログラマのための Lua 入門リファレンス ( ポインタ編 )</li>
</ul>
<p><a href="pointer">pointer</a></p>
<p>
このドキュメントは Lua 5.2, 5.3 をターゲットにしています。</p>
<p>
Lua5.4 の差分については次を参照してください。</p>
<p>
<a href="lua5.4">lua5.4</a></p>
<p>
<strong>以降の記載について</strong></p>
<ul>
<li><strong>特に明記しない限り、C 言語と記載した場合は C/C++ 言語の両方を意味します。</strong></li>
<li><strong>特に Lua や C 等の言語を明記しない限り、Lua の仕様の説明です。</strong></li>
</ul>
<p>このドキュメントは次の情報を元に作成しています。
Lua で利用できる標準ライブラリの詳細は、次の公式 URL を参照してください。</p>
<ul>
<li><a href="http://www.lua.org/manual/5.3/manual.html">http://www.lua.org/manual/5.3/manual.html</a></li>
<li><a href="http://milkpot.sakura.ne.jp/lua/lua53_manual_ja.html">http://milkpot.sakura.ne.jp/lua/lua53_manual_ja.html</a></li>
</ul>
<p>Lua 初心者の方は、次の記事も是非確認してください。</p>
<ul>
<li>Lua でやりがちなミス</li>
</ul>
<p><a href="anti-pattern">anti-pattern</a></p>
<div id="outline-container-headline-1" class="outline-2">
<h2 id="headline-1">
トランスコンパイラ LuneScript
</h2>
<div id="outline-text-headline-1" class="outline-text-2">
<p>
<strong>TypeScript から Lua に変換する TypeScriptToLua があるので、基本的にはそちらを使った方が良いでしょう。</strong></p>
<p>
&lt;<a href="https://typescripttolua.github.io/">https://typescripttolua.github.io/</a>&gt;</p>
<hr>
<p>
Lua の説明に入る前に、トランスコンパイラ LuneScript を紹介します。</p>
<p>
LuneScript は次の特徴を持ち、
規模の大きい Lua スクリプトを作成する際の生産性を上げることが出来ます。</p>
<ul>
<li>NULL 安全 (null safety)。</li>
<li>静的型付け言語であるため、型チェックにより単純なミスをコンパイル時に発見可能。</li>
<li>型推論により、型宣言の手間を最小化。</li>
<li>generics により、型情報を保ったままの処理が可能。</li>
<li>言語の文法としてクラス定義を対応。</li>
<li>パターンマッチ対応。</li>
<li>遅延ロード対応。</li>
<li>構造化データと非構造化データとの相互変換。</li>
<li>マクロ により、ポリモーフィズム等の動的処理に頼らないデザインを実現可能。</li>
<li>Lua と go へのトランスコンパイル。</li>
<li>JSON と互換なデータ表現をサポート。</li>
<li>トランスコンパイルした Lua コードは、外部ライブラリを前提とせずに単体で動作可能。</li>
<li>トランスコンパイルした Lua コードは、LuneScript で書いた処理そのままが出力されるので、
性能劣化がない。</li>
<li>既存の Lua の外部モジュールを LuneScript から利用可能。</li>
<li>LuneScript は Lua 上で動作し、Lua 標準モジュール以外を必要としないため、導入が簡単。</li>
<li>LuneScript から変換した Lua モジュールを、 他の Lua モジュールから利用可能。</li>
<li>Lua5.1 〜 5.4 をサポート。</li>
<li>LuneScript はセルフホスティングで開発している。</li>
<li>emacs でのコード補完に対応</li>
<li>glue コードの自動生成に対応</li>
<li>Lua と C の syntax を基調としているため、学習コストが低い。</li>
</ul>
<p>
詳しくは、次の記事を参照してください。</p>
<p>
<a href="../lunescript">../lunescript</a></p>
<p>
イマドキのプログラム言語での開発経験を持つエンジニアには、
Lua で開発するよりも LuneScript で開発した方が馴染易い可能性があります。</p>
<p>
前置きはこの辺にして本題に戻ります。</p>
</div>
</div>
<div id="outline-container-headline-2" class="outline-2">
<h2 id="headline-2">
Lua の説明
</h2>
<div id="outline-text-headline-2" class="outline-text-2">
<p>
以降で Lua の各特徴について説明します。</p>
<div id="outline-container-headline-3" class="outline-3">
<h3 id="headline-3">
Lua と C との差分概要
</h3>
<div id="outline-text-headline-3" class="outline-text-3">
<p>
まず C 言語との差分概要をまとめると次のものが挙げられます。
もちろん実際にはもっと多くのものがあります。</p>
<ul>
<li>Native ではなく Lua VM 上で動作します。 (JIT が動作する実装もあります)</li>
<li>コンパイル不要です。(事前にバイトコード化することもできます)</li>
<li>数値は実数が基本です。(整数のビット演算も可能です)</li>
<li>文の区切り記号は ; ではありません。 ( ; も使えます )</li>
<li>main 関数は不要です。</li>
<li>ポインタ型はありません。</li>
<li>バイト配列は文字列として扱います。</li>
<li>配列のインデックスは 1 からです。</li>
<li>連想配列を持ちます。</li>
<li>構造体、共用体はありません。(テーブルを構造体と似たような使い方ができます)</li>
<li>ガーベジコレクション(GC)を搭載しています。</li>
<li>戻り値に複数の値を返せます。</li>
<li>コルーチンを使用できます。</li>
<li>typedef はありません。</li>
<li>#define 等のプリプロセッサはありません。  </li>
<li>言語仕様内にデバッグインタフェースを持ちます。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-4" class="outline-3">
<h3 id="headline-4">
Lua の実行
</h3>
<div id="outline-text-headline-4" class="outline-text-3">
<p>
Lua は、スクリプトを一旦 Lua VM 用のバイトコードに変換してから Lua VM 上で実行します。
ただし、スクリプトからバイトコードへの変換処理は Lua の内部的に行なわれるため、
ユーザが意識する必要はありません。</p>
<p>
C の様なコンパイル/リンク作業は不要です。</p>
<p>
VM 上で動作するため Native よりも実行速度は遅くなります。</p>
</div>
</div>
<div id="outline-container-headline-5" class="outline-3">
<h3 id="headline-5">
ガーベジコレクション
</h3>
<div id="outline-text-headline-5" class="outline-text-3">
<p>
Lua は、ガーベジコレクションを持っています。
参照されなくなった値は、自動的に解放されます。</p>
<p>
C の様に、メモリの解放を意識して行なう必要はありません。
ただし、不要になった値を参照していると解放されないので、
不要になった値は参照しないようにする必要があります。
例えば不要になった値は、その値を保持する変数に nil を上書きします。
これにより参照を無くせます。
ローカル変数であれば、
明示的に nil を代入しなくともローカル変数のスコープが外れることでも同じです。</p>
<p>
なお、オブジェクトが参照されなくなったタイミングと、
オブジェクトがガーベジコレクションで解放されるタイミングは一致しません。</p>
</div>
</div>
<div id="outline-container-headline-6" class="outline-3">
<h3 id="headline-6">
main 関数
</h3>
<div id="outline-text-headline-6" class="outline-text-3">
<p>
Lua には、多くのスクリプト言語と同様に main 関数というものはありません。
実行するファイルの先頭から順に実行されます。</p>
</div>
</div>
<div id="outline-container-headline-7" class="outline-3">
<h3 id="headline-7">
コメント
</h3>
<div id="outline-text-headline-7" class="outline-text-3">
<p>
<code>--</code> 以降はコメントになります。 C の // と同じ扱いです。
複数行をコメントにする場合は、 <code>--[[]]</code> を指定できます。
C の <code>/* */</code> と似た扱いです。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="c1">-- ここ以降はコメント</span>
</span></span><span class="line"><span class="cl"><span class="cm">--[[ここは
</span></span></span><span class="line"><span class="cl"><span class="cm">コメント]]</span></span></span></code></pre></div>
</div>
<p>
<code>[[]]</code> は、後述する文字列と同じで [=[ ]=] のパターンが利用できます。</p>
<p>
文字列中のコメント開始、終了文字は、文字列として扱われます。</p>
</div>
</div>
<div id="outline-container-headline-8" class="outline-3">
<h3 id="headline-8">
セミコロン(;)
</h3>
<div id="outline-text-headline-8" class="outline-text-3">
<p>
セミコロン(;) の意味が Lua と C で異なります。
C では文の区切りとしてセミコロン(;)を使用しますが、
Lua はセミコロン(;)そのものが「何もしない」文を示す【空文】となります。</p>
<p>
C と同じ感覚でセミコロン(;)を使用しても特に問題はありませんが、
無意味に利用するのは控えましょう。</p>
</div>
</div>
<div id="outline-container-headline-9" class="outline-3">
<h3 id="headline-9">
値
</h3>
<div id="outline-text-headline-9" class="outline-text-3">
<p>
Lua では、次の値を扱えます。</p>
<ul>
<li>nil</li>
<li>ブーリアン</li>
<li>数値</li>
<li>文字列</li>
<li>関数</li>
<li>ユーザーデータ</li>
<li>スレッド</li>
<li>テーブル </li>
</ul>
<div id="outline-container-headline-10" class="outline-4">
<h4 id="headline-10">
nil
</h4>
<div id="outline-text-headline-10" class="outline-text-4">
<p>
nil は他のどの値とも異なる特殊な値です。</p>
<p>
C で例えるなら NULL のようなものです。
C の NULL と異なるのは、
NULL は型がポインタであり、値が NULL であるのに対し、
nil は型が nil であり、値も nil であることです。</p>
</div>
</div>
<div id="outline-container-headline-11" class="outline-4">
<h4 id="headline-11">
ブーリアン
</h4>
<div id="outline-text-headline-11" class="outline-text-4">
<p>
true, false が定義されています。</p>
<p>
ただし、論理演算が true か false だけを返す訳ではありません。
詳しくは後述します。</p>
</div>
</div>
<div id="outline-container-headline-12" class="outline-4">
<h4 id="headline-12">
数値
</h4>
<div id="outline-text-headline-12" class="outline-text-4">
<p>
数値は全て符号付き実数です(Lua の環境によって整数の場合もある)。
C では char, short, int, long などのバイト長の違いや、
signed, unsigned の符号の有無の違いがありますが、
Lua では符号付き実数のみです。</p>
<p>
実数ですが、整数ビット演算が利用可能です。</p>
<p>
リテラルは、次のように 10 進数と 16 進数で指定できます。</p>
<ul>
<li>3</li>
<li>345</li>
<li>0xff</li>
<li>0xBEBADA</li>
</ul>
<p>また、実数は次のような指定が可能です。</p>
<ul>
<li>3.0</li>
<li>3.1416</li>
<li>314.16e-2</li>
<li>0.31416E1</li>
<li>34e1</li>
<li>0x0.1E</li>
<li>0xA23p-4</li>
<li>0X1.921FB54442D18P+1</li>
</ul>
</div>
</div>
<div id="outline-container-headline-13" class="outline-4">
<h4 id="headline-13">
文字列
</h4>
<div id="outline-text-headline-13" class="outline-text-4">
<p>
Lua の文字列は、C とは異なり &#39;\0&#39; で終端されていません。
なぜならば、Lua の文字列は全てのバイナリデータを格納できるためです。</p>
<p>
<em>終端文字があるということは、終端文字を複数持てないことと同義。</em></p>
<p>
&#39;\0&#39; で終端されていない代わりに、文字列データそのものがサイズ情報を保持しています。
サイズ情報には # でアクセスできます。</p>
<p>
例えば #&#34;abc&#34; は 3 になります。</p>
<p>
なお、Lua の文字列には文字コードの概念はありません。
単なるバイト列として扱われます。</p>
<p>
文字列は &#39; か &#34; で囲みます。
&#39; で囲む場合 &#34; を文字列中に含められます。
&#34; で囲む場合 &#39; を文字列中に含められます。</p>
<p>
文字列中には \xXX(Xは 16進数) や \ddd(Xは 10進数)で、
0〜255までの任意の値を指定できます。</p>
<p>
さらに \u{XXX}(X は1桁以上の16進数) で、マルチバイト文字を指定できます。</p>
<p>
文字列中に改行を含ませるには、次の方法があります。</p>
<ul>
<li>\n を利用する</li>
<li>\ の直後に改行する</li>
<li><code>[[]]</code> を利用する</li>
</ul>
<p><code>[[]]</code> は [=[]=] [==[]==] [===[]===] のように = を入れられます。</p>
<p>
<code>[[]]</code> で囲まれた文字列は \n 等のエスケープはそのままの文字列となります。</p>
<p>
なお、 <code>[[]]</code> の <code>[[</code> 直後にある改行は無視されます。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">str</span> <span class="o">=</span> <span class="s1">&#39;&#34;abc&#34;&#39;</span> <span class="c1">-- &#34;abc&#34;</span>
</span></span><span class="line"><span class="cl"><span class="n">str</span> <span class="o">=</span> <span class="s2">&#34;&#39;abc&#39;&#34;</span> <span class="c1">-- &#39;abc&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">str</span> <span class="o">=</span> <span class="s">[[
</span></span></span><span class="line"><span class="cl"><span class="s">&#34;&#39;abc&#39;&#34;
</span></span></span><span class="line"><span class="cl"><span class="s">]]</span> <span class="c1">-- &#34;&#39;abc&#39;&#34;\n</span>
</span></span><span class="line"><span class="cl"><span class="n">str</span> <span class="o">=</span> <span class="s">[=[[[abc]]]=]</span> <span class="c1">-- [[abc]]</span></span></span></code></pre></div>
</div>
<p>
文字列 str の N 番目の文字コードを取得する場合は、string.byte( str, N ) です。
N は 1 以上です。</p>
<p>
文字列は .. で連結できます。</p>
<p>
&#34;abc&#34; .. &#34;def&#34; は &#34;abcdef&#34; です。</p>
</div>
</div>
<div id="outline-container-headline-14" class="outline-4">
<h4 id="headline-14">
関数
</h4>
<div id="outline-text-headline-14" class="outline-text-4">
<p>
Lua は関数自体を値として扱えます。
ただし、C の関数ポインタのように他の型への型変換はできません。
関数はあくまで関数です。</p>
</div>
</div>
<div id="outline-container-headline-15" class="outline-4">
<h4 id="headline-15">
ユーザーデータ
</h4>
<div id="outline-text-headline-15" class="outline-text-4">
<p>
Lua は、主に C 言語をホストプログラムとして組込むことを想定した言語です。
ホストプログラムと連携して動作する場合、
ホストプログラムのデータを Lua の値にマッピングできない、
あるいはマッピングするためのオーバーヘッドが大きくなることがあります。
そのような場合に、ホストプログラムのデータを <strong>ユーザデータ</strong> として
そのまま Lua に渡すことができます。</p>
<p>
ただし Lua からは、ユーザデータはユーザデータとしてしかアクセスできません。</p>
<p>
ユーザデータに何が格納されているか、直接 Lua スクリプトからアクセスできません。</p>
</div>
</div>
<div id="outline-container-headline-16" class="outline-4">
<h4 id="headline-16">
スレッド
</h4>
<div id="outline-text-headline-16" class="outline-text-4">
<p>
ここでスレッドとは pthread 等で扱う OS の thread ではなく、Lua のコルーチンを指します。</p>
<p>
コルーチンは、プリエンプティブで処理を切り替える概念です。</p>
<p>
なお、Lua のコルーチンを複数作っても 1 つの OS の thread 上で動作します。</p>
</div>
</div>
<div id="outline-container-headline-17" class="outline-4">
<h4 id="headline-17">
テーブル
</h4>
<div id="outline-text-headline-17" class="outline-text-4">
<p>
テーブルは、配列と STL の map が一緒になったようなデータです。
テーブルには、nil 以外の全ての型のデータを格納できます。</p>
<p>
テーブルは、次のように {} で囲みます。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">tblA</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">&#34;1&#34;</span><span class="p">,</span> <span class="s2">&#34;2&#34;</span><span class="p">,</span> <span class="s2">&#34;3&#34;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">-- tblA[1] == &#34;1&#34;; tblA[2] == &#34;2&#34;; tblA[3] == &#34;3&#34;; tblA[4] == 4; tblA[5] == 5;</span></span></span></code></pre></div>
</div>
<p>
上記のテーブルの要素にアクセスする場合、インデックスは <strong>1</strong> からになります。
C 言語では 0 からなので、気を付ける必要があります。</p>
<p>
また、次のように数値以外のキーを指定することもできます。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">tblB</span> <span class="o">=</span> <span class="p">{</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bar</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span> <span class="s2">&#34;.hoge&#34;</span> <span class="p">]</span> <span class="o">=</span> <span class="mi">3</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="c1">-- tblB.foo == &#34;1&#34;; tblB.bar == &#34;2&#34;; tblB[&#34;.hoge&#34;] == &#34;3&#34;;</span></span></span></code></pre></div>
</div>
<p>
キーには nil(と NaN) 以外の全ての値を指定できます。</p>
<p>
数値以外のキーが指定されている場合、
tblB.foo のようにキーのシンボルを指定して要素にアクセスできます。
tblB[ &#34;foo&#34; ] としてもアクセス可能です。</p>
<p>
キーが . や = 等の文字を含んでいる場合は、
[ &#34;.&#34; ] や [ &#34;=&#34; ]  のように指定することでアクセスできます。</p>
<p>
なお、テーブルで保持するデータの全てのキーが 1 から順に 1 ずつ増えている場合(自然数)、
そのテーブルを <strong>シーケンス</strong> と呼びます。
数値以外のキーや、数値であっても 1 ずつ増えてない場合は、 <strong>シーケンス</strong> とは言いません。</p>
<p>
#table で、そのテーブルの要素数を返しますが、これはシーケンスの要素数を返します。
シーケンスでないテーブルの # は要素数を示しません。</p>
<p>
任意のテーブルがシーケンスかどうかを判定する方法は提供されていません。</p>
<p>
上記の例で言うと、#tblA は 5 を返しますが、#tblB は 3 になりません。</p>
<p>
存在していないキーにアクセスすると、nil を返します。</p>
<p>
上記の例では、 tblB.xyz は nil になります。</p>
<div id="outline-container-headline-18" class="outline-5">
<h5 id="headline-18">
テーブルコンストラクタ
</h5>
<div id="outline-text-headline-18" class="outline-text-5">
<p>
上記の様に {} を使用したテーブルの生成をテーブルコンストラクタと言います。</p>
<p>
このテーブルコンストタクタには、上記で説明した以外に一つ大きな特徴があります。</p>
<p>
その特徴とは、
最終要素がキーを指定しない式で、
その式の結果が関数呼び出しか可変長引数である場合、
その式が返す全ての値をテーブルに追加する、ことです。</p>
<p>
なお、これは最終要素の場合のみ有効です。</p>
<p>
この特徴は、可変長引数を持つ関数や、ラッパー関数を作成する際に有効になります。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="kr">function</span> <span class="nf">func</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="kr">return</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">func</span><span class="p">()</span> <span class="p">}</span> <span class="c1">-- { a, b, c, 1, 2, 3 }</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">func</span><span class="p">(),</span> <span class="n">d</span> <span class="p">}</span> <span class="c1">-- { a, b, c, 1, d }</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">func</span><span class="p">(),</span> <span class="kc">nil</span> <span class="p">}</span> <span class="c1">-- { a, b, c, 1 }</span></span></span></code></pre></div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-19" class="outline-3">
<h3 id="headline-19">
型情報
</h3>
<div id="outline-text-headline-19" class="outline-text-3">
<p>
type( value ) で、値 value の型情報を取得できます。
型情報は次のいずれかの文字列になります。</p>
<ul>
<li>&#34;nil&#34;</li>
<li>&#34;number&#34;</li>
<li>&#34;string&#34;</li>
<li>&#34;boolean&#34;</li>
<li>&#34;table&#34;</li>
<li>&#34;function&#34;</li>
<li>&#34;thread&#34;</li>
<li>&#34;userdata&#34; </li>
</ul>
</div>
</div>
<div id="outline-container-headline-20" class="outline-3">
<h3 id="headline-20">
変数
</h3>
<div id="outline-text-headline-20" class="outline-text-3">
<p>
Lua の変数は型を限定しません。
どのような値でも格納できます。
また、C89 のようにブロックの先頭に書く必要もありません。</p>
<p>
なお、値を代入する前の変数の値は nil となります。</p>
<div id="outline-container-headline-21" class="outline-4">
<h4 id="headline-21">
グローバル変数と、ローカル変数
</h4>
<div id="outline-text-headline-21" class="outline-text-4">
<p>
変数にはグローバル変数とローカル変数があります。</p>
<p>
ローカル変数の宣言は local を使用します。
local を使用しないとグローバル変数になります。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">globalA</span> <span class="o">=</span> <span class="mi">10</span>       <span class="c1">-- global </span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">localA</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1">-- local</span></span></span></code></pre></div>
</div>
<p>
ローカル変数のスコープは、ローカル変数宣言の次の文から有効で、
ブロックの終端で終わります。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">value</span> <span class="o">=</span> <span class="mi">10</span>               <span class="c1">-- global value = 10</span>
</span></span><span class="line"><span class="cl"><span class="kr">do</span>
</span></span><span class="line"><span class="cl">  <span class="kd">local</span> <span class="n">value</span> <span class="o">=</span> <span class="n">value</span>    <span class="c1">-- local value = global valule(10)</span>
</span></span><span class="line"><span class="cl">  <span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">+</span> <span class="mi">1</span>      <span class="c1">-- local value = 10 + 1 = 11</span>
</span></span><span class="line"><span class="cl">  <span class="n">print</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>         <span class="c1">-- local value: 11</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>           <span class="c1">-- global valule: 10</span></span></span></code></pre></div>
</div>
<p>
グローバル変数は、 _ENV テーブルに格納されます。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">value</span> <span class="o">=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="kr">if</span> <span class="n">value</span> <span class="o">==</span> <span class="n">_ENV.value</span> <span class="kr">then</span> <span class="c1">-- true</span>
</span></span><span class="line"><span class="cl">  <span class="n">print</span><span class="p">(</span> <span class="s2">&#34;equals&#34;</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span></span></span></code></pre></div>
</div>
<p>
なお、C でグローバル変数の利用を控えることが推奨されているように、
Lua でも特に理由がない限りローカル変数を使用するべきです。</p>
</div>
</div>
<div id="outline-container-headline-22" class="outline-4">
<h4 id="headline-22">
代入文
</h4>
<div id="outline-text-headline-22" class="outline-text-4">
<p>
Lua の代入は、1つの文で複数の値を代入できます。</p>
<p>
例えば次の文は、3 つの値を代入する同じ処理です。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">value1</span> <span class="o">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="n">value2</span> <span class="o">=</span> <span class="mi">2</span>
</span></span><span class="line"><span class="cl"><span class="n">value3</span> <span class="o">=</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">,</span> <span class="n">value3</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span></span></span></code></pre></div>
</div>
<p>
なお、代入先の変数に対して代入元の値の個数が足りない場合、
足りない分は nil が代入されます。
代入元の値が多い場合は無視されます。</p>
<p>
代入文でも、テーブルコンストラクタのように最終式が関数呼び出しか、
可変長式の場合は、その値全てが展開されます。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="kr">function</span> <span class="nf">func</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="kr">return</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">20</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="n">value1</span><span class="p">,</span> <span class="n">value2</span><span class="p">,</span> <span class="n">value3</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">func</span><span class="p">()</span> <span class="c1">-- value1 = 0, value2 = 10, value2 = 20</span></span></span></code></pre></div>
</div>
<p>
代入は、右辺の全ての値が評価され、その後それぞれの値が左辺に代入されます。</p>
<p>
例えば、X, Y の値を swap する場合、次のようにすることができます。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">X</span><span class="p">,</span><span class="n">Y</span> <span class="o">=</span> <span class="n">Y</span><span class="p">,</span><span class="n">X</span></span></span></code></pre></div>
</div>
<p>
なお、Lua の代入は、値を持ちません。
よって、次の C の様な代入はできません。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">int</span> <span class="n">value1</span> <span class="o">=</span> <span class="n">value2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span></span></span></code></pre></div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-23" class="outline-3">
<h3 id="headline-23">
制御文
</h3>
<div id="outline-text-headline-23" class="outline-text-3">
<p>
Lua には、次の制御文があります。</p>
<ul>
<li>if</li>
<li>while</li>
<li>repeat</li>
<li>for</li>
</ul>
<p>それぞれの条件式は、
false と nil が偽と扱われ、それ以外が真となります。</p>
<div id="outline-container-headline-24" class="outline-4">
<h4 id="headline-24">
if 文
</h4>
<div id="outline-text-headline-24" class="outline-text-4">
<p>
<strong>if</strong> exp <strong>then</strong> block {<strong>elseif</strong> exp <strong>then</strong> block} [ <strong>else</strong> block] <strong>end</strong></p>
<p>
Lua の if は上記構文です。</p>
<p>
次が C との差分です。</p>
<ul>
<li>条件式に () が不要</li>
<li>必ず end が必要</li>
<li>else if ではなく elseif がある  </li>
</ul>
</div>
</div>
<div id="outline-container-headline-25" class="outline-4">
<h4 id="headline-25">
while 文
</h4>
<div id="outline-text-headline-25" class="outline-text-4">
<p>
<strong>while</strong> exp <strong>do</strong> block <strong>end</strong></p>
<p>
Lua の while は上記構文です。</p>
<p>
次が C との差分です。</p>
<ul>
<li>条件式に () が不要</li>
<li>必ず end が必要</li>
</ul>
</div>
</div>
<div id="outline-container-headline-26" class="outline-4">
<h4 id="headline-26">
repeat 文
</h4>
<div id="outline-text-headline-26" class="outline-text-4">
<p>
<strong>repeat</strong> block <strong>until</strong> exp</p>
<p>
Lua の repeat は上記構文です。</p>
<p>
until の exp が真になるまで、block を繰り返します。</p>
<p>
なお、exp では block で宣言したローカル変数にアクセスできます。</p>
</div>
</div>
<div id="outline-container-headline-27" class="outline-4">
<h4 id="headline-27">
for 文
</h4>
<div id="outline-text-headline-27" class="outline-text-4">
<p>
for 文は 2 種類あります。</p>
<div id="outline-container-headline-28" class="outline-5">
<h5 id="headline-28">
<strong>for</strong> v <strong>=</strong> e1, e2 [, e3] <strong>do</strong> block <strong>end</strong>
</h5>
<div id="outline-text-headline-28" class="outline-text-5">
<p>
これは、次の C の for 文と似ています。</p>
<div class="src src-c">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="n">v</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="k">for</span> <span class="p">(</span> <span class="n">v</span> <span class="o">=</span> <span class="n">e1</span><span class="p">;</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="n">e2</span><span class="p">;</span> <span class="n">v</span> <span class="o">+=</span> <span class="n">e3</span> <span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span></span></span></code></pre></div>
</div>
<p>
しかし、次の点で大きく異なるため <strong>注意</strong> が必要です。</p>
<ul>
<li>
<p>e1, e2, e3 は、ループ開始前の一度だけ評価される</p>
<ul>
<li>つまり e2, e3 に関数や変数を指定しても、その値はループ中に変化しません。</li>
</ul>
</li>
<li>e3 を指定しない場合は 1 が使用される</li>
<li>v のスコープは for 文内のみ</li>
</ul>
</div>
</div>
<div id="outline-container-headline-29" class="outline-5">
<h5 id="headline-29">
<strong>for</strong> v <strong>in</strong> exp <strong>do</strong> block <strong>end</strong>
</h5>
<div id="outline-text-headline-29" class="outline-text-5">
<p>
これはイテレータを使用したループ制御です。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kr">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="kr">in</span> <span class="n">pairs</span><span class="p">(</span> <span class="n">tbl</span> <span class="p">)</span> <span class="kr">do</span>
</span></span><span class="line"><span class="cl">  <span class="n">print</span><span class="p">(</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span></span></span></code></pre></div>
</div>
<p>
上記のようにテーブル tbl の要素を列挙するような場合に利用します。</p>
<p>
exp は、次の値を返す式である必要があります。</p>
<p>
local func, param, prev = exp</p>
<p>
ここで func は、次の値を返すイテレータ関数です。</p>
<p>
local next_1, next_2, …, next_n = func( param, prev )</p>
<p>
ここで next_1 〜 next_n は、イテレータ関数で列挙する値の集合です。
上の pairs の例では、 key, value がそれにあたります。
n はイテレータ関数側によって定義します。
イテレータ関数 func は、prev が nil の場合に列挙する先頭の値の集合を返す必要があります。
for 文は、イテレータ関数 func が返す next_1 が nil の場合、ループを終了します。</p>
<p>
例えば 1, &#34;1&#34; : 2, &#34;2&#34; : 〜 : N, &#34;N&#34; を列挙する場合、次のように定義します。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="kr">function</span> <span class="nf">ite</span><span class="p">(</span> <span class="n">param</span><span class="p">,</span> <span class="n">prev</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="kr">if</span> <span class="n">prev</span> <span class="o">==</span> <span class="n">param</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">      <span class="kr">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">   <span class="kr">end</span>
</span></span><span class="line"><span class="cl">   <span class="kr">if</span> <span class="n">prev</span> <span class="o">==</span> <span class="kc">nil</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">      <span class="n">prev</span> <span class="o">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">   <span class="kr">end</span>
</span></span><span class="line"><span class="cl">   <span class="kd">local</span> <span class="n">next</span> <span class="o">=</span> <span class="n">prev</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">   <span class="kr">return</span> <span class="n">next</span><span class="p">,</span> <span class="n">string.format</span><span class="p">(</span> <span class="s2">&#34;%d&#34;</span><span class="p">,</span> <span class="n">next</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kr">for</span> <span class="n">value1</span><span class="p">,</span> <span class="n">value2</span>  <span class="kr">in</span> <span class="n">ite</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="kc">nil</span> <span class="kr">do</span>
</span></span><span class="line"><span class="cl">   <span class="n">print</span><span class="p">(</span> <span class="n">string.format</span><span class="p">(</span> <span class="s1">&#39;%d &#34;%s&#34;&#39;</span><span class="p">,</span>  <span class="n">value1</span><span class="p">,</span> <span class="n">value2</span> <span class="p">)</span> <span class="p">)</span> <span class="c1">-- 1, &#34;1&#34; : 2, &#34;2&#34; : 〜 : 10, &#34;10&#34;</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span></span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-30" class="outline-5">
<h5 id="headline-30">
pairs(), ipairs() 関数
</h5>
<div id="outline-text-headline-30" class="outline-text-5">
<p>
pairs(), ipairs() 関数は、 for 文でテーブルの要素を列挙するために利用する関数です。</p>
<p>
pairs() と ipairs() の差分を注意して使用する必要があります。</p>
<ul>
<li><strong>pairs() は、テーブルの全要素を列挙する。</strong></li>
<li><strong>ipairs() は、シーケンスの要素のみを対象に列挙する。</strong></li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-31" class="outline-4">
<h4 id="headline-31">
break 文
</h4>
<div id="outline-text-headline-31" class="outline-text-4">
<p>
Lua の break 文は、基本的に C 言語と同じです。</p>
<p>
break 文は、while, repeat, for 文のループを抜けます。</p>
<p>
ループが入れ子になっている場合は、最も内側のループを抜けます。</p>
</div>
</div>
<div id="outline-container-headline-32" class="outline-4">
<h4 id="headline-32">
continue 文
</h4>
<div id="outline-text-headline-32" class="outline-text-4">
<p>
Lua には continue がありません。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-33" class="outline-3">
<h3 id="headline-33">
ブロック
</h3>
<div id="outline-text-headline-33" class="outline-text-3">
<p>C の制御文は、ブロック文として宣言しないと 1 文しか処理対象になりませんでしたが、
Lua の制御文は必ずブロックを処理対象とし、終端に end を必要とします。</p>
<p>
よって、C の様に明示的にブロック文を使用することは滅多にありませんが、
ブロック文を明示することもできます。</p>
<p>
 <strong>do</strong> block <strong>end</strong> </p>
<p>
上記のように do end で囲んだ個所がブロックとなります。</p>
</div>
</div>
<div id="outline-container-headline-34" class="outline-3">
<h3 id="headline-34">
論理演算
</h3>
<div id="outline-text-headline-34" class="outline-text-3">
<p>
論理演算は次の 3 つです。</p>
<ul>
<li>not</li>
<li>or</li>
<li>and</li>
</ul>
<p>真、偽の扱いは条件式と同じで、false と nil が偽で、それ以外が真です。</p>
<div id="outline-container-headline-35" class="outline-4">
<h4 id="headline-35">
not
</h4>
<div id="outline-text-headline-35" class="outline-text-4">
<p>
not は真・偽を反転します。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="ow">not</span> <span class="kc">false</span> <span class="c1">-- true</span>
</span></span><span class="line"><span class="cl"><span class="ow">not</span> <span class="kc">nil</span> <span class="c1">-- true</span>
</span></span><span class="line"><span class="cl"><span class="ow">not</span> <span class="kc">true</span> <span class="c1">-- false</span>
</span></span><span class="line"><span class="cl"><span class="ow">not</span> <span class="mi">1</span> <span class="c1">-- false</span></span></span></code></pre></div>
</div>
<p>
必ず true か false になります。</p>
</div>
</div>
<div id="outline-container-headline-36" class="outline-4">
<h4 id="headline-36">
or
</h4>
<div id="outline-text-headline-36" class="outline-text-4">
<p>
or は真になるまで値を評価します。
or の結果は、真になるまで最終的に評価した値です。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kc">nil</span> <span class="ow">or</span> <span class="kc">false</span> <span class="ow">or</span> <span class="mi">1</span> <span class="c1">-- 1</span>
</span></span><span class="line"><span class="cl"><span class="kc">nil</span> <span class="ow">or</span> <span class="mi">2</span> <span class="ow">or</span> <span class="mi">3</span> <span class="c1">-- 2</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span> <span class="ow">or</span> <span class="mi">5</span> <span class="c1">-- 4</span>
</span></span><span class="line"><span class="cl"><span class="kc">nil</span> <span class="ow">or</span> <span class="kc">false</span> <span class="c1">-- false</span></span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-37" class="outline-4">
<h4 id="headline-37">
and
</h4>
<div id="outline-text-headline-37" class="outline-text-4">
<p>
and は、偽になるまで値を評価します。
and の結果は、偽になるまで最終的に評価した値です。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="mi">1</span> <span class="ow">and</span> <span class="mi">2</span> <span class="ow">and</span> <span class="mi">3</span> <span class="ow">and</span> <span class="kc">nil</span> <span class="c1">-- nil</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="ow">and</span> <span class="mi">2</span> <span class="ow">and</span> <span class="mi">3</span> <span class="c1">-- 3</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span> <span class="ow">and</span> <span class="kc">false</span> <span class="ow">and</span> <span class="mi">2</span> <span class="c1">-- false</span></span></span></code></pre></div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-38" class="outline-3">
<h3 id="headline-38">
関係演算
</h3>
<div id="outline-text-headline-38" class="outline-text-3">
<p>関係演算は次のものを利用できます。
~= 以外は C と同じです。</p>
<ul>
<li>
<p>==</p>
<ul>
<li>等しい</li>
</ul>
</li>
<li>
<p>~=</p>
<ul>
<li>等しくない</li>
</ul>
</li>
<li>
<p>&lt;</p>
<ul>
<li>より小さい</li>
</ul>
</li>
<li>
<p><code>&gt;</code></p>
<ul>
<li>より大きい</li>
</ul>
</li>
<li>
<p>&lt;=</p>
<ul>
<li>小さいまたは等しい</li>
</ul>
</li>
<li>
<p><code>&gt;=</code></p>
<ul>
<li>大きいまたは等しい</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-39" class="outline-3">
<h3 id="headline-39">
算術演算
</h3>
<div id="outline-text-headline-39" class="outline-text-3">
<p>
算術演算は次のものを利用できます。
除算と累乗以外は C と同じです。</p>
<ul>
<li>
<p><code>+</code></p>
<ul>
<li>加算</li>
</ul>
</li>
<li>
<p><code>-</code></p>
<ul>
<li>減算</li>
</ul>
</li>
<li>
<p><code>*</code></p>
<ul>
<li>乗算</li>
</ul>
</li>
<li>
<p><code>/</code></p>
<ul>
<li>浮動小数点数除算</li>
</ul>
</li>
<li>
<p><code>//</code></p>
<ul>
<li>切り捨て除算 <strong>5.2 は非サポート</strong></li>
</ul>
</li>
<li>
<p><code>%</code></p>
<ul>
<li>剰余</li>
</ul>
</li>
<li>
<p><code>^</code></p>
<ul>
<li>累乗</li>
</ul>
</li>
<li>
<p><code>-</code></p>
<ul>
<li>単項マイナス</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-40" class="outline-3">
<h3 id="headline-40">
ビット演算
</h3>
<div id="outline-text-headline-40" class="outline-text-3">
<p>
ビット演算を行なう場合、値は 32bit の整数に丸められてから演算が行なわれます。</p>
<p>
また、Lua のバージョン 5.2 と 5.3 とで、ビット演算の仕様が大きく代わります。</p>
<ul>
<li>
<p>利用方法</p>
<ul>
<li>5.2 では bit 演算用パッケージ bit32 の関数を利用する必要があります。</li>
<li>5.3 では C と同様に bit 演算用の演算子を利用できます。</li>
</ul>
</li>
<li>
<p>右シフト</p>
<ul>
<li>5.2 では算術シフトです。(最上位ビットがコピーされる)</li>
<li>5.3 では論理シフトです。(最上位ビットには 0 が入る)</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-headline-41" class="outline-3">
<h3 id="headline-41">
関数
</h3>
<div id="outline-text-headline-41" class="outline-text-3">
<p>
C の関数は、必ず名前(シンボル)が紐付いていますが、   
Lua の関数は名前に紐付いているとは限りません。</p>
<p>
C の関数は、関数ポインタを関数ポインタ型の変数に代入して、
その変数から関数を呼び出すことができます。
Lua の場合は、C の関数ポインタ変数から関数を実行するような使い方になります。</p>
<p>
Lua の関数を保持する変数は、単なる変数なので後から別の値(関数)を代入することが
可能です。もちろん関数でない値を代入することも可能です。</p>
<p>
また、変数なのでグローバルと local があります。</p>
<div id="outline-container-headline-42" class="outline-4">
<h4 id="headline-42">
定義
</h4>
<div id="outline-text-headline-42" class="outline-text-4">
<p>
次の定義方法があります。</p>
<ul>
<li>name = <strong>function(</strong> args <strong>)</strong> block <strong>end</strong></li>
<li><strong>local</strong> name; name = <strong>function(</strong> args <strong>)</strong> block <strong>end</strong></li>
</ul>
<p>1 番目がグローバル関数で、 2 番目がローカル関数です。
name が関数名、args は引数、block は関数の処理です。
args は 0 個以上の変数です。
また、args は関数内がスコープになるローカル変数となります。</p>
<p>
function() end が関数オブジェクトを返す式であることは分かると思います。
その関数オブジェクトをグローバル変数に代入するか、ローカル変数に代入するかで、
その関数がグローバル関数になるかローカル関数になるかが決まります。</p>
<p>
local 関数の場合、変数に代入する前に local 変数の宣言をしています。
これは、再帰呼び出しを行なう際に、その関数自身を呼ぶことを保証するためです。</p>
<p>
なお、関数定義は次のようにも書けます。</p>
<ul>
<li><strong>function</strong> name <strong>(</strong> args <strong>)</strong> block <strong>end</strong></li>
<li>local <strong>function</strong> name <strong>(</strong> args <strong>)</strong> block <strong>end</strong></li>
</ul>
<p>これは上記と全く同じ意味を持ちます。</p>
<p>
特に理由がない限り、関数定義は後者の書式で書いた方が良いでしょう。</p>
</div>
</div>
<div id="outline-container-headline-43" class="outline-4">
<h4 id="headline-43">
関数呼び出し
</h4>
<div id="outline-text-headline-43" class="outline-text-4">
<p>
関数オブジェクトに () を付けることによって関数が実行されます。
() には、引数を与えます。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="kr">function</span> <span class="nf">func</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="kr">return</span> <span class="n">value</span> <span class="o">+</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="s2">&#34;value = &#34;</span><span class="p">,</span> <span class="n">func</span><span class="p">(</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span> <span class="c1">-- 2</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="s2">&#34;value = &#34;</span><span class="p">,</span> <span class="p">(</span><span class="kr">function</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="kr">return</span> <span class="n">value</span> <span class="o">+</span> <span class="mi">2</span> <span class="kr">end</span><span class="p">)(</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="c1">-- 3</span></span></span></code></pre></div>
</div>
<p>
上記 5 行目のように、 <strong>function()</strong> body <strong>end</strong> で取得した関数オブジェクトに
直接 () を付けても実行できます。</p>
<p>
関数呼び出し時に与えた引数の数と、
関数オブジェクトで定義した引数の数に違いがある場合は、
代入文で説明した通り足りない場合は nil を設定、多い場合は無視されます。</p>
<p>
このような動作になるため、C++ のオーバーロードの概念は Lua にはありません。</p>
</div>
</div>
<div id="outline-container-headline-44" class="outline-4">
<h4 id="headline-44">
可変長引数
</h4>
<div id="outline-text-headline-44" class="outline-text-4">
<p>
Lua は、C の printf のような可変長の引数を持つ関数を定義することができます。</p>
<p>
<strong>function(</strong> … <strong>)</strong></p>
<p>
上記のように引数の宣言部に … を記載することで、そこは可変長引数になります。</p>
<p>
可変長引数は、次のようにそのまま … を指定することで与えられた引数を表現できます。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="kr">function</span> <span class="nf">log</span><span class="p">(</span> <span class="p">...</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="kr">if</span> <span class="n">enableLogFlag</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">    <span class="n">print</span><span class="p">(</span> <span class="p">...</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="n">log</span><span class="p">(</span> <span class="s2">&#34;test&#34;</span><span class="p">,</span> <span class="s2">&#34;hoge&#34;</span> <span class="p">)</span> <span class="c1">-- print( &#34;test&#34;, &#34;hoge&#34; )</span></span></span></code></pre></div>
</div>
<p>
return … で、可変長引数をそのまま返すこともできます。</p>
<p>
… に何が与えられているのかを調べたい場合は、
{…} で、その可変長引数を要素に持つテーブルを生成できるので、
テーブルを作成した後でそのテーブルに対して操作することで
可変長引数の要素にアクセスできます。</p>
<p>
なお、これは上記のテーブルコンストラクタで説明した通り
最終要素のみの特徴であるため、
次の場合は可変長引数の先頭要素だけを持つテーブルが生成されます。</p>
<p>
{…,nil}</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="kr">function</span> <span class="nf">log</span><span class="p">(</span> <span class="p">...</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="kd">local</span> <span class="n">val1</span> <span class="o">=</span> <span class="p">{...}</span>
</span></span><span class="line"><span class="cl">  <span class="n">print</span><span class="p">(</span> <span class="n">val1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">val1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span> <span class="c1">-- &#34;test&#34; &#34;hoge&#34;</span>
</span></span><span class="line"><span class="cl">  <span class="kd">local</span> <span class="n">val2</span> <span class="o">=</span> <span class="p">{...,</span><span class="kc">nil</span><span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="n">print</span><span class="p">(</span> <span class="n">val2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">val2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span> <span class="c1">-- &#34;test&#34; nil</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="n">log</span><span class="p">(</span> <span class="s2">&#34;test&#34;</span><span class="p">,</span> <span class="s2">&#34;hoge&#34;</span> <span class="p">)</span></span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-45" class="outline-4">
<h4 id="headline-45">
return
</h4>
<div id="outline-text-headline-45" class="outline-text-4">
<p>
関数を終了し、戻り値を返します。</p>
<p>
なお、関数は戻り値を複数個返すことができます。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="kr">function</span> <span class="nf">func</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="kr">return</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">,</span> <span class="n">val3</span> <span class="o">=</span> <span class="n">func</span><span class="p">()</span> <span class="c1">-- val1 = 1, val2 = 2, val3 = 3</span></span></span></code></pre></div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-46" class="outline-3">
<h3 id="headline-46">
オブジェクト指向プログラミング
</h3>
<div id="outline-text-headline-46" class="outline-text-3">
<p>
Lua では、テーブルを利用することでオブジェクト指向プログラミングができます。</p>
<p>
ただし、C++ の private, protected のようなアクセス制御 <del>や、継承</del> はできません。</p>
<div id="outline-container-headline-47" class="outline-4">
<h4 id="headline-47">
定義
</h4>
<div id="outline-text-headline-47" class="outline-text-4">
<div id="outline-container-headline-48" class="outline-5">
<h5 id="headline-48">
クラス定義
</h5>
<div id="outline-text-headline-48" class="outline-text-5">
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">classA</span> <span class="o">=</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">function</span> <span class="nc">classA</span><span class="p">:</span><span class="nf">func</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="kr">return</span> <span class="n">self.value</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="n">classA</span><span class="p">:</span><span class="n">func</span><span class="p">()</span> <span class="c1">-- 0</span></span></span></code></pre></div>
</div>
<p>
上記の定義で、classA に func メソッドを定義しています。</p>
<p>
ここで self は、func() を保持しているテーブルそのものを示します。
C++ の this と同じです。</p>
<p>
メソッド、メンバは複数持てます。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">classA</span> <span class="o">=</span> <span class="p">{</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">1</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">function</span> <span class="nc">classA</span><span class="p">:</span><span class="nf">getTotal</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="kr">return</span> <span class="n">self.total</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kr">function</span> <span class="nc">classA</span><span class="p">:</span><span class="nf">add</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">  <span class="n">self.total</span> <span class="o">=</span> <span class="n">self.total</span> <span class="o">+</span> <span class="n">self.value</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kr">function</span> <span class="nc">classA</span><span class="p">:</span><span class="nf">setValue</span><span class="p">(</span> <span class="n">val</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">self.value</span> <span class="o">=</span> <span class="n">val</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">classA</span><span class="p">:</span><span class="n">getTotal</span><span class="p">()</span> <span class="p">)</span> <span class="c1">-- 0</span>
</span></span><span class="line"><span class="cl"><span class="n">classA</span><span class="p">:</span><span class="n">add</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">classA</span><span class="p">:</span><span class="n">getTotal</span><span class="p">()</span> <span class="p">)</span> <span class="c1">-- 1</span>
</span></span><span class="line"><span class="cl"><span class="n">classA</span><span class="p">:</span><span class="n">setValue</span><span class="p">(</span> <span class="mi">2</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">classA</span><span class="p">:</span><span class="n">add</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">classA</span><span class="p">:</span><span class="n">getTotal</span><span class="p">()</span> <span class="p">)</span> <span class="c1">-- 3</span></span></span></code></pre></div>
</div>
<p>
なお、メソッドは次のようにも記載できます。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">classA</span> <span class="o">=</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">function</span> <span class="nc">classA</span><span class="p">.</span><span class="nf">func</span><span class="p">(</span> <span class="n">self</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="kr">return</span> <span class="n">self.value</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="n">classA.func</span><span class="p">(</span> <span class="n">classA</span> <span class="p">)</span> <span class="c1">-- 0</span></span></span></code></pre></div>
</div>
<p>
ちょっと違いが分かり難いですが、次の点が異なります。</p>
<ul>
<li><code class="verbatim">:</code> ではなく . になっている</li>
<li>関数定義の引数に self が入っている</li>
<li>メソッド呼び出しの引数に classA を指定している</li>
</ul>
<p>これは <strong>: を利用することで、 self の処理を Lua が行なっている、</strong> ということです。</p>
<p>
なお、: を利用したメソッド定義は self が自動的に利用されますが、
. を利用した関数定義では self の部分に何を使うかはユーザ次第です。
ですが、self を使うのが混乱せずに良いでしょう。</p>
<p>
別の記載の方法として、次のようにもできます。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">classA</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">get</span> <span class="o">=</span> <span class="kr">function</span><span class="p">(</span> <span class="n">self</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="kr">return</span> <span class="n">self.value</span>
</span></span><span class="line"><span class="cl">  <span class="kr">end</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">  <span class="n">set</span> <span class="o">=</span> <span class="kr">function</span><span class="p">(</span> <span class="n">self</span><span class="p">,</span> <span class="n">value</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">     <span class="n">self.value</span> <span class="o">=</span> <span class="n">value</span>
</span></span><span class="line"><span class="cl">  <span class="kr">end</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">classA</span><span class="p">:</span><span class="n">get</span><span class="p">()</span> <span class="p">)</span> <span class="c1">-- 0</span>
</span></span><span class="line"><span class="cl"><span class="n">classA.set</span><span class="p">(</span> <span class="n">classA</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">classA.get</span><span class="p">(</span> <span class="n">classA</span> <span class="p">)</span> <span class="p">)</span> <span class="c1">-- 1</span></span></span></code></pre></div>
</div>
<p>
これは、テーブルコンストラクタの中にメソッド定義を含めているだけです。
なお、テーブルコンストラクタでは : を利用した定義はできません。</p>
</div>
</div>
<div id="outline-container-headline-49" class="outline-5">
<h5 id="headline-49">
継承
</h5>
<div id="outline-text-headline-49" class="outline-text-5">
<p>
Lua は、クラスの継承が可能です。
継承の実現方法には複数の実装方法があります。
今回紹介する方法は、あくまで 1 つのサンプルです。</p>
<div class="src src-lua -n">
<pre tabindex="0"><code class="language-lua -n" data-lang="lua -n">function DefClass( SuperClass ) -- クラス定義用関数
   local NewClass = {}
   setmetatable( NewClass, { __index = SuperClass } )
   function NewClass:super( ... )
      local obj = {}
      if SuperClass then
	 obj = SuperClass:new( ... )
      end
      setmetatable( obj, { __index = NewClass } )
      return obj
   end
   function NewClass:new( ... )
      return self:super( ... )
   end
   return NewClass
end

local SuperClass = DefClass( nil ) -- クラス定義。 継承無し
function SuperClass:new( value )
  local obj = self:super() -- 親クラスのインスタンス生成
  obj.valueA = value
  return obj
end
function SuperClass:funcA()
  return self.valueA
end

local SubClass = DefClass( SuperClass ) -- クラス定義。  SuperClass を継承。 コンストラクタはデフォルト。
function SubClass:funcB()
  return self.valueA + 10
end

local SubSubClass = DefClass( SubClass ) -- クラス定義。 SubClass を継承
function SubSubClass:new( value1, value2 )
  local obj = self:super( value1 ) -- 親クラスのインスタンス生成
  obj.valueC = value2
  return obj
end
function SubSubClass:funcC()
  return self.valueC
end

local obj = SuperClass:new( 1 )
print( obj:funcA(), obj.funcB, obj.funcC ) -- 1, nil, nil
obj = SubClass:new( 1 )
print( obj:funcA(), obj:funcB(), obj.funcC) -- 1, 11, nil
obj = SubSubClass:new( 1, 2 )
print( obj:funcA(), obj:funcB(), obj:funcC() ) -- 1, 11, 2</code></pre>
</div>
<ul>
<li>サンプル概要</li>
</ul>
<p>これは SuperClass, SubClass, SubSubClass を定義するサンプルです。
名前の通り、 SubSubClass は SubClass を継承しています。
SubClass は SuperClass を継承しています。
SuperClass は何も継承していません。</p>
<ul>
<li>クラス定義用関数</li>
</ul>
<p>まず 1〜16 行目は、クラス定義用の関数を定義しています。
DefClass( SuperClass ) を利用することで 、
SuperClass クラスを親クラスに持つ新しいクラスを定義することができます。
なお、この関数で定義したクラスにコンストラクタを作成する場合、
new フィールドに関数をセットする必要があります。
コンストラクタ内では、super フィールドで親クラスのコンストラタを呼び出す必要があります。
コンストラタは、クラスのメンバーを初期化し、クラスのインスタンステーブルを返します。
デフォルトで、super を呼び出すだけのデフォルトコンストラクタが定義されます。</p>
<ul>
<li>SuperClass の定義</li>
</ul>
<p>18 行目は、 親クラスを持たない SuperClass を定義します。
19〜26 行目で、 SuperClass のコンストラクタと、メソッド funcA を定義しています。</p>
<ul>
<li>SubClass の定義</li>
</ul>
<p>29 行目は、 SuperClass を親クラスに持つ SubClass を定義します。
29〜31 行目で、 SubClassメソッド funcB を定義しています。
SubClass は独自のコンストラクタを持たないクラスです。</p>
<ul>
<li>SubSubClass の定義</li>
</ul>
<p>33 行目は、 SubClass を親クラスに持つ SubSubClass を定義します。
34〜41 行目で、 SubClass のコンストラクタと、メソッド funcC を定義しています。</p>
<ul>
<li>インスタンス生成</li>
</ul>
<p>43〜48 行目で SuperClass, SubClass, SubSubClass インスタンスを生成し、
メソッドを実行しています。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-50" class="outline-3">
<h3 id="headline-50">
require と loadfile
</h3>
<div id="outline-text-headline-50" class="outline-text-3">
<p>
C の場合 include で外部モジュールの関数を利用できるようになりますが、
Lua では require あるいは load を利用します。</p>
<p>
多くの場合、require を利用します。</p>
<div id="outline-container-headline-51" class="outline-4">
<h4 id="headline-51">
require
</h4>
<div id="outline-text-headline-51" class="outline-text-4">
<p>
require は、別のスクリプトで定義した機能を利用する際に使用します。</p>
<ul>
<li>main.lua</li>
</ul>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">sub</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span> <span class="s1">&#39;foo.sub&#39;</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">sub</span><span class="p">:</span><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="c1">-- 1</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">sub</span><span class="p">:</span><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="c1">-- 2</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">sub2</span> <span class="o">=</span> <span class="n">require</span><span class="p">(</span> <span class="s1">&#39;foo.sub&#39;</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">sub</span> <span class="o">==</span> <span class="n">sub2</span> <span class="p">)</span> <span class="c1">-- true</span></span></span></code></pre></div>
</div>
<ul>
<li>foo/sub.lua </li>
</ul>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">tbl</span> <span class="o">=</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">function</span> <span class="nc">tbl</span><span class="p">:</span><span class="nf">func</span><span class="p">(</span> <span class="n">val</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">self.value</span> <span class="o">=</span> <span class="n">self.value</span> <span class="o">+</span> <span class="n">val</span>
</span></span><span class="line"><span class="cl">  <span class="kr">return</span> <span class="n">self.value</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kr">return</span> <span class="n">tbl</span></span></span></code></pre></div>
</div>
<p>
概念が似ているだけで、include とはそもそも動作が異なります。</p>
<ul>
<li>
<p>require はファイル名ではなく、モジュール名で指定します。</p>
<ul>
<li>モジュール名は拡張子を含みません。またパス区切りには / ではなく . を使用します。</li>
<li>. や .. の相対パスは使えません。 (区切り文字が . なので、 . を使うと意味不明になる)</li>
</ul>
</li>
<li>require は、指定されたモジュールをロードし、実行結果を返します。</li>
<li>require した際に返される値は 1 つだけです。</li>
<li>require( modname ) したモジュール結果は、package.loaded[ modname ] テーブルに格納されます。</li>
<li>次に require( modname ) した時は、 package.loaded[ modname ] に格納している値を返します。</li>
<li>もしも modname で指定したモジュールの内容が、前回 require したときと異なる内容になっていたとしても
package.loaded[ modname ] にロードされている場合は新規にロードしなおしません。</li>
<li>強制的にロードし直したい場合は、事前に package.loaded[ modname ] = nil とします。</li>
</ul>
<p>モジュールの検索パスは、 package.path を利用します。</p>
</div>
</div>
<div id="outline-container-headline-52" class="outline-4">
<h4 id="headline-52">
loadfile
</h4>
<div id="outline-text-headline-52" class="outline-text-4">
<p>
loadfile は指定したスクリプトをロードして、そのロードしたスクリプトを実行するための関数を返します。
よって、loadfile が返した関数を実行するまで、指定したスクリプトは実行されません。</p>
<p>
require と loadfile とでは次の点で異なります。</p>
<ul>
<li>
<p>スクリプトの実行タイミング</p>
<ul>
<li>require は、 require() を処理したタイミングで実行します</li>
<li>loadfile は、loadfile() が返す関数を実行したタイミングになります</li>
</ul>
</li>
<li>
<p>2回目以降の処理</p>
<ul>
<li>require は、2 回目以降実行した場合は前回と同じモノを返します</li>
<li>loadfile は新しくオブジェクトを生成します</li>
</ul>
</li>
<li>main.lua</li>
</ul>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">sub3func</span> <span class="o">=</span> <span class="n">loadfile</span><span class="p">(</span> <span class="s1">&#39;foo/sub.lua&#39;</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">sub31</span> <span class="o">=</span> <span class="n">sub3func</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">sub32</span> <span class="o">=</span> <span class="n">sub3func</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">sub31</span><span class="p">:</span><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="c1">-- 1</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">sub32</span><span class="p">:</span><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span> <span class="c1">-- 1</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">sub31</span> <span class="o">==</span> <span class="n">sub32</span> <span class="p">)</span> <span class="c1">-- false</span></span></span></code></pre></div>
</div>
<ul>
<li>foo/sub.lua </li>
</ul>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">tbl</span> <span class="o">=</span> <span class="p">{</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kr">function</span> <span class="nc">tbl</span><span class="p">:</span><span class="nf">func</span><span class="p">(</span> <span class="n">val</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="n">self.value</span> <span class="o">=</span> <span class="n">self.value</span> <span class="o">+</span> <span class="n">val</span>
</span></span><span class="line"><span class="cl">  <span class="kr">return</span> <span class="n">self.value</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kr">return</span> <span class="n">tbl</span></span></span></code></pre></div>
</div>
<p>
loadfile は次のようにファイル名の他に、mode, env を指定できます。</p>
<p>
loadfile( filename, mode, end )</p>
<ul>
<li>
<p>mode は、次を指定できます。デフォルトは &#34;bt&#34; です。</p>
<ul>
<li>&#34;b&#34;: 対象ファイルをスクリプトファイルに限定</li>
<li>&#34;t&#34;: 対象ファイルをバイトコード済みファイルに限定</li>
<li>&#34;bt&#34;: 対象ファイルを限定しない</li>
</ul>
</li>
<li>env は、グローバル変数の格納テーブルを指定します。デフォルトは _ENV です。</li>
</ul>
</div>
</div>
<div id="outline-container-headline-53" class="outline-4">
<h4 id="headline-53">
require と loadfile の使い分け
</h4>
<div id="outline-text-headline-53" class="outline-text-4">
<p>
次の場合を除き、 require を使うべきです。</p>
<ul>
<li>loadfile の mode, env 引数を指定する必要がある場合。</li>
<li>スクリプトを再実行したい場合。</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-54" class="outline-3">
<h3 id="headline-54">
コルーチン
</h3>
<div id="outline-text-headline-54" class="outline-text-3">
<p>
コルーチンは、値の受渡しが可能になった RTOS 等のノンプリエンプティブなタスク切り替え機構と考えると分かり易いです。</p>
<p>
coroutine.resume() と coroutine.yield() が、タスクの再開、一時停止にあたります。</p>
<ul>
<li>
<p>coroutine.resume( crn, arg_c ) は、コルーチン crn の実行を再開します。</p>
<ul>
<li>このとき、コルーチン crn は arg_c を受けとります。</li>
</ul>
</li>
<li>
<p>coroutine.yield(arg_r) は、実行中のコルーチンを suspend にし、coroutine.resume() を呼び出した元の処理に戻ります。</p>
<ul>
<li>このとき、coroutine.resume() の戻り値として arg_r が返ります。</li>
<li>
<p>ただし、coroutine.resume() の戻り値の第一戻り値は、指定のコルーチンの処理が続きがあるかどうかを最後まで実行したかどうかのフラグを返します。</p>
<ul>
<li>true の場合、コルーチンの処理が続きます。</li>
<li>false の場合、コルーチンの処理は全て終了しています。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>coroutine.resume() の戻り値が true の場合、コルーチンの処理は続きがあります。</p>
<ul>
<li>この状態で 再度 coroutine.resume( crn, arg_c ) を実行することで、コルーチンの処理の続きから実行されます。</li>
<li>resume の引数 arg_c は、coroutine.yield() の戻り値となります。</li>
</ul>
</li>
<li>
<p>コルーチンの処理が終了すると、最後の coroutine.resume() 呼び出し位置に戻ります。</p>
<ul>
<li>このときの coroutine.resume() の戻り値は、第一戻り値が false で、第二以降の戻り値がコルーチンの戻り値になります。</li>
</ul>
</li>
</ul>
<p>なお、 コルーチンを作るには coroutine.create( func ) を使用します。</p>
<p>
 <strong>コルーチンを生成しただけでは、コルーチンは動作しません。</strong>
 <strong>coroutine.resume() で初めてコルーチンが実行されます。</strong>
 <strong>初回の resume() で与えられた引数が、コルーチンの引数になります。</strong>
 <strong>2回目以降の resume() で与えられた引数は、 coroutine.yield() の戻り値になります。</strong></p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">crn</span> <span class="o">=</span> <span class="n">coroutine.create</span><span class="p">(</span> <span class="kr">function</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">print</span><span class="p">(</span> <span class="s2">&#34;c1&#34;</span><span class="p">,</span> <span class="n">value</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">print</span><span class="p">(</span> <span class="s2">&#34;c2&#34;</span><span class="p">,</span> <span class="n">coroutine.yield</span><span class="p">(</span> <span class="n">value</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="kr">return</span> <span class="n">value</span> <span class="o">+</span> <span class="mi">2</span> 
</span></span><span class="line"><span class="cl"><span class="kr">end</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="s2">&#34;m1&#34;</span><span class="p">,</span> <span class="n">coroutine.resume</span><span class="p">(</span> <span class="n">crn</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="s2">&#34;m2&#34;</span><span class="p">,</span> <span class="n">coroutine.resume</span><span class="p">(</span> <span class="n">crn</span><span class="p">,</span> <span class="mi">3</span> <span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="s2">&#34;m3&#34;</span><span class="p">,</span> <span class="n">coroutine.resume</span><span class="p">(</span> <span class="n">crn</span><span class="p">,</span> <span class="mi">4</span> <span class="p">)</span> <span class="p">)</span></span></span></code></pre></div>
</div>
<p>
上の例の出力結果は次になります。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">c1	2
</span></span><span class="line"><span class="cl">m1	true	3
</span></span><span class="line"><span class="cl">c2	3
</span></span><span class="line"><span class="cl">m2	true	4
</span></span><span class="line"><span class="cl">m3	false	cannot resume dead coroutine</span></span></code></pre></div>
</div>
<p>
coroutine.wrap() を使用してもコルーチンを生成できます。</p>
<p>
この場合 coroutine.create() と次の点で異なります。</p>
<ul>
<li>coroutine.wrap() はコルーチンを返すのではなく、コルーチンを resume する関数 wfun() を返します。</li>
<li>wfun( arg ) の引数 arg は、 resume の第二引数以降に与える引数になります。</li>
<li>wfun() の戻り値は、コルーチンの続きの有無を示すフラグを含みません。</li>
<li>wfun() は、コルーチンのエラーをキャッチしません。</li>
</ul>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="n">crn</span> <span class="o">=</span> <span class="n">coroutine.wrap</span><span class="p">(</span> <span class="kr">function</span><span class="p">(</span> <span class="n">value</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">print</span><span class="p">(</span> <span class="s2">&#34;c1&#34;</span><span class="p">,</span> <span class="n">value</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="n">print</span><span class="p">(</span> <span class="s2">&#34;c2&#34;</span><span class="p">,</span> <span class="n">coroutine.yield</span><span class="p">(</span> <span class="n">value</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">      <span class="kr">return</span> <span class="n">value</span> <span class="o">+</span> <span class="mi">2</span> 
</span></span><span class="line"><span class="cl"><span class="kr">end</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="s2">&#34;m1&#34;</span><span class="p">,</span> <span class="n">crn</span><span class="p">(</span> <span class="mi">2</span> <span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="s2">&#34;m2&#34;</span><span class="p">,</span> <span class="n">crn</span><span class="p">(</span> <span class="mi">3</span> <span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1">--print( &#34;m3&#34;, crn( 3 ) ) -- error</span></span></span></code></pre></div>
</div>
<p>
上の例の出力結果は次になります。</p>
<div class="src src-txt">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-txt" data-lang="txt"><span class="line"><span class="cl">c1	2
</span></span><span class="line"><span class="cl">m1	3
</span></span><span class="line"><span class="cl">c2	3
</span></span><span class="line"><span class="cl">m2	4</span></span></code></pre></div>
</div>
<p>
coroutine.wrap() を利用することで、for 文のサンプルとして挙げたイテレータ関数 ite を次のように書けます。
コルーチンを使用することでスッキリ書けることが分かると思います。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">ite</span> <span class="o">=</span> <span class="n">coroutine.wrap</span><span class="p">(</span> <span class="kr">function</span> <span class="p">(</span> <span class="n">param</span><span class="p">,</span> <span class="n">prev</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="kr">for</span> <span class="n">next</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">param</span> <span class="kr">do</span>
</span></span><span class="line"><span class="cl">     <span class="n">coroutine.yield</span><span class="p">(</span> <span class="n">next</span><span class="p">,</span> <span class="n">string.format</span><span class="p">(</span> <span class="s2">&#34;%d&#34;</span><span class="p">,</span> <span class="n">next</span> <span class="p">)</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="kr">end</span>
</span></span><span class="line"><span class="cl">   <span class="kr">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="c1">-- 以下と同じ結果になる</span>
</span></span><span class="line"><span class="cl"><span class="c1">-- local function ite( param, prev )</span>
</span></span><span class="line"><span class="cl"><span class="c1">--    if prev == param then</span>
</span></span><span class="line"><span class="cl"><span class="c1">--       return nil</span>
</span></span><span class="line"><span class="cl"><span class="c1">--    end</span>
</span></span><span class="line"><span class="cl"><span class="c1">--    if prev == nil then</span>
</span></span><span class="line"><span class="cl"><span class="c1">--       prev = 0</span>
</span></span><span class="line"><span class="cl"><span class="c1">--    end</span>
</span></span><span class="line"><span class="cl"><span class="c1">--    local next = prev + 1</span>
</span></span><span class="line"><span class="cl"><span class="c1">--    return next, string.format( &#34;%d&#34;, next )</span>
</span></span><span class="line"><span class="cl"><span class="c1">-- end</span></span></span></code></pre></div>
</div>
</div>
</div>
<div id="outline-container-headline-55" class="outline-3">
<h3 id="headline-55">
メタテーブル
</h3>
<div id="outline-text-headline-55" class="outline-text-3">
<p>
メタテーブルとは、C++ の演算子オーバーロードのようなものです。</p>
<p>
メタテーブルを利用することで、値に対する処理をカスタマイズすることができます。
メタテーブルを設定できる値は、型がユーザデータかテーブルのデータだけです。
ただし、Lua スクリプトから設定できるのはテーブル型のデータのみです。
ユーザデータ型のデータは、 C 側から設定可能です。</p>
<p>
setmetatable(table, metatable) で、指定のテーブルにメタテーブルを設定します。</p>
<p>
Lua でカスタマイズ可能な処理が行なわれる際に、メタテーブルに定義したメソッド(メタメソッド)が呼ばれます。</p>
<p>
例ば次のようにテーブル要素へのアクセスをカスタマイズすることができます。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">meta</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__index</span> <span class="o">=</span> <span class="kr">function</span><span class="p">(</span> <span class="n">tbl</span><span class="p">,</span> <span class="n">key</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kr">return</span> <span class="n">key</span>
</span></span><span class="line"><span class="cl">  <span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">local</span> <span class="n">tbl</span> <span class="o">=</span> <span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">tbl</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="p">)</span> <span class="c1">-- nil</span>
</span></span><span class="line"><span class="cl"><span class="n">setmetatable</span><span class="p">(</span> <span class="n">tbl</span><span class="p">,</span> <span class="n">meta</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">print</span><span class="p">(</span> <span class="n">tbl</span><span class="p">[</span> <span class="mi">1</span> <span class="p">]</span> <span class="p">)</span> <span class="c1">-- 1</span></span></span></code></pre></div>
</div>
<p>
この例では、 tbl の要素を取得した際に、キーを返すように振舞をカスタマイズしています。
(tbl の 1 の要素を取得すると、 1 が返る。)</p>
<p>
以降で、カスタマイズ可能な動作について説明します。</p>
<div id="outline-container-headline-56" class="outline-4">
<h4 id="headline-56">
二項演算
</h4>
<div id="outline-text-headline-56" class="outline-text-4">
<p>
メタメソッドは次の引数を持ちます。</p>
<p>
function func( value1, value2 )</p>
<p>
次の二項演算をカスタマイズできます。</p>
<ul>
<li>
<p><code>__add</code></p>
<ul>
<li><code>+</code></li>
</ul>
</li>
<li>
<p><code>__sub</code></p>
<ul>
<li><code>-</code></li>
</ul>
</li>
<li>
<p><code>__mul</code></p>
<ul>
<li><code>*</code></li>
</ul>
</li>
<li>
<p><code>__div</code></p>
<ul>
<li><code>/</code></li>
</ul>
</li>
<li>
<p><code>__mod</code></p>
<ul>
<li><code>%</code></li>
</ul>
</li>
<li>
<p><code>__pow</code></p>
<ul>
<li><code>^</code></li>
</ul>
</li>
<li>
<p><code>__concat</code></p>
<ul>
<li><code>..</code></li>
</ul>
</li>
<li>
<p><code>__idiv</code></p>
<ul>
<li><code>//</code> (ver 5.3)</li>
</ul>
</li>
</ul>
<p>二項演算は、第一引数、第二引数の順で、該当のハンドラを定義しているかどうかを確認します。
ハンドラを定義している場合、そのハンドラの処理を実行します。
定義していない場合は、デフォルトの処理を行ないます。</p>
<p>
メタメソッドは演算結果を返します。</p>
</div>
</div>
<div id="outline-container-headline-57" class="outline-4">
<h4 id="headline-57">
ビット演算 (ver 5.3)
</h4>
<div id="outline-text-headline-57" class="outline-text-4">
<p>
メタメソッドは次の引数を持ちます。</p>
<p>
function func( value1, value2 )</p>
<ul>
<li>
<p><code>__band</code></p>
<ul>
<li><code>&amp;</code></li>
</ul>
</li>
<li>
<p><code>__bor</code></p>
<ul>
<li><code>|</code></li>
</ul>
</li>
<li>
<p><code>__bxor</code></p>
<ul>
<li>~</li>
</ul>
</li>
<li>
<p><code>__bnot</code></p>
<ul>
<li><code>^</code></li>
</ul>
</li>
<li>
<p><code>__shl</code></p>
<ul>
<li><code>&lt;&lt;</code></li>
</ul>
</li>
<li>
<p><code>__shr</code></p>
<ul>
<li><code>&gt;&gt;</code></li>
</ul>
</li>
</ul>
<p>ビット演算は、第一引数、第二引数のどちらかが整数でなく、かつ整数に変換不可能な値の場合に、
第一引数、第二引数の順で、該当のハンドラを定義しているかどうかを確認します。
ハンドラを定義している場合、そのハンドラの処理を実行します。
定義していない場合は、デフォルトの処理を行ないます。</p>
<p>
メタメソッドは演算結果を返します。</p>
</div>
</div>
<div id="outline-container-headline-58" class="outline-4">
<h4 id="headline-58">
単項演算
</h4>
<div id="outline-text-headline-58" class="outline-text-4">
<p>
メタメソッドは次の引数を持ちます。</p>
<p>
function func( value )</p>
<p>
次の単項演算をカスタマイズできます。</p>
<ul>
<li>
<p><code>__unm</code></p>
<ul>
<li><code>-</code></li>
</ul>
</li>
<li>
<p><code>__len</code></p>
<ul>
<li><code>#</code></li>
</ul>
</li>
</ul>
<p>単項演算は、指定の値のメタテーブルが該当のハンドラを定義しているかどうかを確認します。
ハンドラを定義している場合、そのハンドラの処理を実行します。
定義していない場合は、デフォルトの処理を行ないます。</p>
<p>
メタメソッドは演算結果を返します。</p>
</div>
</div>
<div id="outline-container-headline-59" class="outline-4">
<h4 id="headline-59">
<code>__eq</code> ( == )
</h4>
<div id="outline-text-headline-59" class="outline-text-4">
<p>
メタメソッドは次の引数を持ちます。</p>
<p>
function func( value1, value2 )</p>
<p>
<code>__eq</code> は、第一引数と第二引数が、該当のハンドラを定義しているかどうかを確認します。
また、そのハンドラが同じハンドラである場合に限り、そのハンドラの処理を実行します。
そうでない場合は、デフォルトの処理を行ないます。</p>
<p>
メタメソッドは条件が成り立つ時に true, 成り立たない時に false を返します。</p>
</div>
</div>
<div id="outline-container-headline-60" class="outline-4">
<h4 id="headline-60">
<code>__lt</code> ( &lt; ), <code>__le</code> ( &lt;= )
</h4>
<div id="outline-text-headline-60" class="outline-text-4">
<p>
メタメソッドは次の引数を持ちます。</p>
<p>
function func( value1, value2 )</p>
<p>
<code>__lt</code> , <code>__le</code> は、第一引数、第二引数の順で、該当のハンドラを定義しているかどうかを確認します。
ハンドラを定義している場合、そのハンドラの処理を実行します。
定義していない場合は、デフォルトの処理を行ないます。</p>
<p>
メタメソッドは条件が成り立つ時に true, 成り立たない時に false を返します。</p>
<p>
ただし  <code>__le</code> の定義がない場合、a &lt;= b は not (b &lt; a) として <code>__lt</code> を確認します。</p>
</div>
</div>
<div id="outline-container-headline-61" class="outline-4">
<h4 id="headline-61">
<code>__index</code>
</h4>
<div id="outline-text-headline-61" class="outline-text-4">
<p>
メタメソッドは次の引数を持ちます。</p>
<p>
function func( table, key )</p>
<p>
table[key] のデータにアクセスする際の動作をカスタマイズします。</p>
<p>
<code>__index</code> に設定されているのが関数だった場合、上記の関数として実行し戻り値を返します。
関数ではなくテーブルだった場合、そのテーブルのキー key の要素を返します。</p>
<p>
なお、カスタマイズ可能なのは table に key のデータがない場合のみです。
table に key のデータがある場合は、その値を返します。
また、 <code>__index</code> に設定されているのが、関数ではなくテーブルだった場合、
そのテーブルのキー key の要素を返します。</p>
<p>
メタデータをセットしているのがユーザデータ型の場合は、常に有効になります。</p>
<p>
メタメソッドは table の key に対する値を返します。</p>
</div>
</div>
<div id="outline-container-headline-62" class="outline-4">
<h4 id="headline-62">
<code>__newindex</code>
</h4>
<div id="outline-text-headline-62" class="outline-text-4">
<p>
メタメソッドは次の引数を持ちます。</p>
<p>
function func( table, key, value )</p>
<p>
table[key] にデータを設定する際の動作をカスタマイズします。</p>
<p>
<code>__newindex</code> に設定されているのが関数だった場合、上記の関数として実行します。
関数ではなくテーブルだった場合、そのテーブルのキー key に値 value を設定します。</p>
<p>
なお、カスタマイズ可能なのは table に key のデータがない場合のみです。</p>
<p>
table に key のデータがある場合は、指定の値がセットされます。</p>
<p>
メタデータをセットしているのがユーザデータ型の場合は、常に有効になります。</p>
</div>
</div>
<div id="outline-container-headline-63" class="outline-4">
<h4 id="headline-63">
<code>__call</code>
</h4>
<div id="outline-text-headline-63" class="outline-text-4">
<p>
メタメソッドは次の引数を持ちます。</p>
<p>
function func( func, … )</p>
<p>
関数コールの動作をカスタマイズします。</p>
<p>
指定の値のメタテーブルが該当のハンドラを定義しているかどうかを確認します。
ハンドラを定義している場合、そのハンドラの処理を実行します。
定義していない場合は、デフォルトの処理を行ないます。</p>
<p>
メタメソッドは func の実行結果を返します。</p>
</div>
</div>
<div id="outline-container-headline-64" class="outline-4">
<h4 id="headline-64">
<code>__gc</code> ( == )
</h4>
<div id="outline-text-headline-64" class="outline-text-4">
<p>
メタメソッドは次の引数を持ちます。</p>
<p>
function func( self )</p>
<p>
<code>__gc</code> は、そのメタメソッドを設定されている値が GC で解放される前に呼び出されます。</p>
</div>
</div>
<div id="outline-container-headline-65" class="outline-4">
<h4 id="headline-65">
<code>__tostring</code> ( == )
</h4>
<div id="outline-text-headline-65" class="outline-text-4">
<p>
メタメソッドは次の引数を持ちます。</p>
<p>
function func( self )</p>
<p>
<code>__tostring</code> は、 string.format の &#34;%s&#34; 等で変換する際に呼出されます。</p>
<p>
メタメソッドは文字列を返します。 </p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-66" class="outline-3">
<h3 id="headline-66">
クロージャ
</h3>
<div id="outline-text-headline-66" class="outline-text-3">
<p>
Lua はクロージャを使用できます。
クロージャは、Lisp 等でも利用できる古くからある機能の一つですが、C++ では C++11 で取入れられた機能です。</p>
<p>
クロージャを利用することで、関数の引数、グルーバル変数以外で、関数の振舞いを変更することができます。</p>
<p>
例えば、C の qsort には次の関数ポインタを引数に与える必要があります。</p>
<p>
int (*compare)(const void * val1, const void * val2)</p>
<p>
この関数は、val1, val2 に格納されている値を比較して結果を返す関数です。</p>
<p>
ここで、もし要素の比較を行なうために次のようにもう一つの引数が必要だった場合、
どうすれば qsort() を利用できるようになるでしょうか？</p>
<div class="src src-c">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">sampleCompare</span><span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">val1</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">val2</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">param</span> <span class="p">);</span></span></span></code></pre></div>
</div>
<p>
方法としては、次の 2 つが考えられます。</p>
<ul>
<li>
<p>param をグローバル変数 <code>g_param</code> に設定する</p>
<ul>
<li>
<p>sampleCompareWrap( const void * val1, const void * val2 ) を作成。</p>
<ul>
<li>この sampleCompareWrap() から sampleCompare( val1, val2, <code>g_param</code> ) を実行する。</li>
</ul>
</li>
<li><code>g_param</code> に値を設定する</li>
<li>sampleCompareWrap() を qsort() に渡す</li>
</ul>
</li>
<li>
<p>param を固定値にして sampleCompare() 実行するラッパー関数を用意する</p>
<ul>
<li>
<p>sampleCompareWrapX( const void * val1, const void * val2 ) を作成。</p>
<ul>
<li>この sampleCompareWrapX() から sampleCompare( val1, val2, PARAM ) を実行する。</li>
<li>ここで PARAM は、param が取り得る値の 1 つです</li>
</ul>
</li>
<li>param のパターン分 sampleCompareWrapX() を用意する。</li>
<li>使用する param のパターンに合せて qsort() に与える sampleCompareWrapX() を変更する</li>
</ul>
</li>
</ul>
<p>どちらも、あまり良い方法とは言えません。</p>
<p>
このような時にクロージャを使用すると簡単に解決できます。</p>
<p>
Lua のクロージャを使うと次のようになります。</p>
<div class="src src-lua">
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="kd">local</span> <span class="kr">function</span> <span class="nf">generateCompare</span><span class="p">(</span> <span class="n">param</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="kr">return</span> <span class="kr">function</span><span class="p">(</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span> <span class="p">)</span> <span class="c1">-- ★</span>
</span></span><span class="line"><span class="cl">    <span class="kr">return</span> <span class="n">sampleCompare</span><span class="p">(</span> <span class="n">val1</span><span class="p">,</span> <span class="n">val2</span><span class="p">,</span> <span class="n">param</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">  <span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span><span class="line"><span class="cl"><span class="n">qsort</span><span class="p">(</span> <span class="n">array</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">generateCompare</span><span class="p">(</span> <span class="n">param</span> <span class="p">)</span> <span class="p">)</span> <span class="c1">-- C の qsort() と同じインタフェースとする</span></span></span></code></pre></div>
</div>
<p>
上記で説明している通り、クロージャを利用することで、関数の引数、グローバル変数を使わずに、
上記の ★ マークの関数の振舞いを変更できます。</p>
<p>
クロージャで重要なことは、関数の処理内で、関数定義外部で宣言されているローカル変数を利用しているということです。
ローカル変数は、宣言されると新しくインスタンスを生成します。
そして Lua の値は、参照がなくなるまで解放されないようになっています。
これにより、ローカル変数のスコープであるブロックの処理を抜けても、関数内で参照されているためインスタンスが解放されることなく残ることになります。</p>
</div>
</div>
<div id="outline-container-headline-67" class="outline-3">
<h3 id="headline-67">
デバッグインタフェース
</h3>
<div id="outline-text-headline-67" class="outline-text-3">
<p>
Lua は、自分自身をデバッグするためのインタフェースを持ちます。
これを利用することで、例えばスタックトレースを動的に取得することができます。
また、この機能を利用することでリモードデバッガ等を実現できます。</p>
</div>
</div>
</div>
</div>
<div id="outline-container-headline-68" class="outline-2">
<h2 id="headline-68">
C/C++ 言語プログラマのためのサポートツール
</h2>
<div id="outline-text-headline-68" class="outline-text-2">
<p>
Lua には直接関係ありませんが、
C/C++ 言語プログラマのためのサポートツールとして、lctags を開発しています。</p>
<p>
この lctags は、
いわゆるタグジャンプをサポートするソースコードタグシステムです。
lctags を利用することで、
従来ツールで課題だった構造体のメンバを認識した
タグジャンプが出来ない問題を解決できます。
他にも、コールグラフの表示など多くの機能に対応しています。</p>
<p>
是非、次の記事を御一読下さい。</p>
<p>
<a href="../lctags/">../lctags/</a></p>
<p>
<strong>ちなみにこの lctags は、 Lua で開発しています。</strong></p>
</div>
</div>
<div class="edit-meta">

<br></div><nav class="pagination"><a class="nav nav-prev-2" href="https://ifritjp.github.io/documents/lctags/windows/" title="Windows で lctags (C言語/C&#43;&#43; のタグジャンプ、コールグラフ、etc..)"><i class="fas fa-arrow-left" aria-hidden="true"></i> Prev - Windows で lctags (C言語/C&#43;&#43; のタグジャンプ、コールグラフ、etc..)</a>
<a class="nav nav-next-2" href="https://ifritjp.github.io/documents/lua/detail/" title="C インタフェース詳細編">Next - C インタフェース詳細編 <i class="fas fa-arrow-right" aria-hidden="true"></i></a>
</nav><footer><p class="powered">Powered by <a href="https://gohugo.io">Hugo</a>. Theme by <a href="https://themes.gohugo.io/hugo-theme-techdoc/">TechDoc</a>. Designed by <a href="https://github.com/thingsym/hugo-theme-techdoc">Thingsym</a>.</p>
</footer>
</main><div class="sidebar">

<nav class="slide-menu">
<ul>
<li class=""><a href="https://ifritjp.github.io/documents">Home</a></li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/lctags/">C/C&#43;&#43; ソースコードタグシステム lctags の紹介<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/lctags/introduce/">C/C&#43;&#43; ソースコードタグシステム lctags の紹介</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/rename/">C/C&#43;&#43; ソースコードをリファクタリング by lctags on emacs (リネーム編)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/enum/">C/C&#43;&#43; の enum 補完 by lctags on emacs</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/highlight/">C/C&#43;&#43; の特定シンボルをハイライト by lctags on emacs</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/varsize/">C/C&#43;&#43; の変数サイズ確認 by lctags on emacs</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/callgraph/">C言語/C&#43;&#43; コードを解析してインタラクティブなコールグラフ表示 by lctags</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/modulegraph/">C言語/C&#43;&#43; コードを解析してインタラクティブなモジュール構成図っぽいグラフ表示 by lctags</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/callfunc/">lctags で C 言語の関数コールを簡単に</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/register/">lctags のプロジェクト簡易登録</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/c-language/">lctags を開発している時に改めて感じた C 言語規格のイケてないところ</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/subroutine/">lctags を使って C/C&#43;&#43; ソースコードをリファクタリング(サブルーチン化編)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lctags/windows/">Windows で lctags (C言語/C&#43;&#43; のタグジャンプ、コールグラフ、etc..)</a></li>
</ul>
  
</li>

<li class=" active has-sub-menu"><a href="https://ifritjp.github.io/documents/lua/">C/C&#43;&#43; 言語プログラマのための Lua 入門リファレンス<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/lua/detail/">C インタフェース詳細編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lua/interface/">C インタフェース編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lua/fengari/">fengari の使い方 (Lua を Web ブラウザで動かす方法)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lua/lua5.4/">Lua 5.4 の主な変更点</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lua/anti-pattern/">Lua でやりがちなミス</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lua/pointer/">ポインタ編</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/emacs/">Emacs<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/emacs/simple-httpd/">emacs 簡易 HTTPD 化パケージ simple-httpd.el</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/emacs/company-mode/">自作言語 (LuneScript) の emacs company-mode backend 設定</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/go/">Goes<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/go/package/">Go のパッケージ</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/go/guide/">Go 入門</a></li>
</ul>
  
</li>

<li class=""><a href="https://ifritjp.github.io/documents/gcp/">Google Cloud Platform を使ってみる</a>
  
</li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/javascript/">Javascripts<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/javascript/d3force/">D3.js V4 forceSimulation のノード動的更新(追加・削除)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/javascript/thread/">JavaScript のスレッド(非同期処理)</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/libclang/">Lua で C/C&#43;&#43; の構文解析 (libclang の Lua binding)<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/libclang/operator/">libclang で演算子を特定する方法</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/libclang/ast/">libclang の AST(Abstract Syntax Tree)</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/rust/">Rusts<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/rust/lifetime/">C/C&#43;&#43;エンジニアのための Rust のデータ所有権とライフタイム入門</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/singleboard/">Singleboards<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/singleboard/raspios64-point/">64bit 版 Raspberry Pi OS でカーネルモジュールを使った際に遭遇したエラーと対応方法</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/singleboard/build-kernel-module-64/">64bit 版 Raspberry Pi OS のカーネルモジュールのビルド環境設定</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/singleboard/bluetooth-a2dp-receiver/">Raspberry Pi で Bluetooth レシーバー (オーディオ:A2DP) を作成するための設定方法解説</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/singleboard/usb-gadget/">USB Gadget 機能を利用して Raspberry Pi を HID Keyboard と RNDIS の複合デバイスにする</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/singleboard/recover-image/">誤ってパーティションテーブル (LBA 0) を消して(0クリアして)しまった場合の対処</a></li>
</ul>
  
</li>

<li class=" has-sub-menu"><a href="https://ifritjp.github.io/documents/lunescript/">トランスコンパイラ LuneScript で Lua の開発をもっと楽に!!<span class="mark closed">+</span></a>
  
<ul class="sub-menu">
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/tutorial1/">00. はじめに</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/tutorial2.setup/">01. 導入編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/tutorial3.hello/">02. Hello world</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/crosscompile/">03. Lua バージョン間のクロスコンパイル</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/value/">04. 値編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/set/">04.2. Set 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/enum/">05. enum 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/match/">06. match 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/variable/">07. 変数 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/branch/">08. 一般分岐構文 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/loop/">09. 繰り返し構文 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/func/">10. 関数 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/multipleretval/">10.2. 多値の戻り値</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/defaultarg/">10.3. 引数の省略 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/arg/">10.4. 可変長引数、戻り値 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/closure/">10.5. クロージャ</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/nilable/">11. nilable 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/class1/">12. クラス 基本 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/class2accessor/">13. accessor 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/classinherit/">14. クラス 継承 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/classadvertise/">15. クラス advertise 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/classoverride/">16. クラス override 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/interface/">17. インタフェース 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/classmapping/">18. mapping 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/generics/">19. generics 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/nilcond/">20. nil 条件演算子 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/import/">21. import/provide 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/require/">22. require/module 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/glue/">22.1. glue コードの半自動生成</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/lua/">22.2. Lua と連携 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/make/">23. ビルド 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/macro/">24. マクロ 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/cast/">25. キャスト 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/subfile/">26. subfile 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/lazyloading/">27. 遅延ロード 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/shebang_main/">28. shebang とコマンドライン引数</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/dir/">29. LuneScript を利用するプロジェクトの推奨ディレクトリ構成</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/go/">80. Go 言語へのトランスコンパイル</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/go_package/">80.2 Go 言語へのトランスコンパイル時のパッケージ</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/lua_runtime/">80.3 Go へトランスコンパイルした際の Lua ランタイム</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/go_wasm/">80.4 LuneScript の WebAssembly 対応</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/async/">81. 安全な非同期処理</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/async_old/">81.1 非同期処理(過去情報)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/luago/">82. Lua と連携 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/lnstags/">A. lnstags によるタグジャンプ (ソースコードタグシステム)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/reason/">A. Lua のトランスコンパイラ LuneScript を開発した理由</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/regret/">A. LuneScript の言語仕様でミスだったと思っているところ</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/onweb/">A. Web ブラウザ上で動作する LuneScript</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/recommend/">A. トランスコンパイラ開発のすゝめ</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/completion/">A.イマドキな開発環境でもっと楽しよう</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/box/">Box 編</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/test/">X. 言語開発の品質コントロールにおけるセルフホスティングの重要性とテスト設計</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/design/">Y.1 LuneScript の開発方法</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/go_study/">Z. Go 言語へのトランスコンパイル (検討段階)</a></li>
<li class=""><a href="https://ifritjp.github.io/documents/lunescript/all/">全文検索用結合ファイル</a></li>
</ul>
  
</li>
</ul>
</nav>



<div class="sidebar-footer"></div>
</div>
</div><a href="#" id="backtothetop-fixed" class="backtothetop"
 data-backtothetop-duration="600"
 data-backtothetop-easing="easeOutQuart"
 data-backtothetop-fixed-fadeIn="1000"
 data-backtothetop-fixed-fadeOut="1000"
 data-backtothetop-fixed-bottom="10"
 data-backtothetop-fixed-right="20">
<span class="fa-layers fa-fw">
<i class="fas fa-circle"></i>
<i class="fas fa-arrow-circle-up"></i>
</span></a>
</div>
</body>
</html>
