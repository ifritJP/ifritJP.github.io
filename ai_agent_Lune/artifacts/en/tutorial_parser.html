<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LuneScript Guide - Practical: Expression Parser</title>
    <link rel="stylesheet" href="../style.css">
    <script src="../main.js" defer></script>
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-4708B8S6ES"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-4708B8S6ES');
</script>
</head>

<body>
    <div class="sidebar">
        <h1>LuneScript Guide</h1>
        <ul class="nav-links">
            <li class="nav-item">
                <button class="toggle-btn">▶</button>
                <a href="index.html">Introduction</a>
                <ul class="submenu">
                    <li><a href="index.html#features">Key Features</a></li>
                    <li><a href="index.html#audience">Target Audience</a></li>
                    <li><a href="index.html#license">License</a></li>
                </ul>
            </li>
            <li class="nav-item">
                <button class="toggle-btn">▶</button>
                <a href="learning.html">Learning Guide</a>
                <ul class="submenu">
                    <li><a href="learning.html#step1">Step 1: Basics</a></li>
                    <li><a href="learning.html#step2">Step 2: Safety Features</a></li>
                    <li><a href="learning.html#step3">Step 3: Modern Features</a></li>
                    <li><a href="learning.html#navigation">Using Documentation</a></li>
                </ul>
            </li>
            <li class="nav-item">
                <button class="toggle-btn">▶</button>
                <a href="tutorial.html">Installation and Hello World</a>
                <ul class="submenu">
                    <li><a href="tutorial.html#install">Installation</a></li>
                    <li><a href="tutorial.html#hello">Hello World</a></li>
                    <li><a href="tutorial.html#options">lnsc Command</a></li>
                </ul>
            </li>
            <li class="nav-item">
                <button class="toggle-btn">▶</button>
                <a href="syntax.html">Basic Syntax</a>
                <ul class="submenu">
                    <li><a href="syntax.html#comments">Comments</a></li>
                    <li><a href="syntax.html#vars">Variable Declarations</a></li>
                    <li><a href="syntax.html#flow">Initialization by Flow Analysis</a></li>
                    <li><a href="syntax.html#scope">Scope Blocks</a></li>
                    <li><a href="syntax.html#attr">Attributes</a></li>
                </ul>
            </li>
            <li class="nav-item">
                <button class="toggle-btn">▶</button>
                <a href="value.html">Values and Types</a>
                <ul class="submenu">
                    <li><a href="value.html#primitive">Primitive Types</a></li>
                    <li><a href="value.html#collection">Collections</a></li>
                    <li><a href="value.html#list">&nbsp;&nbsp;List</a></li>
                    <li><a href="value.html#map">&nbsp;&nbsp;Map</a></li>
                    <li><a href="value.html#set">&nbsp;&nbsp;Set</a></li>
                    <li><a href="value.html#nilable">Nilable Types</a></li>
                    <li><a href="value.html#cast">Casting</a></li>
                    <li><a href="value.html#alge">Algebraic Data Types</a></li>
                    <li><a href="value.html#enum">Enum</a></li>
                    <li><a href="value.html#tuple">Tuple</a></li>
                </ul>
            </li>
            <li class="nav-item">
                <button class="toggle-btn">▶</button>
                <a href="control.html">Control Flow</a>
                <ul class="submenu">
                    <li><a href="control.html#if">if statement</a></li>
                    <li><a href="control.html#switch">switch statement</a></li>
                    <li><a href="control.html#while">while statement</a></li>
                    <li><a href="control.html#repeat">repeat statement</a></li>
                    <li><a href="control.html#for">for statement</a></li>
                    <li><a href="control.html#foreach">foreach statement</a></li>
                    <li><a href="control.html#apply">apply statement</a></li>
                    <li><a href="control.html#match">match statement</a></li>
                </ul>
            </li>
            <li class="nav-item">
                <button class="toggle-btn">▶</button>
                <a href="error.html">Error Handling</a>
                <ul class="submenu">
                    <li><a href="error.html#ret">__Ret Type</a></li>
                    <li><a href="error.html#delegation">Error Delegation</a></li>
                    <li><a href="error.html#best_practice">Types and Best Practices</a></li>
                </ul>
            </li>
            <li class="nav-item">
                <button class="toggle-btn">▶</button>
                <a href="function.html">Functions</a>
                <ul class="submenu">
                    <li><a href="function.html#def">Definition</a></li>
                    <li><a href="function.html#multi_ret">Multiple Returns</a></li>
                    <li><a href="function.html#closure">Closures</a></li>
                    <li><a href="function.html#form">Form (Function Type)</a></li>
                    <li><a href="function.html#varargs">Variable Arguments</a></li>
                </ul>
            </li>
            <li class="nav-item">
                <button class="toggle-btn">▶</button>
                <a href="class.html">Classes</a>
                <ul class="submenu">
                    <li><a href="class.html#def">Definition and Instantiation</a></li>
                    <li><a href="class.html#inherit">Inheritance and Overriding</a></li>
                    <li><a href="class.html#abstract">Abstract Classes</a></li>
                    <li><a href="class.html#interface">Interfaces</a></li>
                    <li><a href="class.html#advertise">Advertise</a></li>
                    <li><a href="class.html#mapping">Mapping</a></li>
                    <li><a href="class.html#proto">Prototype Declarations</a></li>
                </ul>
            </li>
            <li class="nav-item">
                <button class="toggle-btn">▶</button>
                <a href="generics.html">Generics</a>
                <ul class="submenu">
                    <li><a href="generics.html#func">Function Generics</a></li>
                    <li><a href="generics.html#class">Class Generics</a></li>
                    <li><a href="generics.html#constraint">Type Parameter Constraints</a></li>
                    <li><a href="generics.html#method">Method Generics</a></li>
                    <li><a href="generics.html#mut">Generics and Mutability</a></li>
                </ul>
            </li>
            <li class="nav-item">
                <button class="toggle-btn">▶</button>
                <a href="macro.html">Macros</a>
                <ul class="submenu">
                    <li><a href="macro.html#def">Definition</a></li>
                    <li><a href="macro.html#arg">Arguments</a></li>
                    <li><a href="macro.html#quote">Quoting</a></li>
                    <li><a href="macro.html#statement">Macro Statement</a></li>
                </ul>
            </li>
            <li class="nav-item">
                <button class="toggle-btn">▶</button>
                <a href="advanced.html">Advanced Features</a>
                <ul class="submenu">
                    <li><a href="advanced.html#match">Pattern Matching</a></li>
                    <li><a href="advanced.html#async">Asynchronous Processing</a></li>
                    <li><a href="advanced.html#glue">Glue Code</a></li>
                </ul>
            </li>
            <li class="nav-item">
                <button class="toggle-btn">▶</button>
                <a href="module.html">Modules and Projects</a>
                <ul class="submenu">
                    <li><a href="module.html#module">Module System</a></li>
                    <li><a href="module.html#project">Project Settings</a></li>
                    <li><a href="module.html#provide">Provide</a></li>
                    <li><a href="module.html#require">Require</a></li>
                    <li><a href="module.html#subfile">Subfile</a></li>
                </ul>
            </li>
            <li class="nav-item">
                <button class="toggle-btn">▶</button>
                <a href="standard.html">Standard Library</a>
                <ul class="submenu">
                    <li><a href="standard.html#builtin">Built-in Functions</a></li>
                    <li><a href="standard.html#lua">Lua Standard Library</a></li>
                    <li><a href="standard.html#io">IO</a></li>
                </ul>
            </li>
            <li class="nav-item">
                <button class="toggle-btn">▶</button>
                <a href="tutorial_macro.html">Practical: Macro Usage</a>
                <ul class="submenu">
                    <li><a href="tutorial_macro.html#step1">Step 1: Debug Print</a></li>
                    <li><a href="tutorial_macro.html#step2">Step 2: Assertion</a></li>
                    <li><a href="tutorial_macro.html#step3">Step 3: Measurement</a></li>
                </ul>
            </li>
            <li class="nav-item">
                <button class="toggle-btn">▶</button>
                <a href="tutorial_parser.html">Practical: Expression Parser</a>
                <ul class="submenu">
                    <li><a href="tutorial_parser.html#goal">Goal</a></li>
                    <li><a href="tutorial_parser.html#token">Step 1: Token Definition</a></li>
                    <li><a href="tutorial_parser.html#lexer">Step 2: Lexical Analysis</a></li>
                    <li><a href="tutorial_parser.html#ast">Step 3: Abstract Syntax Tree (AST)</a></li>
                    <li><a href="tutorial_parser.html#parser">Step 4: Parsing</a></li>
                    <li><a href="tutorial_parser.html#eval">Step 5: Evaluation and Execution</a></li>
                </ul>
            </li>
            <li class="nav-item">
                <button class="toggle-btn">▶</button>
                <a href="keyword.html">Keywords List</a>
                <ul class="submenu">
                    <li><a href="keyword.html#a">A-G</a></li>
                    <li><a href="keyword.html#h">H-N</a></li>
                    <li><a href="keyword.html#o">O-U</a></li>
                    <li><a href="keyword.html#v">V-Z</a></li>
                </ul>
            </li>
            <li class="nav-item">
                <button class="toggle-btn">▶</button>
                <a href="troubleshooting.html">Troubleshooting</a>
                <ul class="submenu">
                    <li><a href="troubleshooting.html#char">Character Literals</a></li>
                    <li><a href="troubleshooting.html#mut">Mutable Methods</a></li>
                    <li><a href="troubleshooting.html#match">Pattern Matching</a></li>
                    <li><a href="troubleshooting.html#unwrap">Nilable Operations</a></li>
                    <li><a href="troubleshooting.html#macro">Macro Syntax Errors</a></li>
                </ul>
            </li>
            <li class="nav-item">
                <button class="toggle-btn">▶</button>
                <a href="evaluation.html">Discussion and Evaluation</a>
                <ul class="submenu">
                    <li><a href="evaluation.html#quality">Language Quality</a></li>
                    <li><a href="evaluation.html#vs-lua">Comparison with Lua</a></li>
                    <li><a href="evaluation.html#vs-teal">Comparison with Teal</a></li>
                    <li><a href="evaluation.html#issues">Issues and Proposals</a></li>
                </ul>
            </li>
        </ul>
    </div>

    <div class="main-content">
    <div class="header-nav">
        <a href="../ja/tutorial_parser.html" class="lang-link">日本語</a>
    </div>
        <h1>Practical: Creating an Expression Parser</h1>

        <p>By leveraging LuneScript's powerful type system, particularly Algebraic Data Types (ADTs) and pattern
            matching, let's create an expression parser (calculator).<br>
            In this tutorial, we will create a program step-by-step that parses strings like <code>"1 + 2 * 3"</code>
            and produces calculation results.</p>

        <h2 id="goal">Goal</h2>
        <p>The following features will be implemented.</p>
        <ul>
            <li>Support for basic arithmetic (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>) and
                parentheses <code>()</code>.</li>
            <li>Integer calculations.</li>
            <li>Interactive execution in REPL (Read-Eval-Print Loop) format.</li>
        </ul>

        <h2 id="token">Step 1: Token Definition</h2>
        <p>First, we define types for breaking down the input string into meaningful units (tokens). LuneScript's
            <code>alge</code> (Algebraic Data Type) is perfect for this.</p>

        <pre><code class="language-lns"><span class="comment">// Token Type Definition</span>
<span class="keyword">alge</span> Token {
    Num( val: <span class="type">int</span> ),      <span class="comment">// Numbers: 123</span>
    Op( val: <span class="type">str</span> ),       <span class="comment">// Operators: +, -, *, / (, )</span>
    Eof,                  <span class="comment">// End of string</span>
}
</code></pre>

        <h2 id="lexer">Step 2: Lexical Analysis (Lexer)</h2>
        <p>Create a <code>Lexer</code> class that reads the string and generates <code>Token</code>s.</p>
        <pre><code class="language-lns"><span class="keyword">class</span> Lexer {
    <span class="keyword">let</span> text: <span class="type">str</span>;
    <span class="keyword">let</span> len: <span class="type">int</span>;
    <span class="keyword">let</span> <span class="keyword">mut</span> pos: <span class="type">int</span>;

    <span class="keyword">pub</span> <span class="keyword">fn</span> __init( text:<span class="type">str</span> ) {
        <span class="keyword">self</span>.text = text;
        <span class="keyword">self</span>.len = #text;
        <span class="keyword">self</span>.pos = <span class="number">1</span>;
    }

    <span class="comment">// Get current character (returns character code 0 if out of range)</span>
    <span class="keyword">fn</span> getChar(): <span class="type">int</span> {
        <span class="keyword">if</span> <span class="keyword">self</span>.pos &gt; <span class="keyword">self</span>.len { <span class="keyword">return</span> <span class="number">0</span>; }
        <span class="keyword">return</span> <span class="keyword">unwrap</span> <span class="keyword">self</span>.text.byte( <span class="keyword">self</span>.pos ) <span class="keyword">default</span> <span class="number">0</span>;
    }

    <span class="comment">// Get next token</span>
    <span class="keyword">pub</span> <span class="keyword">fn</span> next() <span class="keyword">mut</span>: Token {
        <span class="comment">// Skip whitespace</span>
        <span class="keyword">while</span> <span class="keyword">self</span>.getChar() == ?  {
            <span class="keyword">self</span>.pos = <span class="keyword">self</span>.pos + <span class="number">1</span>;
        }
        
        <span class="keyword">let</span> ch = <span class="keyword">self</span>.getChar();
        <span class="keyword">if</span> ch == <span class="number">0</span> { <span class="keyword">return</span> .Eof; }

        <span class="comment">// In case of numbers</span>
        <span class="keyword">if</span> ch &gt;= ?<span class="number">0</span> and ch &lt;= ?<span class="number">9</span> {
            <span class="keyword">let</span> <span class="keyword">mut</span> numVal = <span class="number">0</span>;
            <span class="keyword">while</span> <span class="keyword">true</span> {
                <span class="keyword">let</span> cur = <span class="keyword">self</span>.getChar();
                <span class="keyword">if</span> cur &lt; ?<span class="number">0</span> or cur &gt; ?<span class="number">9</span> { <span class="keyword">break</span>; }
                numVal = numVal * <span class="number">10</span> + ( cur - ?<span class="number">0</span> );
                <span class="keyword">self</span>.pos = <span class="keyword">self</span>.pos + <span class="number">1</span>;
            }
            <span class="keyword">return</span> Token.Num( numVal );
        }

        <span class="comment">// In case of operators</span>
        <span class="keyword">self</span>.pos = <span class="keyword">self</span>.pos + <span class="number">1</span>;
        <span class="keyword">return</span> Token.Op( <span class="string">"%c"</span> ( ch ) );
    }
}
</code></pre>
        <div class="note">
            <code>?</code> is a character code literal (e.g., <code>?A</code> is 65).
        </div>

        <h2 id="ast">Step 3: Definition of Abstract Syntax Tree (AST)</h2>
        <p>Define a tree structure to store parsing results. <code>alge</code> shines here too.</p>
        <pre><code class="language-lns"><span class="keyword">alge</span> Ast {
    Val( val: <span class="type">int</span> ),                      <span class="comment">// Numerical value</span>
    Bin( op: <span class="type">str</span>, left: Ast, right: Ast ), <span class="comment">// Binary operation (left op right)</span>
}
</code></pre>

        <h2 id="parser">Step 4: Parsing (Parser)</h2>
        <p>Convert the token sequence into an AST using Recursive Descent Parsing. To handle precedence, methods are
            split into <code>Expr</code> (expression), <code>Term</code> (term), and <code>Factor</code> (factor).</p>

        <pre><code class="language-lns"><span class="keyword">class</span> Parser {
    <span class="keyword">let</span> <span class="keyword">mut</span> lexer: Lexer;
    <span class="keyword">let</span> <span class="keyword">mut</span> cur: Token;

    <span class="keyword">pub</span> <span class="keyword">fn</span> __init( text: <span class="type">str</span> ) {
        <span class="keyword">self</span>.lexer = <span class="keyword">new</span> Lexer( text );
        <span class="keyword">self</span>.cur = <span class="keyword">self</span>.lexer.next();
    }

    <span class="comment">// Advance token</span>
    <span class="keyword">fn</span> next() <span class="keyword">mut</span> {
        <span class="keyword">self</span>.cur = <span class="keyword">self</span>.lexer.next();
    }

    <span class="comment">// Factor: Number or (Expression)</span>
    <span class="keyword">fn</span> parseFactor() <span class="keyword">mut</span>: Ast {
        <span class="keyword">match</span> <span class="keyword">self</span>.cur {
            <span class="keyword">case</span> .Num( val ) {
                <span class="keyword">self</span>.next();
                <span class="keyword">return</span> .Val( val );
            }
            <span class="keyword">case</span> .Op( op ) {
                <span class="keyword">if</span> op == <span class="string">"("</span> {
                    <span class="keyword">self</span>.next();
                    <span class="keyword">let</span> node = <span class="keyword">self</span>.parseExpr();
                    <span class="keyword">match</span> <span class="keyword">self</span>.cur {
                       <span class="keyword">case</span> .Op( nextOp ) {
                           <span class="keyword">if</span> nextOp == <span class="string">")"</span> {
                               <span class="keyword">self</span>.next();
                               <span class="keyword">return</span> node;
                           }
                       }
                       <span class="keyword">default</span> {}
                    }
                    print( <span class="string">"Error: missing )"</span> );
                    <span class="keyword">return</span> node;
                }
            }
            <span class="keyword">default</span> {
                print( <span class="string">"Error: unexpected token"</span> );
            }
        }
        <span class="keyword">return</span> .Val( <span class="number">0</span> );
    }

    <span class="comment">// Term: Multiplication, Division</span>
    <span class="keyword">fn</span> parseTerm() <span class="keyword">mut</span>: Ast {
        <span class="keyword">let</span> <span class="keyword">mut</span> left = <span class="keyword">self</span>.parseFactor();
        <span class="keyword">while</span> <span class="keyword">true</span> {
            <span class="keyword">match</span> <span class="keyword">self</span>.cur {
                <span class="keyword">case</span> .Op( op ) {
                    <span class="keyword">if</span> op == <span class="string">"*"</span> or op == <span class="string">"/"</span> {
                        <span class="keyword">self</span>.next();
                        <span class="keyword">let</span> right = <span class="keyword">self</span>.parseFactor();
                        left = .Bin( op, left, right );
                    } <span class="keyword">else</span> {
                        <span class="keyword">break</span>;
                    }
                }
                <span class="keyword">default</span> { <span class="keyword">break</span>; }
            }
        }
        <span class="keyword">return</span> left;
    }

    <span class="comment">// Expression: Addition, Subtraction</span>
    <span class="keyword">pub</span> <span class="keyword">fn</span> parseExpr() <span class="keyword">mut</span>: Ast {
        <span class="keyword">let</span> <span class="keyword">mut</span> left = <span class="keyword">self</span>.parseTerm();
        <span class="keyword">while</span> <span class="keyword">true</span> {
            <span class="keyword">match</span> <span class="keyword">self</span>.cur {
                <span class="keyword">case</span> .Op( op ) {
                    <span class="keyword">if</span> op == <span class="string">"+"</span> or op == <span class="string">"-"</span> {
                        <span class="keyword">self</span>.next();
                        <span class="keyword">let</span> right = <span class="keyword">self</span>.parseTerm();
                        left = .Bin( op, left, right );
                    } <span class="keyword">else</span> {
                        <span class="keyword">break</span>;
                    }
                }
                <span class="keyword">default</span> { <span class="keyword">break</span>; }
            }
        }
        <span class="keyword">return</span> left;
    }
}
</code></pre>

        <h2 id="eval">Step 5: Evaluation and Execution</h2>
        <p>Finally, create a function that recursively processes the generated AST to obtain calculation results. Using
            the <code>match</code> expression allows for concise writing.</p>

        <pre><code class="language-lns"><span class="keyword">fn</span> eval( node: Ast ): <span class="type">int</span> {
    <span class="keyword">match</span> node {
        <span class="keyword">case</span> .Val( val ) {
            <span class="keyword">return</span> val;
        }
        <span class="keyword">case</span> .Bin( op, left, right ) {
            <span class="keyword">let</span> l = eval( left );
            <span class="keyword">let</span> r = eval( right );
            <span class="keyword">switch</span> op {
                <span class="keyword">case</span> <span class="string">"+"</span> { <span class="keyword">return</span> l + r; }
                <span class="keyword">case</span> <span class="string">"-"</span> { <span class="keyword">return</span> l - r; }
                <span class="keyword">case</span> <span class="string">"*"</span> { <span class="keyword">return</span> l * r; }
                <span class="keyword">case</span> <span class="string">"/"</span> { <span class="keyword">return</span> l / r; }
            }
        }
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="comment">// Main process</span>
<span class="keyword">let</span> input = <span class="string">"1 + 2 * (3 + 4)"</span>;
<span class="keyword">let</span> <span class="keyword">mut</span> parser = <span class="keyword">new</span> Parser( input );
<span class="keyword">let</span> ast = parser.parseExpr();
print( <span class="string">"%s = %d"</span> ( input, eval( ast ) ) );
</code></pre>
        <p>Executing this outputs <code>1 + 2 * (3 + 4) = 15</code>!</p>

        <hr>
        <h3>Complete Code</h3>
        <p>The following is the combined code for all steps.</p>
        <pre><code class="language-lns"><span class="keyword">alge</span> Token {
    Num( val: <span class="type">int</span> ),
    Op( val: <span class="type">str</span> ),
    Eof,
}

<span class="keyword">class</span> Lexer {
    <span class="keyword">let</span> text: <span class="type">str</span>;
    <span class="keyword">let</span> len: <span class="type">int</span>;
    <span class="keyword">let</span> <span class="keyword">mut</span> pos: <span class="type">int</span>;

    <span class="keyword">pub</span> <span class="keyword">fn</span> __init( text:<span class="type">str</span> ) {
        <span class="keyword">self</span>.text = text;
        <span class="keyword">self</span>.len = #text;
        <span class="keyword">self</span>.pos = <span class="number">1</span>;
    }

    <span class="keyword">fn</span> getChar(): <span class="type">int</span> {
        <span class="keyword">if</span> <span class="keyword">self</span>.pos &gt; <span class="keyword">self</span>.len { <span class="keyword">return</span> <span class="number">0</span>; }
        <span class="keyword">return</span> <span class="keyword">unwrap</span> <span class="keyword">self</span>.text.byte( <span class="keyword">self</span>.pos ) <span class="keyword">default</span> <span class="number">0</span>;
    }

    <span class="keyword">pub</span> <span class="keyword">fn</span> next() <span class="keyword">mut</span>: Token {
        <span class="keyword">while</span> <span class="keyword">self</span>.getChar() == ?  {
            <span class="keyword">self</span>.pos = <span class="keyword">self</span>.pos + <span class="number">1</span>;
        }
        
        <span class="keyword">let</span> ch = <span class="keyword">self</span>.getChar();
        <span class="keyword">if</span> ch == <span class="number">0</span> { <span class="keyword">return</span> .Eof; }

        <span class="keyword">if</span> ch &gt;= ?<span class="number">0</span> and ch &lt;= ?<span class="number">9</span> {
            <span class="keyword">let</span> <span class="keyword">mut</span> numVal = <span class="number">0</span>;
            <span class="keyword">while</span> <span class="keyword">true</span> {
                <span class="keyword">let</span> cur = <span class="keyword">self</span>.getChar();
                <span class="keyword">if</span> cur &lt; ?<span class="number">0</span> or cur &gt; ?<span class="number">9</span> { <span class="keyword">break</span>; }
                numVal = numVal * <span class="number">10</span> + ( cur - ?<span class="number">0</span> );
                <span class="keyword">self</span>.pos = <span class="keyword">self</span>.pos + <span class="number">1</span>;
            }
            <span class="keyword">return</span> Token.Num( numVal );
        }

        <span class="keyword">self</span>.pos = <span class="keyword">self</span>.pos + <span class="number">1</span>;
        <span class="keyword">return</span> Token.Op( <span class="string">"%c"</span> ( ch ) );
    }
}

<span class="keyword">alge</span> Ast {
    Val( val: <span class="type">int</span> ),
    Bin( op: <span class="type">str</span>, left: Ast, right: Ast ),
}

<span class="keyword">class</span> Parser {
    <span class="keyword">let</span> <span class="keyword">mut</span> lexer: Lexer;
    <span class="keyword">let</span> <span class="keyword">mut</span> cur: Token;

    <span class="keyword">pub</span> <span class="keyword">fn</span> __init( text: <span class="type">str</span> ) {
        <span class="keyword">self</span>.lexer = <span class="keyword">new</span> Lexer( text );
        <span class="keyword">self</span>.cur = <span class="keyword">self</span>.lexer.next();
    }

    <span class="keyword">fn</span> next() <span class="keyword">mut</span> {
        <span class="keyword">self</span>.cur = <span class="keyword">self</span>.lexer.next();
    }

    <span class="keyword">fn</span> parseFactor() <span class="keyword">mut</span>: Ast {
        <span class="keyword">match</span> <span class="keyword">self</span>.cur {
            <span class="keyword">case</span> .Num( val ) {
                <span class="keyword">self</span>.next();
                <span class="keyword">return</span> .Val( val );
            }
            <span class="keyword">case</span> .Op( op ) {
                <span class="keyword">if</span> op == <span class="string">"("</span> {
                    <span class="keyword">self</span>.next();
                    <span class="keyword">let</span> node = <span class="keyword">self</span>.parseExpr();
                    <span class="keyword">match</span> <span class="keyword">self</span>.cur {
                       <span class="keyword">case</span> .Op( nextOp ) {
                           <span class="keyword">if</span> nextOp == <span class="string">")"</span> {
                               <span class="keyword">self</span>.next();
                               <span class="keyword">return</span> node;
                           }
                       }
                       <span class="keyword">default</span> {}
                    }
                    print( <span class="string">"Error: missing )"</span> );
                    <span class="keyword">return</span> node;
                }
            }
            <span class="keyword">default</span> {
                print( <span class="string">"Error: unexpected token"</span> );
            }
        }
        <span class="keyword">return</span> .Val( <span class="number">0</span> );
    }

    <span class="keyword">fn</span> parseTerm() <span class="keyword">mut</span>: Ast {
        <span class="keyword">let</span> <span class="keyword">mut</span> left = <span class="keyword">self</span>.parseFactor();
        <span class="keyword">while</span> <span class="keyword">true</span> {
            <span class="keyword">match</span> <span class="keyword">self</span>.cur {
                <span class="keyword">case</span> .Op( op ) {
                    <span class="keyword">if</span> op == <span class="string">"*"</span> or op == <span class="string">"/"</span> {
                        <span class="keyword">self</span>.next();
                        <span class="keyword">let</span> right = <span class="keyword">self</span>.parseFactor();
                        left = .Bin( op, left, right );
                    } <span class="keyword">else</span> {
                        <span class="keyword">break</span>;
                    }
                }
                <span class="keyword">default</span> { <span class="keyword">break</span>; }
            }
        }
        <span class="keyword">return</span> left;
    }

    <span class="keyword">pub</span> <span class="keyword">fn</span> parseExpr() <span class="keyword">mut</span>: Ast {
        <span class="keyword">let</span> <span class="keyword">mut</span> left = <span class="keyword">self</span>.parseTerm();
        <span class="keyword">while</span> <span class="keyword">true</span> {
            <span class="keyword">match</span> <span class="keyword">self</span>.cur {
                <span class="keyword">case</span> .Op( op ) {
                    <span class="keyword">if</span> op == <span class="string">"+"</span> or op == <span class="string">"-"</span> {
                        <span class="keyword">self</span>.next();
                        <span class="keyword">let</span> right = <span class="keyword">self</span>.parseTerm();
                        left = .Bin( op, left, right );
                    } <span class="keyword">else</span> {
                        <span class="keyword">break</span>;
                    }
                }
                <span class="keyword">default</span> { <span class="keyword">break</span>; }
            }
        }
        <span class="keyword">return</span> left;
    }
}

<span class="keyword">fn</span> eval( node: Ast ): <span class="type">int</span> {
    <span class="keyword">match</span> node {
        <span class="keyword">case</span> .Val( val ) {
            <span class="keyword">return</span> val;
        }
        <span class="keyword">case</span> .Bin( op, left, right ) {
            <span class="keyword">let</span> l = eval( left );
            <span class="keyword">let</span> r = eval( right );
            <span class="keyword">switch</span> op {
                <span class="keyword">case</span> <span class="string">"+"</span> { <span class="keyword">return</span> l + r; }
                <span class="keyword">case</span> <span class="string">"-"</span> { <span class="keyword">return</span> l - r; }
                <span class="keyword">case</span> <span class="string">"*"</span> { <span class="keyword">return</span> l * r; }
                <span class="keyword">case</span> <span class="string">"/"</span> { <span class="keyword">return</span> l / r; }
            }
        }
    }
    <span class="keyword">return</span> <span class="number">0</span>;
}

<span class="comment">// Main process</span>
<span class="keyword">let</span> input = <span class="string">"1 + 2 * (3 + 4)"</span>;
<span class="keyword">let</span> <span class="keyword">mut</span> parser = <span class="keyword">new</span> Parser( input );
<span class="keyword">let</span> ast = parser.parseExpr();
print( <span class="string">"%s = %d"</span> ( input, eval( ast ) ) );
</code></pre>

    </div>
</body>

</html>